{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/a.png","path":"a.png","modified":0,"renderable":0},{"_id":"source/c.png","path":"c.png","modified":0,"renderable":0},{"_id":"source/b.png","path":"b.png","modified":0,"renderable":0},{"_id":"source/gitflow.png","path":"gitflow.png","modified":0,"renderable":0},{"_id":"source/gitflow2.jpg","path":"gitflow2.jpg","modified":0,"renderable":0},{"_id":"source/kafka-partition-offset.png","path":"kafka-partition-offset.png","modified":0,"renderable":0},{"_id":"source/kafka_partition.png","path":"kafka_partition.png","modified":0,"renderable":0},{"_id":"source/kafka发布订阅模型.png","path":"kafka发布订阅模型.png","modified":0,"renderable":0},{"_id":"source/leader.png","path":"leader.png","modified":0,"renderable":0},{"_id":"source/leader1.png","path":"leader1.png","modified":0,"renderable":0},{"_id":"source/rabbitmq架构.jpg","path":"rabbitmq架构.jpg","modified":0,"renderable":0},{"_id":"source/range.jpg","path":"range.jpg","modified":0,"renderable":0},{"_id":"source/roundbin.png","path":"roundbin.png","modified":0,"renderable":0},{"_id":"source/sentinel-1.jpg","path":"sentinel-1.jpg","modified":0,"renderable":0},{"_id":"source/sentinel2.jpg","path":"sentinel2.jpg","modified":0,"renderable":0},{"_id":"source/sentinel3.jpg","path":"sentinel3.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"c44c3538924d2ff9b19019cab752b2ce08302c05","modified":1610350283288},{"_id":"source/a.png","hash":"4b9e9c313122b397e6a6a7efc47d67ba97c08ebb","modified":1570204539000},{"_id":"source/c.png","hash":"14fa69819f1a61f3ac513162ca9da2fc43d04700","modified":1570204539000},{"_id":"source/b.png","hash":"3d0090aeb626b846da19060012cf9a1e995a86cd","modified":1570204539000},{"_id":"source/kafka_partition.png","hash":"08ae2b950d8c0ceb046fd2bdfdd2eb926b1370a5","modified":1610335786532},{"_id":"source/gitflow2.jpg","hash":"afbe8829bd3ad5b8961e4aad4b94bc2b5793b5d0","modified":1610091109685},{"_id":"source/leader1.png","hash":"0ca89b4ca29ad485087c34c9d72c29d4bf49d731","modified":1610420307106},{"_id":"source/rabbitmq架构.jpg","hash":"395575fe820525c5d9d02acadadc09c6698428ac","modified":1585533214615},{"_id":"source/range.jpg","hash":"d6bf881bc12050d41734b6f564dd3874844934f3","modified":1610336525032},{"_id":"source/_posts/MQ简介.md","hash":"4b12e934143d8d6377bef35425ed3d29412e2f85","modified":1610423850334},{"_id":"source/_posts/annotation.md","hash":"fafc43cdd5d2c06e328b17df97bbd896cacc48e1","modified":1610350283290},{"_id":"source/_posts/blog-origin.md","hash":"78d019461dc24f090046dd0cf5c58a6079becb92","modified":1610350283291},{"_id":"source/_posts/codeStyle.md","hash":"ec1430940d359c3df7e47978a2a7c02ad181ff02","modified":1610421207634},{"_id":"source/_posts/design-10.md","hash":"a28947826d517c80a73703edbfac523e43105951","modified":1610350283293},{"_id":"source/_posts/design-11.md","hash":"e493815ce5d870dedda2b5caad5c40b21e36ccf9","modified":1610350283293},{"_id":"source/_posts/design-1.md","hash":"c2d8d77b447905fcc025ead80c1729f7007fed86","modified":1610350283292},{"_id":"source/_posts/design-12.md","hash":"3f5340eba34af8c1697ae1be064cd9e86106bd1a","modified":1610350283293},{"_id":"source/_posts/design-13.md","hash":"187a7be6ae954527b1d4ed1051964c3a1cad3fbf","modified":1610350283294},{"_id":"source/_posts/design-2.md","hash":"14f66b51a8de2dd7febed949c81f01a0f70d80af","modified":1610350283294},{"_id":"source/_posts/design-3.md","hash":"9967f457301d9c72b2f3d926deac03ee6f82676c","modified":1610350283295},{"_id":"source/_posts/design-4.md","hash":"6d5f8e6d024178aff3fd985e763bed833436d819","modified":1610350283295},{"_id":"source/_posts/design-5.md","hash":"37a9107c4ffee3f4898c3df3d35d1e76ceffe52d","modified":1610350283295},{"_id":"source/_posts/design-6.md","hash":"4bf7ab93bb5797713d0e80db6f938eb05ce42989","modified":1610350283296},{"_id":"source/_posts/design-7.md","hash":"53ce4bd95a4b41edd339d16c9950190be358731b","modified":1610350283296},{"_id":"source/_posts/design-8.md","hash":"08de0ac5bedde325b9e2184246fa704298c152d2","modified":1610350283296},{"_id":"source/_posts/design-9.md","hash":"c442a0d3570e0fe726d9d63142dbf1cfade39817","modified":1610350283297},{"_id":"source/_posts/dubbo-1.md","hash":"8b7706e7406a8a37808c54fe82ca9b2880db5fab","modified":1610350283297},{"_id":"source/_posts/dubbo-2.md","hash":"75aa1fdd121852582b63cbd60f990624949ef952","modified":1610350283297},{"_id":"source/_posts/gclib.md","hash":"deaf8015800d22935a353b3ea2ea4cd847fb921d","modified":1610350283298},{"_id":"source/_posts/git-subtree.md","hash":"cfee4c06876ecd62eb2ca0cfbe971cdb800bdcff","modified":1610350283298},{"_id":"source/_posts/git.md","hash":"e7b751093775a2371f1a45c198d55bff78241d1b","modified":1610350283299},{"_id":"source/_posts/gitflow2.jpg","hash":"afbe8829bd3ad5b8961e4aad4b94bc2b5793b5d0","modified":1610350283301},{"_id":"source/_posts/gradle.md","hash":"084a24de25ed68514b77748e1ea424cd51189530","modified":1610350283301},{"_id":"source/_posts/grpc-learn.md","hash":"9f68937286522707cccd1bbd4e279a6b9bee66e1","modified":1610350283301},{"_id":"source/_posts/hello-world.md","hash":"e84e14fbf453ae1dfec33cc95b1ab905c54c5cb4","modified":1610350283302},{"_id":"source/_posts/home-2.md","hash":"1d94fd0aae699745f628ae44119b636a7ca947e0","modified":1610350283302},{"_id":"source/_posts/home-3.md","hash":"5aa2fdb663e5bf54e565285c3c678368ad9513c6","modified":1610350283302},{"_id":"source/_posts/home.md","hash":"7d50a62bf683877f963d598e6608a694fa7c3793","modified":1610350283303},{"_id":"source/_posts/intresting.md","hash":"532c6ef658591999498003707734dac52ab8d7de","modified":1610350283303},{"_id":"source/_posts/javaee-1.md","hash":"f094541dc83239a327197f18e49abc00d9d09788","modified":1610350283304},{"_id":"source/_posts/java-code.md","hash":"6ba83d358f1e77fde21d116d069369016dfc86df","modified":1610350283304},{"_id":"source/_posts/jvm-1.md","hash":"f9e73dfa90d7b0943fa85de742e227dd131322bb","modified":1610350283305},{"_id":"source/_posts/jvm-2.md","hash":"7d9e47a93a8fdc57192127f10bffb98f4488191a","modified":1610350283305},{"_id":"source/_posts/jvm-3.md","hash":"20a2c7b4532bc5e408a8ba29d1a03b44e50e532f","modified":1610350283306},{"_id":"source/_posts/jvm-4.md","hash":"5e2c7b6965ea51d2206bac03da66221664dbeac1","modified":1610350283306},{"_id":"source/_posts/jvm-5.md","hash":"92cdeb784355daa3c37d15512407f48bf3e99fa6","modified":1610350283307},{"_id":"source/_posts/jvm-6.md","hash":"bdf0cf04b51ad08c9737e4b1a82c0b63934f42e1","modified":1610350283307},{"_id":"source/_posts/kafka-1.md","hash":"8be5e235d450582babf080d23ff9cc4f5bb6dfc7","modified":1610422984034},{"_id":"source/_posts/kafka-2.md","hash":"9a2a5b2cd28a87b3b5b8af05fc76b21573eb68c0","modified":1612063928182},{"_id":"source/_posts/kafka.md","hash":"400ed9a74c9f1235d749c9a699e15e1061f84bf1","modified":1616903844877},{"_id":"source/_posts/leetcode.md","hash":"0b3c9d12ff0b447f0adfdca87d480a3e0b401653","modified":1610350283308},{"_id":"source/_posts/logback-2.md","hash":"f0961576a4fb91d1863778e0ab6a562d7d40da2c","modified":1610350283308},{"_id":"source/_posts/logback.md","hash":"ace58844510b91e9b9cbbb80f0d7eaa2200371a8","modified":1610350283309},{"_id":"source/_posts/nacos.md","hash":"722b98959f9edbfc4c07a12550542fe7fccb257e","modified":1610350283310},{"_id":"source/_posts/netty学习笔记.md","hash":"707b052fd28fbdb97e768c2109c1107a19fd1168","modified":1610350283310},{"_id":"source/_posts/nio.md","hash":"0840b5eea2e57cce57caad9acea21702c47f5667","modified":1610350283310},{"_id":"source/_posts/photo.md","hash":"dc328bab1c2aec7344321f742638996e23f6aa55","modified":1610350283311},{"_id":"source/_posts/rabbitMQ-springboot-0.md","hash":"6e498a2764d5e3e012566d8221abf9f8541c93be","modified":1610423233779},{"_id":"source/_posts/rabbitMQ-springboot-1.md","hash":"84845b7a3223a2b7d9442bffc2910f03fd676189","modified":1610422564532},{"_id":"source/_posts/rabbitMQ-springboot-3.md","hash":"704ccb7770779585c2fe5b3e5d09ad699c48d326","modified":1610422578610},{"_id":"source/_posts/rabbitMQ-yunwei.md","hash":"80746caf376dcd5582332c9de9824087db271bb5","modified":1610423855110},{"_id":"source/_posts/rabbitMQ安装与简单使用.md","hash":"a31ea4fcb968cba2ccae5bbdda68dfd210e75521","modified":1610424012768},{"_id":"source/_posts/rabbitMQ简介.md","hash":"106191e5bc22b6ea288a2b4b11bf320deaeae697","modified":1610423183208},{"_id":"source/_posts/redis-1.md","hash":"c6b76b6d29e4c5b2f0e4b02e8adbfe4456ab182c","modified":1610350283313},{"_id":"source/_posts/reptile.md","hash":"055bd9c07be257cb7bff91a653050cded6643cc8","modified":1610350283313},{"_id":"source/_posts/spi.md","hash":"1183e5ada667ab50007bcf95d7d8be3cb42479c4","modified":1610350283314},{"_id":"source/_posts/security-oauth2学习笔记.md","hash":"26c92971411f1289c84bf256c384c7d86f7d6700","modified":1610350283313},{"_id":"source/_posts/sppringboot.md","hash":"6a2c3284205c51e7116060fbb5985e48aa602be6","modified":1610350283314},{"_id":"source/_posts/spring-1.md","hash":"ba18469dfe114cc17018a3afd06bae33d6462d90","modified":1610350283315},{"_id":"source/_posts/spring-boot-starter.md","hash":"c998266b2eb114daafa59949402495b86ea9b810","modified":1610350283315},{"_id":"source/_posts/springSecurity2.md","hash":"68e5a0cfc94a62a6f4160dbe6ea7824a107e1815","modified":1610350283316},{"_id":"source/_posts/springSecurity深度解析.md","hash":"3ff69b6c4be11e0cf98893c6005f7bbfb8b55dd1","modified":1610350283321},{"_id":"source/_posts/springcloud-1.md","hash":"11cc45055bcaf2b2aef9b66decf1ea893f902e8a","modified":1610350283321},{"_id":"source/_posts/springcloud-2.md","hash":"0f31d78069ebfac51329c5bd17a894690fadefe4","modified":1610350283322},{"_id":"source/_posts/springcloud-3.md","hash":"d38aa1ebf8d1af61ecfdbcb4a25a3ac525c91f95","modified":1610350283322},{"_id":"source/_posts/thread-1.md","hash":"c2ccf8efd9ce3f66e4b7f8569756206a640fdd7d","modified":1610350283327},{"_id":"source/_posts/thread-2.md","hash":"afc1a2b4003d7ddaeae95e5d49d198c0c0d74dab","modified":1610350283327},{"_id":"source/_posts/thread-3.md","hash":"a4dd23c444615725f8f703e94fc02b580dbdf6ad","modified":1610350283327},{"_id":"source/_posts/windows.md","hash":"b66edf4c8c8662ff22ffc0efd4eb0dba8e1b4c6e","modified":1610350283328},{"_id":"source/_posts/zookeeper.md","hash":"b860a8895b1a3d56668dab7c539feb71d59ee8df","modified":1610350283328},{"_id":"source/_posts/在vscode中编写markdown.md","hash":"4d4eded2f921b3eb5a0c7159bbcd961c889e8faf","modified":1610350283329},{"_id":"source/roundbin.png","hash":"73ec90347baeddcc0faf8af7c2df8ccc7800c487","modified":1610336463606},{"_id":"source/_posts/gitflow.png","hash":"63b44785f1acb5f057d0c934a51203a4c0557dc0","modified":1610350283300},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580258640475},{"_id":"source/gitflow.png","hash":"63b44785f1acb5f057d0c934a51203a4c0557dc0","modified":1610090993912},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1580258640462},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1580258640463},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1580258640463},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1580258640463},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1580258640463},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1580258640464},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1580258640464},{"_id":"themes/yilia/_config.yml","hash":"a8b65a6bb34b1518173dd39b749e3892960ef1a6","modified":1580634538428},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1580258640478},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1580258640508},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1580258640465},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1580258640465},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1580258640465},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1580258640465},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1580258640466},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1580258640466},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1580258640466},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1580258640476},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1580258640477},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1580258640476},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1580258640477},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1580258640477},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1580258640478},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1580258640478},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1580258640479},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1580258640500},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1580258640507},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1580258640467},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1580258640467},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1580258640467},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"8dea8f5f93a60185439b330b0f1d1649a6ab4bd0","modified":1580258640469},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1580258640469},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1580258640469},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1580258640469},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1580258640470},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1580258640470},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1580258640470},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1580258640470},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1580258640471},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1580258640471},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1580258640471},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1580258640475},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1580258640476},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1580258640480},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1580258640480},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1580258640480},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1580258640481},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1580258640481},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1580258640481},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1580258640482},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1580258640482},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1580258640482},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1580258640486},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1580258640487},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1580258640488},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1580258640488},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1580258640489},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1580258640490},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1580258640490},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1580258640491},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1580258640491},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1580258640491},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1580258640491},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1580258640492},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1580258640492},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1580258640492},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1580258640492},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1580258640494},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1580258640494},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1580258640494},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1580258640496},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1580258640496},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1580258640496},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1580258640497},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1580258640497},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1580258640498},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1580258640498},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1580258640499},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1580258640499},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1580258640500},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1580258640499},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1580258640500},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1580258640501},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1580258640502},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1580258640502},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1580258640502},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1580258640503},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1580258640504},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1580258640505},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1580258640504},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1580258640472},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1580258640472},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1580258640472},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1580258640472},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1580258640473},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1580258640473},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1580258640473},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1580258640474},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1580258640474},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1580258640474},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1580258640483},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1580258640484},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1580258640484},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1580258640484},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1580258640484},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1580258640486},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1580258640487},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1580258640487},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1580258640487},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1580258640489},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1580258640490},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1580258640490},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1580258640505},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1580258640506},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1580258640475},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1580258640495},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1580258640506},{"_id":"source/leader.png","hash":"6a9b3566a91b71e5cd166fc9dc0b8f4d8fcc1aab","modified":1610335777661},{"_id":"source/kafka发布订阅模型.png","hash":"1ba4fd44227d900c6d1825db65978958b3b4d029","modified":1609297405329},{"_id":"source/kafka-partition-offset.png","hash":"997217cb2f1164c5b4d042a41f371cae97fe074d","modified":1609376429597},{"_id":"public/content.json","hash":"2f27d2b3eba89ee30687d3826a966b3aba63683d","modified":1627273645367},{"_id":"public/2021/01/11/codeStyle/index.html","hash":"4c7003407cd1948265803fc22d143004f4749354","modified":1627185125664},{"_id":"public/2020/12/22/kafka-2/index.html","hash":"24d052616e63f794540a32106519d6cafe4b06fc","modified":1627185125664},{"_id":"public/2020/12/21/kafka-1/index.html","hash":"a329d2ef2583650e6ee7f1a03f9aa9752b551a4f","modified":1627185125664},{"_id":"public/2020/12/20/kafka/index.html","hash":"eb9cbce5e1bd0d01a8ab23b744220318f1800435","modified":1627185125664},{"_id":"public/2020/12/17/rabbitMQ-yunwei/index.html","hash":"ca041c1d2c6b72f4a5ba76f5b7d56f600198247f","modified":1627185125664},{"_id":"public/2020/12/16/rabbitMQ-springboot-3/index.html","hash":"46469a432b629b8e859b3c31fcfd6917c319ca1b","modified":1627185125664},{"_id":"public/2020/12/15/rabbitMQ-springboot-1/index.html","hash":"0b446e4ab0f24738c458209fa5103bb9145b53b6","modified":1627185125664},{"_id":"public/2020/12/14/rabbitMQ-springboot-0/index.html","hash":"19c9dbd563e001c2e69c5229bd578585da152f14","modified":1627185125664},{"_id":"public/2020/12/13/rabbitMQ简介/index.html","hash":"e4ce266ee6599c9af6193eb02a1e4a38d7d5ad7b","modified":1627185125664},{"_id":"public/2020/12/12/MQ简介/index.html","hash":"991bfddf11e30a404e3af866d9bd3339617a32d7","modified":1627185125664},{"_id":"public/2020/12/12/rabbitMQ安装与简单使用/index.html","hash":"bb94503fa3084b9dd0aa75a64d3b0690e6e1edd2","modified":1627185125664},{"_id":"public/2020/02/02/design-13/index.html","hash":"93745c5e4e4aaed66b660289d409b34db3723a7c","modified":1627185125664},{"_id":"public/2020/09/07/java-code/index.html","hash":"7f82b9f06b4f1fc3e97edcfa54e1e8e8191009c6","modified":1627185125664},{"_id":"public/2020/02/02/design-12/index.html","hash":"c91e85382b9194dd3451539376e63afc59d2b3de","modified":1627185125664},{"_id":"public/2020/02/02/design-11/index.html","hash":"df0cb19b3c95f43d02e0e46f135be95f80c81f82","modified":1627185125664},{"_id":"public/2020/02/02/design-10/index.html","hash":"c41479d1af13878cee328655cdc38801c828adae","modified":1627185125664},{"_id":"public/2020/02/02/design-9/index.html","hash":"e95405f0646efd429ca8c265def832248d916126","modified":1627185125664},{"_id":"public/2020/02/02/design-8/index.html","hash":"9628fb475baf13eaa57da4ecb206d1ad785c50eb","modified":1627185125664},{"_id":"public/2020/02/02/design-7/index.html","hash":"1d69e93570eb11b956835758b639d423e98f121b","modified":1627185125664},{"_id":"public/2020/02/02/design-6/index.html","hash":"a7c0f7b81bd8c523ace15e139d7f8d734b570abe","modified":1627185125664},{"_id":"public/2019/08/30/design-5/index.html","hash":"dee3dabae50b4edf0408966c9e425d4dd8517816","modified":1627185125664},{"_id":"public/2019/08/02/intresting/index.html","hash":"694dbbc66be1965be6d4a0e2a52baffb88d38b3a","modified":1627185125664},{"_id":"public/2019/07/18/design-4/index.html","hash":"a095813fa3bc340acf096ebca4af60ded949721c","modified":1627185125664},{"_id":"public/2019/07/17/design-3/index.html","hash":"46569153a56d8dd7c4902028d2c4c5d39748693b","modified":1627185125664},{"_id":"public/2019/07/17/design-2/index.html","hash":"51770c6c3c30a33e6e1bdc243f9ab0289173bae5","modified":1627185125664},{"_id":"public/2019/06/15/zookeeper/index.html","hash":"79f4f2be8b153cf412b92a03248fdce4eebd2bf0","modified":1627185125664},{"_id":"public/2019/05/27/dubbo-2/index.html","hash":"081476cf2c44e4c2e2fb01c0ca516ff0ea8a7f05","modified":1627185125664},{"_id":"public/2019/05/24/git/index.html","hash":"32d22c7884736654988a75adecb6db0657e99083","modified":1627185125664},{"_id":"public/2019/05/17/spi/index.html","hash":"a50428cbc737c7ed04eea4296e3b983b9d606c4a","modified":1627185125664},{"_id":"public/2019/05/15/gradle/index.html","hash":"d61ce0e873c220bc0d1157b9f10a54f2c6eccbd7","modified":1627185125664},{"_id":"public/2019/05/15/annotation/index.html","hash":"a02e65e3e3090a7167692939bc6a6d7b46694a7c","modified":1627185125664},{"_id":"public/2019/05/15/spring-boot-starter/index.html","hash":"9fa0cc3c912ac43c5d36021b723a30bdf503d1b0","modified":1627185125664},{"_id":"public/2019/05/14/grpc-learn/index.html","hash":"3e98e9bbddbd42018c7624c4b6654208818c039d","modified":1627185125664},{"_id":"public/2019/05/13/gclib/index.html","hash":"229d6bcd58826c5033798ef1b5bd734d93fa4dcc","modified":1627185125664},{"_id":"public/2019/05/09/jvm-6/index.html","hash":"b1f10e17b1ab5e4d9c26daa9014fc4a9d365cefc","modified":1627185125664},{"_id":"public/2019/05/08/spring-1/index.html","hash":"d841489abac06574e619d19abe90dabe37410ff5","modified":1627185125664},{"_id":"public/2019/05/06/redis-1/index.html","hash":"2a6e81120a9ef6c30a3128aa014e224f62de07a9","modified":1627185125664},{"_id":"public/2019/05/05/git-subtree/index.html","hash":"1fce877eb338b2ad9afa645240f8834994bb5142","modified":1627185125664},{"_id":"public/2019/05/01/windows/index.html","hash":"77f1e9a1e6a9ddc17b71b6f61f5c337a2fe21b2b","modified":1627185125664},{"_id":"public/2019/04/30/reptile/index.html","hash":"07f3206d9482365274d0bd4243611cc6c324f640","modified":1627185125664},{"_id":"public/2019/04/27/home-2/index.html","hash":"ef0e7f96a29720471aef8022ee19531b0ba20b21","modified":1627185125664},{"_id":"public/2019/04/27/leetcode/index.html","hash":"379b6ec3a2147d7d4a6b898aa4c0148f67c6a77c","modified":1627185125664},{"_id":"public/2019/04/27/nacos/index.html","hash":"33bc679769d66cbd484ecc156ca5d489976ec8ab","modified":1627185125664},{"_id":"public/2019/04/27/springcloud-3/index.html","hash":"32ab1ba26db52217689b6ee2d34e2dd85d5334d5","modified":1627185125664},{"_id":"public/2019/04/26/dubbo-1/index.html","hash":"8b6459b8977769bbc6422e937fd0738f4ed58575","modified":1627185125664},{"_id":"public/2019/04/26/nio/index.html","hash":"a5d95113ddbfb6b3b4560480e5126d39c005465e","modified":1627185125664},{"_id":"public/2019/04/26/springcloud-2/index.html","hash":"bad0fd395e86e4b81e915b33ee8f036f6ade2ab3","modified":1627185125664},{"_id":"public/2019/04/26/springcloud-1/index.html","hash":"bd384464ffeb2b77e07d43f498c60f688f9631d2","modified":1627185125664},{"_id":"public/2019/04/25/design-1/index.html","hash":"9edc0939d8cbd47ff8d0cbe2f2d63274c3399cab","modified":1627185125664},{"_id":"public/2019/04/24/jvm-5/index.html","hash":"83635f8fa4c47958aeb82bf5dda15233cb9d38b5","modified":1627185125664},{"_id":"public/2019/04/24/jvm-4/index.html","hash":"fff30b705e80f0ded0abaa8431d05c98a884134e","modified":1627185125664},{"_id":"public/2019/04/24/jvm-3/index.html","hash":"3e22688ccdf5272975a4f86b495c5249bc1d73e6","modified":1627185125664},{"_id":"public/2019/04/23/jvm-2/index.html","hash":"948d616b0bee52b2a8f0ec7c151e95e3bf978bc6","modified":1627185125664},{"_id":"public/2019/04/23/jvm-1/index.html","hash":"a4e82bbb52c22c47021bb59c51d72f4966acb3fa","modified":1627185125664},{"_id":"public/2019/04/23/thread-3/index.html","hash":"2b7cf3e357220a61f00bc9a9c33edd78d60537e3","modified":1627185125664},{"_id":"public/2019/04/23/thread-2/index.html","hash":"9477553c94b95525ac3cdc17d6fb456eb26a46a2","modified":1627185125664},{"_id":"public/2019/04/22/thread-1/index.html","hash":"848145666711901ebfdd4652ed106018d7c796e0","modified":1627185125664},{"_id":"public/2019/04/22/blog-origin/index.html","hash":"e520463b98641853eb1b5eb96486b1119793b3a5","modified":1627185125664},{"_id":"public/2019/04/22/logback-2/index.html","hash":"995233f066a36ae775e26b9d6c565bc03ca3c05e","modified":1627185125664},{"_id":"public/2019/04/20/springSecurity2/index.html","hash":"066b22477b3768d3d34a59caa1363754cacf15ed","modified":1627185125664},{"_id":"public/2019/04/20/photo/index.html","hash":"5b892682022433e140b31296e61809f830a06abf","modified":1627185125664},{"_id":"public/2019/04/16/sppringboot/index.html","hash":"cdd984ea0e1802438bb66a10798e06435b47687c","modified":1627185125664},{"_id":"public/2019/04/12/在vscode中编写markdown/index.html","hash":"3e399e78336e87c3a83f6ca62e45d5ac459022d8","modified":1627185125664},{"_id":"public/2019/04/12/security-oauth2学习笔记/index.html","hash":"ff66fbd20b79f738925fdfd2e63037ae5fb85c15","modified":1627185125664},{"_id":"public/2019/04/11/springSecurity深度解析/index.html","hash":"69c9502580c1b95ed4335152df877e756b38f8ce","modified":1627185125664},{"_id":"public/2019/04/01/netty学习笔记/index.html","hash":"abbbf042f11857615e22e4671229d4fbcf9863cd","modified":1627185125664},{"_id":"public/2019/03/28/hello-world/index.html","hash":"1ab7b363169bd4bdc3845cdd92700d98f189a895","modified":1627185125664},{"_id":"public/2019/03/28/logback/index.html","hash":"e17c8f7e0e4eb25e8ce6ef545a455b65f3769e59","modified":1627185125664},{"_id":"public/2019/03/27/home-3/index.html","hash":"0c144ed3d8a1ce9015052340f1cd6af6b1936fe4","modified":1627185125664},{"_id":"public/2019/03/20/javaee-1/index.html","hash":"f0217189436beba5f9f205f2d30aa3c5581efd22","modified":1627185125664},{"_id":"public/2019/03/20/home/index.html","hash":"ce18cef9dc3be14441f8403c9dc67656014bed81","modified":1627185125664},{"_id":"public/archives/index.html","hash":"f66005436de099182d068045f027e048507b0b71","modified":1627273645367},{"_id":"public/archives/page/2/index.html","hash":"12f03ccb10cf8ef5943fc2d9c8db83b4aabb9099","modified":1627273581851},{"_id":"public/archives/page/3/index.html","hash":"72723842c0c9b7d6e020a294c69e32179f8b5412","modified":1627273581851},{"_id":"public/archives/page/4/index.html","hash":"4775e1baf73c80516a86f14719785dfa95a839f5","modified":1627273581851},{"_id":"public/archives/page/5/index.html","hash":"7d7b9cd0a1ec5e67204cd61d7b7426b0ef5ca080","modified":1627273581851},{"_id":"public/archives/page/6/index.html","hash":"03cefa511209fbadf58ade5accb5ce8a0bea533a","modified":1627273581851},{"_id":"public/archives/page/7/index.html","hash":"689da9fbfdda1873b2edcbcd49475884ef02d3d9","modified":1627273581851},{"_id":"public/archives/page/8/index.html","hash":"1c63cdb98b2efb541fc2bb3edaaabad6852c085b","modified":1627273581851},{"_id":"public/archives/2019/index.html","hash":"982d28093afeb993e3456605c4cbc0050e22f037","modified":1627185125664},{"_id":"public/archives/2019/page/2/index.html","hash":"18cb16211e6933a8c1ba84482007ec08f35be0bd","modified":1627185125664},{"_id":"public/archives/2019/page/3/index.html","hash":"b8eff14eba628cc78212abc136732f60d4d99816","modified":1627185125664},{"_id":"public/archives/2019/page/4/index.html","hash":"20cf93a5c5d2574edeb3c8b3535016be0299a2ab","modified":1627185125664},{"_id":"public/archives/2019/page/5/index.html","hash":"a1601e98af406c2d623f558c7d521ae41aa81b48","modified":1627185125664},{"_id":"public/archives/2019/page/6/index.html","hash":"a395395cd91495d06ce3d5caec46ed3d4db56506","modified":1627185125664},{"_id":"public/archives/2019/03/index.html","hash":"0ccc8ab474681d38765004c5965bad6d4cf614cc","modified":1627185125664},{"_id":"public/archives/2019/04/index.html","hash":"b0468344f4345841c9e8f55fddbd326051f83809","modified":1627185125664},{"_id":"public/archives/2019/04/page/2/index.html","hash":"116fd7f333a3ce9c72ea1657c5f3f6b3b519ee59","modified":1627185125664},{"_id":"public/archives/2019/04/page/3/index.html","hash":"9ce615512f8c87d653e0e0701a2ac3ef584b53ff","modified":1627185125664},{"_id":"public/archives/2019/05/index.html","hash":"9a4c9aef2e476fc120ef0271d35c4780f8753351","modified":1627185125664},{"_id":"public/archives/2019/05/page/2/index.html","hash":"12ce5feed205c4355e9d33d9922970df95295bc8","modified":1627185125664},{"_id":"public/archives/2019/06/index.html","hash":"a718e4dc7e2e3bf6112fd40251fda2ddf88a4257","modified":1627185125664},{"_id":"public/archives/2019/07/index.html","hash":"3c37d136483c4a2e142af1b9453cfbc478969fcd","modified":1627185125664},{"_id":"public/archives/2019/08/index.html","hash":"627f48e3670f523771f6063a4f6301557a6c7514","modified":1627185125664},{"_id":"public/archives/2020/index.html","hash":"c885fc99ca22bbccbe2d693115dd942696c4570f","modified":1627185125664},{"_id":"public/archives/2020/page/2/index.html","hash":"928b7c562586438dc7d97f39783921da77fe109a","modified":1627185125664},{"_id":"public/archives/2020/02/index.html","hash":"fad1ef060a68ffc9915615d7a5a8d9ede6b0297c","modified":1627185125664},{"_id":"public/archives/2020/09/index.html","hash":"71ae00fb43a480b0a0d810ebdd1c2be3070fa92a","modified":1627185125664},{"_id":"public/archives/2020/12/index.html","hash":"f77d6fe29f17e45fac23e217d095334259a15895","modified":1627185125664},{"_id":"public/archives/2021/index.html","hash":"618360aea2bec4bf480951badcdd32104947d3e0","modified":1627273645367},{"_id":"public/archives/2021/01/index.html","hash":"bf7a80c66c07d4f34d542ace0ec7af7ac7d5022c","modified":1627185125664},{"_id":"public/index.html","hash":"b5a24c3b3ccfcf9e86f27e5e63ea27a7b841c831","modified":1627274869087},{"_id":"public/tags/中间件/index.html","hash":"22f5e8c3fde3283b8e8f64eac6f3d7e06a3b2f09","modified":1627273645367},{"_id":"public/tags/中间件/page/2/index.html","hash":"8e42cd434a0b4dfd234ce78c8d9777e1a69897a2","modified":1627273645367},{"_id":"public/tags/tool/index.html","hash":"1e3fee3c69a40a396db88df34867a39c4b5f0e93","modified":1627185125664},{"_id":"public/tags/javase/index.html","hash":"1428bf7a2248b532876e798ac08098bdf34f8da6","modified":1627185125664},{"_id":"public/tags/javaee/index.html","hash":"1e85e5af5b64609182669791210576b5af93f6ce","modified":1627185125664},{"_id":"public/tags/设计模式/index.html","hash":"116af728035835c3c2b2c0bf4fd8b2a2934d1342","modified":1627185125664},{"_id":"public/tags/设计模式/page/2/index.html","hash":"762dd523a78ba52d3d34cee9d6c894f5b6706f8f","modified":1627185125664},{"_id":"public/tags/cloud/index.html","hash":"35f81e43094ea7b69d04c1f9b71af6c3d1819f64","modified":1627185125664},{"_id":"public/tags/developing/index.html","hash":"67769f0c487859e97bf247e7275987ab1ff9450c","modified":1627185125664},{"_id":"public/tags/苟？/index.html","hash":"4adbb46b3e378031821e155b5ad8d5b8b7cc7f7c","modified":1627185125664},{"_id":"public/tags/home/index.html","hash":"8b957226d40ba6be141e695abaf34f65be4e0f46","modified":1627185125664},{"_id":"public/tags/jvm/index.html","hash":"d25a7767e1674ad490da3ffb53fc32ca63b02ff3","modified":1627185125664},{"_id":"public/tags/算法/index.html","hash":"c666454b00ee9c051d9420b10e4220174959b7fd","modified":1627185125664},{"_id":"public/tags/log/index.html","hash":"6d4f37a4b1e5e183741024bcb6246390c9378d1e","modified":1627185125664},{"_id":"public/tags/netty/index.html","hash":"acfed3083556b6259eaec43289d3639e7189fd24","modified":1627185125664},{"_id":"public/tags/photo/index.html","hash":"ed23044c465e72fb28027bc59f7999d23d6565e6","modified":1627185125664},{"_id":"public/tags/security/index.html","hash":"b471d316f07a6deda7499cbec177e9b5f80f0312","modified":1627185125664},{"_id":"public/tags/springboot/index.html","hash":"6f55584fd5d4932e9e06198454a6b929cc6b6627","modified":1627185125664},{"_id":"public/tags/spring/index.html","hash":"01b17dd2a3a1195eb94fa4b4f3ee326857cbaa3e","modified":1627185125664},{"_id":"public/tags/thread/index.html","hash":"0b28e0791127a3936229260489d166ebbde3a4f9","modified":1627185125664},{"_id":"public/tags/mysql/index.html","hash":"7a69f785b414420ec6b4263bf88cff49416ee167","modified":1627185125664},{"_id":"public/tags/redis/index.html","hash":"377b846331c16245c3e25c26a8d0c01477e548ad","modified":1627185125664},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1610423866896},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1610423866896},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1610423866896},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1610423866896},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1610423866896},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1610423866896},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1610423866896},{"_id":"public/CNAME","hash":"c44c3538924d2ff9b19019cab752b2ce08302c05","modified":1610423866896},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1610423866896},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1610423866896},{"_id":"public/a.png","hash":"4b9e9c313122b397e6a6a7efc47d67ba97c08ebb","modified":1610423866896},{"_id":"public/c.png","hash":"14fa69819f1a61f3ac513162ca9da2fc43d04700","modified":1610423866896},{"_id":"public/b.png","hash":"3d0090aeb626b846da19060012cf9a1e995a86cd","modified":1610423866896},{"_id":"public/gitflow2.jpg","hash":"afbe8829bd3ad5b8961e4aad4b94bc2b5793b5d0","modified":1610423866896},{"_id":"public/kafka_partition.png","hash":"08ae2b950d8c0ceb046fd2bdfdd2eb926b1370a5","modified":1610423866896},{"_id":"public/leader1.png","hash":"0ca89b4ca29ad485087c34c9d72c29d4bf49d731","modified":1610423866896},{"_id":"public/range.jpg","hash":"d6bf881bc12050d41734b6f564dd3874844934f3","modified":1610423866896},{"_id":"public/rabbitmq架构.jpg","hash":"395575fe820525c5d9d02acadadc09c6698428ac","modified":1610423866896},{"_id":"public/roundbin.png","hash":"73ec90347baeddcc0faf8af7c2df8ccc7800c487","modified":1610423866896},{"_id":"public/gitflow.png","hash":"63b44785f1acb5f057d0c934a51203a4c0557dc0","modified":1610423866896},{"_id":"public/kafka发布订阅模型.png","hash":"1ba4fd44227d900c6d1825db65978958b3b4d029","modified":1610423866896},{"_id":"public/leader.png","hash":"6a9b3566a91b71e5cd166fc9dc0b8f4d8fcc1aab","modified":1610423866896},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1610423866896},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1610423866896},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1610423866896},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1610423866896},{"_id":"public/kafka-partition-offset.png","hash":"997217cb2f1164c5b4d042a41f371cae97fe074d","modified":1610423866896},{"_id":"source/_posts/kafka事务.md","hash":"45b949c7ad98cf1f258985440353519c19e56891","modified":1616465549054},{"_id":"public/2021/01/31/kafka事务/index.html","hash":"d2feda4cd0c5bf56005e8891655f999a8bbcdbd5","modified":1627185125664},{"_id":"source/_posts/开发小计.md","hash":"52f62c8aac494fe690f4f985b0d4c270ce207bf2","modified":1613961778349},{"_id":"public/2021/02/06/开发小计/index.html","hash":"a5cdc15302908e8c01468621f4b5d4d7e16d9e7e","modified":1627185125664},{"_id":"public/archives/2021/02/index.html","hash":"8115f8ddc122712613eb5d3353289d76d3fe0202","modified":1627185125664},{"_id":"source/_posts/kafka-spring-boot.md","hash":"254596ae10f100297b0d1a2de020ade881fd6d30","modified":1616903278425},{"_id":"public/2021/03/28/kafka-spring-boot/index.html","hash":"d0a3fb2c7ae1e51bfbd0111f955966179bf293c9","modified":1627185125664},{"_id":"public/archives/2021/03/index.html","hash":"9d07096cf8d9ca0a87a287ea7a29939eb0635b71","modified":1627185125664},{"_id":"source/_posts/流控组件-sentinel.md","hash":"beda52e39838fdf5e0f4adc22420fe81750638f6","modified":1627273681354},{"_id":"public/2021/07/25/流控组件-sentinel/index.html","hash":"c3438d7aa11b5a92856b2d3e347e27e0568dc41b","modified":1627273689057},{"_id":"public/archives/2021/07/index.html","hash":"16bdbd8e60cf5284212e1b00cfd345e10ca6fed4","modified":1627273645367},{"_id":"source/sentinel2.jpg","hash":"26938e65bca6fd1a316cc8ee7dfd36a2fcc4e0d5","modified":1626854586142},{"_id":"source/sentinel3.jpg","hash":"fa021bd550256be1be0696a1f72f9531017ced79","modified":1626861826164},{"_id":"source/sentinel-1.jpg","hash":"37a93b2f3c86cfe5627fb1102e221246cebb7838","modified":1625815182031},{"_id":"public/sentinel3.jpg","hash":"fa021bd550256be1be0696a1f72f9531017ced79","modified":1627273216480},{"_id":"public/sentinel-1.jpg","hash":"37a93b2f3c86cfe5627fb1102e221246cebb7838","modified":1627273216480},{"_id":"public/sentinel2.jpg","hash":"26938e65bca6fd1a316cc8ee7dfd36a2fcc4e0d5","modified":1627273216480},{"_id":"source/_posts/sentinel-持久化.md","hash":"bf83e526737f47b03b291887a6acd689af80c19e","modified":1627274862239},{"_id":"public/2021/07/26/sentinel-持久化/index.html","hash":"14777e8922287bc4137f39c8eff39fda135fc23b","modified":1627274869087}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"MQ简介","date":"2020-12-11T16:00:00.000Z","_content":"\n\n`mq` 就是消息队列（`Message Queue`）。想必大家对队列的数据结构已经很熟悉了，消息队列可以简单理解为：把要传输的数据放在队列中，mq 就是存放和发送消息的这么一个队列中间件。在消息队列中，把数据放到消息队列的角色叫做 `生产者`，从消息队列中消费获取数据的叫做 `消费者`。\n\n那么消息队列有哪些使用场景呢? 六字真言：异步削峰解耦。\n<!--more-->\n## MQ的异步\n\n异步概念想必大家都熟悉了，就是 a应用（或程序） 将数据传递给b应用（或程序）后，不等待b的响应结果直接做下一步动作，而b并行执行，提高效率。使用mq，就能完美支持异步：a将数据发送到mq，然后自己该干嘛干嘛，b监听mq的消息，来了消息就消费它。这样就做到程序或者应用间的异步。\n\n## mq的削峰\n\n首先我们要知道什么是削峰：削峰的全称应该叫削峰填谷。削峰就是当应用或者程序的请求量过大的时候，将一部分请求延时处理，放到请求量不大时间段去处理它。mq削峰填谷的原理也很简单，mq在应用程序中相当于一个 “蓄水池” 的作用——当 “水流量（请求）” 过大的时候，“蓄水池（mq）” 将 \"水\" 先存起来。当有能力去消费这些水的时候再去从 “蓄水池” 放水。实际的过程是——请求数据先发到 mq ，应用程序监听mq 并消费消息。当请求量大于消费量的时候，请求积压在mq中存储；当消费量大于请求量的时候，请求就会慢慢被处理完。这听上去就像小学做的游泳池放水排水的数学题。\n\n## mq的解耦\n\nmq解耦性是显而易见的，应用程序直接不直接互相耦合，甚至可以不用知道对方的存在。它想要发出什么样的请求，或者拿什么数据，都是去找mq。mq就像个搬运工一样在这些应用之间搬运数据。\n\n## mq 协议及产品\n\nmq 协议有两种，`jms` 和 `AMQP` 。通常而言提到JMS（`Java MessageService`）实际上是指 `JMS API` 。`JMS` 是由Sun公司早期提出的消息标准，旨在为java应用提供统一的消息操作，包括create、send、receive\n\n等。JMS已经成为 `Java Enterprise Edition` 的一部分。从使用角度看，JMS和JDBC担任差不多的角色，用户都是根据相应的接口可以和实现了 `JMS` 的服务进行通信，进行相关的操作。\n\nJMS角色概念：\n\n- JMS provider：实现了JMS接口的消息中间件，如ActiveMQ\n\n- JMS client：生产或者消费消息的应用\n\n- JMS producer/publisher：JMS消息生产者\n\n- JMS consumer/subscriber ：JMS消息消费者\n\n- JMS message：消息，在各个JMS client传输的对象；\n\n- JMS queue：Provider存放等待被消费的消息的地方\n\n- JMS topic：一种提供多个订阅者消费消息的一种机制；在MQ中常常被提到，topic模式。\n\n `AMQP（advanced message queuing protocol）` 在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。AMQP是一种 `binary wire-level protocol`（链接协议）。`AMQP` 不从 API 的层面层对使用规范进行限定，而是直接定义网络交换的数据格式。这意味着实现了amqp协议的消息队列中间件支持跨平台。我们可以使用 Java 的 `AMQP provider` 而 `consumer` 可以是golang 。\n\n在AMQP中，消息路由（`messagerouting`）和JMS存在一些差别，在AMQP中增加了 `Exchange` 和 `binding` 的角色。`producer` 将消息发送给 `Exchange` ，`binding` 决定 `Exchange` 的消息应该发送到那个 `queue`，而consumer直接从queue中消费消息。queue和exchange的bind有consumer来决定。\n\n相对而言，AMQP的消息队列使用的更为广泛。如 `rabbitMQ` , `kafka` , `rocketMQ` 等都是实现AMQP协议的消息队列。接下来我们将会学习 `rabbitMQ` 和 `kafka` 的相关知识。 \n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","source":"_posts/MQ简介.md","raw":"---\ntitle: MQ简介\ndate: 2020-12-12 \ntags: 中间件\n---\n\n\n`mq` 就是消息队列（`Message Queue`）。想必大家对队列的数据结构已经很熟悉了，消息队列可以简单理解为：把要传输的数据放在队列中，mq 就是存放和发送消息的这么一个队列中间件。在消息队列中，把数据放到消息队列的角色叫做 `生产者`，从消息队列中消费获取数据的叫做 `消费者`。\n\n那么消息队列有哪些使用场景呢? 六字真言：异步削峰解耦。\n<!--more-->\n## MQ的异步\n\n异步概念想必大家都熟悉了，就是 a应用（或程序） 将数据传递给b应用（或程序）后，不等待b的响应结果直接做下一步动作，而b并行执行，提高效率。使用mq，就能完美支持异步：a将数据发送到mq，然后自己该干嘛干嘛，b监听mq的消息，来了消息就消费它。这样就做到程序或者应用间的异步。\n\n## mq的削峰\n\n首先我们要知道什么是削峰：削峰的全称应该叫削峰填谷。削峰就是当应用或者程序的请求量过大的时候，将一部分请求延时处理，放到请求量不大时间段去处理它。mq削峰填谷的原理也很简单，mq在应用程序中相当于一个 “蓄水池” 的作用——当 “水流量（请求）” 过大的时候，“蓄水池（mq）” 将 \"水\" 先存起来。当有能力去消费这些水的时候再去从 “蓄水池” 放水。实际的过程是——请求数据先发到 mq ，应用程序监听mq 并消费消息。当请求量大于消费量的时候，请求积压在mq中存储；当消费量大于请求量的时候，请求就会慢慢被处理完。这听上去就像小学做的游泳池放水排水的数学题。\n\n## mq的解耦\n\nmq解耦性是显而易见的，应用程序直接不直接互相耦合，甚至可以不用知道对方的存在。它想要发出什么样的请求，或者拿什么数据，都是去找mq。mq就像个搬运工一样在这些应用之间搬运数据。\n\n## mq 协议及产品\n\nmq 协议有两种，`jms` 和 `AMQP` 。通常而言提到JMS（`Java MessageService`）实际上是指 `JMS API` 。`JMS` 是由Sun公司早期提出的消息标准，旨在为java应用提供统一的消息操作，包括create、send、receive\n\n等。JMS已经成为 `Java Enterprise Edition` 的一部分。从使用角度看，JMS和JDBC担任差不多的角色，用户都是根据相应的接口可以和实现了 `JMS` 的服务进行通信，进行相关的操作。\n\nJMS角色概念：\n\n- JMS provider：实现了JMS接口的消息中间件，如ActiveMQ\n\n- JMS client：生产或者消费消息的应用\n\n- JMS producer/publisher：JMS消息生产者\n\n- JMS consumer/subscriber ：JMS消息消费者\n\n- JMS message：消息，在各个JMS client传输的对象；\n\n- JMS queue：Provider存放等待被消费的消息的地方\n\n- JMS topic：一种提供多个订阅者消费消息的一种机制；在MQ中常常被提到，topic模式。\n\n `AMQP（advanced message queuing protocol）` 在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。AMQP是一种 `binary wire-level protocol`（链接协议）。`AMQP` 不从 API 的层面层对使用规范进行限定，而是直接定义网络交换的数据格式。这意味着实现了amqp协议的消息队列中间件支持跨平台。我们可以使用 Java 的 `AMQP provider` 而 `consumer` 可以是golang 。\n\n在AMQP中，消息路由（`messagerouting`）和JMS存在一些差别，在AMQP中增加了 `Exchange` 和 `binding` 的角色。`producer` 将消息发送给 `Exchange` ，`binding` 决定 `Exchange` 的消息应该发送到那个 `queue`，而consumer直接从queue中消费消息。queue和exchange的bind有consumer来决定。\n\n相对而言，AMQP的消息队列使用的更为广泛。如 `rabbitMQ` , `kafka` , `rocketMQ` 等都是实现AMQP协议的消息队列。接下来我们将会学习 `rabbitMQ` 和 `kafka` 的相关知识。 \n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","slug":"MQ简介","published":1,"updated":"2021-01-12T03:57:30.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5a000000wi8d8o5m6z","content":"<p><code>mq</code> 就是消息队列（<code>Message Queue</code>）。想必大家对队列的数据结构已经很熟悉了，消息队列可以简单理解为：把要传输的数据放在队列中，mq 就是存放和发送消息的这么一个队列中间件。在消息队列中，把数据放到消息队列的角色叫做 <code>生产者</code>，从消息队列中消费获取数据的叫做 <code>消费者</code>。</p>\n<p>那么消息队列有哪些使用场景呢? 六字真言：异步削峰解耦。</p>\n<a id=\"more\"></a>\n<h2 id=\"MQ的异步\"><a href=\"#MQ的异步\" class=\"headerlink\" title=\"MQ的异步\"></a>MQ的异步</h2><p>异步概念想必大家都熟悉了，就是 a应用（或程序） 将数据传递给b应用（或程序）后，不等待b的响应结果直接做下一步动作，而b并行执行，提高效率。使用mq，就能完美支持异步：a将数据发送到mq，然后自己该干嘛干嘛，b监听mq的消息，来了消息就消费它。这样就做到程序或者应用间的异步。</p>\n<h2 id=\"mq的削峰\"><a href=\"#mq的削峰\" class=\"headerlink\" title=\"mq的削峰\"></a>mq的削峰</h2><p>首先我们要知道什么是削峰：削峰的全称应该叫削峰填谷。削峰就是当应用或者程序的请求量过大的时候，将一部分请求延时处理，放到请求量不大时间段去处理它。mq削峰填谷的原理也很简单，mq在应用程序中相当于一个 “蓄水池” 的作用——当 “水流量（请求）” 过大的时候，“蓄水池（mq）” 将 “水” 先存起来。当有能力去消费这些水的时候再去从 “蓄水池” 放水。实际的过程是——请求数据先发到 mq ，应用程序监听mq 并消费消息。当请求量大于消费量的时候，请求积压在mq中存储；当消费量大于请求量的时候，请求就会慢慢被处理完。这听上去就像小学做的游泳池放水排水的数学题。</p>\n<h2 id=\"mq的解耦\"><a href=\"#mq的解耦\" class=\"headerlink\" title=\"mq的解耦\"></a>mq的解耦</h2><p>mq解耦性是显而易见的，应用程序直接不直接互相耦合，甚至可以不用知道对方的存在。它想要发出什么样的请求，或者拿什么数据，都是去找mq。mq就像个搬运工一样在这些应用之间搬运数据。</p>\n<h2 id=\"mq-协议及产品\"><a href=\"#mq-协议及产品\" class=\"headerlink\" title=\"mq 协议及产品\"></a>mq 协议及产品</h2><p>mq 协议有两种，<code>jms</code> 和 <code>AMQP</code> 。通常而言提到JMS（<code>Java MessageService</code>）实际上是指 <code>JMS API</code> 。<code>JMS</code> 是由Sun公司早期提出的消息标准，旨在为java应用提供统一的消息操作，包括create、send、receive</p>\n<p>等。JMS已经成为 <code>Java Enterprise Edition</code> 的一部分。从使用角度看，JMS和JDBC担任差不多的角色，用户都是根据相应的接口可以和实现了 <code>JMS</code> 的服务进行通信，进行相关的操作。</p>\n<p>JMS角色概念：</p>\n<ul>\n<li><p>JMS provider：实现了JMS接口的消息中间件，如ActiveMQ</p>\n</li>\n<li><p>JMS client：生产或者消费消息的应用</p>\n</li>\n<li><p>JMS producer/publisher：JMS消息生产者</p>\n</li>\n<li><p>JMS consumer/subscriber ：JMS消息消费者</p>\n</li>\n<li><p>JMS message：消息，在各个JMS client传输的对象；</p>\n</li>\n<li><p>JMS queue：Provider存放等待被消费的消息的地方</p>\n</li>\n<li><p>JMS topic：一种提供多个订阅者消费消息的一种机制；在MQ中常常被提到，topic模式。</p>\n<p><code>AMQP（advanced message queuing protocol）</code> 在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。AMQP是一种 <code>binary wire-level protocol</code>（链接协议）。<code>AMQP</code> 不从 API 的层面层对使用规范进行限定，而是直接定义网络交换的数据格式。这意味着实现了amqp协议的消息队列中间件支持跨平台。我们可以使用 Java 的 <code>AMQP provider</code> 而 <code>consumer</code> 可以是golang 。</p>\n</li>\n</ul>\n<p>在AMQP中，消息路由（<code>messagerouting</code>）和JMS存在一些差别，在AMQP中增加了 <code>Exchange</code> 和 <code>binding</code> 的角色。<code>producer</code> 将消息发送给 <code>Exchange</code> ，<code>binding</code> 决定 <code>Exchange</code> 的消息应该发送到那个 <code>queue</code>，而consumer直接从queue中消费消息。queue和exchange的bind有consumer来决定。</p>\n<p>相对而言，AMQP的消息队列使用的更为广泛。如 <code>rabbitMQ</code> , <code>kafka</code> , <code>rocketMQ</code> 等都是实现AMQP协议的消息队列。接下来我们将会学习 <code>rabbitMQ</code> 和 <code>kafka</code> 的相关知识。 </p>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>\n","site":{"data":{}},"excerpt":"<p><code>mq</code> 就是消息队列（<code>Message Queue</code>）。想必大家对队列的数据结构已经很熟悉了，消息队列可以简单理解为：把要传输的数据放在队列中，mq 就是存放和发送消息的这么一个队列中间件。在消息队列中，把数据放到消息队列的角色叫做 <code>生产者</code>，从消息队列中消费获取数据的叫做 <code>消费者</code>。</p>\n<p>那么消息队列有哪些使用场景呢? 六字真言：异步削峰解耦。</p>","more":"<h2 id=\"MQ的异步\"><a href=\"#MQ的异步\" class=\"headerlink\" title=\"MQ的异步\"></a>MQ的异步</h2><p>异步概念想必大家都熟悉了，就是 a应用（或程序） 将数据传递给b应用（或程序）后，不等待b的响应结果直接做下一步动作，而b并行执行，提高效率。使用mq，就能完美支持异步：a将数据发送到mq，然后自己该干嘛干嘛，b监听mq的消息，来了消息就消费它。这样就做到程序或者应用间的异步。</p>\n<h2 id=\"mq的削峰\"><a href=\"#mq的削峰\" class=\"headerlink\" title=\"mq的削峰\"></a>mq的削峰</h2><p>首先我们要知道什么是削峰：削峰的全称应该叫削峰填谷。削峰就是当应用或者程序的请求量过大的时候，将一部分请求延时处理，放到请求量不大时间段去处理它。mq削峰填谷的原理也很简单，mq在应用程序中相当于一个 “蓄水池” 的作用——当 “水流量（请求）” 过大的时候，“蓄水池（mq）” 将 “水” 先存起来。当有能力去消费这些水的时候再去从 “蓄水池” 放水。实际的过程是——请求数据先发到 mq ，应用程序监听mq 并消费消息。当请求量大于消费量的时候，请求积压在mq中存储；当消费量大于请求量的时候，请求就会慢慢被处理完。这听上去就像小学做的游泳池放水排水的数学题。</p>\n<h2 id=\"mq的解耦\"><a href=\"#mq的解耦\" class=\"headerlink\" title=\"mq的解耦\"></a>mq的解耦</h2><p>mq解耦性是显而易见的，应用程序直接不直接互相耦合，甚至可以不用知道对方的存在。它想要发出什么样的请求，或者拿什么数据，都是去找mq。mq就像个搬运工一样在这些应用之间搬运数据。</p>\n<h2 id=\"mq-协议及产品\"><a href=\"#mq-协议及产品\" class=\"headerlink\" title=\"mq 协议及产品\"></a>mq 协议及产品</h2><p>mq 协议有两种，<code>jms</code> 和 <code>AMQP</code> 。通常而言提到JMS（<code>Java MessageService</code>）实际上是指 <code>JMS API</code> 。<code>JMS</code> 是由Sun公司早期提出的消息标准，旨在为java应用提供统一的消息操作，包括create、send、receive</p>\n<p>等。JMS已经成为 <code>Java Enterprise Edition</code> 的一部分。从使用角度看，JMS和JDBC担任差不多的角色，用户都是根据相应的接口可以和实现了 <code>JMS</code> 的服务进行通信，进行相关的操作。</p>\n<p>JMS角色概念：</p>\n<ul>\n<li><p>JMS provider：实现了JMS接口的消息中间件，如ActiveMQ</p>\n</li>\n<li><p>JMS client：生产或者消费消息的应用</p>\n</li>\n<li><p>JMS producer/publisher：JMS消息生产者</p>\n</li>\n<li><p>JMS consumer/subscriber ：JMS消息消费者</p>\n</li>\n<li><p>JMS message：消息，在各个JMS client传输的对象；</p>\n</li>\n<li><p>JMS queue：Provider存放等待被消费的消息的地方</p>\n</li>\n<li><p>JMS topic：一种提供多个订阅者消费消息的一种机制；在MQ中常常被提到，topic模式。</p>\n<p><code>AMQP（advanced message queuing protocol）</code> 在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。AMQP是一种 <code>binary wire-level protocol</code>（链接协议）。<code>AMQP</code> 不从 API 的层面层对使用规范进行限定，而是直接定义网络交换的数据格式。这意味着实现了amqp协议的消息队列中间件支持跨平台。我们可以使用 Java 的 <code>AMQP provider</code> 而 <code>consumer</code> 可以是golang 。</p>\n</li>\n</ul>\n<p>在AMQP中，消息路由（<code>messagerouting</code>）和JMS存在一些差别，在AMQP中增加了 <code>Exchange</code> 和 <code>binding</code> 的角色。<code>producer</code> 将消息发送给 <code>Exchange</code> ，<code>binding</code> 决定 <code>Exchange</code> 的消息应该发送到那个 <code>queue</code>，而consumer直接从queue中消费消息。queue和exchange的bind有consumer来决定。</p>\n<p>相对而言，AMQP的消息队列使用的更为广泛。如 <code>rabbitMQ</code> , <code>kafka</code> , <code>rocketMQ</code> 等都是实现AMQP协议的消息队列。接下来我们将会学习 <code>rabbitMQ</code> 和 <code>kafka</code> 的相关知识。 </p>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>"},{"title":"博客搭建新司机指南","date":"2019-04-22T07:17:24.000Z","_content":"\n作者：muggle\n\n## 准备工作\n\n### 安装hexo并创建一个博客项目\n\n在安装hexo之前请确保安装了git 和node.js\n\n打开cmd，输入\n\n```js\nnpm install -g hexo-cli\n```\n\n<!--more-->\n\n创建一个名为blog的博客项目\n\n```\n$ hexo init blog\n$ cd blog\n$ npm install\n```\n\n新建完成后，指定文件夹的目录如下：\n\n```xml\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n### 配置\n\n可以在 `_config.yml` 中修改大部分的配置。配置参数说明：\n\n| 参数          | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| `title`       | 网站标题                                                     |\n| `subtitle`    | 网站副标题                                                   |\n| `description` | 网站描述                                                     |\n| `author`      | 您的名字                                                     |\n| `language`    | 网站使用的语言                                               |\n| `timezone`    | 网站时区。Hexo 默认使用您电脑的时区。[时区列表](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)。比如说：`America/New_York`, `Japan`, 和 `UTC` 。 |\n\n## 撸博客\n\n### 新建文章并查看效果\n\n在项目文件夹下打开cmd 执行\n\n```java\nhexo new \"test\"\n```\n\ntest 为你的文件名，在source文件下的_posts 文件夹里有一个test.md；用markdown编辑器打开，就能写博客辣。\n\n在这个md文件头部有一个`title`的属性，就是你的博客名，还可以在该头部配置日期等属性，这个文件最上方以 `---` 分隔的区域叫Front-matter。以下是一些预先定义的参数，您可在模板中使用这些参数值并加以利用。\n\n| 参数         | 描述                 | 默认值       |\n| :----------- | :------------------- | :----------- |\n| `layout`     | 布局                 |              |\n| `title`      | 标题                 |              |\n| `date`       | 建立日期             | 文件建立日期 |\n| `updated`    | 更新日期             | 文件更新日期 |\n| `comments`   | 开启文章的评论功能   | true         |\n| `tags`       | 标签（不适用于分页） |              |\n| `categories` | 分类（不适用于分页） |              |\n| `permalink`  | 覆盖文章网址         |              |\n\n写完文章保存后，在原来打开的命令窗口 运行\n\n```java\nhexo g\n```\n\n这个指令是构建静态页面，它会在项目下生成一个public文件夹，里面就是我们`hexo g`得到博客静态页面，运行\n\n```java\nhexo s\n```\n\n将代码部署到本地，访问http://localhost:4000/可以查看你的博客效果\n\n### 上传\n\n博客上传之前需要在github上建立一个仓库，仓库名称要为`用户名.github.io`，因为我们博客就算基于gitpages来搭建的，所以我们要按照github的要求来命名。\n\n创建成功之后，修改 hexo 的 `_config.yml` 文件，配置 GitHub 地址，如下：\n\n```java\ndeploy:  \n\ttype: git  \n\trepo: 仓库地址  \n\tbranch: master\n```\n\n配置完成运行\n\n```java\nhexo d \n```\n\n完成部署，这个时候可以访问 `用户名.github.io`这个网址来查看自己的博客\n\n### hexo命令一览\n\n```\n$ hexo init [folder]\n```\n\n新建一个网站。如果没有设置 `folder` ，Hexo 默认在目前的文件夹建立网站。\n\n**new**\n\n```\n$ hexo new [layout] <title>\n```\n\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 [_config.yml](https://hexo.io/zh-cn/docs/configuration) 中的 `default_layout` 参数代替。如果标题包含空格的话，请使用引号括起来。\n\n```\n$ hexo new \"post title with whitespace\"\n```\n\n**generate**\n\n```\n$ hexo generate\n```\n\n生成静态文件。\n\n| 选项             | 描述                   |\n| :--------------- | :--------------------- |\n| `-d`, `--deploy` | 文件生成后立即部署网站 |\n| `-w`, `--watch`  | 监视文件变动           |\n\n该命令可以简写为\n\n```\n$ hexo g\n```\n\n**publish**\n\n```\n$ hexo publish [layout] <filename>\n```\n\n发表草稿。\n\n**server**\n\n```\n$ hexo server\n```\n\n启动服务器。默认情况下，访问网址为： `http://localhost:4000/`。\n\n| 选项             | 描述                           |\n| :--------------- | :----------------------------- |\n| `-p`, `--port`   | 重设端口                       |\n| `-s`, `--static` | 只使用静态文件                 |\n| `-l`, `--log`    | 启动日记记录，使用覆盖记录格式 |\n\n**deploy**\n\n```\n$ hexo deploy\n```\n\n部署网站。\n\n| 参数               | 描述                     |\n| :----------------- | :----------------------- |\n| `-g`, `--generate` | 部署之前预先生成静态文件 |\n\n该命令可以简写为：\n\n```\n$ hexo d\n```\n\n**render**\n\n```\n$ hexo render <file1> [file2] ...\n```\n\n渲染文件。\n\n| 参数             | 描述         |\n| :--------------- | :----------- |\n| `-o`, `--output` | 设置输出路径 |\n\n**migrate**\n\n```\n$ hexo migrate <type>\n```\n\n从其他博客系统 [迁移内容](https://hexo.io/zh-cn/docs/migration)。\n\n**clean**\n\n```\n$ hexo clean\n```\n\n清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。\n\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n**list**\n\n```\n$ hexo list <type>\n```\n\n列出网站资料。\n\n**version**\n\n```\n$ hexo version\n```\n\n显示 Hexo 版本。\n\n**选项**\n\n**安全模式**\n\n```\n$ hexo --safe\n```\n\n在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。\n\n**调试模式**\n\n```\n$ hexo --debug\n```\n\n在终端中显示调试信息并记录到 `debug.log`。当您碰到问题时，可以尝试用调试模式重新执行一次，并 [提交调试信息到 GitHub](https://github.com/hexojs/hexo/issues/new)。\n\n**简洁模式**\n\n```\n$ hexo --silent\n```\n\n隐藏终端信息。\n\n**自定义配置文件的路径**\n\n```\n$ hexo --config custom.yml\n```\n\n自定义配置文件的路径，执行后将不再使用 `_config.yml`。\n\n**显示草稿**\n\n```\n$ hexo --draft\n```\n\n显示 `source/_drafts` 文件夹中的草稿文章。\n\n**自定义 CWD**\n\n```\n$ hexo --cwd /path/to/cwd\n```\n\n自定义当前工作目录（Current working directory）的路径。\n\n## 进阶\n\n### 换主题\n\n下载主题到`./themes`目录下，修改 hexo 的 _config.yml 文件的theme属性为你的主题名就ok了，下面推荐几个hexo主题\n\n- [hexo-theme-next](<https://github.com/iissnan/hexo-theme-next>)\n- [hexo-theme-yilia](https://link.zhihu.com/?target=https%3A//github.com/litten/hexo-theme-yilia)\n- [uno](https://link.zhihu.com/?target=https%3A//github.com/daleanthony/uno)\n- [hexo-theme-strict](https://link.zhihu.com/?target=https%3A//github.com/17/hexo-theme-strict)\n\n### 换域名\n\n首先申请一个域名，然后在博客所在目录下的 source 目录中，创建一个 CNAME 文件，文件内容就是你的域名，然后执行 `hexo d` 命令将这个文件上传到 GitHub就可以了；域名换好后需要配置域名解析。\n\n## 附\n\n### markdown 语法一览\n\n```java\n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n##### 这是五级标题\n###### 这是六级标题\n**这是加粗的文字**\n*这是倾斜的文字*\n***这是斜体加粗的文字***\n~~ 这是加删除线的文字~~\n> 这是引用的内容\n三个或者三个以上的 - 或者 *为分割线\n![图片alt](图片地址 ''图片title'')\n[超链接名](超链接地址 \"超链接title\")\n    \n- 列表内容\n+ 列表内容\n* 列表内容\n注意：- + * 跟内容之间都要有一个空格\n\n1.列表内容\n2.列表内容\n3.列表内容\n\n注意：序号跟内容之间要有空格\n\n表头|表头|表头\n---|:--:|---:\n内容|内容|内容\n内容|内容|内容\n`代码内容`\n​```\n代码内容\n​```\n```\n\n\n\n### markdown文档编辑器Typora\n\n百度Typora 下载安装好之后点 文件>偏好设置>勾选自动保存，这样就不怕忘记保存而文档丢失了；\n\n快捷键：\n- 标题：ctrl+数字\n- 表格：ctrl+t\n- 生成目录：[TOC]按回车\n- 选中一整行：ctrl+l\n- 选中单词：ctrl+d\n- 选中相同格式的文字：ctrl+e\n- 跳转到文章开头：ctrl+home\n- 跳转到文章结尾：ctrl+end\n- 搜索：ctrl+f\n- 替换：ctrl+h\n- 引用：输入>之后输入空格\n- 代码块：ctrl+alt+f\n- 加粗：ctrl+b\n- 倾斜：ctrl+i\n- 下划线：ctrl+u\n- 删除线：alt+shift+5\n- 插入图片：直接拖动到指定位置即可或者ctrl+shift+i\n- 插入链接：ctrl + k\n\n左下角有一个 O 和 </>的符号 O表示打开侧边栏 </>查看文档源代码；\n\n可去官网下载好主题之后点 文件>偏好设置>打开主题文件夹将解压好的主题相关文件复制粘贴到该目录下（一般是一个  主题名称文件夹 和一个 主题名称.css文件）之后重启编辑器 然后点 主题可看见安装好的主题。\n\n","source":"_posts/blog-origin.md","raw":"---\ntitle: 博客搭建新司机指南\ndate: 2019-04-22 15:17:24\ntags: tool\n---\n\n作者：muggle\n\n## 准备工作\n\n### 安装hexo并创建一个博客项目\n\n在安装hexo之前请确保安装了git 和node.js\n\n打开cmd，输入\n\n```js\nnpm install -g hexo-cli\n```\n\n<!--more-->\n\n创建一个名为blog的博客项目\n\n```\n$ hexo init blog\n$ cd blog\n$ npm install\n```\n\n新建完成后，指定文件夹的目录如下：\n\n```xml\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n### 配置\n\n可以在 `_config.yml` 中修改大部分的配置。配置参数说明：\n\n| 参数          | 描述                                                         |\n| :------------ | :----------------------------------------------------------- |\n| `title`       | 网站标题                                                     |\n| `subtitle`    | 网站副标题                                                   |\n| `description` | 网站描述                                                     |\n| `author`      | 您的名字                                                     |\n| `language`    | 网站使用的语言                                               |\n| `timezone`    | 网站时区。Hexo 默认使用您电脑的时区。[时区列表](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)。比如说：`America/New_York`, `Japan`, 和 `UTC` 。 |\n\n## 撸博客\n\n### 新建文章并查看效果\n\n在项目文件夹下打开cmd 执行\n\n```java\nhexo new \"test\"\n```\n\ntest 为你的文件名，在source文件下的_posts 文件夹里有一个test.md；用markdown编辑器打开，就能写博客辣。\n\n在这个md文件头部有一个`title`的属性，就是你的博客名，还可以在该头部配置日期等属性，这个文件最上方以 `---` 分隔的区域叫Front-matter。以下是一些预先定义的参数，您可在模板中使用这些参数值并加以利用。\n\n| 参数         | 描述                 | 默认值       |\n| :----------- | :------------------- | :----------- |\n| `layout`     | 布局                 |              |\n| `title`      | 标题                 |              |\n| `date`       | 建立日期             | 文件建立日期 |\n| `updated`    | 更新日期             | 文件更新日期 |\n| `comments`   | 开启文章的评论功能   | true         |\n| `tags`       | 标签（不适用于分页） |              |\n| `categories` | 分类（不适用于分页） |              |\n| `permalink`  | 覆盖文章网址         |              |\n\n写完文章保存后，在原来打开的命令窗口 运行\n\n```java\nhexo g\n```\n\n这个指令是构建静态页面，它会在项目下生成一个public文件夹，里面就是我们`hexo g`得到博客静态页面，运行\n\n```java\nhexo s\n```\n\n将代码部署到本地，访问http://localhost:4000/可以查看你的博客效果\n\n### 上传\n\n博客上传之前需要在github上建立一个仓库，仓库名称要为`用户名.github.io`，因为我们博客就算基于gitpages来搭建的，所以我们要按照github的要求来命名。\n\n创建成功之后，修改 hexo 的 `_config.yml` 文件，配置 GitHub 地址，如下：\n\n```java\ndeploy:  \n\ttype: git  \n\trepo: 仓库地址  \n\tbranch: master\n```\n\n配置完成运行\n\n```java\nhexo d \n```\n\n完成部署，这个时候可以访问 `用户名.github.io`这个网址来查看自己的博客\n\n### hexo命令一览\n\n```\n$ hexo init [folder]\n```\n\n新建一个网站。如果没有设置 `folder` ，Hexo 默认在目前的文件夹建立网站。\n\n**new**\n\n```\n$ hexo new [layout] <title>\n```\n\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 [_config.yml](https://hexo.io/zh-cn/docs/configuration) 中的 `default_layout` 参数代替。如果标题包含空格的话，请使用引号括起来。\n\n```\n$ hexo new \"post title with whitespace\"\n```\n\n**generate**\n\n```\n$ hexo generate\n```\n\n生成静态文件。\n\n| 选项             | 描述                   |\n| :--------------- | :--------------------- |\n| `-d`, `--deploy` | 文件生成后立即部署网站 |\n| `-w`, `--watch`  | 监视文件变动           |\n\n该命令可以简写为\n\n```\n$ hexo g\n```\n\n**publish**\n\n```\n$ hexo publish [layout] <filename>\n```\n\n发表草稿。\n\n**server**\n\n```\n$ hexo server\n```\n\n启动服务器。默认情况下，访问网址为： `http://localhost:4000/`。\n\n| 选项             | 描述                           |\n| :--------------- | :----------------------------- |\n| `-p`, `--port`   | 重设端口                       |\n| `-s`, `--static` | 只使用静态文件                 |\n| `-l`, `--log`    | 启动日记记录，使用覆盖记录格式 |\n\n**deploy**\n\n```\n$ hexo deploy\n```\n\n部署网站。\n\n| 参数               | 描述                     |\n| :----------------- | :----------------------- |\n| `-g`, `--generate` | 部署之前预先生成静态文件 |\n\n该命令可以简写为：\n\n```\n$ hexo d\n```\n\n**render**\n\n```\n$ hexo render <file1> [file2] ...\n```\n\n渲染文件。\n\n| 参数             | 描述         |\n| :--------------- | :----------- |\n| `-o`, `--output` | 设置输出路径 |\n\n**migrate**\n\n```\n$ hexo migrate <type>\n```\n\n从其他博客系统 [迁移内容](https://hexo.io/zh-cn/docs/migration)。\n\n**clean**\n\n```\n$ hexo clean\n```\n\n清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。\n\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n**list**\n\n```\n$ hexo list <type>\n```\n\n列出网站资料。\n\n**version**\n\n```\n$ hexo version\n```\n\n显示 Hexo 版本。\n\n**选项**\n\n**安全模式**\n\n```\n$ hexo --safe\n```\n\n在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。\n\n**调试模式**\n\n```\n$ hexo --debug\n```\n\n在终端中显示调试信息并记录到 `debug.log`。当您碰到问题时，可以尝试用调试模式重新执行一次，并 [提交调试信息到 GitHub](https://github.com/hexojs/hexo/issues/new)。\n\n**简洁模式**\n\n```\n$ hexo --silent\n```\n\n隐藏终端信息。\n\n**自定义配置文件的路径**\n\n```\n$ hexo --config custom.yml\n```\n\n自定义配置文件的路径，执行后将不再使用 `_config.yml`。\n\n**显示草稿**\n\n```\n$ hexo --draft\n```\n\n显示 `source/_drafts` 文件夹中的草稿文章。\n\n**自定义 CWD**\n\n```\n$ hexo --cwd /path/to/cwd\n```\n\n自定义当前工作目录（Current working directory）的路径。\n\n## 进阶\n\n### 换主题\n\n下载主题到`./themes`目录下，修改 hexo 的 _config.yml 文件的theme属性为你的主题名就ok了，下面推荐几个hexo主题\n\n- [hexo-theme-next](<https://github.com/iissnan/hexo-theme-next>)\n- [hexo-theme-yilia](https://link.zhihu.com/?target=https%3A//github.com/litten/hexo-theme-yilia)\n- [uno](https://link.zhihu.com/?target=https%3A//github.com/daleanthony/uno)\n- [hexo-theme-strict](https://link.zhihu.com/?target=https%3A//github.com/17/hexo-theme-strict)\n\n### 换域名\n\n首先申请一个域名，然后在博客所在目录下的 source 目录中，创建一个 CNAME 文件，文件内容就是你的域名，然后执行 `hexo d` 命令将这个文件上传到 GitHub就可以了；域名换好后需要配置域名解析。\n\n## 附\n\n### markdown 语法一览\n\n```java\n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n##### 这是五级标题\n###### 这是六级标题\n**这是加粗的文字**\n*这是倾斜的文字*\n***这是斜体加粗的文字***\n~~ 这是加删除线的文字~~\n> 这是引用的内容\n三个或者三个以上的 - 或者 *为分割线\n![图片alt](图片地址 ''图片title'')\n[超链接名](超链接地址 \"超链接title\")\n    \n- 列表内容\n+ 列表内容\n* 列表内容\n注意：- + * 跟内容之间都要有一个空格\n\n1.列表内容\n2.列表内容\n3.列表内容\n\n注意：序号跟内容之间要有空格\n\n表头|表头|表头\n---|:--:|---:\n内容|内容|内容\n内容|内容|内容\n`代码内容`\n​```\n代码内容\n​```\n```\n\n\n\n### markdown文档编辑器Typora\n\n百度Typora 下载安装好之后点 文件>偏好设置>勾选自动保存，这样就不怕忘记保存而文档丢失了；\n\n快捷键：\n- 标题：ctrl+数字\n- 表格：ctrl+t\n- 生成目录：[TOC]按回车\n- 选中一整行：ctrl+l\n- 选中单词：ctrl+d\n- 选中相同格式的文字：ctrl+e\n- 跳转到文章开头：ctrl+home\n- 跳转到文章结尾：ctrl+end\n- 搜索：ctrl+f\n- 替换：ctrl+h\n- 引用：输入>之后输入空格\n- 代码块：ctrl+alt+f\n- 加粗：ctrl+b\n- 倾斜：ctrl+i\n- 下划线：ctrl+u\n- 删除线：alt+shift+5\n- 插入图片：直接拖动到指定位置即可或者ctrl+shift+i\n- 插入链接：ctrl + k\n\n左下角有一个 O 和 </>的符号 O表示打开侧边栏 </>查看文档源代码；\n\n可去官网下载好主题之后点 文件>偏好设置>打开主题文件夹将解压好的主题相关文件复制粘贴到该目录下（一般是一个  主题名称文件夹 和一个 主题名称.css文件）之后重启编辑器 然后点 主题可看见安装好的主题。\n\n","slug":"blog-origin","published":1,"updated":"2021-01-11T07:31:23.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5f000100wi3cfrhvmg","content":"<p>作者：muggle</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"安装hexo并创建一个博客项目\"><a href=\"#安装hexo并创建一个博客项目\" class=\"headerlink\" title=\"安装hexo并创建一个博客项目\"></a>安装hexo并创建一个博客项目</h3><p>在安装hexo之前请确保安装了git 和node.js</p>\n<p>打开cmd，输入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n\n<p>创建一个名为blog的博客项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog</span><br><span class=\"line\">$ cd blog</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>新建完成后，指定文件夹的目录如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>可以在 <code>_config.yml</code> 中修改大部分的配置。配置参数说明：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>title</code></td>\n<td align=\"left\">网站标题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>subtitle</code></td>\n<td align=\"left\">网站副标题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>description</code></td>\n<td align=\"left\">网站描述</td>\n</tr>\n<tr>\n<td align=\"left\"><code>author</code></td>\n<td align=\"left\">您的名字</td>\n</tr>\n<tr>\n<td align=\"left\"><code>language</code></td>\n<td align=\"left\">网站使用的语言</td>\n</tr>\n<tr>\n<td align=\"left\"><code>timezone</code></td>\n<td align=\"left\">网站时区。Hexo 默认使用您电脑的时区。<a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td>\n</tr>\n</tbody></table>\n<h2 id=\"撸博客\"><a href=\"#撸博客\" class=\"headerlink\" title=\"撸博客\"></a>撸博客</h2><h3 id=\"新建文章并查看效果\"><a href=\"#新建文章并查看效果\" class=\"headerlink\" title=\"新建文章并查看效果\"></a>新建文章并查看效果</h3><p>在项目文件夹下打开cmd 执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">new</span> <span class=\"string\">&quot;test&quot;</span></span><br></pre></td></tr></table></figure>\n<p>test 为你的文件名，在source文件下的_posts 文件夹里有一个test.md；用markdown编辑器打开，就能写博客辣。</p>\n<p>在这个md文件头部有一个<code>title</code>的属性，就是你的博客名，还可以在该头部配置日期等属性，这个文件最上方以 <code>---</code> 分隔的区域叫Front-matter。以下是一些预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>layout</code></td>\n<td align=\"left\">布局</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>title</code></td>\n<td align=\"left\">标题</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>date</code></td>\n<td align=\"left\">建立日期</td>\n<td align=\"left\">文件建立日期</td>\n</tr>\n<tr>\n<td align=\"left\"><code>updated</code></td>\n<td align=\"left\">更新日期</td>\n<td align=\"left\">文件更新日期</td>\n</tr>\n<tr>\n<td align=\"left\"><code>comments</code></td>\n<td align=\"left\">开启文章的评论功能</td>\n<td align=\"left\">true</td>\n</tr>\n<tr>\n<td align=\"left\"><code>tags</code></td>\n<td align=\"left\">标签（不适用于分页）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>categories</code></td>\n<td align=\"left\">分类（不适用于分页）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>permalink</code></td>\n<td align=\"left\">覆盖文章网址</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>写完文章保存后，在原来打开的命令窗口 运行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<p>这个指令是构建静态页面，它会在项目下生成一个public文件夹，里面就是我们<code>hexo g</code>得到博客静态页面，运行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p>将代码部署到本地，访问<a href=\"http://localhost:4000/可以查看你的博客效果\">http://localhost:4000/可以查看你的博客效果</a></p>\n<h3 id=\"上传\"><a href=\"#上传\" class=\"headerlink\" title=\"上传\"></a>上传</h3><p>博客上传之前需要在github上建立一个仓库，仓库名称要为<code>用户名.github.io</code>，因为我们博客就算基于gitpages来搭建的，所以我们要按照github的要求来命名。</p>\n<p>创建成功之后，修改 hexo 的 <code>_config.yml</code> 文件，配置 GitHub 地址，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:  </span><br><span class=\"line\">\ttype: git  </span><br><span class=\"line\">\trepo: 仓库地址  </span><br><span class=\"line\">\tbranch: master</span><br></pre></td></tr></table></figure>\n<p>配置完成运行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d </span><br></pre></td></tr></table></figure>\n<p>完成部署，这个时候可以访问 <code>用户名.github.io</code>这个网址来查看自己的博客</p>\n<h3 id=\"hexo命令一览\"><a href=\"#hexo命令一览\" class=\"headerlink\" title=\"hexo命令一览\"></a>hexo命令一览</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init [folder]</span><br></pre></td></tr></table></figure>\n<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>\n<p><strong>new</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href=\"https://hexo.io/zh-cn/docs/configuration\">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>generate</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>生成静态文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-d</code>, <code>--deploy</code></td>\n<td align=\"left\">文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-w</code>, <code>--watch</code></td>\n<td align=\"left\">监视文件变动</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n<p><strong>publish</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n<p>发表草稿。</p>\n<p><strong>server</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-p</code>, <code>--port</code></td>\n<td align=\"left\">重设端口</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-s</code>, <code>--static</code></td>\n<td align=\"left\">只使用静态文件</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-l</code>, <code>--log</code></td>\n<td align=\"left\">启动日记记录，使用覆盖记录格式</td>\n</tr>\n</tbody></table>\n<p><strong>deploy</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>部署网站。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-g</code>, <code>--generate</code></td>\n<td align=\"left\">部署之前预先生成静态文件</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n<p><strong>render</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>\n<p>渲染文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-o</code>, <code>--output</code></td>\n<td align=\"left\">设置输出路径</td>\n</tr>\n</tbody></table>\n<p><strong>migrate</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure>\n<p>从其他博客系统 <a href=\"https://hexo.io/zh-cn/docs/migration\">迁移内容</a>。</p>\n<p><strong>clean</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>\n<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>\n<p><strong>list</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>\n<p>列出网站资料。</p>\n<p><strong>version</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo version</span><br></pre></td></tr></table></figure>\n<p>显示 Hexo 版本。</p>\n<p><strong>选项</strong></p>\n<p><strong>安全模式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --safe</span><br></pre></td></tr></table></figure>\n<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>\n<p><strong>调试模式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --debug</span><br></pre></td></tr></table></figure>\n<p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href=\"https://github.com/hexojs/hexo/issues/new\">提交调试信息到 GitHub</a>。</p>\n<p><strong>简洁模式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --silent</span><br></pre></td></tr></table></figure>\n<p>隐藏终端信息。</p>\n<p><strong>自定义配置文件的路径</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --config custom.yml</span><br></pre></td></tr></table></figure>\n<p>自定义配置文件的路径，执行后将不再使用 <code>_config.yml</code>。</p>\n<p><strong>显示草稿</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --draft</span><br></pre></td></tr></table></figure>\n<p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>\n<p><strong>自定义 CWD</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd</span><br></pre></td></tr></table></figure>\n<p>自定义当前工作目录（Current working directory）的路径。</p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><h3 id=\"换主题\"><a href=\"#换主题\" class=\"headerlink\" title=\"换主题\"></a>换主题</h3><p>下载主题到<code>./themes</code>目录下，修改 hexo 的 _config.yml 文件的theme属性为你的主题名就ok了，下面推荐几个hexo主题</p>\n<ul>\n<li><a href=\"https://github.com/iissnan/hexo-theme-next\">hexo-theme-next</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/litten/hexo-theme-yilia\">hexo-theme-yilia</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/daleanthony/uno\">uno</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/17/hexo-theme-strict\">hexo-theme-strict</a></li>\n</ul>\n<h3 id=\"换域名\"><a href=\"#换域名\" class=\"headerlink\" title=\"换域名\"></a>换域名</h3><p>首先申请一个域名，然后在博客所在目录下的 source 目录中，创建一个 CNAME 文件，文件内容就是你的域名，然后执行 <code>hexo d</code> 命令将这个文件上传到 GitHub就可以了；域名换好后需要配置域名解析。</p>\n<h2 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h2><h3 id=\"markdown-语法一览\"><a href=\"#markdown-语法一览\" class=\"headerlink\" title=\"markdown 语法一览\"></a>markdown 语法一览</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是一级标题</span><br><span class=\"line\">## 这是二级标题</span><br><span class=\"line\">### 这是三级标题</span><br><span class=\"line\">#### 这是四级标题</span><br><span class=\"line\">##### 这是五级标题</span><br><span class=\"line\">###### 这是六级标题</span><br><span class=\"line\">**这是加粗的文字**</span><br><span class=\"line\">*这是倾斜的文字*</span><br><span class=\"line\">***这是斜体加粗的文字***</span><br><span class=\"line\">~~ 这是加删除线的文字~~</span><br><span class=\"line\">&gt; 这是引用的内容</span><br><span class=\"line\">三个或者三个以上的 - 或者 *为分割线</span><br><span class=\"line\">![图片alt](图片地址 <span class=\"string\">&#x27;&#x27;</span>图片title<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">[超链接名](超链接地址 <span class=\"string\">&quot;超链接title&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">- 列表内容</span><br><span class=\"line\">+ 列表内容</span><br><span class=\"line\">* 列表内容</span><br><span class=\"line\">注意：- + * 跟内容之间都要有一个空格</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>列表内容</span><br><span class=\"line\"><span class=\"number\">2.</span>列表内容</span><br><span class=\"line\"><span class=\"number\">3.</span>列表内容</span><br><span class=\"line\"></span><br><span class=\"line\">注意：序号跟内容之间要有空格</span><br><span class=\"line\"></span><br><span class=\"line\">表头|表头|表头</span><br><span class=\"line\">---|:--:|---:</span><br><span class=\"line\">内容|内容|内容</span><br><span class=\"line\">内容|内容|内容</span><br><span class=\"line\">`代码内容`</span><br><span class=\"line\">​```</span><br><span class=\"line\">代码内容</span><br><span class=\"line\">​```</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"markdown文档编辑器Typora\"><a href=\"#markdown文档编辑器Typora\" class=\"headerlink\" title=\"markdown文档编辑器Typora\"></a>markdown文档编辑器Typora</h3><p>百度Typora 下载安装好之后点 文件&gt;偏好设置&gt;勾选自动保存，这样就不怕忘记保存而文档丢失了；</p>\n<p>快捷键：</p>\n<ul>\n<li>标题：ctrl+数字</li>\n<li>表格：ctrl+t</li>\n<li>生成目录：[TOC]按回车</li>\n<li>选中一整行：ctrl+l</li>\n<li>选中单词：ctrl+d</li>\n<li>选中相同格式的文字：ctrl+e</li>\n<li>跳转到文章开头：ctrl+home</li>\n<li>跳转到文章结尾：ctrl+end</li>\n<li>搜索：ctrl+f</li>\n<li>替换：ctrl+h</li>\n<li>引用：输入&gt;之后输入空格</li>\n<li>代码块：ctrl+alt+f</li>\n<li>加粗：ctrl+b</li>\n<li>倾斜：ctrl+i</li>\n<li>下划线：ctrl+u</li>\n<li>删除线：alt+shift+5</li>\n<li>插入图片：直接拖动到指定位置即可或者ctrl+shift+i</li>\n<li>插入链接：ctrl + k</li>\n</ul>\n<p>左下角有一个 O 和 &lt;/&gt;的符号 O表示打开侧边栏 &lt;/&gt;查看文档源代码；</p>\n<p>可去官网下载好主题之后点 文件&gt;偏好设置&gt;打开主题文件夹将解压好的主题相关文件复制粘贴到该目录下（一般是一个  主题名称文件夹 和一个 主题名称.css文件）之后重启编辑器 然后点 主题可看见安装好的主题。</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"安装hexo并创建一个博客项目\"><a href=\"#安装hexo并创建一个博客项目\" class=\"headerlink\" title=\"安装hexo并创建一个博客项目\"></a>安装hexo并创建一个博客项目</h3><p>在安装hexo之前请确保安装了git 和node.js</p>\n<p>打开cmd，输入</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>","more":"<p>创建一个名为blog的博客项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init blog</span><br><span class=\"line\">$ cd blog</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>新建完成后，指定文件夹的目录如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>可以在 <code>_config.yml</code> 中修改大部分的配置。配置参数说明：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>title</code></td>\n<td align=\"left\">网站标题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>subtitle</code></td>\n<td align=\"left\">网站副标题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>description</code></td>\n<td align=\"left\">网站描述</td>\n</tr>\n<tr>\n<td align=\"left\"><code>author</code></td>\n<td align=\"left\">您的名字</td>\n</tr>\n<tr>\n<td align=\"left\"><code>language</code></td>\n<td align=\"left\">网站使用的语言</td>\n</tr>\n<tr>\n<td align=\"left\"><code>timezone</code></td>\n<td align=\"left\">网站时区。Hexo 默认使用您电脑的时区。<a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td>\n</tr>\n</tbody></table>\n<h2 id=\"撸博客\"><a href=\"#撸博客\" class=\"headerlink\" title=\"撸博客\"></a>撸博客</h2><h3 id=\"新建文章并查看效果\"><a href=\"#新建文章并查看效果\" class=\"headerlink\" title=\"新建文章并查看效果\"></a>新建文章并查看效果</h3><p>在项目文件夹下打开cmd 执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">new</span> <span class=\"string\">&quot;test&quot;</span></span><br></pre></td></tr></table></figure>\n<p>test 为你的文件名，在source文件下的_posts 文件夹里有一个test.md；用markdown编辑器打开，就能写博客辣。</p>\n<p>在这个md文件头部有一个<code>title</code>的属性，就是你的博客名，还可以在该头部配置日期等属性，这个文件最上方以 <code>---</code> 分隔的区域叫Front-matter。以下是一些预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>layout</code></td>\n<td align=\"left\">布局</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>title</code></td>\n<td align=\"left\">标题</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>date</code></td>\n<td align=\"left\">建立日期</td>\n<td align=\"left\">文件建立日期</td>\n</tr>\n<tr>\n<td align=\"left\"><code>updated</code></td>\n<td align=\"left\">更新日期</td>\n<td align=\"left\">文件更新日期</td>\n</tr>\n<tr>\n<td align=\"left\"><code>comments</code></td>\n<td align=\"left\">开启文章的评论功能</td>\n<td align=\"left\">true</td>\n</tr>\n<tr>\n<td align=\"left\"><code>tags</code></td>\n<td align=\"left\">标签（不适用于分页）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>categories</code></td>\n<td align=\"left\">分类（不适用于分页）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>permalink</code></td>\n<td align=\"left\">覆盖文章网址</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>写完文章保存后，在原来打开的命令窗口 运行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<p>这个指令是构建静态页面，它会在项目下生成一个public文件夹，里面就是我们<code>hexo g</code>得到博客静态页面，运行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p>将代码部署到本地，访问<a href=\"http://localhost:4000/可以查看你的博客效果\">http://localhost:4000/可以查看你的博客效果</a></p>\n<h3 id=\"上传\"><a href=\"#上传\" class=\"headerlink\" title=\"上传\"></a>上传</h3><p>博客上传之前需要在github上建立一个仓库，仓库名称要为<code>用户名.github.io</code>，因为我们博客就算基于gitpages来搭建的，所以我们要按照github的要求来命名。</p>\n<p>创建成功之后，修改 hexo 的 <code>_config.yml</code> 文件，配置 GitHub 地址，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:  </span><br><span class=\"line\">\ttype: git  </span><br><span class=\"line\">\trepo: 仓库地址  </span><br><span class=\"line\">\tbranch: master</span><br></pre></td></tr></table></figure>\n<p>配置完成运行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d </span><br></pre></td></tr></table></figure>\n<p>完成部署，这个时候可以访问 <code>用户名.github.io</code>这个网址来查看自己的博客</p>\n<h3 id=\"hexo命令一览\"><a href=\"#hexo命令一览\" class=\"headerlink\" title=\"hexo命令一览\"></a>hexo命令一览</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init [folder]</span><br></pre></td></tr></table></figure>\n<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>\n<p><strong>new</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href=\"https://hexo.io/zh-cn/docs/configuration\">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>generate</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>生成静态文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-d</code>, <code>--deploy</code></td>\n<td align=\"left\">文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-w</code>, <code>--watch</code></td>\n<td align=\"left\">监视文件变动</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n<p><strong>publish</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n<p>发表草稿。</p>\n<p><strong>server</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-p</code>, <code>--port</code></td>\n<td align=\"left\">重设端口</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-s</code>, <code>--static</code></td>\n<td align=\"left\">只使用静态文件</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-l</code>, <code>--log</code></td>\n<td align=\"left\">启动日记记录，使用覆盖记录格式</td>\n</tr>\n</tbody></table>\n<p><strong>deploy</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>部署网站。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-g</code>, <code>--generate</code></td>\n<td align=\"left\">部署之前预先生成静态文件</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n<p><strong>render</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>\n<p>渲染文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-o</code>, <code>--output</code></td>\n<td align=\"left\">设置输出路径</td>\n</tr>\n</tbody></table>\n<p><strong>migrate</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure>\n<p>从其他博客系统 <a href=\"https://hexo.io/zh-cn/docs/migration\">迁移内容</a>。</p>\n<p><strong>clean</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>\n<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>\n<p><strong>list</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>\n<p>列出网站资料。</p>\n<p><strong>version</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo version</span><br></pre></td></tr></table></figure>\n<p>显示 Hexo 版本。</p>\n<p><strong>选项</strong></p>\n<p><strong>安全模式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --safe</span><br></pre></td></tr></table></figure>\n<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>\n<p><strong>调试模式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --debug</span><br></pre></td></tr></table></figure>\n<p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href=\"https://github.com/hexojs/hexo/issues/new\">提交调试信息到 GitHub</a>。</p>\n<p><strong>简洁模式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --silent</span><br></pre></td></tr></table></figure>\n<p>隐藏终端信息。</p>\n<p><strong>自定义配置文件的路径</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --config custom.yml</span><br></pre></td></tr></table></figure>\n<p>自定义配置文件的路径，执行后将不再使用 <code>_config.yml</code>。</p>\n<p><strong>显示草稿</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --draft</span><br></pre></td></tr></table></figure>\n<p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>\n<p><strong>自定义 CWD</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd</span><br></pre></td></tr></table></figure>\n<p>自定义当前工作目录（Current working directory）的路径。</p>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><h3 id=\"换主题\"><a href=\"#换主题\" class=\"headerlink\" title=\"换主题\"></a>换主题</h3><p>下载主题到<code>./themes</code>目录下，修改 hexo 的 _config.yml 文件的theme属性为你的主题名就ok了，下面推荐几个hexo主题</p>\n<ul>\n<li><a href=\"https://github.com/iissnan/hexo-theme-next\">hexo-theme-next</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/litten/hexo-theme-yilia\">hexo-theme-yilia</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/daleanthony/uno\">uno</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/17/hexo-theme-strict\">hexo-theme-strict</a></li>\n</ul>\n<h3 id=\"换域名\"><a href=\"#换域名\" class=\"headerlink\" title=\"换域名\"></a>换域名</h3><p>首先申请一个域名，然后在博客所在目录下的 source 目录中，创建一个 CNAME 文件，文件内容就是你的域名，然后执行 <code>hexo d</code> 命令将这个文件上传到 GitHub就可以了；域名换好后需要配置域名解析。</p>\n<h2 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h2><h3 id=\"markdown-语法一览\"><a href=\"#markdown-语法一览\" class=\"headerlink\" title=\"markdown 语法一览\"></a>markdown 语法一览</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是一级标题</span><br><span class=\"line\">## 这是二级标题</span><br><span class=\"line\">### 这是三级标题</span><br><span class=\"line\">#### 这是四级标题</span><br><span class=\"line\">##### 这是五级标题</span><br><span class=\"line\">###### 这是六级标题</span><br><span class=\"line\">**这是加粗的文字**</span><br><span class=\"line\">*这是倾斜的文字*</span><br><span class=\"line\">***这是斜体加粗的文字***</span><br><span class=\"line\">~~ 这是加删除线的文字~~</span><br><span class=\"line\">&gt; 这是引用的内容</span><br><span class=\"line\">三个或者三个以上的 - 或者 *为分割线</span><br><span class=\"line\">![图片alt](图片地址 <span class=\"string\">&#x27;&#x27;</span>图片title<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">[超链接名](超链接地址 <span class=\"string\">&quot;超链接title&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">- 列表内容</span><br><span class=\"line\">+ 列表内容</span><br><span class=\"line\">* 列表内容</span><br><span class=\"line\">注意：- + * 跟内容之间都要有一个空格</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>列表内容</span><br><span class=\"line\"><span class=\"number\">2.</span>列表内容</span><br><span class=\"line\"><span class=\"number\">3.</span>列表内容</span><br><span class=\"line\"></span><br><span class=\"line\">注意：序号跟内容之间要有空格</span><br><span class=\"line\"></span><br><span class=\"line\">表头|表头|表头</span><br><span class=\"line\">---|:--:|---:</span><br><span class=\"line\">内容|内容|内容</span><br><span class=\"line\">内容|内容|内容</span><br><span class=\"line\">`代码内容`</span><br><span class=\"line\">​```</span><br><span class=\"line\">代码内容</span><br><span class=\"line\">​```</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"markdown文档编辑器Typora\"><a href=\"#markdown文档编辑器Typora\" class=\"headerlink\" title=\"markdown文档编辑器Typora\"></a>markdown文档编辑器Typora</h3><p>百度Typora 下载安装好之后点 文件&gt;偏好设置&gt;勾选自动保存，这样就不怕忘记保存而文档丢失了；</p>\n<p>快捷键：</p>\n<ul>\n<li>标题：ctrl+数字</li>\n<li>表格：ctrl+t</li>\n<li>生成目录：[TOC]按回车</li>\n<li>选中一整行：ctrl+l</li>\n<li>选中单词：ctrl+d</li>\n<li>选中相同格式的文字：ctrl+e</li>\n<li>跳转到文章开头：ctrl+home</li>\n<li>跳转到文章结尾：ctrl+end</li>\n<li>搜索：ctrl+f</li>\n<li>替换：ctrl+h</li>\n<li>引用：输入&gt;之后输入空格</li>\n<li>代码块：ctrl+alt+f</li>\n<li>加粗：ctrl+b</li>\n<li>倾斜：ctrl+i</li>\n<li>下划线：ctrl+u</li>\n<li>删除线：alt+shift+5</li>\n<li>插入图片：直接拖动到指定位置即可或者ctrl+shift+i</li>\n<li>插入链接：ctrl + k</li>\n</ul>\n<p>左下角有一个 O 和 &lt;/&gt;的符号 O表示打开侧边栏 &lt;/&gt;查看文档源代码；</p>\n<p>可去官网下载好主题之后点 文件&gt;偏好设置&gt;打开主题文件夹将解压好的主题相关文件复制粘贴到该目录下（一般是一个  主题名称文件夹 和一个 主题名称.css文件）之后重启编辑器 然后点 主题可看见安装好的主题。</p>"},{"title":"注解及其反射机制","date":"2019-05-15T08:53:32.000Z","_content":"\n# 注解相关知识\n\n## 元注解\n\n1. @Retention：生命周期，RetentionPolicy.SOURCE 注解只在源码阶段保留，RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM中，RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候\n2. @Documented：作用是能够将注解中的元素包含到 Javadoc 中去。\n3. @Target：指定了注解运用的地方。ElementType.ANNOTATION_TYPE 可以给一个注解进行注解，ElementType.CONSTRUCTOR 可以给构造方法，ElementType.FIELD 可以给属性，ElementType.LOCAL_VARIABLE 可以给局部变量，ElementType.METHOD 可以给方法，ElementType.PACKAGE 可以给一个包，ElementType.PARAMETER 可以给一个方法内的参数，ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举\n4. @Inherited：一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。\n5. @Repeatable ：可重复注解\n\n<!--more-->\n\n## 注解的属性\n\n注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。\n\n```java\npublic class BootStaterTestApplicationTests {\n    @Test\n    public void contextLoads() {\n        @muggle(test = \"ss\")\n        String test=\"ss\";\n    }\n}\n\n@Target(ElementType.LOCAL_VARIABLE)\n@interface muggle{\n    String test();\n}\n```\n\n解中属性可以有默认值，默认值需要用 default 关键值指定。\n\n```java\n@Target(ElementType.LOCAL_VARIABLE)\n@interface muggle{\n    String test()default \"test\";\n}\n```\n\n一些缺省写法略\n\n## 反射获取注解\n\n类注解\n\n```java\n\t\ttest test = new test();\n        Class<? extends com.muggle.bootstatertest.test> aClass = test.getClass();\n        Class<Muggle> muggleClass = Muggle.class;\n        boolean annotationPresent = aClass.isAnnotationPresent(muggleClass);\n        System.out.println(annotationPresent);\n        Annotation[] annotations = aClass.getAnnotations();\n        Muggle annotation = aClass.getAnnotation(Muggle.class);\n```\n\n属性注解\n\n```java\nField[] fields = aClass.getFields();\nAnnotation[] annotations1 = fields[0].getAnnotations();\n```\n\n方法注解\n\n```java\nMethod[] methods = aClass.getMethods();\nMethod[] declaredMethod = aClass.getDeclaredMethods();\nAnnotation[] declaredAnnotations = methods[0].getDeclaredAnnotations();\n```\n\n","source":"_posts/annotation.md","raw":"---\ntitle: 注解及其反射机制\ndate: 2019-05-15 16:53:32\ntags: javase\n---\n\n# 注解相关知识\n\n## 元注解\n\n1. @Retention：生命周期，RetentionPolicy.SOURCE 注解只在源码阶段保留，RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM中，RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候\n2. @Documented：作用是能够将注解中的元素包含到 Javadoc 中去。\n3. @Target：指定了注解运用的地方。ElementType.ANNOTATION_TYPE 可以给一个注解进行注解，ElementType.CONSTRUCTOR 可以给构造方法，ElementType.FIELD 可以给属性，ElementType.LOCAL_VARIABLE 可以给局部变量，ElementType.METHOD 可以给方法，ElementType.PACKAGE 可以给一个包，ElementType.PARAMETER 可以给一个方法内的参数，ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举\n4. @Inherited：一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。\n5. @Repeatable ：可重复注解\n\n<!--more-->\n\n## 注解的属性\n\n注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。\n\n```java\npublic class BootStaterTestApplicationTests {\n    @Test\n    public void contextLoads() {\n        @muggle(test = \"ss\")\n        String test=\"ss\";\n    }\n}\n\n@Target(ElementType.LOCAL_VARIABLE)\n@interface muggle{\n    String test();\n}\n```\n\n解中属性可以有默认值，默认值需要用 default 关键值指定。\n\n```java\n@Target(ElementType.LOCAL_VARIABLE)\n@interface muggle{\n    String test()default \"test\";\n}\n```\n\n一些缺省写法略\n\n## 反射获取注解\n\n类注解\n\n```java\n\t\ttest test = new test();\n        Class<? extends com.muggle.bootstatertest.test> aClass = test.getClass();\n        Class<Muggle> muggleClass = Muggle.class;\n        boolean annotationPresent = aClass.isAnnotationPresent(muggleClass);\n        System.out.println(annotationPresent);\n        Annotation[] annotations = aClass.getAnnotations();\n        Muggle annotation = aClass.getAnnotation(Muggle.class);\n```\n\n属性注解\n\n```java\nField[] fields = aClass.getFields();\nAnnotation[] annotations1 = fields[0].getAnnotations();\n```\n\n方法注解\n\n```java\nMethod[] methods = aClass.getMethods();\nMethod[] declaredMethod = aClass.getDeclaredMethods();\nAnnotation[] declaredAnnotations = methods[0].getDeclaredAnnotations();\n```\n\n","slug":"annotation","published":1,"updated":"2021-01-11T07:31:23.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5i000300wi5hdt5pax","content":"<h1 id=\"注解相关知识\"><a href=\"#注解相关知识\" class=\"headerlink\" title=\"注解相关知识\"></a>注解相关知识</h1><h2 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h2><ol>\n<li>@Retention：生命周期，RetentionPolicy.SOURCE 注解只在源码阶段保留，RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM中，RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候</li>\n<li>@Documented：作用是能够将注解中的元素包含到 Javadoc 中去。</li>\n<li>@Target：指定了注解运用的地方。ElementType.ANNOTATION_TYPE 可以给一个注解进行注解，ElementType.CONSTRUCTOR 可以给构造方法，ElementType.FIELD 可以给属性，ElementType.LOCAL_VARIABLE 可以给局部变量，ElementType.METHOD 可以给方法，ElementType.PACKAGE 可以给一个包，ElementType.PARAMETER 可以给一个方法内的参数，ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li>\n<li>@Inherited：一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</li>\n<li>@Repeatable ：可重复注解</li>\n</ol>\n<a id=\"more\"></a>\n\n<h2 id=\"注解的属性\"><a href=\"#注解的属性\" class=\"headerlink\" title=\"注解的属性\"></a>注解的属性</h2><p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootStaterTestApplicationTests</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextLoads</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@muggle(test = &quot;ss&quot;)</span></span><br><span class=\"line\">        String test=<span class=\"string\">&quot;ss&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.LOCAL_VARIABLE)</span></span><br><span class=\"line\"><span class=\"meta\">@interface</span> muggle&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解中属性可以有默认值，默认值需要用 default 关键值指定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.LOCAL_VARIABLE)</span></span><br><span class=\"line\"><span class=\"meta\">@interface</span> muggle&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">()</span><span class=\"keyword\">default</span> &quot;test&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一些缺省写法略</p>\n<h2 id=\"反射获取注解\"><a href=\"#反射获取注解\" class=\"headerlink\" title=\"反射获取注解\"></a>反射获取注解</h2><p>类注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test test = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\">      Class&lt;? extends com.muggle.bootstatertest.test&gt; aClass = test.getClass();</span><br><span class=\"line\">      Class&lt;Muggle&gt; muggleClass = Muggle.class;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> annotationPresent = aClass.isAnnotationPresent(muggleClass);</span><br><span class=\"line\">      System.out.println(annotationPresent);</span><br><span class=\"line\">      Annotation[] annotations = aClass.getAnnotations();</span><br><span class=\"line\">      Muggle annotation = aClass.getAnnotation(Muggle.class);</span><br></pre></td></tr></table></figure>\n<p>属性注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field[] fields = aClass.getFields();</span><br><span class=\"line\">Annotation[] annotations1 = fields[<span class=\"number\">0</span>].getAnnotations();</span><br></pre></td></tr></table></figure>\n<p>方法注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] methods = aClass.getMethods();</span><br><span class=\"line\">Method[] declaredMethod = aClass.getDeclaredMethods();</span><br><span class=\"line\">Annotation[] declaredAnnotations = methods[<span class=\"number\">0</span>].getDeclaredAnnotations();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"注解相关知识\"><a href=\"#注解相关知识\" class=\"headerlink\" title=\"注解相关知识\"></a>注解相关知识</h1><h2 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h2><ol>\n<li>@Retention：生命周期，RetentionPolicy.SOURCE 注解只在源码阶段保留，RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM中，RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候</li>\n<li>@Documented：作用是能够将注解中的元素包含到 Javadoc 中去。</li>\n<li>@Target：指定了注解运用的地方。ElementType.ANNOTATION_TYPE 可以给一个注解进行注解，ElementType.CONSTRUCTOR 可以给构造方法，ElementType.FIELD 可以给属性，ElementType.LOCAL_VARIABLE 可以给局部变量，ElementType.METHOD 可以给方法，ElementType.PACKAGE 可以给一个包，ElementType.PARAMETER 可以给一个方法内的参数，ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li>\n<li>@Inherited：一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</li>\n<li>@Repeatable ：可重复注解</li>\n</ol>","more":"<h2 id=\"注解的属性\"><a href=\"#注解的属性\" class=\"headerlink\" title=\"注解的属性\"></a>注解的属性</h2><p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootStaterTestApplicationTests</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextLoads</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@muggle(test = &quot;ss&quot;)</span></span><br><span class=\"line\">        String test=<span class=\"string\">&quot;ss&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.LOCAL_VARIABLE)</span></span><br><span class=\"line\"><span class=\"meta\">@interface</span> muggle&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解中属性可以有默认值，默认值需要用 default 关键值指定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.LOCAL_VARIABLE)</span></span><br><span class=\"line\"><span class=\"meta\">@interface</span> muggle&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">()</span><span class=\"keyword\">default</span> &quot;test&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一些缺省写法略</p>\n<h2 id=\"反射获取注解\"><a href=\"#反射获取注解\" class=\"headerlink\" title=\"反射获取注解\"></a>反射获取注解</h2><p>类注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test test = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\">      Class&lt;? extends com.muggle.bootstatertest.test&gt; aClass = test.getClass();</span><br><span class=\"line\">      Class&lt;Muggle&gt; muggleClass = Muggle.class;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> annotationPresent = aClass.isAnnotationPresent(muggleClass);</span><br><span class=\"line\">      System.out.println(annotationPresent);</span><br><span class=\"line\">      Annotation[] annotations = aClass.getAnnotations();</span><br><span class=\"line\">      Muggle annotation = aClass.getAnnotation(Muggle.class);</span><br></pre></td></tr></table></figure>\n<p>属性注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field[] fields = aClass.getFields();</span><br><span class=\"line\">Annotation[] annotations1 = fields[<span class=\"number\">0</span>].getAnnotations();</span><br></pre></td></tr></table></figure>\n<p>方法注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] methods = aClass.getMethods();</span><br><span class=\"line\">Method[] declaredMethod = aClass.getDeclaredMethods();</span><br><span class=\"line\">Annotation[] declaredAnnotations = methods[<span class=\"number\">0</span>].getDeclaredAnnotations();</span><br></pre></td></tr></table></figure>"},{"title":"聊一聊代码规范","date":"2021-01-11T07:58:52.000Z","_content":"\n# 代码混乱的常见问题\n\n很多时候我们项目迭代到后期，项目会变得很混乱，往往只有少数人能知道某段代码是干嘛的和该如何去改，或者是干脆谁都不知道，只能靠通过注释去猜测这段代码可能的作用。原因有可能是因为团队内部的人事变动，导致原先写这段代码的人不再管理这段代码了，并且代码写的实在是屎没人捋的清。往往我们称这类代码为“祖传代码”，就像祖宗传下来的代码一样，没人懂没人敢动。祖传代码一多，这个项目就变成了屎一样，开发人员再这基础上迭代就如同屎海翻腾，恶心别人也恶心自己。这是一个很可怕的恶心循环，我们如何去避免这种事情发生呢？先让我们分析下这类代码的通病\n\n<!--more-->\n\n## 代码又臭又长\n\n我见过最长的方法是5000多行，那段代码没人敢动，只敢往下加 if else，每次需要改这段代码的开发都战战兢兢，生怕出现什么莫名其妙的bug。java 可是一门面向对象的语言，一个方法里面有5000多行可以说是很可恶的事情了。我想一开始代码长度可能没这么夸张，是什么导致这种结果的？一个是当初写这段代码的人本身写的是直来直去的方法，一堆if else ；后面迭代的开发，面对这么长的代码瞬间失去了从头读到尾的耐心，直接继续在后面加 if else 迭代，最后这个方法就变成了一个缝合怪一样的玩意。\n\n好的 sql 可以很大程度上简化代码的复杂程度，但是太过复杂sql 本身就会给后来的开发人员造成阅读困难，结果又是变成一条无人敢动的祖传代码，我想这应该是不少公司极度抵制存储过程的原因之一。当然不少银行应用开发还是大量使用存储过程，存储过程有用武之地的，但是一个又臭又长的存储过程就等着变成祖传代码吧。当年我见到一个60多个join的sql，看到第一眼就惊为天人从此难以忘怀，当然那段sql也成了没人敢去动的代码了。\n\n## 代码逻辑不明所以\n\n代码逻辑不明所以是我们开发很容易去犯的毛病，是一个不致命却烦人的毛病。在代码上的体现是，逻辑判断写的比较反人类各种双重否定是肯定，不把你绕晕不罢休。或者是写起代码来东一榔头西一棒槌，让人不知道你想干嘛。导致这个的原因有可能是开发人员在需求理解上出现偏差，做到后面发现不对劲，再回去改又不大可能了，只能硬着头皮往下写，结果就是代码弯弯绕绕；还有很重要的锅是在产品经理，任意变更需求，想一出是一出，开发人员无奈只能跟着想一出写一出。还用可能是开发人员方法或者类命名太艺术了，什么四川方言拼音这种没有十年脑血栓想不出的命名咱就不说了。就说那种国产凌凌漆式的无厘头命名——这看上去是个刮胡刀实际上是个吹风机，就这种不知道让人说什么好。\n\n# 规划代码的核心思想\n\n吐槽了一堆代码规范问题，接下来我们说说如何去规范我们的代码以及如何做到就算开发人员更换了，或者项目转手给他人了，仍然可以让后面的开发可以无碍的去阅读代码修改代码。当然各个公司/团队都有自己的一套代码规范，比如项目的结构、代码命名风格、代码格式等等。不同团队有不同的风格，但核心思想是大同小异的。接下来我就我个人的开发经验来分享一下一些代码规范的思想。\n\n## 花叶论\n\n就我个人而言，这个理论是我代码规范中最浅显也是最核心的思想，只要稍微动动脑子就能想出这个思路出来。或许我们做业务开发的时候，大部分都在写crud，感觉似乎这部分代码没什么规范好说的，其实不然。对一段业务代码而言，我们可以将其分为四类：\n\n- 数据校验\n- 业务逻辑\n- 数据转换\n- 数据库交互（查询与持久化）\n\n大部分时候我们最关心的是逻辑判断相关的代码，其次是数据库交互，对于远程调用的方法，我们就视其为一个普通的方法以简化模型，方法调用算业务逻辑部分的代码，对于读代码的人而言基本上不关心数据校验和数据的转换（DTO转VO等）。因此，代码应该分出一个主次，应该尽量把主逻辑给凸显出来，最好一眼看去就能让人明白这个方法或者这个类干了啥，步骤是什么样的。对于那些不重要但必要的代码我称其为叶，对于那些主要的代码我称其为花。叶是为了衬托花的，因此我们应该将那些叶子代码精简或者隐藏起来。\n\n隐藏叶子代码，突出主干逻辑的一些手法\n\n1）Converter（转换器）\n\n大部分时候我们使用 bean 拷贝使用的是 `BeanUtils` 这个类来完成，然而一些稍微复杂的实体转换，这个类就无法胜任了，这个时候我们只能手动的 get set ,往往就是这些get set 方法掩盖了主干逻辑，让代码结构不清晰。因此我建议在你的业务逻辑代码中引入 `1）Converter` 这个角色来专门负责数据的传递与转换。\n\n2）manager 层\n\n无论我们使用的持久层框架是哪一种，jpa 或者 mybatis 我觉得我们都应该对持久层的部分方法进行简单封装一下，这也是阿里规范里面提倡的。这样做好处是明显的，我们做一个查询时往往要 set 一些查询条件或者对查询结果进行一些简单的判断，往往这类操作在业务代码可能有比较高的重复性。如果把这些代码放到业务逻辑代码里面，少量还好，多了的话就显得很臃肿了。如果把这种代码移到manager层里面去，不仅主业务逻辑代码不会被干扰，还能提高一定的代码复用率。\n\n3）方法简单封装\n假设我们一个方法要完成一端逻辑要分成三大步，而每一个步骤又分成几个小步骤，那我们就可以将这个方法拆分成三个方法，然后在这三个方法里面完成各自的步骤。这手法是很简单的，想必大家都能想到，但是我这里要介绍的是简化复杂方法封装的神器——函数式编程，我这里指的函数式编程不仅仅是 stream 流和 lambda 表达式的使用。函数式编程封装适用的场景是：整个流程比较固定，但是某几个步骤变化是不确定的。我们可以去看看 `java.util.function` 这个包的源码，你会发现这个包下面全是接口，这些接口被称为函数式接口。这些函数式接口总体上分为四类：\n\n- Function 类型：传入一个bean 返回另外一个bean\n- Consumer 类型：传入一个bean 无返回值\n- Predicate 类型：传入一个bean 返回布尔值\n- Supplier 类型：没有入参，有出参\n\n以 Consumer 的使用为例：\n\n```java\npublic User getUser(Consumer<User> consumer){\n    User user=new User();\n    consumer.accept(user);\n    user=userMapper.getUser(user);\n    return user;\n}\n\npublic void doSomething1(){\n    User user=getUser(user->{user.setId(1L)});\n}\n\npublic void doSomething2(){\n    User user=getUser(user->{user.setName(\"xxx\")});\n}\n```\n函数式编程的想象空间很大，使用的得当必定会简化你的代码，提高代码复用率。但是在多线程中使用函数式要留意数据的可见性问题。\n\n## 日志和注释的一些个人经验\n\n1）日志\n\n首先我们要明白日志是给人看的，你加这段日志时要考虑清楚，有没有人会去查这段日志，这段日志有没有用。然后我们查阅日志的时候，一般会通过关键词去搜索；因此我们打的日志一定要有关键词，而且这个关键词不要和其他日志重复，不要过长，便于搜索才是王道。大部分情况我们查看日志都是为了追溯bug，那么一个基本原则就是能通过日志分析出业务逻辑或者流程的走向，对此我建议打日志的地方：\n\n- 数据更新：我们有必要知道写库的数据是不是正确的数据；\n- 条件分支：便于我们分析业务走的哪一条逻辑；\n- 批量写库：打上数据量大小的日志，便于我们分析性能瓶颈。\n\n并不是所有的这些地方都应该打上日志，有的时候我们可能只需要通过一两条日志就能分析出整个流程的问题点在哪，这个时候其他的日志就显得多余了。还有我们打完日志之后应该在本地环境追溯一下，看看这些日志自己是否能读懂，是否有必要，是否少了重要参数。\n\n2）注释\n\n最基本的两个注释——类注释，方法注释相关规范阿里开发手册上就有，我这里就不复述了，我分享下我写注释的个人习惯。\n方法注释上除了基本的注释，我还会将产品需求的原文贴重要的部分上去再写上日期，这样做的好处是让别人明白产品需求要求干啥这个方法该干啥，而且产品经理偷偷改需求你还能有追查的根据，有个小本本偷偷记录他的罪行。\n\n代码注释我分享一个我偷师来的小技巧：\n\n```java\npulic void test(){\n    /** 1. 从excel 获取 vo*/\n    Workbook workBook = getWorkBook(wookbookStream);\n    //获取成员信息\n    Sheet userSheet = workBook.getSheetAt(3);\n     Map<String, UserVO> userVOMap = getUserForExcel(file, userSheet);\n    // 获取项目vo\n    Sheet projectSheet = workBook.getSheetAt(0);\n    ProjectVO projectVO = getProjectForExcel(file, isInsert, userVOMap);\n    // 获取任务vo\n    Sheet taskSheet = workBook.getSheetAt(1);\n    Map<String, TaskVO> taskVOMap = getTaskListForExcel(file, taskSheet, userVOMap);\n    /** 2. 插入数据 */\n    if (isInsert.get()){\n        ......\n    }\n   /** 3.写入异常信息 */\n    if (!isInsert.get()) {\n        .....\n    }\n}\n```\n如你所见，对于主干的步骤 我用 `/** 1. */`  `/** 2. */` javadoc的注释来标注了，而普通的注释我用 `// ` 标注，因为idea 在纯黑主题下会给 `/**` 这样的注释配上绿色，会比较显眼。我通过这种方式来强调我代码那些是花，哪些是叶子。当然这种方式实际上是不大符合代码规范的，小伙伴们理性取舍，这种手法未必好。\n\n## 六大基本原则\n\n对于面向对象的的语言，六大基本是很重要的开发准则，但似乎大部分人在写代码的时候都不大在意这个，这也是导致一个方法变得又臭又长的一个重要原因之一。对于类的复杂度我们应该遵循单一职责原则——一个类或者方法承担的职责越多，它被复用的可能性就越小，重构或者修改起来就会变得困难重重，我们应该尽量让一个方法只去做一件事情。\n\n对于许多代码我们只要通过一些简单的手法就能很好的提高其扩展性，比如通过接口去实现类与类之间的协作就能提前解决掉许多未知隐患，而且运用得当的情况下还能满足开闭原则与里氏替换原则，其实service层的设计就有那么点味道了，而且spring的特性也支持接口注入List和map，然而许多开发多年的同学都不知道这个特性，这个特性在许多场景下可以提高代码的扩展性，众所周知，map可以减少代码的 if else 分支。\n\n## 方法命名 ‘潜规则’\n\n很多时候，好的方法命名本身就是对代码的一种注释，我这里好的方法命名是指大家约定俗成的命名规则。如果你多留心各个开源框架的代码都会发现一些特定的命名规则。阿里开发手册里面也列举不少命名前缀与后缀的规范，其实各个团队可以根据自己的实际情况规定一些命名规则，降低团队内部的代码阅读的成本。关于我的文章   [设计模式杂谈](https://mp.weixin.qq.com/s/k6utPTmuDmdLwSM9U-f4tA)\n\n介绍过部分命名规则，感兴趣的小伙伴可以去看看。\n\n## 代码提交及版本控制\n\n正确代码提交日志格式可以帮助开发人员及时的缕清代码的修改历史，从而快速的定位问题。以git为例，我们大部分人提交日志就是几个字而已，当然你能够通过日志去定位到自己的修改历史的话，这样做也没什么大问题，但是对于团队而言，你的修改日志要让别人能看懂就得按一定的格式来写了。Git Commit message的 Angular规范中定义的 commit message 格式有3个内容：\n\n- Header Header部分有3个字段： type(必需), scope(可选), subject(必需)\n- Body 部分是对本次 commit 的详细描述，可以分成多行。\n- Footer不常用，可为空 包括不兼容变动、关闭issue。\n\n这里由于篇幅问题不细说，感兴趣的小伙伴可以百度查查资料。我们团队不一定要按照这么严格的规则来，但是可以制定一个类似的规范来管理提交日志。\n\n对于团队而言，gitflow 是一个很不错的开发流程。可以很大程度上管理好我们的分支代码，避免团队的人由于误操作而导致某个重要分支出现问题。下面贴出gitflow 流程图，对于其具体内容同样不会介绍太多，感兴趣小伙伴去百度吧\n\n![xxx](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/gitflow.png)\n\n# 帮助代码规范的工具\n\n本节主要介绍提高代码质量的idea插件和框架，当然大名鼎鼎的 阿里代码规范插件咱就不介绍了，想必大家多少了解。不过本人感觉这个插件并不适合一些团队，一是感觉这个规范太过严格，对开发人员素质要求太高，二是有的团队有自己的规范规则，而且有可能和阿里规范冲突，不适用于这个插件。下面介绍的插件可能不适合一些小伙伴。我列举出来大家自己寻思吧。\n\n## mapstruct\n\n对于我而言是很喜欢这个东西的，这个框架解决的问题其实就是我上文提到的花叶论中的 “数据转换” 的问题。其实不少公司也有类似的概念——定义一个工具类作用是将 DO转VO 或者 VO转DTO等，一般这类类都是以 `converter` 结尾。而mapstruct这个框架通过编译期生成字节码来自动的生成bean的转换类。我们想将一个bean的数据赋值给另外一个bean只需要去定义接口即可。这样既减轻了开发人员的工作量还将无意义的get和set方法从逻辑代码块中剔除出去。这个框架的缺点是字节码缓存问题，用过类似自动生成字节码工具的小伙伴应该知道——mapstruct 是根据接口去自动生成类的，当我们更新了接口的时候，这个类有可能没重新生成，当然这只有用idea调试的时候才会有的问题，所以也不必太担心。\n\n## checkStyle\n\nidea checkStyle 插件可以通过自定义配置文件来统一团队的代码风格和代码规范，降低团队的交流成本，一般配合 save actions Reborn 食用更佳。关于checkStyle的配置文件网上也不少，这里也不贴出来占篇幅了。\n\n## git flow\n\n前文提到过git flow 给团队带来的好处，idea也有对应的插件——git Flow Integration，可以通过这个插件来规范我们的流程：\n\n![gitflow插件](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/gitflow2.jpg)\n\n开发新功能选择 start Feature 拉取分支，修复bug 选择 Start Bugfix 拉取分支，等等。此外还有 push on finish等功能，小伙伴如果感兴趣可以百度。\n\n## Git Commit Template\n\n这个主要是用来规范git commit 的一个idea插件小工具了，github上也有类似的开源插件。团队内部也可以自己开发一个类似插件，比较简单，成本也不高。\n\n代码规范的一些个人看法就聊到这了，喜欢的小伙伴可以分享一下哦。","source":"_posts/codeStyle.md","raw":"---\ntitle: 聊一聊代码规范\ndate: 2021-01-11 15:58:52\ntags: javaee\n---\n\n# 代码混乱的常见问题\n\n很多时候我们项目迭代到后期，项目会变得很混乱，往往只有少数人能知道某段代码是干嘛的和该如何去改，或者是干脆谁都不知道，只能靠通过注释去猜测这段代码可能的作用。原因有可能是因为团队内部的人事变动，导致原先写这段代码的人不再管理这段代码了，并且代码写的实在是屎没人捋的清。往往我们称这类代码为“祖传代码”，就像祖宗传下来的代码一样，没人懂没人敢动。祖传代码一多，这个项目就变成了屎一样，开发人员再这基础上迭代就如同屎海翻腾，恶心别人也恶心自己。这是一个很可怕的恶心循环，我们如何去避免这种事情发生呢？先让我们分析下这类代码的通病\n\n<!--more-->\n\n## 代码又臭又长\n\n我见过最长的方法是5000多行，那段代码没人敢动，只敢往下加 if else，每次需要改这段代码的开发都战战兢兢，生怕出现什么莫名其妙的bug。java 可是一门面向对象的语言，一个方法里面有5000多行可以说是很可恶的事情了。我想一开始代码长度可能没这么夸张，是什么导致这种结果的？一个是当初写这段代码的人本身写的是直来直去的方法，一堆if else ；后面迭代的开发，面对这么长的代码瞬间失去了从头读到尾的耐心，直接继续在后面加 if else 迭代，最后这个方法就变成了一个缝合怪一样的玩意。\n\n好的 sql 可以很大程度上简化代码的复杂程度，但是太过复杂sql 本身就会给后来的开发人员造成阅读困难，结果又是变成一条无人敢动的祖传代码，我想这应该是不少公司极度抵制存储过程的原因之一。当然不少银行应用开发还是大量使用存储过程，存储过程有用武之地的，但是一个又臭又长的存储过程就等着变成祖传代码吧。当年我见到一个60多个join的sql，看到第一眼就惊为天人从此难以忘怀，当然那段sql也成了没人敢去动的代码了。\n\n## 代码逻辑不明所以\n\n代码逻辑不明所以是我们开发很容易去犯的毛病，是一个不致命却烦人的毛病。在代码上的体现是，逻辑判断写的比较反人类各种双重否定是肯定，不把你绕晕不罢休。或者是写起代码来东一榔头西一棒槌，让人不知道你想干嘛。导致这个的原因有可能是开发人员在需求理解上出现偏差，做到后面发现不对劲，再回去改又不大可能了，只能硬着头皮往下写，结果就是代码弯弯绕绕；还有很重要的锅是在产品经理，任意变更需求，想一出是一出，开发人员无奈只能跟着想一出写一出。还用可能是开发人员方法或者类命名太艺术了，什么四川方言拼音这种没有十年脑血栓想不出的命名咱就不说了。就说那种国产凌凌漆式的无厘头命名——这看上去是个刮胡刀实际上是个吹风机，就这种不知道让人说什么好。\n\n# 规划代码的核心思想\n\n吐槽了一堆代码规范问题，接下来我们说说如何去规范我们的代码以及如何做到就算开发人员更换了，或者项目转手给他人了，仍然可以让后面的开发可以无碍的去阅读代码修改代码。当然各个公司/团队都有自己的一套代码规范，比如项目的结构、代码命名风格、代码格式等等。不同团队有不同的风格，但核心思想是大同小异的。接下来我就我个人的开发经验来分享一下一些代码规范的思想。\n\n## 花叶论\n\n就我个人而言，这个理论是我代码规范中最浅显也是最核心的思想，只要稍微动动脑子就能想出这个思路出来。或许我们做业务开发的时候，大部分都在写crud，感觉似乎这部分代码没什么规范好说的，其实不然。对一段业务代码而言，我们可以将其分为四类：\n\n- 数据校验\n- 业务逻辑\n- 数据转换\n- 数据库交互（查询与持久化）\n\n大部分时候我们最关心的是逻辑判断相关的代码，其次是数据库交互，对于远程调用的方法，我们就视其为一个普通的方法以简化模型，方法调用算业务逻辑部分的代码，对于读代码的人而言基本上不关心数据校验和数据的转换（DTO转VO等）。因此，代码应该分出一个主次，应该尽量把主逻辑给凸显出来，最好一眼看去就能让人明白这个方法或者这个类干了啥，步骤是什么样的。对于那些不重要但必要的代码我称其为叶，对于那些主要的代码我称其为花。叶是为了衬托花的，因此我们应该将那些叶子代码精简或者隐藏起来。\n\n隐藏叶子代码，突出主干逻辑的一些手法\n\n1）Converter（转换器）\n\n大部分时候我们使用 bean 拷贝使用的是 `BeanUtils` 这个类来完成，然而一些稍微复杂的实体转换，这个类就无法胜任了，这个时候我们只能手动的 get set ,往往就是这些get set 方法掩盖了主干逻辑，让代码结构不清晰。因此我建议在你的业务逻辑代码中引入 `1）Converter` 这个角色来专门负责数据的传递与转换。\n\n2）manager 层\n\n无论我们使用的持久层框架是哪一种，jpa 或者 mybatis 我觉得我们都应该对持久层的部分方法进行简单封装一下，这也是阿里规范里面提倡的。这样做好处是明显的，我们做一个查询时往往要 set 一些查询条件或者对查询结果进行一些简单的判断，往往这类操作在业务代码可能有比较高的重复性。如果把这些代码放到业务逻辑代码里面，少量还好，多了的话就显得很臃肿了。如果把这种代码移到manager层里面去，不仅主业务逻辑代码不会被干扰，还能提高一定的代码复用率。\n\n3）方法简单封装\n假设我们一个方法要完成一端逻辑要分成三大步，而每一个步骤又分成几个小步骤，那我们就可以将这个方法拆分成三个方法，然后在这三个方法里面完成各自的步骤。这手法是很简单的，想必大家都能想到，但是我这里要介绍的是简化复杂方法封装的神器——函数式编程，我这里指的函数式编程不仅仅是 stream 流和 lambda 表达式的使用。函数式编程封装适用的场景是：整个流程比较固定，但是某几个步骤变化是不确定的。我们可以去看看 `java.util.function` 这个包的源码，你会发现这个包下面全是接口，这些接口被称为函数式接口。这些函数式接口总体上分为四类：\n\n- Function 类型：传入一个bean 返回另外一个bean\n- Consumer 类型：传入一个bean 无返回值\n- Predicate 类型：传入一个bean 返回布尔值\n- Supplier 类型：没有入参，有出参\n\n以 Consumer 的使用为例：\n\n```java\npublic User getUser(Consumer<User> consumer){\n    User user=new User();\n    consumer.accept(user);\n    user=userMapper.getUser(user);\n    return user;\n}\n\npublic void doSomething1(){\n    User user=getUser(user->{user.setId(1L)});\n}\n\npublic void doSomething2(){\n    User user=getUser(user->{user.setName(\"xxx\")});\n}\n```\n函数式编程的想象空间很大，使用的得当必定会简化你的代码，提高代码复用率。但是在多线程中使用函数式要留意数据的可见性问题。\n\n## 日志和注释的一些个人经验\n\n1）日志\n\n首先我们要明白日志是给人看的，你加这段日志时要考虑清楚，有没有人会去查这段日志，这段日志有没有用。然后我们查阅日志的时候，一般会通过关键词去搜索；因此我们打的日志一定要有关键词，而且这个关键词不要和其他日志重复，不要过长，便于搜索才是王道。大部分情况我们查看日志都是为了追溯bug，那么一个基本原则就是能通过日志分析出业务逻辑或者流程的走向，对此我建议打日志的地方：\n\n- 数据更新：我们有必要知道写库的数据是不是正确的数据；\n- 条件分支：便于我们分析业务走的哪一条逻辑；\n- 批量写库：打上数据量大小的日志，便于我们分析性能瓶颈。\n\n并不是所有的这些地方都应该打上日志，有的时候我们可能只需要通过一两条日志就能分析出整个流程的问题点在哪，这个时候其他的日志就显得多余了。还有我们打完日志之后应该在本地环境追溯一下，看看这些日志自己是否能读懂，是否有必要，是否少了重要参数。\n\n2）注释\n\n最基本的两个注释——类注释，方法注释相关规范阿里开发手册上就有，我这里就不复述了，我分享下我写注释的个人习惯。\n方法注释上除了基本的注释，我还会将产品需求的原文贴重要的部分上去再写上日期，这样做的好处是让别人明白产品需求要求干啥这个方法该干啥，而且产品经理偷偷改需求你还能有追查的根据，有个小本本偷偷记录他的罪行。\n\n代码注释我分享一个我偷师来的小技巧：\n\n```java\npulic void test(){\n    /** 1. 从excel 获取 vo*/\n    Workbook workBook = getWorkBook(wookbookStream);\n    //获取成员信息\n    Sheet userSheet = workBook.getSheetAt(3);\n     Map<String, UserVO> userVOMap = getUserForExcel(file, userSheet);\n    // 获取项目vo\n    Sheet projectSheet = workBook.getSheetAt(0);\n    ProjectVO projectVO = getProjectForExcel(file, isInsert, userVOMap);\n    // 获取任务vo\n    Sheet taskSheet = workBook.getSheetAt(1);\n    Map<String, TaskVO> taskVOMap = getTaskListForExcel(file, taskSheet, userVOMap);\n    /** 2. 插入数据 */\n    if (isInsert.get()){\n        ......\n    }\n   /** 3.写入异常信息 */\n    if (!isInsert.get()) {\n        .....\n    }\n}\n```\n如你所见，对于主干的步骤 我用 `/** 1. */`  `/** 2. */` javadoc的注释来标注了，而普通的注释我用 `// ` 标注，因为idea 在纯黑主题下会给 `/**` 这样的注释配上绿色，会比较显眼。我通过这种方式来强调我代码那些是花，哪些是叶子。当然这种方式实际上是不大符合代码规范的，小伙伴们理性取舍，这种手法未必好。\n\n## 六大基本原则\n\n对于面向对象的的语言，六大基本是很重要的开发准则，但似乎大部分人在写代码的时候都不大在意这个，这也是导致一个方法变得又臭又长的一个重要原因之一。对于类的复杂度我们应该遵循单一职责原则——一个类或者方法承担的职责越多，它被复用的可能性就越小，重构或者修改起来就会变得困难重重，我们应该尽量让一个方法只去做一件事情。\n\n对于许多代码我们只要通过一些简单的手法就能很好的提高其扩展性，比如通过接口去实现类与类之间的协作就能提前解决掉许多未知隐患，而且运用得当的情况下还能满足开闭原则与里氏替换原则，其实service层的设计就有那么点味道了，而且spring的特性也支持接口注入List和map，然而许多开发多年的同学都不知道这个特性，这个特性在许多场景下可以提高代码的扩展性，众所周知，map可以减少代码的 if else 分支。\n\n## 方法命名 ‘潜规则’\n\n很多时候，好的方法命名本身就是对代码的一种注释，我这里好的方法命名是指大家约定俗成的命名规则。如果你多留心各个开源框架的代码都会发现一些特定的命名规则。阿里开发手册里面也列举不少命名前缀与后缀的规范，其实各个团队可以根据自己的实际情况规定一些命名规则，降低团队内部的代码阅读的成本。关于我的文章   [设计模式杂谈](https://mp.weixin.qq.com/s/k6utPTmuDmdLwSM9U-f4tA)\n\n介绍过部分命名规则，感兴趣的小伙伴可以去看看。\n\n## 代码提交及版本控制\n\n正确代码提交日志格式可以帮助开发人员及时的缕清代码的修改历史，从而快速的定位问题。以git为例，我们大部分人提交日志就是几个字而已，当然你能够通过日志去定位到自己的修改历史的话，这样做也没什么大问题，但是对于团队而言，你的修改日志要让别人能看懂就得按一定的格式来写了。Git Commit message的 Angular规范中定义的 commit message 格式有3个内容：\n\n- Header Header部分有3个字段： type(必需), scope(可选), subject(必需)\n- Body 部分是对本次 commit 的详细描述，可以分成多行。\n- Footer不常用，可为空 包括不兼容变动、关闭issue。\n\n这里由于篇幅问题不细说，感兴趣的小伙伴可以百度查查资料。我们团队不一定要按照这么严格的规则来，但是可以制定一个类似的规范来管理提交日志。\n\n对于团队而言，gitflow 是一个很不错的开发流程。可以很大程度上管理好我们的分支代码，避免团队的人由于误操作而导致某个重要分支出现问题。下面贴出gitflow 流程图，对于其具体内容同样不会介绍太多，感兴趣小伙伴去百度吧\n\n![xxx](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/gitflow.png)\n\n# 帮助代码规范的工具\n\n本节主要介绍提高代码质量的idea插件和框架，当然大名鼎鼎的 阿里代码规范插件咱就不介绍了，想必大家多少了解。不过本人感觉这个插件并不适合一些团队，一是感觉这个规范太过严格，对开发人员素质要求太高，二是有的团队有自己的规范规则，而且有可能和阿里规范冲突，不适用于这个插件。下面介绍的插件可能不适合一些小伙伴。我列举出来大家自己寻思吧。\n\n## mapstruct\n\n对于我而言是很喜欢这个东西的，这个框架解决的问题其实就是我上文提到的花叶论中的 “数据转换” 的问题。其实不少公司也有类似的概念——定义一个工具类作用是将 DO转VO 或者 VO转DTO等，一般这类类都是以 `converter` 结尾。而mapstruct这个框架通过编译期生成字节码来自动的生成bean的转换类。我们想将一个bean的数据赋值给另外一个bean只需要去定义接口即可。这样既减轻了开发人员的工作量还将无意义的get和set方法从逻辑代码块中剔除出去。这个框架的缺点是字节码缓存问题，用过类似自动生成字节码工具的小伙伴应该知道——mapstruct 是根据接口去自动生成类的，当我们更新了接口的时候，这个类有可能没重新生成，当然这只有用idea调试的时候才会有的问题，所以也不必太担心。\n\n## checkStyle\n\nidea checkStyle 插件可以通过自定义配置文件来统一团队的代码风格和代码规范，降低团队的交流成本，一般配合 save actions Reborn 食用更佳。关于checkStyle的配置文件网上也不少，这里也不贴出来占篇幅了。\n\n## git flow\n\n前文提到过git flow 给团队带来的好处，idea也有对应的插件——git Flow Integration，可以通过这个插件来规范我们的流程：\n\n![gitflow插件](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/gitflow2.jpg)\n\n开发新功能选择 start Feature 拉取分支，修复bug 选择 Start Bugfix 拉取分支，等等。此外还有 push on finish等功能，小伙伴如果感兴趣可以百度。\n\n## Git Commit Template\n\n这个主要是用来规范git commit 的一个idea插件小工具了，github上也有类似的开源插件。团队内部也可以自己开发一个类似插件，比较简单，成本也不高。\n\n代码规范的一些个人看法就聊到这了，喜欢的小伙伴可以分享一下哦。","slug":"codeStyle","published":1,"updated":"2021-01-12T03:13:27.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5i000400wihd5of5s1","content":"<h1 id=\"代码混乱的常见问题\"><a href=\"#代码混乱的常见问题\" class=\"headerlink\" title=\"代码混乱的常见问题\"></a>代码混乱的常见问题</h1><p>很多时候我们项目迭代到后期，项目会变得很混乱，往往只有少数人能知道某段代码是干嘛的和该如何去改，或者是干脆谁都不知道，只能靠通过注释去猜测这段代码可能的作用。原因有可能是因为团队内部的人事变动，导致原先写这段代码的人不再管理这段代码了，并且代码写的实在是屎没人捋的清。往往我们称这类代码为“祖传代码”，就像祖宗传下来的代码一样，没人懂没人敢动。祖传代码一多，这个项目就变成了屎一样，开发人员再这基础上迭代就如同屎海翻腾，恶心别人也恶心自己。这是一个很可怕的恶心循环，我们如何去避免这种事情发生呢？先让我们分析下这类代码的通病</p>\n<a id=\"more\"></a>\n\n<h2 id=\"代码又臭又长\"><a href=\"#代码又臭又长\" class=\"headerlink\" title=\"代码又臭又长\"></a>代码又臭又长</h2><p>我见过最长的方法是5000多行，那段代码没人敢动，只敢往下加 if else，每次需要改这段代码的开发都战战兢兢，生怕出现什么莫名其妙的bug。java 可是一门面向对象的语言，一个方法里面有5000多行可以说是很可恶的事情了。我想一开始代码长度可能没这么夸张，是什么导致这种结果的？一个是当初写这段代码的人本身写的是直来直去的方法，一堆if else ；后面迭代的开发，面对这么长的代码瞬间失去了从头读到尾的耐心，直接继续在后面加 if else 迭代，最后这个方法就变成了一个缝合怪一样的玩意。</p>\n<p>好的 sql 可以很大程度上简化代码的复杂程度，但是太过复杂sql 本身就会给后来的开发人员造成阅读困难，结果又是变成一条无人敢动的祖传代码，我想这应该是不少公司极度抵制存储过程的原因之一。当然不少银行应用开发还是大量使用存储过程，存储过程有用武之地的，但是一个又臭又长的存储过程就等着变成祖传代码吧。当年我见到一个60多个join的sql，看到第一眼就惊为天人从此难以忘怀，当然那段sql也成了没人敢去动的代码了。</p>\n<h2 id=\"代码逻辑不明所以\"><a href=\"#代码逻辑不明所以\" class=\"headerlink\" title=\"代码逻辑不明所以\"></a>代码逻辑不明所以</h2><p>代码逻辑不明所以是我们开发很容易去犯的毛病，是一个不致命却烦人的毛病。在代码上的体现是，逻辑判断写的比较反人类各种双重否定是肯定，不把你绕晕不罢休。或者是写起代码来东一榔头西一棒槌，让人不知道你想干嘛。导致这个的原因有可能是开发人员在需求理解上出现偏差，做到后面发现不对劲，再回去改又不大可能了，只能硬着头皮往下写，结果就是代码弯弯绕绕；还有很重要的锅是在产品经理，任意变更需求，想一出是一出，开发人员无奈只能跟着想一出写一出。还用可能是开发人员方法或者类命名太艺术了，什么四川方言拼音这种没有十年脑血栓想不出的命名咱就不说了。就说那种国产凌凌漆式的无厘头命名——这看上去是个刮胡刀实际上是个吹风机，就这种不知道让人说什么好。</p>\n<h1 id=\"规划代码的核心思想\"><a href=\"#规划代码的核心思想\" class=\"headerlink\" title=\"规划代码的核心思想\"></a>规划代码的核心思想</h1><p>吐槽了一堆代码规范问题，接下来我们说说如何去规范我们的代码以及如何做到就算开发人员更换了，或者项目转手给他人了，仍然可以让后面的开发可以无碍的去阅读代码修改代码。当然各个公司/团队都有自己的一套代码规范，比如项目的结构、代码命名风格、代码格式等等。不同团队有不同的风格，但核心思想是大同小异的。接下来我就我个人的开发经验来分享一下一些代码规范的思想。</p>\n<h2 id=\"花叶论\"><a href=\"#花叶论\" class=\"headerlink\" title=\"花叶论\"></a>花叶论</h2><p>就我个人而言，这个理论是我代码规范中最浅显也是最核心的思想，只要稍微动动脑子就能想出这个思路出来。或许我们做业务开发的时候，大部分都在写crud，感觉似乎这部分代码没什么规范好说的，其实不然。对一段业务代码而言，我们可以将其分为四类：</p>\n<ul>\n<li>数据校验</li>\n<li>业务逻辑</li>\n<li>数据转换</li>\n<li>数据库交互（查询与持久化）</li>\n</ul>\n<p>大部分时候我们最关心的是逻辑判断相关的代码，其次是数据库交互，对于远程调用的方法，我们就视其为一个普通的方法以简化模型，方法调用算业务逻辑部分的代码，对于读代码的人而言基本上不关心数据校验和数据的转换（DTO转VO等）。因此，代码应该分出一个主次，应该尽量把主逻辑给凸显出来，最好一眼看去就能让人明白这个方法或者这个类干了啥，步骤是什么样的。对于那些不重要但必要的代码我称其为叶，对于那些主要的代码我称其为花。叶是为了衬托花的，因此我们应该将那些叶子代码精简或者隐藏起来。</p>\n<p>隐藏叶子代码，突出主干逻辑的一些手法</p>\n<p>1）Converter（转换器）</p>\n<p>大部分时候我们使用 bean 拷贝使用的是 <code>BeanUtils</code> 这个类来完成，然而一些稍微复杂的实体转换，这个类就无法胜任了，这个时候我们只能手动的 get set ,往往就是这些get set 方法掩盖了主干逻辑，让代码结构不清晰。因此我建议在你的业务逻辑代码中引入 <code>1）Converter</code> 这个角色来专门负责数据的传递与转换。</p>\n<p>2）manager 层</p>\n<p>无论我们使用的持久层框架是哪一种，jpa 或者 mybatis 我觉得我们都应该对持久层的部分方法进行简单封装一下，这也是阿里规范里面提倡的。这样做好处是明显的，我们做一个查询时往往要 set 一些查询条件或者对查询结果进行一些简单的判断，往往这类操作在业务代码可能有比较高的重复性。如果把这些代码放到业务逻辑代码里面，少量还好，多了的话就显得很臃肿了。如果把这种代码移到manager层里面去，不仅主业务逻辑代码不会被干扰，还能提高一定的代码复用率。</p>\n<p>3）方法简单封装<br>假设我们一个方法要完成一端逻辑要分成三大步，而每一个步骤又分成几个小步骤，那我们就可以将这个方法拆分成三个方法，然后在这三个方法里面完成各自的步骤。这手法是很简单的，想必大家都能想到，但是我这里要介绍的是简化复杂方法封装的神器——函数式编程，我这里指的函数式编程不仅仅是 stream 流和 lambda 表达式的使用。函数式编程封装适用的场景是：整个流程比较固定，但是某几个步骤变化是不确定的。我们可以去看看 <code>java.util.function</code> 这个包的源码，你会发现这个包下面全是接口，这些接口被称为函数式接口。这些函数式接口总体上分为四类：</p>\n<ul>\n<li>Function 类型：传入一个bean 返回另外一个bean</li>\n<li>Consumer 类型：传入一个bean 无返回值</li>\n<li>Predicate 类型：传入一个bean 返回布尔值</li>\n<li>Supplier 类型：没有入参，有出参</li>\n</ul>\n<p>以 Consumer 的使用为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUser</span><span class=\"params\">(Consumer&lt;User&gt; consumer)</span></span>&#123;</span><br><span class=\"line\">    User user=<span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    consumer.accept(user);</span><br><span class=\"line\">    user=userMapper.getUser(user);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    User user=getUser(user-&gt;&#123;user.setId(<span class=\"number\">1L</span>)&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    User user=getUser(user-&gt;&#123;user.setName(<span class=\"string\">&quot;xxx&quot;</span>)&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数式编程的想象空间很大，使用的得当必定会简化你的代码，提高代码复用率。但是在多线程中使用函数式要留意数据的可见性问题。</p>\n<h2 id=\"日志和注释的一些个人经验\"><a href=\"#日志和注释的一些个人经验\" class=\"headerlink\" title=\"日志和注释的一些个人经验\"></a>日志和注释的一些个人经验</h2><p>1）日志</p>\n<p>首先我们要明白日志是给人看的，你加这段日志时要考虑清楚，有没有人会去查这段日志，这段日志有没有用。然后我们查阅日志的时候，一般会通过关键词去搜索；因此我们打的日志一定要有关键词，而且这个关键词不要和其他日志重复，不要过长，便于搜索才是王道。大部分情况我们查看日志都是为了追溯bug，那么一个基本原则就是能通过日志分析出业务逻辑或者流程的走向，对此我建议打日志的地方：</p>\n<ul>\n<li>数据更新：我们有必要知道写库的数据是不是正确的数据；</li>\n<li>条件分支：便于我们分析业务走的哪一条逻辑；</li>\n<li>批量写库：打上数据量大小的日志，便于我们分析性能瓶颈。</li>\n</ul>\n<p>并不是所有的这些地方都应该打上日志，有的时候我们可能只需要通过一两条日志就能分析出整个流程的问题点在哪，这个时候其他的日志就显得多余了。还有我们打完日志之后应该在本地环境追溯一下，看看这些日志自己是否能读懂，是否有必要，是否少了重要参数。</p>\n<p>2）注释</p>\n<p>最基本的两个注释——类注释，方法注释相关规范阿里开发手册上就有，我这里就不复述了，我分享下我写注释的个人习惯。<br>方法注释上除了基本的注释，我还会将产品需求的原文贴重要的部分上去再写上日期，这样做的好处是让别人明白产品需求要求干啥这个方法该干啥，而且产品经理偷偷改需求你还能有追查的根据，有个小本本偷偷记录他的罪行。</p>\n<p>代码注释我分享一个我偷师来的小技巧：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pulic <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 1. 从excel 获取 vo*/</span></span><br><span class=\"line\">    Workbook workBook = getWorkBook(wookbookStream);</span><br><span class=\"line\">    <span class=\"comment\">//获取成员信息</span></span><br><span class=\"line\">    Sheet userSheet = workBook.getSheetAt(<span class=\"number\">3</span>);</span><br><span class=\"line\">     Map&lt;String, UserVO&gt; userVOMap = getUserForExcel(file, userSheet);</span><br><span class=\"line\">    <span class=\"comment\">// 获取项目vo</span></span><br><span class=\"line\">    Sheet projectSheet = workBook.getSheetAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">    ProjectVO projectVO = getProjectForExcel(file, isInsert, userVOMap);</span><br><span class=\"line\">    <span class=\"comment\">// 获取任务vo</span></span><br><span class=\"line\">    Sheet taskSheet = workBook.getSheetAt(<span class=\"number\">1</span>);</span><br><span class=\"line\">    Map&lt;String, TaskVO&gt; taskVOMap = getTaskListForExcel(file, taskSheet, userVOMap);</span><br><span class=\"line\">    <span class=\"comment\">/** 2. 插入数据 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isInsert.get())&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">/** 3.写入异常信息 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isInsert.get()) &#123;</span><br><span class=\"line\">        .....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如你所见，对于主干的步骤 我用 <code>/** 1. */</code>  <code>/** 2. */</code> javadoc的注释来标注了，而普通的注释我用 <code>//</code> 标注，因为idea 在纯黑主题下会给 <code>/**</code> 这样的注释配上绿色，会比较显眼。我通过这种方式来强调我代码那些是花，哪些是叶子。当然这种方式实际上是不大符合代码规范的，小伙伴们理性取舍，这种手法未必好。</p>\n<h2 id=\"六大基本原则\"><a href=\"#六大基本原则\" class=\"headerlink\" title=\"六大基本原则\"></a>六大基本原则</h2><p>对于面向对象的的语言，六大基本是很重要的开发准则，但似乎大部分人在写代码的时候都不大在意这个，这也是导致一个方法变得又臭又长的一个重要原因之一。对于类的复杂度我们应该遵循单一职责原则——一个类或者方法承担的职责越多，它被复用的可能性就越小，重构或者修改起来就会变得困难重重，我们应该尽量让一个方法只去做一件事情。</p>\n<p>对于许多代码我们只要通过一些简单的手法就能很好的提高其扩展性，比如通过接口去实现类与类之间的协作就能提前解决掉许多未知隐患，而且运用得当的情况下还能满足开闭原则与里氏替换原则，其实service层的设计就有那么点味道了，而且spring的特性也支持接口注入List和map，然而许多开发多年的同学都不知道这个特性，这个特性在许多场景下可以提高代码的扩展性，众所周知，map可以减少代码的 if else 分支。</p>\n<h2 id=\"方法命名-‘潜规则’\"><a href=\"#方法命名-‘潜规则’\" class=\"headerlink\" title=\"方法命名 ‘潜规则’\"></a>方法命名 ‘潜规则’</h2><p>很多时候，好的方法命名本身就是对代码的一种注释，我这里好的方法命名是指大家约定俗成的命名规则。如果你多留心各个开源框架的代码都会发现一些特定的命名规则。阿里开发手册里面也列举不少命名前缀与后缀的规范，其实各个团队可以根据自己的实际情况规定一些命名规则，降低团队内部的代码阅读的成本。关于我的文章   <a href=\"https://mp.weixin.qq.com/s/k6utPTmuDmdLwSM9U-f4tA\">设计模式杂谈</a></p>\n<p>介绍过部分命名规则，感兴趣的小伙伴可以去看看。</p>\n<h2 id=\"代码提交及版本控制\"><a href=\"#代码提交及版本控制\" class=\"headerlink\" title=\"代码提交及版本控制\"></a>代码提交及版本控制</h2><p>正确代码提交日志格式可以帮助开发人员及时的缕清代码的修改历史，从而快速的定位问题。以git为例，我们大部分人提交日志就是几个字而已，当然你能够通过日志去定位到自己的修改历史的话，这样做也没什么大问题，但是对于团队而言，你的修改日志要让别人能看懂就得按一定的格式来写了。Git Commit message的 Angular规范中定义的 commit message 格式有3个内容：</p>\n<ul>\n<li>Header Header部分有3个字段： type(必需), scope(可选), subject(必需)</li>\n<li>Body 部分是对本次 commit 的详细描述，可以分成多行。</li>\n<li>Footer不常用，可为空 包括不兼容变动、关闭issue。</li>\n</ul>\n<p>这里由于篇幅问题不细说，感兴趣的小伙伴可以百度查查资料。我们团队不一定要按照这么严格的规则来，但是可以制定一个类似的规范来管理提交日志。</p>\n<p>对于团队而言，gitflow 是一个很不错的开发流程。可以很大程度上管理好我们的分支代码，避免团队的人由于误操作而导致某个重要分支出现问题。下面贴出gitflow 流程图，对于其具体内容同样不会介绍太多，感兴趣小伙伴去百度吧</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/gitflow.png\" alt=\"xxx\"></p>\n<h1 id=\"帮助代码规范的工具\"><a href=\"#帮助代码规范的工具\" class=\"headerlink\" title=\"帮助代码规范的工具\"></a>帮助代码规范的工具</h1><p>本节主要介绍提高代码质量的idea插件和框架，当然大名鼎鼎的 阿里代码规范插件咱就不介绍了，想必大家多少了解。不过本人感觉这个插件并不适合一些团队，一是感觉这个规范太过严格，对开发人员素质要求太高，二是有的团队有自己的规范规则，而且有可能和阿里规范冲突，不适用于这个插件。下面介绍的插件可能不适合一些小伙伴。我列举出来大家自己寻思吧。</p>\n<h2 id=\"mapstruct\"><a href=\"#mapstruct\" class=\"headerlink\" title=\"mapstruct\"></a>mapstruct</h2><p>对于我而言是很喜欢这个东西的，这个框架解决的问题其实就是我上文提到的花叶论中的 “数据转换” 的问题。其实不少公司也有类似的概念——定义一个工具类作用是将 DO转VO 或者 VO转DTO等，一般这类类都是以 <code>converter</code> 结尾。而mapstruct这个框架通过编译期生成字节码来自动的生成bean的转换类。我们想将一个bean的数据赋值给另外一个bean只需要去定义接口即可。这样既减轻了开发人员的工作量还将无意义的get和set方法从逻辑代码块中剔除出去。这个框架的缺点是字节码缓存问题，用过类似自动生成字节码工具的小伙伴应该知道——mapstruct 是根据接口去自动生成类的，当我们更新了接口的时候，这个类有可能没重新生成，当然这只有用idea调试的时候才会有的问题，所以也不必太担心。</p>\n<h2 id=\"checkStyle\"><a href=\"#checkStyle\" class=\"headerlink\" title=\"checkStyle\"></a>checkStyle</h2><p>idea checkStyle 插件可以通过自定义配置文件来统一团队的代码风格和代码规范，降低团队的交流成本，一般配合 save actions Reborn 食用更佳。关于checkStyle的配置文件网上也不少，这里也不贴出来占篇幅了。</p>\n<h2 id=\"git-flow\"><a href=\"#git-flow\" class=\"headerlink\" title=\"git flow\"></a>git flow</h2><p>前文提到过git flow 给团队带来的好处，idea也有对应的插件——git Flow Integration，可以通过这个插件来规范我们的流程：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/gitflow2.jpg\" alt=\"gitflow插件\"></p>\n<p>开发新功能选择 start Feature 拉取分支，修复bug 选择 Start Bugfix 拉取分支，等等。此外还有 push on finish等功能，小伙伴如果感兴趣可以百度。</p>\n<h2 id=\"Git-Commit-Template\"><a href=\"#Git-Commit-Template\" class=\"headerlink\" title=\"Git Commit Template\"></a>Git Commit Template</h2><p>这个主要是用来规范git commit 的一个idea插件小工具了，github上也有类似的开源插件。团队内部也可以自己开发一个类似插件，比较简单，成本也不高。</p>\n<p>代码规范的一些个人看法就聊到这了，喜欢的小伙伴可以分享一下哦。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"代码混乱的常见问题\"><a href=\"#代码混乱的常见问题\" class=\"headerlink\" title=\"代码混乱的常见问题\"></a>代码混乱的常见问题</h1><p>很多时候我们项目迭代到后期，项目会变得很混乱，往往只有少数人能知道某段代码是干嘛的和该如何去改，或者是干脆谁都不知道，只能靠通过注释去猜测这段代码可能的作用。原因有可能是因为团队内部的人事变动，导致原先写这段代码的人不再管理这段代码了，并且代码写的实在是屎没人捋的清。往往我们称这类代码为“祖传代码”，就像祖宗传下来的代码一样，没人懂没人敢动。祖传代码一多，这个项目就变成了屎一样，开发人员再这基础上迭代就如同屎海翻腾，恶心别人也恶心自己。这是一个很可怕的恶心循环，我们如何去避免这种事情发生呢？先让我们分析下这类代码的通病</p>","more":"<h2 id=\"代码又臭又长\"><a href=\"#代码又臭又长\" class=\"headerlink\" title=\"代码又臭又长\"></a>代码又臭又长</h2><p>我见过最长的方法是5000多行，那段代码没人敢动，只敢往下加 if else，每次需要改这段代码的开发都战战兢兢，生怕出现什么莫名其妙的bug。java 可是一门面向对象的语言，一个方法里面有5000多行可以说是很可恶的事情了。我想一开始代码长度可能没这么夸张，是什么导致这种结果的？一个是当初写这段代码的人本身写的是直来直去的方法，一堆if else ；后面迭代的开发，面对这么长的代码瞬间失去了从头读到尾的耐心，直接继续在后面加 if else 迭代，最后这个方法就变成了一个缝合怪一样的玩意。</p>\n<p>好的 sql 可以很大程度上简化代码的复杂程度，但是太过复杂sql 本身就会给后来的开发人员造成阅读困难，结果又是变成一条无人敢动的祖传代码，我想这应该是不少公司极度抵制存储过程的原因之一。当然不少银行应用开发还是大量使用存储过程，存储过程有用武之地的，但是一个又臭又长的存储过程就等着变成祖传代码吧。当年我见到一个60多个join的sql，看到第一眼就惊为天人从此难以忘怀，当然那段sql也成了没人敢去动的代码了。</p>\n<h2 id=\"代码逻辑不明所以\"><a href=\"#代码逻辑不明所以\" class=\"headerlink\" title=\"代码逻辑不明所以\"></a>代码逻辑不明所以</h2><p>代码逻辑不明所以是我们开发很容易去犯的毛病，是一个不致命却烦人的毛病。在代码上的体现是，逻辑判断写的比较反人类各种双重否定是肯定，不把你绕晕不罢休。或者是写起代码来东一榔头西一棒槌，让人不知道你想干嘛。导致这个的原因有可能是开发人员在需求理解上出现偏差，做到后面发现不对劲，再回去改又不大可能了，只能硬着头皮往下写，结果就是代码弯弯绕绕；还有很重要的锅是在产品经理，任意变更需求，想一出是一出，开发人员无奈只能跟着想一出写一出。还用可能是开发人员方法或者类命名太艺术了，什么四川方言拼音这种没有十年脑血栓想不出的命名咱就不说了。就说那种国产凌凌漆式的无厘头命名——这看上去是个刮胡刀实际上是个吹风机，就这种不知道让人说什么好。</p>\n<h1 id=\"规划代码的核心思想\"><a href=\"#规划代码的核心思想\" class=\"headerlink\" title=\"规划代码的核心思想\"></a>规划代码的核心思想</h1><p>吐槽了一堆代码规范问题，接下来我们说说如何去规范我们的代码以及如何做到就算开发人员更换了，或者项目转手给他人了，仍然可以让后面的开发可以无碍的去阅读代码修改代码。当然各个公司/团队都有自己的一套代码规范，比如项目的结构、代码命名风格、代码格式等等。不同团队有不同的风格，但核心思想是大同小异的。接下来我就我个人的开发经验来分享一下一些代码规范的思想。</p>\n<h2 id=\"花叶论\"><a href=\"#花叶论\" class=\"headerlink\" title=\"花叶论\"></a>花叶论</h2><p>就我个人而言，这个理论是我代码规范中最浅显也是最核心的思想，只要稍微动动脑子就能想出这个思路出来。或许我们做业务开发的时候，大部分都在写crud，感觉似乎这部分代码没什么规范好说的，其实不然。对一段业务代码而言，我们可以将其分为四类：</p>\n<ul>\n<li>数据校验</li>\n<li>业务逻辑</li>\n<li>数据转换</li>\n<li>数据库交互（查询与持久化）</li>\n</ul>\n<p>大部分时候我们最关心的是逻辑判断相关的代码，其次是数据库交互，对于远程调用的方法，我们就视其为一个普通的方法以简化模型，方法调用算业务逻辑部分的代码，对于读代码的人而言基本上不关心数据校验和数据的转换（DTO转VO等）。因此，代码应该分出一个主次，应该尽量把主逻辑给凸显出来，最好一眼看去就能让人明白这个方法或者这个类干了啥，步骤是什么样的。对于那些不重要但必要的代码我称其为叶，对于那些主要的代码我称其为花。叶是为了衬托花的，因此我们应该将那些叶子代码精简或者隐藏起来。</p>\n<p>隐藏叶子代码，突出主干逻辑的一些手法</p>\n<p>1）Converter（转换器）</p>\n<p>大部分时候我们使用 bean 拷贝使用的是 <code>BeanUtils</code> 这个类来完成，然而一些稍微复杂的实体转换，这个类就无法胜任了，这个时候我们只能手动的 get set ,往往就是这些get set 方法掩盖了主干逻辑，让代码结构不清晰。因此我建议在你的业务逻辑代码中引入 <code>1）Converter</code> 这个角色来专门负责数据的传递与转换。</p>\n<p>2）manager 层</p>\n<p>无论我们使用的持久层框架是哪一种，jpa 或者 mybatis 我觉得我们都应该对持久层的部分方法进行简单封装一下，这也是阿里规范里面提倡的。这样做好处是明显的，我们做一个查询时往往要 set 一些查询条件或者对查询结果进行一些简单的判断，往往这类操作在业务代码可能有比较高的重复性。如果把这些代码放到业务逻辑代码里面，少量还好，多了的话就显得很臃肿了。如果把这种代码移到manager层里面去，不仅主业务逻辑代码不会被干扰，还能提高一定的代码复用率。</p>\n<p>3）方法简单封装<br>假设我们一个方法要完成一端逻辑要分成三大步，而每一个步骤又分成几个小步骤，那我们就可以将这个方法拆分成三个方法，然后在这三个方法里面完成各自的步骤。这手法是很简单的，想必大家都能想到，但是我这里要介绍的是简化复杂方法封装的神器——函数式编程，我这里指的函数式编程不仅仅是 stream 流和 lambda 表达式的使用。函数式编程封装适用的场景是：整个流程比较固定，但是某几个步骤变化是不确定的。我们可以去看看 <code>java.util.function</code> 这个包的源码，你会发现这个包下面全是接口，这些接口被称为函数式接口。这些函数式接口总体上分为四类：</p>\n<ul>\n<li>Function 类型：传入一个bean 返回另外一个bean</li>\n<li>Consumer 类型：传入一个bean 无返回值</li>\n<li>Predicate 类型：传入一个bean 返回布尔值</li>\n<li>Supplier 类型：没有入参，有出参</li>\n</ul>\n<p>以 Consumer 的使用为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUser</span><span class=\"params\">(Consumer&lt;User&gt; consumer)</span></span>&#123;</span><br><span class=\"line\">    User user=<span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    consumer.accept(user);</span><br><span class=\"line\">    user=userMapper.getUser(user);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    User user=getUser(user-&gt;&#123;user.setId(<span class=\"number\">1L</span>)&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    User user=getUser(user-&gt;&#123;user.setName(<span class=\"string\">&quot;xxx&quot;</span>)&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数式编程的想象空间很大，使用的得当必定会简化你的代码，提高代码复用率。但是在多线程中使用函数式要留意数据的可见性问题。</p>\n<h2 id=\"日志和注释的一些个人经验\"><a href=\"#日志和注释的一些个人经验\" class=\"headerlink\" title=\"日志和注释的一些个人经验\"></a>日志和注释的一些个人经验</h2><p>1）日志</p>\n<p>首先我们要明白日志是给人看的，你加这段日志时要考虑清楚，有没有人会去查这段日志，这段日志有没有用。然后我们查阅日志的时候，一般会通过关键词去搜索；因此我们打的日志一定要有关键词，而且这个关键词不要和其他日志重复，不要过长，便于搜索才是王道。大部分情况我们查看日志都是为了追溯bug，那么一个基本原则就是能通过日志分析出业务逻辑或者流程的走向，对此我建议打日志的地方：</p>\n<ul>\n<li>数据更新：我们有必要知道写库的数据是不是正确的数据；</li>\n<li>条件分支：便于我们分析业务走的哪一条逻辑；</li>\n<li>批量写库：打上数据量大小的日志，便于我们分析性能瓶颈。</li>\n</ul>\n<p>并不是所有的这些地方都应该打上日志，有的时候我们可能只需要通过一两条日志就能分析出整个流程的问题点在哪，这个时候其他的日志就显得多余了。还有我们打完日志之后应该在本地环境追溯一下，看看这些日志自己是否能读懂，是否有必要，是否少了重要参数。</p>\n<p>2）注释</p>\n<p>最基本的两个注释——类注释，方法注释相关规范阿里开发手册上就有，我这里就不复述了，我分享下我写注释的个人习惯。<br>方法注释上除了基本的注释，我还会将产品需求的原文贴重要的部分上去再写上日期，这样做的好处是让别人明白产品需求要求干啥这个方法该干啥，而且产品经理偷偷改需求你还能有追查的根据，有个小本本偷偷记录他的罪行。</p>\n<p>代码注释我分享一个我偷师来的小技巧：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pulic <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 1. 从excel 获取 vo*/</span></span><br><span class=\"line\">    Workbook workBook = getWorkBook(wookbookStream);</span><br><span class=\"line\">    <span class=\"comment\">//获取成员信息</span></span><br><span class=\"line\">    Sheet userSheet = workBook.getSheetAt(<span class=\"number\">3</span>);</span><br><span class=\"line\">     Map&lt;String, UserVO&gt; userVOMap = getUserForExcel(file, userSheet);</span><br><span class=\"line\">    <span class=\"comment\">// 获取项目vo</span></span><br><span class=\"line\">    Sheet projectSheet = workBook.getSheetAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">    ProjectVO projectVO = getProjectForExcel(file, isInsert, userVOMap);</span><br><span class=\"line\">    <span class=\"comment\">// 获取任务vo</span></span><br><span class=\"line\">    Sheet taskSheet = workBook.getSheetAt(<span class=\"number\">1</span>);</span><br><span class=\"line\">    Map&lt;String, TaskVO&gt; taskVOMap = getTaskListForExcel(file, taskSheet, userVOMap);</span><br><span class=\"line\">    <span class=\"comment\">/** 2. 插入数据 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isInsert.get())&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">/** 3.写入异常信息 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isInsert.get()) &#123;</span><br><span class=\"line\">        .....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如你所见，对于主干的步骤 我用 <code>/** 1. */</code>  <code>/** 2. */</code> javadoc的注释来标注了，而普通的注释我用 <code>//</code> 标注，因为idea 在纯黑主题下会给 <code>/**</code> 这样的注释配上绿色，会比较显眼。我通过这种方式来强调我代码那些是花，哪些是叶子。当然这种方式实际上是不大符合代码规范的，小伙伴们理性取舍，这种手法未必好。</p>\n<h2 id=\"六大基本原则\"><a href=\"#六大基本原则\" class=\"headerlink\" title=\"六大基本原则\"></a>六大基本原则</h2><p>对于面向对象的的语言，六大基本是很重要的开发准则，但似乎大部分人在写代码的时候都不大在意这个，这也是导致一个方法变得又臭又长的一个重要原因之一。对于类的复杂度我们应该遵循单一职责原则——一个类或者方法承担的职责越多，它被复用的可能性就越小，重构或者修改起来就会变得困难重重，我们应该尽量让一个方法只去做一件事情。</p>\n<p>对于许多代码我们只要通过一些简单的手法就能很好的提高其扩展性，比如通过接口去实现类与类之间的协作就能提前解决掉许多未知隐患，而且运用得当的情况下还能满足开闭原则与里氏替换原则，其实service层的设计就有那么点味道了，而且spring的特性也支持接口注入List和map，然而许多开发多年的同学都不知道这个特性，这个特性在许多场景下可以提高代码的扩展性，众所周知，map可以减少代码的 if else 分支。</p>\n<h2 id=\"方法命名-‘潜规则’\"><a href=\"#方法命名-‘潜规则’\" class=\"headerlink\" title=\"方法命名 ‘潜规则’\"></a>方法命名 ‘潜规则’</h2><p>很多时候，好的方法命名本身就是对代码的一种注释，我这里好的方法命名是指大家约定俗成的命名规则。如果你多留心各个开源框架的代码都会发现一些特定的命名规则。阿里开发手册里面也列举不少命名前缀与后缀的规范，其实各个团队可以根据自己的实际情况规定一些命名规则，降低团队内部的代码阅读的成本。关于我的文章   <a href=\"https://mp.weixin.qq.com/s/k6utPTmuDmdLwSM9U-f4tA\">设计模式杂谈</a></p>\n<p>介绍过部分命名规则，感兴趣的小伙伴可以去看看。</p>\n<h2 id=\"代码提交及版本控制\"><a href=\"#代码提交及版本控制\" class=\"headerlink\" title=\"代码提交及版本控制\"></a>代码提交及版本控制</h2><p>正确代码提交日志格式可以帮助开发人员及时的缕清代码的修改历史，从而快速的定位问题。以git为例，我们大部分人提交日志就是几个字而已，当然你能够通过日志去定位到自己的修改历史的话，这样做也没什么大问题，但是对于团队而言，你的修改日志要让别人能看懂就得按一定的格式来写了。Git Commit message的 Angular规范中定义的 commit message 格式有3个内容：</p>\n<ul>\n<li>Header Header部分有3个字段： type(必需), scope(可选), subject(必需)</li>\n<li>Body 部分是对本次 commit 的详细描述，可以分成多行。</li>\n<li>Footer不常用，可为空 包括不兼容变动、关闭issue。</li>\n</ul>\n<p>这里由于篇幅问题不细说，感兴趣的小伙伴可以百度查查资料。我们团队不一定要按照这么严格的规则来，但是可以制定一个类似的规范来管理提交日志。</p>\n<p>对于团队而言，gitflow 是一个很不错的开发流程。可以很大程度上管理好我们的分支代码，避免团队的人由于误操作而导致某个重要分支出现问题。下面贴出gitflow 流程图，对于其具体内容同样不会介绍太多，感兴趣小伙伴去百度吧</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/gitflow.png\" alt=\"xxx\"></p>\n<h1 id=\"帮助代码规范的工具\"><a href=\"#帮助代码规范的工具\" class=\"headerlink\" title=\"帮助代码规范的工具\"></a>帮助代码规范的工具</h1><p>本节主要介绍提高代码质量的idea插件和框架，当然大名鼎鼎的 阿里代码规范插件咱就不介绍了，想必大家多少了解。不过本人感觉这个插件并不适合一些团队，一是感觉这个规范太过严格，对开发人员素质要求太高，二是有的团队有自己的规范规则，而且有可能和阿里规范冲突，不适用于这个插件。下面介绍的插件可能不适合一些小伙伴。我列举出来大家自己寻思吧。</p>\n<h2 id=\"mapstruct\"><a href=\"#mapstruct\" class=\"headerlink\" title=\"mapstruct\"></a>mapstruct</h2><p>对于我而言是很喜欢这个东西的，这个框架解决的问题其实就是我上文提到的花叶论中的 “数据转换” 的问题。其实不少公司也有类似的概念——定义一个工具类作用是将 DO转VO 或者 VO转DTO等，一般这类类都是以 <code>converter</code> 结尾。而mapstruct这个框架通过编译期生成字节码来自动的生成bean的转换类。我们想将一个bean的数据赋值给另外一个bean只需要去定义接口即可。这样既减轻了开发人员的工作量还将无意义的get和set方法从逻辑代码块中剔除出去。这个框架的缺点是字节码缓存问题，用过类似自动生成字节码工具的小伙伴应该知道——mapstruct 是根据接口去自动生成类的，当我们更新了接口的时候，这个类有可能没重新生成，当然这只有用idea调试的时候才会有的问题，所以也不必太担心。</p>\n<h2 id=\"checkStyle\"><a href=\"#checkStyle\" class=\"headerlink\" title=\"checkStyle\"></a>checkStyle</h2><p>idea checkStyle 插件可以通过自定义配置文件来统一团队的代码风格和代码规范，降低团队的交流成本，一般配合 save actions Reborn 食用更佳。关于checkStyle的配置文件网上也不少，这里也不贴出来占篇幅了。</p>\n<h2 id=\"git-flow\"><a href=\"#git-flow\" class=\"headerlink\" title=\"git flow\"></a>git flow</h2><p>前文提到过git flow 给团队带来的好处，idea也有对应的插件——git Flow Integration，可以通过这个插件来规范我们的流程：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/gitflow2.jpg\" alt=\"gitflow插件\"></p>\n<p>开发新功能选择 start Feature 拉取分支，修复bug 选择 Start Bugfix 拉取分支，等等。此外还有 push on finish等功能，小伙伴如果感兴趣可以百度。</p>\n<h2 id=\"Git-Commit-Template\"><a href=\"#Git-Commit-Template\" class=\"headerlink\" title=\"Git Commit Template\"></a>Git Commit Template</h2><p>这个主要是用来规范git commit 的一个idea插件小工具了，github上也有类似的开源插件。团队内部也可以自己开发一个类似插件，比较简单，成本也不高。</p>\n<p>代码规范的一些个人看法就聊到这了，喜欢的小伙伴可以分享一下哦。</p>"},{"title":"设计模式-代理模式（proxy）","date":"2020-02-02T09:35:26.000Z","_content":"\n代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n代理模式的主要优点有：\n代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n代理对象可以扩展目标对象的功能；\n代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；\n\n其主要缺点是：\n在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n增加了系统的复杂度；\n\n<!--more-->\n\n## 模式结构\n\n代理模式的主要角色如下。\n抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n## 源码导读\n\n在代理模式中动态代理是在各个框架中使用最广泛的一种设计模式，dubbo中 feign中 mybaits中，都有使用到动态代理。在dubbo中，在接口上添加@refrence ，dubbo就会根据这个接口生成一个代理实例来供消费者用生产者。在feign中也是一样；mybatis中你只要指定包扫描的路径，就会在spring中注入一个mapper，实际上这个mapper就是根据接口和xml生成的代理对象。实际上，这种“申明式的”功能实现方式，都是通过代理模式来实现的。\n\n下面我们通过cglib来写一个“残疾缩水”版的mybatis：\n\n首先要整一个xml，我这里用properties代替\n\ntest.properties:\n\n```\ntestA=select * from user where id=\ntestB=select * from user where username=\n```\n\n再整一个接口：\n\n```\n  interface Test {\n\n    String testA(int id);\n    String testB(String username);\n}\n```\n\n再是代码增强处理器，这里面完成对接口的代理逻辑\n\n```\nclass MyInvokationHandler implements MethodInterceptor {\n\n    private static Map<String,String> sqlMap;\n\n    {\n        HashMap<String, String> map = new HashMap<>();\n\n\n\n        Properties prop = new Properties();\n        InputStream in = SystemMenuController.class.getClassLoader().getResourceAsStream(\"test.properties\");\n        try {\n            prop.load(in);\n            Iterator<String> it = prop.stringPropertyNames().iterator();\n            while (it.hasNext()) {\n                String key = it.next();\n                map.put(key,prop.getProperty(key));\n            }\n            in.close();\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        sqlMap=map;\n    }\n\n\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        String name = method.getName();\n        String s = sqlMap.get(name);\n        return s+objects[0];\n    }\n}\n```\n\n包扫描和启动时注入容器略，数据源也略,用个main方法模拟一下：\n\n```\npublic static void main(String[] args) {\n\n      Enhancer enhancer = new Enhancer();\n      enhancer.setSuperclass(Test.class);\n      enhancer.setCallback(new MyInvokationHandler());\n      Test test = (Test) enhancer.create();\n      System.out.println(test.testA(1));\n       System.out.println(test.testB(\"hhh\"));\n  }\n```\n\n最终在控制台中打印：\n\n```\nselect * from user where id=1\nselect * from user where id=hhh\n```\n\n代理模式是一个很强大实用性很强的模式，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。代理模式的使用场景可以总结为：\n\n- 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。\n- 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。\n- 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。\n- 智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。\n- 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。","source":"_posts/design-10.md","raw":"---\ntitle: 设计模式-代理模式（proxy）\ndate: 2020-02-02 17:35:26\ntags: 设计模式\n---\n\n代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\n\n代理模式的主要优点有：\n代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\n代理对象可以扩展目标对象的功能；\n代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；\n\n其主要缺点是：\n在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；\n增加了系统的复杂度；\n\n<!--more-->\n\n## 模式结构\n\n代理模式的主要角色如下。\n抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n## 源码导读\n\n在代理模式中动态代理是在各个框架中使用最广泛的一种设计模式，dubbo中 feign中 mybaits中，都有使用到动态代理。在dubbo中，在接口上添加@refrence ，dubbo就会根据这个接口生成一个代理实例来供消费者用生产者。在feign中也是一样；mybatis中你只要指定包扫描的路径，就会在spring中注入一个mapper，实际上这个mapper就是根据接口和xml生成的代理对象。实际上，这种“申明式的”功能实现方式，都是通过代理模式来实现的。\n\n下面我们通过cglib来写一个“残疾缩水”版的mybatis：\n\n首先要整一个xml，我这里用properties代替\n\ntest.properties:\n\n```\ntestA=select * from user where id=\ntestB=select * from user where username=\n```\n\n再整一个接口：\n\n```\n  interface Test {\n\n    String testA(int id);\n    String testB(String username);\n}\n```\n\n再是代码增强处理器，这里面完成对接口的代理逻辑\n\n```\nclass MyInvokationHandler implements MethodInterceptor {\n\n    private static Map<String,String> sqlMap;\n\n    {\n        HashMap<String, String> map = new HashMap<>();\n\n\n\n        Properties prop = new Properties();\n        InputStream in = SystemMenuController.class.getClassLoader().getResourceAsStream(\"test.properties\");\n        try {\n            prop.load(in);\n            Iterator<String> it = prop.stringPropertyNames().iterator();\n            while (it.hasNext()) {\n                String key = it.next();\n                map.put(key,prop.getProperty(key));\n            }\n            in.close();\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        sqlMap=map;\n    }\n\n\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        String name = method.getName();\n        String s = sqlMap.get(name);\n        return s+objects[0];\n    }\n}\n```\n\n包扫描和启动时注入容器略，数据源也略,用个main方法模拟一下：\n\n```\npublic static void main(String[] args) {\n\n      Enhancer enhancer = new Enhancer();\n      enhancer.setSuperclass(Test.class);\n      enhancer.setCallback(new MyInvokationHandler());\n      Test test = (Test) enhancer.create();\n      System.out.println(test.testA(1));\n       System.out.println(test.testB(\"hhh\"));\n  }\n```\n\n最终在控制台中打印：\n\n```\nselect * from user where id=1\nselect * from user where id=hhh\n```\n\n代理模式是一个很强大实用性很强的模式，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。代理模式的使用场景可以总结为：\n\n- 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。\n- 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。\n- 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。\n- 智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。\n- 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。","slug":"design-10","published":1,"updated":"2021-01-11T07:31:23.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5k000500wid2d10rcv","content":"<p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>\n<p>代理模式的主要优点有：<br>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；<br>代理对象可以扩展目标对象的功能；<br>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</p>\n<p>其主要缺点是：<br>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；<br>增加了系统的复杂度；</p>\n<a id=\"more\"></a>\n\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>代理模式的主要角色如下。<br>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。<br>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。<br>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</p>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>在代理模式中动态代理是在各个框架中使用最广泛的一种设计模式，dubbo中 feign中 mybaits中，都有使用到动态代理。在dubbo中，在接口上添加@refrence ，dubbo就会根据这个接口生成一个代理实例来供消费者用生产者。在feign中也是一样；mybatis中你只要指定包扫描的路径，就会在spring中注入一个mapper，实际上这个mapper就是根据接口和xml生成的代理对象。实际上，这种“申明式的”功能实现方式，都是通过代理模式来实现的。</p>\n<p>下面我们通过cglib来写一个“残疾缩水”版的mybatis：</p>\n<p>首先要整一个xml，我这里用properties代替</p>\n<p>test.properties:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testA&#x3D;select * from user where id&#x3D;</span><br><span class=\"line\">testB&#x3D;select * from user where username&#x3D;</span><br></pre></td></tr></table></figure>\n<p>再整一个接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  interface Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String testA(int id);</span><br><span class=\"line\">    String testB(String username);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再是代码增强处理器，这里面完成对接口的代理逻辑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyInvokationHandler implements MethodInterceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static Map&lt;String,String&gt; sqlMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Properties prop &#x3D; new Properties();</span><br><span class=\"line\">        InputStream in &#x3D; SystemMenuController.class.getClassLoader().getResourceAsStream(&quot;test.properties&quot;);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            prop.load(in);</span><br><span class=\"line\">            Iterator&lt;String&gt; it &#x3D; prop.stringPropertyNames().iterator();</span><br><span class=\"line\">            while (it.hasNext()) &#123;</span><br><span class=\"line\">                String key &#x3D; it.next();</span><br><span class=\"line\">                map.put(key,prop.getProperty(key));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">        &#125; catch (java.io.IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sqlMap&#x3D;map;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class=\"line\">        String name &#x3D; method.getName();</span><br><span class=\"line\">        String s &#x3D; sqlMap.get(name);</span><br><span class=\"line\">        return s+objects[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>包扫描和启动时注入容器略，数据源也略,用个main方法模拟一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      Enhancer enhancer &#x3D; new Enhancer();</span><br><span class=\"line\">      enhancer.setSuperclass(Test.class);</span><br><span class=\"line\">      enhancer.setCallback(new MyInvokationHandler());</span><br><span class=\"line\">      Test test &#x3D; (Test) enhancer.create();</span><br><span class=\"line\">      System.out.println(test.testA(1));</span><br><span class=\"line\">       System.out.println(test.testB(&quot;hhh&quot;));</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>最终在控制台中打印：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from user where id&#x3D;1</span><br><span class=\"line\">select * from user where id&#x3D;hhh</span><br></pre></td></tr></table></figure>\n<p>代理模式是一个很强大实用性很强的模式，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。代理模式的使用场景可以总结为：</p>\n<ul>\n<li>远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li>\n<li>虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>\n<li>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>\n<li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li>\n<li>延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>\n<p>代理模式的主要优点有：<br>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；<br>代理对象可以扩展目标对象的功能；<br>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</p>\n<p>其主要缺点是：<br>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；<br>增加了系统的复杂度；</p>","more":"<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>代理模式的主要角色如下。<br>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。<br>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。<br>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</p>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>在代理模式中动态代理是在各个框架中使用最广泛的一种设计模式，dubbo中 feign中 mybaits中，都有使用到动态代理。在dubbo中，在接口上添加@refrence ，dubbo就会根据这个接口生成一个代理实例来供消费者用生产者。在feign中也是一样；mybatis中你只要指定包扫描的路径，就会在spring中注入一个mapper，实际上这个mapper就是根据接口和xml生成的代理对象。实际上，这种“申明式的”功能实现方式，都是通过代理模式来实现的。</p>\n<p>下面我们通过cglib来写一个“残疾缩水”版的mybatis：</p>\n<p>首先要整一个xml，我这里用properties代替</p>\n<p>test.properties:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testA&#x3D;select * from user where id&#x3D;</span><br><span class=\"line\">testB&#x3D;select * from user where username&#x3D;</span><br></pre></td></tr></table></figure>\n<p>再整一个接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  interface Test &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String testA(int id);</span><br><span class=\"line\">    String testB(String username);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再是代码增强处理器，这里面完成对接口的代理逻辑</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyInvokationHandler implements MethodInterceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static Map&lt;String,String&gt; sqlMap;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Properties prop &#x3D; new Properties();</span><br><span class=\"line\">        InputStream in &#x3D; SystemMenuController.class.getClassLoader().getResourceAsStream(&quot;test.properties&quot;);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            prop.load(in);</span><br><span class=\"line\">            Iterator&lt;String&gt; it &#x3D; prop.stringPropertyNames().iterator();</span><br><span class=\"line\">            while (it.hasNext()) &#123;</span><br><span class=\"line\">                String key &#x3D; it.next();</span><br><span class=\"line\">                map.put(key,prop.getProperty(key));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">        &#125; catch (java.io.IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sqlMap&#x3D;map;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class=\"line\">        String name &#x3D; method.getName();</span><br><span class=\"line\">        String s &#x3D; sqlMap.get(name);</span><br><span class=\"line\">        return s+objects[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>包扫描和启动时注入容器略，数据源也略,用个main方法模拟一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      Enhancer enhancer &#x3D; new Enhancer();</span><br><span class=\"line\">      enhancer.setSuperclass(Test.class);</span><br><span class=\"line\">      enhancer.setCallback(new MyInvokationHandler());</span><br><span class=\"line\">      Test test &#x3D; (Test) enhancer.create();</span><br><span class=\"line\">      System.out.println(test.testA(1));</span><br><span class=\"line\">       System.out.println(test.testB(&quot;hhh&quot;));</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>最终在控制台中打印：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from user where id&#x3D;1</span><br><span class=\"line\">select * from user where id&#x3D;hhh</span><br></pre></td></tr></table></figure>\n<p>代理模式是一个很强大实用性很强的模式，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。代理模式的使用场景可以总结为：</p>\n<ul>\n<li>远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li>\n<li>虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>\n<li>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>\n<li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li>\n<li>延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</li>\n</ul>"},{"title":"设计模式-策略模式","date":"2020-02-02T09:37:07.000Z","_content":"\n策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。策略模式有以下优点：\n\n- 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。\n- 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。\n- 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。\n- 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。\n- 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。\n\n<!--more-->\n\n# 模式结构\n\n策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。\n策略模式的主要角色如下：\n\n- 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。\n- 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。\n- 环境（Context）类：持有一个策略类的引用，最终给客户端调用。\n\n# 源码导读\n\n策略模式的结构很简单，而spring的bean注入特性让我们在spring 框架中使用策略模式很方便，在spring中，对于同一类bean不同的别名是可以注入到一个map中或者list中的，下面的代码演示了如何在spring中方便的使用策略模式\n先定义一个抽象父类：\n\n```\npublic interface Message {\n\n    /**\n     * 抽象策略\n     */\n    String test(String test);\n\n}\n```\n\n再定义不同的实现类\n\n```\n@Service(\"testA\")\npublic class TestA{\n    @Override\n    String test(String test) {\n        return \"testA:\"+test;\n    }\n}\n\n@Service(\"testB\")\npublic class TestA{\n    @Override\n    String test(String test) {\n        return \"testB:\"+test;\n    }\n}\n\n@Service(\"testC\")\npublic class TestA{\n    @Override\n    String test(String test) {\n        return \"testC:\"+test;\n    }\n}\n```\n\n然后在环境类中使用这些策略\n\n```\n@Service\npublic class Subject{\n    @Autowired\n    Map<String,Message> messageStrategy\n\n    public void check(){\n       Message message= messageStrategy.get(\"testB\")\n       System.out.print(message.test())\n    }\n}\n```\n\n以上就是一个简单的策略模式，在spring中使用该模式可以减少条件分支的代码量，而且它的扩展性也很好。","source":"_posts/design-11.md","raw":"---\ntitle: 设计模式-策略模式\ndate: 2020-02-02 17:37:07\ntags: 设计模式\n---\n\n策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。策略模式有以下优点：\n\n- 多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。\n- 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。\n- 策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。\n- 策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。\n- 策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。\n\n<!--more-->\n\n# 模式结构\n\n策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。\n策略模式的主要角色如下：\n\n- 抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。\n- 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。\n- 环境（Context）类：持有一个策略类的引用，最终给客户端调用。\n\n# 源码导读\n\n策略模式的结构很简单，而spring的bean注入特性让我们在spring 框架中使用策略模式很方便，在spring中，对于同一类bean不同的别名是可以注入到一个map中或者list中的，下面的代码演示了如何在spring中方便的使用策略模式\n先定义一个抽象父类：\n\n```\npublic interface Message {\n\n    /**\n     * 抽象策略\n     */\n    String test(String test);\n\n}\n```\n\n再定义不同的实现类\n\n```\n@Service(\"testA\")\npublic class TestA{\n    @Override\n    String test(String test) {\n        return \"testA:\"+test;\n    }\n}\n\n@Service(\"testB\")\npublic class TestA{\n    @Override\n    String test(String test) {\n        return \"testB:\"+test;\n    }\n}\n\n@Service(\"testC\")\npublic class TestA{\n    @Override\n    String test(String test) {\n        return \"testC:\"+test;\n    }\n}\n```\n\n然后在环境类中使用这些策略\n\n```\n@Service\npublic class Subject{\n    @Autowired\n    Map<String,Message> messageStrategy\n\n    public void check(){\n       Message message= messageStrategy.get(\"testB\")\n       System.out.print(message.test())\n    }\n}\n```\n\n以上就是一个简单的策略模式，在spring中使用该模式可以减少条件分支的代码量，而且它的扩展性也很好。","slug":"design-11","published":1,"updated":"2021-01-11T07:31:23.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5l000800wi9vzkds4m","content":"<p>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。策略模式有以下优点：</p>\n<ul>\n<li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li>\n<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li>\n<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li>\n<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li>\n<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h1 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h1><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。<br>策略模式的主要角色如下：</p>\n<ul>\n<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>\n<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>\n<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>\n</ul>\n<h1 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h1><p>策略模式的结构很简单，而spring的bean注入特性让我们在spring 框架中使用策略模式很方便，在spring中，对于同一类bean不同的别名是可以注入到一个map中或者list中的，下面的代码演示了如何在spring中方便的使用策略模式<br>先定义一个抽象父类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Message &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 抽象策略</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    String test(String test);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再定义不同的实现类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service(&quot;testA&quot;)</span><br><span class=\"line\">public class TestA&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    String test(String test) &#123;</span><br><span class=\"line\">        return &quot;testA:&quot;+test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service(&quot;testB&quot;)</span><br><span class=\"line\">public class TestA&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    String test(String test) &#123;</span><br><span class=\"line\">        return &quot;testB:&quot;+test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service(&quot;testC&quot;)</span><br><span class=\"line\">public class TestA&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    String test(String test) &#123;</span><br><span class=\"line\">        return &quot;testC:&quot;+test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在环境类中使用这些策略</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class Subject&#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    Map&lt;String,Message&gt; messageStrategy</span><br><span class=\"line\"></span><br><span class=\"line\">    public void check()&#123;</span><br><span class=\"line\">       Message message&#x3D; messageStrategy.get(&quot;testB&quot;)</span><br><span class=\"line\">       System.out.print(message.test())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上就是一个简单的策略模式，在spring中使用该模式可以减少条件分支的代码量，而且它的扩展性也很好。</p>\n","site":{"data":{}},"excerpt":"<p>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。策略模式有以下优点：</p>\n<ul>\n<li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li>\n<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li>\n<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li>\n<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li>\n<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>\n</ul>","more":"<h1 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h1><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。<br>策略模式的主要角色如下：</p>\n<ul>\n<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>\n<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>\n<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>\n</ul>\n<h1 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h1><p>策略模式的结构很简单，而spring的bean注入特性让我们在spring 框架中使用策略模式很方便，在spring中，对于同一类bean不同的别名是可以注入到一个map中或者list中的，下面的代码演示了如何在spring中方便的使用策略模式<br>先定义一个抽象父类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface Message &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;**</span><br><span class=\"line\">     * 抽象策略</span><br><span class=\"line\">     *&#x2F;</span><br><span class=\"line\">    String test(String test);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再定义不同的实现类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service(&quot;testA&quot;)</span><br><span class=\"line\">public class TestA&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    String test(String test) &#123;</span><br><span class=\"line\">        return &quot;testA:&quot;+test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service(&quot;testB&quot;)</span><br><span class=\"line\">public class TestA&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    String test(String test) &#123;</span><br><span class=\"line\">        return &quot;testB:&quot;+test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service(&quot;testC&quot;)</span><br><span class=\"line\">public class TestA&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    String test(String test) &#123;</span><br><span class=\"line\">        return &quot;testC:&quot;+test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在环境类中使用这些策略</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class Subject&#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    Map&lt;String,Message&gt; messageStrategy</span><br><span class=\"line\"></span><br><span class=\"line\">    public void check()&#123;</span><br><span class=\"line\">       Message message&#x3D; messageStrategy.get(&quot;testB&quot;)</span><br><span class=\"line\">       System.out.print(message.test())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上就是一个简单的策略模式，在spring中使用该模式可以减少条件分支的代码量，而且它的扩展性也很好。</p>"},{"title":"设计模式笔记-大纲","date":"2019-04-25T01:49:37.000Z","_content":"\n作者：muggle\n\n# 设计模式的分类\n\n## 创建型模式\n\n共五种：\n\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n- 建造者模式\n- 原型模式\n\n<!--more-->\n\n## 结构型模式\n\n共七种：\n\n- 适配器模式\n- 装饰器模式\n- 代理模式\n- 外观模式\n- 桥接模式\n- 组合模式\n- 享元模式\n\n## 行为型模式\n\n共十一种：\n\n- 策略模式\n\n- 模板方法模式\n\n- 观察者模式\n\n- 迭代子模式\n\n- 责任链模式\n\n- 命令模式\n\n- 备忘录模式\n\n- 状态模式\n\n- 访问者模式\n\n- 中介者模式\n\n- 解释器模式\n# 设计原则\n\n设计模式的最终目的是为了实现代码设计的六大基本原则的，我们在使用设计模式的时候千万要记住这一点，不用为了使用设计模式而去强行套设计模式\n\n## 单一职责原则\n\n不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。\n\n当需求变化时，将通过更改职责相关的类来体现。如果一个类拥有多于一个的职责，则多个职责耦合在一起，会有多于一个原因来导致这个类发生变化。一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，影响复用性。\n\n单一职责原则解决的问题：\n\n> - 降低类的复杂度；\n> - 提高类的可读性，提高系统的可维护性；\n> - 降低变更引起的风险（降低对其他功能的影响）。\n\n## 里氏替换原则\n\n任何基类可以出现的地方，子类一定可以出现。\n\n只有当子类可以替换掉父类， 代码功能不受到影响时，父类才能真正被复用， 而子类也能够在父类的基础上增加新的行为；从而达到代码复用与扩展的目的；里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。\n\n里氏替换原则解决的问题：\n\n> - 增强程序的健壮性， 版本升级时也可以保持非常好的兼容性。\n> - 提高代码复用率\n\n## 依赖倒置原则\n\n这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。\n\n## 开闭原则\n\n对于引用的模块尽量去扩展，而不是去修改它，也就是所谓的对扩展开放对修改关闭。开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则，抽象化是开闭原则的关键。\n\n## 接口隔离原则\n\n接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。     根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可\n\n## 迪米特原则\n\n一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。\n\n# 设计模式解析\n\n首先允许我提一点建议，有不少设计模式的教程喜欢拿生活中一些事物举例子，比如什么什么奥迪汽车，宝马，汽车工厂这种。这种方式确实能让人更加直观的的体会到一个设计模式的用法和作用，但是我以前这样学的后果就是——看啥都像设计模式，想往设计模式里面套又套不出个所以然来。实际上有的设计模式结构是由好几个角色组成，该如何去写怎么命名都是确定的有理有据的，你光记住生活中的一个例子然后平时写代码去套这个例子，你会有种无从下手的感觉。我们应该把每个设计模式的使用场景结构都记住，但是这样死记难记不说，还很难做到活学活用。我的的建议是结合源码去记，这样你能根据源码中的例子依瓢画葫芦写出自己想要的设计模式出来，我接下来对设计模式的讲解也是结合源码进行讲解的。\n\n然后，我个人建议是能不用设计模式的地方就不用设计模式。并不是因为设计模式不好，一个设计得好的设计模式确实可以减少我们工作量和代码维护成本，但是一个设计不好的设计模式使用起来代价巨大。要知道设计模式的最终目的是减少我们的工作量，不要为了设计模式而设计模式。一个垃圾的设计模式的缺点：代码维护成本翻倍，因为会凭空多了好多莫名其妙的类；代码读不懂，你设计模式用的乱七八糟，别人只会感觉你的代码毫无逻辑，绕来绕去。\n\n一个好的设计模式，首先要用对场景，然后命名要规范，要让别人一看命名就知道你用的什么设计模式，然后根据设计模式去找相关联的类，这样别人脑海里才能形成一个脉络，有点没法按设计模式规范命名的地方也请加上注释，不然让别人猜你的代码写了些啥，用的啥设计模式吗？\n","source":"_posts/design-1.md","raw":"---\ntitle: 设计模式笔记-大纲\ndate: 2019-04-25 09:49:37\ntags: 设计模式\n---\n\n作者：muggle\n\n# 设计模式的分类\n\n## 创建型模式\n\n共五种：\n\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n- 建造者模式\n- 原型模式\n\n<!--more-->\n\n## 结构型模式\n\n共七种：\n\n- 适配器模式\n- 装饰器模式\n- 代理模式\n- 外观模式\n- 桥接模式\n- 组合模式\n- 享元模式\n\n## 行为型模式\n\n共十一种：\n\n- 策略模式\n\n- 模板方法模式\n\n- 观察者模式\n\n- 迭代子模式\n\n- 责任链模式\n\n- 命令模式\n\n- 备忘录模式\n\n- 状态模式\n\n- 访问者模式\n\n- 中介者模式\n\n- 解释器模式\n# 设计原则\n\n设计模式的最终目的是为了实现代码设计的六大基本原则的，我们在使用设计模式的时候千万要记住这一点，不用为了使用设计模式而去强行套设计模式\n\n## 单一职责原则\n\n不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。\n\n当需求变化时，将通过更改职责相关的类来体现。如果一个类拥有多于一个的职责，则多个职责耦合在一起，会有多于一个原因来导致这个类发生变化。一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，影响复用性。\n\n单一职责原则解决的问题：\n\n> - 降低类的复杂度；\n> - 提高类的可读性，提高系统的可维护性；\n> - 降低变更引起的风险（降低对其他功能的影响）。\n\n## 里氏替换原则\n\n任何基类可以出现的地方，子类一定可以出现。\n\n只有当子类可以替换掉父类， 代码功能不受到影响时，父类才能真正被复用， 而子类也能够在父类的基础上增加新的行为；从而达到代码复用与扩展的目的；里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。\n\n里氏替换原则解决的问题：\n\n> - 增强程序的健壮性， 版本升级时也可以保持非常好的兼容性。\n> - 提高代码复用率\n\n## 依赖倒置原则\n\n这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。\n\n## 开闭原则\n\n对于引用的模块尽量去扩展，而不是去修改它，也就是所谓的对扩展开放对修改关闭。开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则，抽象化是开闭原则的关键。\n\n## 接口隔离原则\n\n接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。     根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可\n\n## 迪米特原则\n\n一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。\n\n# 设计模式解析\n\n首先允许我提一点建议，有不少设计模式的教程喜欢拿生活中一些事物举例子，比如什么什么奥迪汽车，宝马，汽车工厂这种。这种方式确实能让人更加直观的的体会到一个设计模式的用法和作用，但是我以前这样学的后果就是——看啥都像设计模式，想往设计模式里面套又套不出个所以然来。实际上有的设计模式结构是由好几个角色组成，该如何去写怎么命名都是确定的有理有据的，你光记住生活中的一个例子然后平时写代码去套这个例子，你会有种无从下手的感觉。我们应该把每个设计模式的使用场景结构都记住，但是这样死记难记不说，还很难做到活学活用。我的的建议是结合源码去记，这样你能根据源码中的例子依瓢画葫芦写出自己想要的设计模式出来，我接下来对设计模式的讲解也是结合源码进行讲解的。\n\n然后，我个人建议是能不用设计模式的地方就不用设计模式。并不是因为设计模式不好，一个设计得好的设计模式确实可以减少我们工作量和代码维护成本，但是一个设计不好的设计模式使用起来代价巨大。要知道设计模式的最终目的是减少我们的工作量，不要为了设计模式而设计模式。一个垃圾的设计模式的缺点：代码维护成本翻倍，因为会凭空多了好多莫名其妙的类；代码读不懂，你设计模式用的乱七八糟，别人只会感觉你的代码毫无逻辑，绕来绕去。\n\n一个好的设计模式，首先要用对场景，然后命名要规范，要让别人一看命名就知道你用的什么设计模式，然后根据设计模式去找相关联的类，这样别人脑海里才能形成一个脉络，有点没法按设计模式规范命名的地方也请加上注释，不然让别人猜你的代码写了些啥，用的啥设计模式吗？\n","slug":"design-1","published":1,"updated":"2021-01-11T07:31:23.292Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5m000900wi3trnhsf2","content":"<p>作者：muggle</p>\n<h1 id=\"设计模式的分类\"><a href=\"#设计模式的分类\" class=\"headerlink\" title=\"设计模式的分类\"></a>设计模式的分类</h1><h2 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h2><p>共五种：</p>\n<ul>\n<li>工厂方法模式</li>\n<li>抽象工厂模式</li>\n<li>单例模式</li>\n<li>建造者模式</li>\n<li>原型模式</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h2><p>共七种：</p>\n<ul>\n<li>适配器模式</li>\n<li>装饰器模式</li>\n<li>代理模式</li>\n<li>外观模式</li>\n<li>桥接模式</li>\n<li>组合模式</li>\n<li>享元模式</li>\n</ul>\n<h2 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h2><p>共十一种：</p>\n<ul>\n<li><p>策略模式</p>\n</li>\n<li><p>模板方法模式</p>\n</li>\n<li><p>观察者模式</p>\n</li>\n<li><p>迭代子模式</p>\n</li>\n<li><p>责任链模式</p>\n</li>\n<li><p>命令模式</p>\n</li>\n<li><p>备忘录模式</p>\n</li>\n<li><p>状态模式</p>\n</li>\n<li><p>访问者模式</p>\n</li>\n<li><p>中介者模式</p>\n</li>\n<li><p>解释器模式</p>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1></li>\n</ul>\n<p>设计模式的最终目的是为了实现代码设计的六大基本原则的，我们在使用设计模式的时候千万要记住这一点，不用为了使用设计模式而去强行套设计模式</p>\n<h2 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h2><p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</p>\n<p>当需求变化时，将通过更改职责相关的类来体现。如果一个类拥有多于一个的职责，则多个职责耦合在一起，会有多于一个原因来导致这个类发生变化。一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，影响复用性。</p>\n<p>单一职责原则解决的问题：</p>\n<blockquote>\n<ul>\n<li>降低类的复杂度；</li>\n<li>提高类的可读性，提高系统的可维护性；</li>\n<li>降低变更引起的风险（降低对其他功能的影响）。</li>\n</ul>\n</blockquote>\n<h2 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h2><p>任何基类可以出现的地方，子类一定可以出现。</p>\n<p>只有当子类可以替换掉父类， 代码功能不受到影响时，父类才能真正被复用， 而子类也能够在父类的基础上增加新的行为；从而达到代码复用与扩展的目的；里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p>\n<p>里氏替换原则解决的问题：</p>\n<blockquote>\n<ul>\n<li>增强程序的健壮性， 版本升级时也可以保持非常好的兼容性。</li>\n<li>提高代码复用率</li>\n</ul>\n</blockquote>\n<h2 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h2><p>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>\n<h2 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h2><p>对于引用的模块尽量去扩展，而不是去修改它，也就是所谓的对扩展开放对修改关闭。开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则，抽象化是开闭原则的关键。</p>\n<h2 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h2><p>接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。     根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可</p>\n<h2 id=\"迪米特原则\"><a href=\"#迪米特原则\" class=\"headerlink\" title=\"迪米特原则\"></a>迪米特原则</h2><p>一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>\n<h1 id=\"设计模式解析\"><a href=\"#设计模式解析\" class=\"headerlink\" title=\"设计模式解析\"></a>设计模式解析</h1><p>首先允许我提一点建议，有不少设计模式的教程喜欢拿生活中一些事物举例子，比如什么什么奥迪汽车，宝马，汽车工厂这种。这种方式确实能让人更加直观的的体会到一个设计模式的用法和作用，但是我以前这样学的后果就是——看啥都像设计模式，想往设计模式里面套又套不出个所以然来。实际上有的设计模式结构是由好几个角色组成，该如何去写怎么命名都是确定的有理有据的，你光记住生活中的一个例子然后平时写代码去套这个例子，你会有种无从下手的感觉。我们应该把每个设计模式的使用场景结构都记住，但是这样死记难记不说，还很难做到活学活用。我的的建议是结合源码去记，这样你能根据源码中的例子依瓢画葫芦写出自己想要的设计模式出来，我接下来对设计模式的讲解也是结合源码进行讲解的。</p>\n<p>然后，我个人建议是能不用设计模式的地方就不用设计模式。并不是因为设计模式不好，一个设计得好的设计模式确实可以减少我们工作量和代码维护成本，但是一个设计不好的设计模式使用起来代价巨大。要知道设计模式的最终目的是减少我们的工作量，不要为了设计模式而设计模式。一个垃圾的设计模式的缺点：代码维护成本翻倍，因为会凭空多了好多莫名其妙的类；代码读不懂，你设计模式用的乱七八糟，别人只会感觉你的代码毫无逻辑，绕来绕去。</p>\n<p>一个好的设计模式，首先要用对场景，然后命名要规范，要让别人一看命名就知道你用的什么设计模式，然后根据设计模式去找相关联的类，这样别人脑海里才能形成一个脉络，有点没法按设计模式规范命名的地方也请加上注释，不然让别人猜你的代码写了些啥，用的啥设计模式吗？</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h1 id=\"设计模式的分类\"><a href=\"#设计模式的分类\" class=\"headerlink\" title=\"设计模式的分类\"></a>设计模式的分类</h1><h2 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h2><p>共五种：</p>\n<ul>\n<li>工厂方法模式</li>\n<li>抽象工厂模式</li>\n<li>单例模式</li>\n<li>建造者模式</li>\n<li>原型模式</li>\n</ul>","more":"<h2 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h2><p>共七种：</p>\n<ul>\n<li>适配器模式</li>\n<li>装饰器模式</li>\n<li>代理模式</li>\n<li>外观模式</li>\n<li>桥接模式</li>\n<li>组合模式</li>\n<li>享元模式</li>\n</ul>\n<h2 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h2><p>共十一种：</p>\n<ul>\n<li><p>策略模式</p>\n</li>\n<li><p>模板方法模式</p>\n</li>\n<li><p>观察者模式</p>\n</li>\n<li><p>迭代子模式</p>\n</li>\n<li><p>责任链模式</p>\n</li>\n<li><p>命令模式</p>\n</li>\n<li><p>备忘录模式</p>\n</li>\n<li><p>状态模式</p>\n</li>\n<li><p>访问者模式</p>\n</li>\n<li><p>中介者模式</p>\n</li>\n<li><p>解释器模式</p>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1></li>\n</ul>\n<p>设计模式的最终目的是为了实现代码设计的六大基本原则的，我们在使用设计模式的时候千万要记住这一点，不用为了使用设计模式而去强行套设计模式</p>\n<h2 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h2><p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</p>\n<p>当需求变化时，将通过更改职责相关的类来体现。如果一个类拥有多于一个的职责，则多个职责耦合在一起，会有多于一个原因来导致这个类发生变化。一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，影响复用性。</p>\n<p>单一职责原则解决的问题：</p>\n<blockquote>\n<ul>\n<li>降低类的复杂度；</li>\n<li>提高类的可读性，提高系统的可维护性；</li>\n<li>降低变更引起的风险（降低对其他功能的影响）。</li>\n</ul>\n</blockquote>\n<h2 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h2><p>任何基类可以出现的地方，子类一定可以出现。</p>\n<p>只有当子类可以替换掉父类， 代码功能不受到影响时，父类才能真正被复用， 而子类也能够在父类的基础上增加新的行为；从而达到代码复用与扩展的目的；里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p>\n<p>里氏替换原则解决的问题：</p>\n<blockquote>\n<ul>\n<li>增强程序的健壮性， 版本升级时也可以保持非常好的兼容性。</li>\n<li>提高代码复用率</li>\n</ul>\n</blockquote>\n<h2 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h2><p>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>\n<h2 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h2><p>对于引用的模块尽量去扩展，而不是去修改它，也就是所谓的对扩展开放对修改关闭。开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则，抽象化是开闭原则的关键。</p>\n<h2 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h2><p>接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。     根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可</p>\n<h2 id=\"迪米特原则\"><a href=\"#迪米特原则\" class=\"headerlink\" title=\"迪米特原则\"></a>迪米特原则</h2><p>一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>\n<h1 id=\"设计模式解析\"><a href=\"#设计模式解析\" class=\"headerlink\" title=\"设计模式解析\"></a>设计模式解析</h1><p>首先允许我提一点建议，有不少设计模式的教程喜欢拿生活中一些事物举例子，比如什么什么奥迪汽车，宝马，汽车工厂这种。这种方式确实能让人更加直观的的体会到一个设计模式的用法和作用，但是我以前这样学的后果就是——看啥都像设计模式，想往设计模式里面套又套不出个所以然来。实际上有的设计模式结构是由好几个角色组成，该如何去写怎么命名都是确定的有理有据的，你光记住生活中的一个例子然后平时写代码去套这个例子，你会有种无从下手的感觉。我们应该把每个设计模式的使用场景结构都记住，但是这样死记难记不说，还很难做到活学活用。我的的建议是结合源码去记，这样你能根据源码中的例子依瓢画葫芦写出自己想要的设计模式出来，我接下来对设计模式的讲解也是结合源码进行讲解的。</p>\n<p>然后，我个人建议是能不用设计模式的地方就不用设计模式。并不是因为设计模式不好，一个设计得好的设计模式确实可以减少我们工作量和代码维护成本，但是一个设计不好的设计模式使用起来代价巨大。要知道设计模式的最终目的是减少我们的工作量，不要为了设计模式而设计模式。一个垃圾的设计模式的缺点：代码维护成本翻倍，因为会凭空多了好多莫名其妙的类；代码读不懂，你设计模式用的乱七八糟，别人只会感觉你的代码毫无逻辑，绕来绕去。</p>\n<p>一个好的设计模式，首先要用对场景，然后命名要规范，要让别人一看命名就知道你用的什么设计模式，然后根据设计模式去找相关联的类，这样别人脑海里才能形成一个脉络，有点没法按设计模式规范命名的地方也请加上注释，不然让别人猜你的代码写了些啥，用的啥设计模式吗？</p>"},{"title":"设计模式-责任链模式","date":"2020-02-02T09:39:12.000Z","_content":"\n责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。\n\n责任链模式也叫职责链模式。\n\n在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。\n\n<!--more-->\n\n责任链模式是一种对象行为型模式，其主要优点如下。\n降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。\n增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。\n增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。\n责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。\n责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。\n\n## 模式结构\n\n职责链模式主要包含以下角色：\n抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。\n具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。\n客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。\n\n# 源码导读\n\n在`spring security` 中其核心设计模式就是责任链模式；它通过注册过滤器链来实现责任链模式，每个过滤器链都只做一件事。springSecurity的责任链顺序如下\n\n> WebAsyncManagerIntegrationFilter：将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。\n>\n> SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除\n> 例如在Session中维护一个用户的安全信息就是这个过滤器处理的。\n>\n> HeaderWriterFilter：用于将头信息加入响应中\n>\n> CsrfFilter：用于处理跨站请求伪造\n>\n> LogoutFilter：用于处理退出登录\n>\n> UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。\n>\n> DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。\n>\n> BasicAuthenticationFilter：检测和处理http basic认证\n>\n> RequestCacheAwareFilter：用来处理请求的缓存\n>\n> SecurityContextHolderAwareRequestFilter：主要是包装请求对象request\n>\n> AnonymousAuthenticationFilter：检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication\n>\n> SessionManagementFilter：管理session的过滤器\n>\n> ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常\n>\n> FilterSecurityInterceptor：可以看做过滤器链的出口\n>\n> RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。\n\n而责任链的客户类是`HttpSecurity`,它负责对责任链的创建和管理，它的`addFilterAt(Filter filter, Class atFilter)` 方法可在责任链中添加一个过滤器。\n在这个框架中 过滤器作为了`抽象处理者（Handler`的角色，各个具体的过滤器类是`具体处理者（Concrete Handler`角色 `HttpSecueiry`是`客户类`角色。","source":"_posts/design-13.md","raw":"---\ntitle: 设计模式-责任链模式\ndate: 2020-02-02 17:39:12\ntags: 设计模式\n---\n\n责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。\n\n责任链模式也叫职责链模式。\n\n在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。\n\n<!--more-->\n\n责任链模式是一种对象行为型模式，其主要优点如下。\n降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。\n增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。\n增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。\n责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。\n责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。\n\n## 模式结构\n\n职责链模式主要包含以下角色：\n抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。\n具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。\n客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。\n\n# 源码导读\n\n在`spring security` 中其核心设计模式就是责任链模式；它通过注册过滤器链来实现责任链模式，每个过滤器链都只做一件事。springSecurity的责任链顺序如下\n\n> WebAsyncManagerIntegrationFilter：将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。\n>\n> SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除\n> 例如在Session中维护一个用户的安全信息就是这个过滤器处理的。\n>\n> HeaderWriterFilter：用于将头信息加入响应中\n>\n> CsrfFilter：用于处理跨站请求伪造\n>\n> LogoutFilter：用于处理退出登录\n>\n> UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。\n>\n> DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。\n>\n> BasicAuthenticationFilter：检测和处理http basic认证\n>\n> RequestCacheAwareFilter：用来处理请求的缓存\n>\n> SecurityContextHolderAwareRequestFilter：主要是包装请求对象request\n>\n> AnonymousAuthenticationFilter：检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication\n>\n> SessionManagementFilter：管理session的过滤器\n>\n> ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常\n>\n> FilterSecurityInterceptor：可以看做过滤器链的出口\n>\n> RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。\n\n而责任链的客户类是`HttpSecurity`,它负责对责任链的创建和管理，它的`addFilterAt(Filter filter, Class atFilter)` 方法可在责任链中添加一个过滤器。\n在这个框架中 过滤器作为了`抽象处理者（Handler`的角色，各个具体的过滤器类是`具体处理者（Concrete Handler`角色 `HttpSecueiry`是`客户类`角色。","slug":"design-13","published":1,"updated":"2021-01-11T07:31:23.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5n000b00wi4lv03xpu","content":"<p>责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>\n<p>责任链模式也叫职责链模式。</p>\n<p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。</p>\n<a id=\"more\"></a>\n\n<p>责任链模式是一种对象行为型模式，其主要优点如下。<br>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。<br>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。<br>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。<br>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。<br>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p>\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>职责链模式主要包含以下角色：<br>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。<br>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。<br>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</p>\n<h1 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h1><p>在<code>spring security</code> 中其核心设计模式就是责任链模式；它通过注册过滤器链来实现责任链模式，每个过滤器链都只做一件事。springSecurity的责任链顺序如下</p>\n<blockquote>\n<p>WebAsyncManagerIntegrationFilter：将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。</p>\n<p>SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除<br>例如在Session中维护一个用户的安全信息就是这个过滤器处理的。</p>\n<p>HeaderWriterFilter：用于将头信息加入响应中</p>\n<p>CsrfFilter：用于处理跨站请求伪造</p>\n<p>LogoutFilter：用于处理退出登录</p>\n<p>UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。</p>\n<p>DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</p>\n<p>BasicAuthenticationFilter：检测和处理http basic认证</p>\n<p>RequestCacheAwareFilter：用来处理请求的缓存</p>\n<p>SecurityContextHolderAwareRequestFilter：主要是包装请求对象request</p>\n<p>AnonymousAuthenticationFilter：检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication</p>\n<p>SessionManagementFilter：管理session的过滤器</p>\n<p>ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常</p>\n<p>FilterSecurityInterceptor：可以看做过滤器链的出口</p>\n<p>RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</p>\n</blockquote>\n<p>而责任链的客户类是<code>HttpSecurity</code>,它负责对责任链的创建和管理，它的<code>addFilterAt(Filter filter, Class atFilter)</code> 方法可在责任链中添加一个过滤器。<br>在这个框架中 过滤器作为了<code>抽象处理者（Handler</code>的角色，各个具体的过滤器类是<code>具体处理者（Concrete Handler</code>角色 <code>HttpSecueiry</code>是<code>客户类</code>角色。</p>\n","site":{"data":{}},"excerpt":"<p>责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>\n<p>责任链模式也叫职责链模式。</p>\n<p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。</p>","more":"<p>责任链模式是一种对象行为型模式，其主要优点如下。<br>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。<br>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。<br>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。<br>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。<br>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p>\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>职责链模式主要包含以下角色：<br>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。<br>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。<br>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</p>\n<h1 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h1><p>在<code>spring security</code> 中其核心设计模式就是责任链模式；它通过注册过滤器链来实现责任链模式，每个过滤器链都只做一件事。springSecurity的责任链顺序如下</p>\n<blockquote>\n<p>WebAsyncManagerIntegrationFilter：将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。</p>\n<p>SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除<br>例如在Session中维护一个用户的安全信息就是这个过滤器处理的。</p>\n<p>HeaderWriterFilter：用于将头信息加入响应中</p>\n<p>CsrfFilter：用于处理跨站请求伪造</p>\n<p>LogoutFilter：用于处理退出登录</p>\n<p>UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。</p>\n<p>DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</p>\n<p>BasicAuthenticationFilter：检测和处理http basic认证</p>\n<p>RequestCacheAwareFilter：用来处理请求的缓存</p>\n<p>SecurityContextHolderAwareRequestFilter：主要是包装请求对象request</p>\n<p>AnonymousAuthenticationFilter：检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication</p>\n<p>SessionManagementFilter：管理session的过滤器</p>\n<p>ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常</p>\n<p>FilterSecurityInterceptor：可以看做过滤器链的出口</p>\n<p>RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</p>\n</blockquote>\n<p>而责任链的客户类是<code>HttpSecurity</code>,它负责对责任链的创建和管理，它的<code>addFilterAt(Filter filter, Class atFilter)</code> 方法可在责任链中添加一个过滤器。<br>在这个框架中 过滤器作为了<code>抽象处理者（Handler</code>的角色，各个具体的过滤器类是<code>具体处理者（Concrete Handler</code>角色 <code>HttpSecueiry</code>是<code>客户类</code>角色。</p>"},{"title":"设计模式-命令模式","date":"2020-02-02T09:37:56.000Z","_content":"\n当我们的代码中”方法的请求者” 和 “方法的实现者” 之间存在较为紧密的耦合的时候，这段代码的后续维护会变得很困难。如果我们想对方法进行回滚 撤销等操作的话就会很困难；使用命名模式可解决这一问题。\n\n在现实生活中，这样的例子也很多，例如，电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者），还有计算机键盘上的“功能键”等。\n\n<!--more-->\n\n\n\n命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。\n命令模式的优点：\n\n- 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。\n- 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。\n- 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。\n- 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。\n\n# 模式结构\n\n命令模式包含以下主要角色：\n\n- 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。\n- 具体命令角色（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。\n- 实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。\n- 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。\n\n# 源码导读\n\n在springboot的redis客户端的`redisTemplate`类中就有使用到命令模式。\n在命令模式中，有三个重要的角色，我们只要找到这三个重要的角色就能捋清命令模式的的脉络了，这三个角色是“客户端”，“命令”，“服务端”。\n在`RedisTemplate` 中存在一个`execute` 方法，这个就是服务端执行命令的方法，而它的方法参数`RedisCallback` 就是命令类了，我们看看如何在客户端构造一个命令给`RedisTemplate`去执行。\n\n```\npublic boolean lockByLua(String key, String value, Long expiredTime){\n        String strExprie = String.valueOf(expiredTime);\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"if redis.call(\\\"setnx\\\",KEYS[1],ARGV[1])==1 \");\n        sb.append(\"then \");\n        sb.append(\"    redis.call(\\\"pexpire\\\",KEYS[1],KEYS[2]) \");\n        sb.append(\"    return 1 \");\n        sb.append(\"else \");\n        sb.append(\"    return 0 \");\n        sb.append(\"end \");\n        String script = sb.toString();\n        RedisCallback<Boolean> callback = (connection) -> {\n            return connection.eval(script.getBytes(), ReturnType.BOOLEAN, 2, key.getBytes(Charset.forName(\"UTF-8\")),strExprie.getBytes(Charset.forName(\"UTF-8\")), value.getBytes(Charset.forName(\"UTF-8\")));\n        };\n        Boolean execute = stringRedisTemplate.execute(callback);\n        return execute;\n    }\n```\n\n以上代码是通过`stringRedisTemplate`执行一个lua脚本，`lockByLua`就是客户端的方法。对于命令模式而言，命令执行方法都是按照`executeXXX`这样的格式命名。","source":"_posts/design-12.md","raw":"---\ntitle: 设计模式-命令模式\ndate: 2020-02-02 17:37:56\ntags: 设计模式\n---\n\n当我们的代码中”方法的请求者” 和 “方法的实现者” 之间存在较为紧密的耦合的时候，这段代码的后续维护会变得很困难。如果我们想对方法进行回滚 撤销等操作的话就会很困难；使用命名模式可解决这一问题。\n\n在现实生活中，这样的例子也很多，例如，电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者），还有计算机键盘上的“功能键”等。\n\n<!--more-->\n\n\n\n命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。\n命令模式的优点：\n\n- 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。\n- 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。\n- 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。\n- 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。\n\n# 模式结构\n\n命令模式包含以下主要角色：\n\n- 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。\n- 具体命令角色（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。\n- 实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。\n- 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。\n\n# 源码导读\n\n在springboot的redis客户端的`redisTemplate`类中就有使用到命令模式。\n在命令模式中，有三个重要的角色，我们只要找到这三个重要的角色就能捋清命令模式的的脉络了，这三个角色是“客户端”，“命令”，“服务端”。\n在`RedisTemplate` 中存在一个`execute` 方法，这个就是服务端执行命令的方法，而它的方法参数`RedisCallback` 就是命令类了，我们看看如何在客户端构造一个命令给`RedisTemplate`去执行。\n\n```\npublic boolean lockByLua(String key, String value, Long expiredTime){\n        String strExprie = String.valueOf(expiredTime);\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"if redis.call(\\\"setnx\\\",KEYS[1],ARGV[1])==1 \");\n        sb.append(\"then \");\n        sb.append(\"    redis.call(\\\"pexpire\\\",KEYS[1],KEYS[2]) \");\n        sb.append(\"    return 1 \");\n        sb.append(\"else \");\n        sb.append(\"    return 0 \");\n        sb.append(\"end \");\n        String script = sb.toString();\n        RedisCallback<Boolean> callback = (connection) -> {\n            return connection.eval(script.getBytes(), ReturnType.BOOLEAN, 2, key.getBytes(Charset.forName(\"UTF-8\")),strExprie.getBytes(Charset.forName(\"UTF-8\")), value.getBytes(Charset.forName(\"UTF-8\")));\n        };\n        Boolean execute = stringRedisTemplate.execute(callback);\n        return execute;\n    }\n```\n\n以上代码是通过`stringRedisTemplate`执行一个lua脚本，`lockByLua`就是客户端的方法。对于命令模式而言，命令执行方法都是按照`executeXXX`这样的格式命名。","slug":"design-12","published":1,"updated":"2021-01-11T07:31:23.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5n000d00wiceg061i1","content":"<p>当我们的代码中”方法的请求者” 和 “方法的实现者” 之间存在较为紧密的耦合的时候，这段代码的后续维护会变得很困难。如果我们想对方法进行回滚 撤销等操作的话就会很困难；使用命名模式可解决这一问题。</p>\n<p>在现实生活中，这样的例子也很多，例如，电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者），还有计算机键盘上的“功能键”等。</p>\n<a id=\"more\"></a>\n\n\n\n<p>命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。<br>命令模式的优点：</p>\n<ul>\n<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>\n<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>\n<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>\n<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>\n</ul>\n<h1 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h1><p>命令模式包含以下主要角色：</p>\n<ul>\n<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li>\n<li>具体命令角色（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>\n<li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>\n<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>\n</ul>\n<h1 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h1><p>在springboot的redis客户端的<code>redisTemplate</code>类中就有使用到命令模式。<br>在命令模式中，有三个重要的角色，我们只要找到这三个重要的角色就能捋清命令模式的的脉络了，这三个角色是“客户端”，“命令”，“服务端”。<br>在<code>RedisTemplate</code> 中存在一个<code>execute</code> 方法，这个就是服务端执行命令的方法，而它的方法参数<code>RedisCallback</code> 就是命令类了，我们看看如何在客户端构造一个命令给<code>RedisTemplate</code>去执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean lockByLua(String key, String value, Long expiredTime)&#123;</span><br><span class=\"line\">        String strExprie &#x3D; String.valueOf(expiredTime);</span><br><span class=\"line\">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class=\"line\">        sb.append(&quot;if redis.call(\\&quot;setnx\\&quot;,KEYS[1],ARGV[1])&#x3D;&#x3D;1 &quot;);</span><br><span class=\"line\">        sb.append(&quot;then &quot;);</span><br><span class=\"line\">        sb.append(&quot;    redis.call(\\&quot;pexpire\\&quot;,KEYS[1],KEYS[2]) &quot;);</span><br><span class=\"line\">        sb.append(&quot;    return 1 &quot;);</span><br><span class=\"line\">        sb.append(&quot;else &quot;);</span><br><span class=\"line\">        sb.append(&quot;    return 0 &quot;);</span><br><span class=\"line\">        sb.append(&quot;end &quot;);</span><br><span class=\"line\">        String script &#x3D; sb.toString();</span><br><span class=\"line\">        RedisCallback&lt;Boolean&gt; callback &#x3D; (connection) -&gt; &#123;</span><br><span class=\"line\">            return connection.eval(script.getBytes(), ReturnType.BOOLEAN, 2, key.getBytes(Charset.forName(&quot;UTF-8&quot;)),strExprie.getBytes(Charset.forName(&quot;UTF-8&quot;)), value.getBytes(Charset.forName(&quot;UTF-8&quot;)));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Boolean execute &#x3D; stringRedisTemplate.execute(callback);</span><br><span class=\"line\">        return execute;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码是通过<code>stringRedisTemplate</code>执行一个lua脚本，<code>lockByLua</code>就是客户端的方法。对于命令模式而言，命令执行方法都是按照<code>executeXXX</code>这样的格式命名。</p>\n","site":{"data":{}},"excerpt":"<p>当我们的代码中”方法的请求者” 和 “方法的实现者” 之间存在较为紧密的耦合的时候，这段代码的后续维护会变得很困难。如果我们想对方法进行回滚 撤销等操作的话就会很困难；使用命名模式可解决这一问题。</p>\n<p>在现实生活中，这样的例子也很多，例如，电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者），还有计算机键盘上的“功能键”等。</p>","more":"<p>命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。<br>命令模式的优点：</p>\n<ul>\n<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>\n<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>\n<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>\n<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>\n</ul>\n<h1 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h1><p>命令模式包含以下主要角色：</p>\n<ul>\n<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li>\n<li>具体命令角色（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>\n<li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>\n<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>\n</ul>\n<h1 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h1><p>在springboot的redis客户端的<code>redisTemplate</code>类中就有使用到命令模式。<br>在命令模式中，有三个重要的角色，我们只要找到这三个重要的角色就能捋清命令模式的的脉络了，这三个角色是“客户端”，“命令”，“服务端”。<br>在<code>RedisTemplate</code> 中存在一个<code>execute</code> 方法，这个就是服务端执行命令的方法，而它的方法参数<code>RedisCallback</code> 就是命令类了，我们看看如何在客户端构造一个命令给<code>RedisTemplate</code>去执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean lockByLua(String key, String value, Long expiredTime)&#123;</span><br><span class=\"line\">        String strExprie &#x3D; String.valueOf(expiredTime);</span><br><span class=\"line\">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class=\"line\">        sb.append(&quot;if redis.call(\\&quot;setnx\\&quot;,KEYS[1],ARGV[1])&#x3D;&#x3D;1 &quot;);</span><br><span class=\"line\">        sb.append(&quot;then &quot;);</span><br><span class=\"line\">        sb.append(&quot;    redis.call(\\&quot;pexpire\\&quot;,KEYS[1],KEYS[2]) &quot;);</span><br><span class=\"line\">        sb.append(&quot;    return 1 &quot;);</span><br><span class=\"line\">        sb.append(&quot;else &quot;);</span><br><span class=\"line\">        sb.append(&quot;    return 0 &quot;);</span><br><span class=\"line\">        sb.append(&quot;end &quot;);</span><br><span class=\"line\">        String script &#x3D; sb.toString();</span><br><span class=\"line\">        RedisCallback&lt;Boolean&gt; callback &#x3D; (connection) -&gt; &#123;</span><br><span class=\"line\">            return connection.eval(script.getBytes(), ReturnType.BOOLEAN, 2, key.getBytes(Charset.forName(&quot;UTF-8&quot;)),strExprie.getBytes(Charset.forName(&quot;UTF-8&quot;)), value.getBytes(Charset.forName(&quot;UTF-8&quot;)));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Boolean execute &#x3D; stringRedisTemplate.execute(callback);</span><br><span class=\"line\">        return execute;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码是通过<code>stringRedisTemplate</code>执行一个lua脚本，<code>lockByLua</code>就是客户端的方法。对于命令模式而言，命令执行方法都是按照<code>executeXXX</code>这样的格式命名。</p>"},{"title":"设计模式——三个工厂模式","date":"2019-07-17T14:55:21.000Z","_content":"\n## 简单工厂模式\n\n简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n\n<!--more-->\n\n### 模式结构\n\n简单工厂模式包含如下角色：\n\n- Factory：工厂角色，工厂角色负责实现创建所有实例的内部逻辑\n- Product：抽象产品角色，抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\n- ConcreteProduct：具体产品角色，具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\n### 源码导读\n\n```java\n public static void main(String[] args) {\n        // 资源加载\n        ClassPathResource classPathResource = new ClassPathResource(\"spring-bean.xml\");\n        // XmlBeanFactory 加载资源并解析注册bean\n        BeanFactory beanFactory = new XmlBeanFactory(classPathResource);\n        // BeanFactory.getBean();\n        UserBean userBean = (UserBean) beanFactory.getBean(\"userBean\");\n        System.out.println(userBean.getName());\n}\n```\n\n这个`XmlBeanFactory`便可以看做是一个稍微变形的简单工厂，`getBean()`方法便是获取产品的实例方法，`userBean`便是我们的产品。如果我们以后遇到与spring中`XmlBeanFactory`类似场景我们便可依瓢画葫芦写出一个漂亮的简单工厂。\n\n## 工厂方法模式\n\n也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n\n### 模式结构\n\n工厂方法模式包含如下角色：\n\n- Product：抽象产品\n- ConcreteProduct：具体产品\n- Factory：抽象工厂\n- ConcreteFactory：具体工厂\n\n### 源码导读\n\njava.util.Collection接口中定义了一个抽象的iterator()方法，该方法就是一个工厂方法。\n我们来看看`ArrayList`中的`iterator()`实现\n\n```java\n@NotNull public Iterator<E> iterator() {\n    return new ArrayList.Itr();\n}\n```\n\n它new了一个`ArrayList`的内部类`Itr` 然后将其返回，Itr：\n\n```java\nprivate class Itr implements Iterator<E> {\n        int cursor;\n        int lastRet = -1;\n        int expectedModCount;\n\n        Itr() {\n            this.expectedModCount = ArrayList.this.modCount;\n        }\n   ......\n   ......\n}\n```\n\n这里`ArrayList`对`Iterator`来说就是一个工厂类，它的`iterator()`方法便是生产`Iterator`的工厂方法。\n\n## 抽象工厂\n\n抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。\n\n### 模式结构\n\n抽象工厂模式包含如下角色：\n\n- AbstractFactory：抽象工厂\n- ConcreteFactory：具体工厂\n- AbstractProduct：抽象产品\n- Product：具体产品\n\n### 源码导读\n\n我们可以看到 抽象工厂和工厂方法的区别是——抽象多了生产相关联产品的其他方法。可以理解为对工厂方法的一个升级，我们来看`HashMap`这个类：\n\n```java\n     HashMap<Object, Object> objectHashMap = new HashMap<>();\n     Set<Map.Entry<Object, Object>> entries = \t\t     objectHashMap.entrySet();\n     Collection<Object> values = objectHashMap.values();\n```\n\n这里`HashMap` 就是抽象工厂，它的`values()`和`entrySet()`就是两个工厂方法，` Collection<Object>`和`Set<Map.Entry<Object, Object>>`是产品。注意：**抽象工厂中抽象的含义是对产品的抽象，不再是某个产品，而是某系列产品**，工厂模式类命名一般以`factory`结尾。\n\n\n\n","source":"_posts/design-2.md","raw":"---\ntitle: 设计模式——三个工厂模式\ndate: 2019-07-17 22:55:21\ntags: 设计模式\n---\n\n## 简单工厂模式\n\n简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n\n<!--more-->\n\n### 模式结构\n\n简单工厂模式包含如下角色：\n\n- Factory：工厂角色，工厂角色负责实现创建所有实例的内部逻辑\n- Product：抽象产品角色，抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\n- ConcreteProduct：具体产品角色，具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。\n\n### 源码导读\n\n```java\n public static void main(String[] args) {\n        // 资源加载\n        ClassPathResource classPathResource = new ClassPathResource(\"spring-bean.xml\");\n        // XmlBeanFactory 加载资源并解析注册bean\n        BeanFactory beanFactory = new XmlBeanFactory(classPathResource);\n        // BeanFactory.getBean();\n        UserBean userBean = (UserBean) beanFactory.getBean(\"userBean\");\n        System.out.println(userBean.getName());\n}\n```\n\n这个`XmlBeanFactory`便可以看做是一个稍微变形的简单工厂，`getBean()`方法便是获取产品的实例方法，`userBean`便是我们的产品。如果我们以后遇到与spring中`XmlBeanFactory`类似场景我们便可依瓢画葫芦写出一个漂亮的简单工厂。\n\n## 工厂方法模式\n\n也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n\n### 模式结构\n\n工厂方法模式包含如下角色：\n\n- Product：抽象产品\n- ConcreteProduct：具体产品\n- Factory：抽象工厂\n- ConcreteFactory：具体工厂\n\n### 源码导读\n\njava.util.Collection接口中定义了一个抽象的iterator()方法，该方法就是一个工厂方法。\n我们来看看`ArrayList`中的`iterator()`实现\n\n```java\n@NotNull public Iterator<E> iterator() {\n    return new ArrayList.Itr();\n}\n```\n\n它new了一个`ArrayList`的内部类`Itr` 然后将其返回，Itr：\n\n```java\nprivate class Itr implements Iterator<E> {\n        int cursor;\n        int lastRet = -1;\n        int expectedModCount;\n\n        Itr() {\n            this.expectedModCount = ArrayList.this.modCount;\n        }\n   ......\n   ......\n}\n```\n\n这里`ArrayList`对`Iterator`来说就是一个工厂类，它的`iterator()`方法便是生产`Iterator`的工厂方法。\n\n## 抽象工厂\n\n抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。\n\n### 模式结构\n\n抽象工厂模式包含如下角色：\n\n- AbstractFactory：抽象工厂\n- ConcreteFactory：具体工厂\n- AbstractProduct：抽象产品\n- Product：具体产品\n\n### 源码导读\n\n我们可以看到 抽象工厂和工厂方法的区别是——抽象多了生产相关联产品的其他方法。可以理解为对工厂方法的一个升级，我们来看`HashMap`这个类：\n\n```java\n     HashMap<Object, Object> objectHashMap = new HashMap<>();\n     Set<Map.Entry<Object, Object>> entries = \t\t     objectHashMap.entrySet();\n     Collection<Object> values = objectHashMap.values();\n```\n\n这里`HashMap` 就是抽象工厂，它的`values()`和`entrySet()`就是两个工厂方法，` Collection<Object>`和`Set<Map.Entry<Object, Object>>`是产品。注意：**抽象工厂中抽象的含义是对产品的抽象，不再是某个产品，而是某系列产品**，工厂模式类命名一般以`factory`结尾。\n\n\n\n","slug":"design-2","published":1,"updated":"2021-01-11T07:31:23.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5o000f00wi0t5l1hdt","content":"<h2 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h2><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h3><p>简单工厂模式包含如下角色：</p>\n<ul>\n<li>Factory：工厂角色，工厂角色负责实现创建所有实例的内部逻辑</li>\n<li>Product：抽象产品角色，抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</li>\n<li>ConcreteProduct：具体产品角色，具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li>\n</ul>\n<h3 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 资源加载</span></span><br><span class=\"line\">        ClassPathResource classPathResource = <span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">&quot;spring-bean.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// XmlBeanFactory 加载资源并解析注册bean</span></span><br><span class=\"line\">        BeanFactory beanFactory = <span class=\"keyword\">new</span> XmlBeanFactory(classPathResource);</span><br><span class=\"line\">        <span class=\"comment\">// BeanFactory.getBean();</span></span><br><span class=\"line\">        UserBean userBean = (UserBean) beanFactory.getBean(<span class=\"string\">&quot;userBean&quot;</span>);</span><br><span class=\"line\">        System.out.println(userBean.getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个<code>XmlBeanFactory</code>便可以看做是一个稍微变形的简单工厂，<code>getBean()</code>方法便是获取产品的实例方法，<code>userBean</code>便是我们的产品。如果我们以后遇到与spring中<code>XmlBeanFactory</code>类似场景我们便可依瓢画葫芦写出一个漂亮的简单工厂。</p>\n<h2 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h2><p>也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<h3 id=\"模式结构-1\"><a href=\"#模式结构-1\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h3><p>工厂方法模式包含如下角色：</p>\n<ul>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n</ul>\n<h3 id=\"源码导读-1\"><a href=\"#源码导读-1\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h3><p>java.util.Collection接口中定义了一个抽象的iterator()方法，该方法就是一个工厂方法。<br>我们来看看<code>ArrayList</code>中的<code>iterator()</code>实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NotNull</span> <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList.Itr();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它new了一个<code>ArrayList</code>的内部类<code>Itr</code> 然后将其返回，Itr：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cursor;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lastRet = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> expectedModCount;</span><br><span class=\"line\"></span><br><span class=\"line\">        Itr() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.expectedModCount = ArrayList.<span class=\"keyword\">this</span>.modCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   ......</span><br><span class=\"line\">   ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里<code>ArrayList</code>对<code>Iterator</code>来说就是一个工厂类，它的<code>iterator()</code>方法便是生产<code>Iterator</code>的工厂方法。</p>\n<h2 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h2><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>\n<h3 id=\"模式结构-2\"><a href=\"#模式结构-2\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h3><p>抽象工厂模式包含如下角色：</p>\n<ul>\n<li>AbstractFactory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>AbstractProduct：抽象产品</li>\n<li>Product：具体产品</li>\n</ul>\n<h3 id=\"源码导读-2\"><a href=\"#源码导读-2\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h3><p>我们可以看到 抽象工厂和工厂方法的区别是——抽象多了生产相关联产品的其他方法。可以理解为对工厂方法的一个升级，我们来看<code>HashMap</code>这个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;Object, Object&gt; objectHashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">Set&lt;Map.Entry&lt;Object, Object&gt;&gt; entries = \t\t     objectHashMap.entrySet();</span><br><span class=\"line\">Collection&lt;Object&gt; values = objectHashMap.values();</span><br></pre></td></tr></table></figure>\n<p>这里<code>HashMap</code> 就是抽象工厂，它的<code>values()</code>和<code>entrySet()</code>就是两个工厂方法，<code>Collection&lt;Object&gt;</code>和<code>Set&lt;Map.Entry&lt;Object, Object&gt;&gt;</code>是产品。注意：<strong>抽象工厂中抽象的含义是对产品的抽象，不再是某个产品，而是某系列产品</strong>，工厂模式类命名一般以<code>factory</code>结尾。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h2><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>","more":"<h3 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h3><p>简单工厂模式包含如下角色：</p>\n<ul>\n<li>Factory：工厂角色，工厂角色负责实现创建所有实例的内部逻辑</li>\n<li>Product：抽象产品角色，抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</li>\n<li>ConcreteProduct：具体产品角色，具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li>\n</ul>\n<h3 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 资源加载</span></span><br><span class=\"line\">        ClassPathResource classPathResource = <span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">&quot;spring-bean.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// XmlBeanFactory 加载资源并解析注册bean</span></span><br><span class=\"line\">        BeanFactory beanFactory = <span class=\"keyword\">new</span> XmlBeanFactory(classPathResource);</span><br><span class=\"line\">        <span class=\"comment\">// BeanFactory.getBean();</span></span><br><span class=\"line\">        UserBean userBean = (UserBean) beanFactory.getBean(<span class=\"string\">&quot;userBean&quot;</span>);</span><br><span class=\"line\">        System.out.println(userBean.getName());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个<code>XmlBeanFactory</code>便可以看做是一个稍微变形的简单工厂，<code>getBean()</code>方法便是获取产品的实例方法，<code>userBean</code>便是我们的产品。如果我们以后遇到与spring中<code>XmlBeanFactory</code>类似场景我们便可依瓢画葫芦写出一个漂亮的简单工厂。</p>\n<h2 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h2><p>也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>\n<h3 id=\"模式结构-1\"><a href=\"#模式结构-1\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h3><p>工厂方法模式包含如下角色：</p>\n<ul>\n<li>Product：抽象产品</li>\n<li>ConcreteProduct：具体产品</li>\n<li>Factory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n</ul>\n<h3 id=\"源码导读-1\"><a href=\"#源码导读-1\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h3><p>java.util.Collection接口中定义了一个抽象的iterator()方法，该方法就是一个工厂方法。<br>我们来看看<code>ArrayList</code>中的<code>iterator()</code>实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NotNull</span> <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList.Itr();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它new了一个<code>ArrayList</code>的内部类<code>Itr</code> 然后将其返回，Itr：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cursor;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lastRet = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> expectedModCount;</span><br><span class=\"line\"></span><br><span class=\"line\">        Itr() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.expectedModCount = ArrayList.<span class=\"keyword\">this</span>.modCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   ......</span><br><span class=\"line\">   ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里<code>ArrayList</code>对<code>Iterator</code>来说就是一个工厂类，它的<code>iterator()</code>方法便是生产<code>Iterator</code>的工厂方法。</p>\n<h2 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h2><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>\n<h3 id=\"模式结构-2\"><a href=\"#模式结构-2\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h3><p>抽象工厂模式包含如下角色：</p>\n<ul>\n<li>AbstractFactory：抽象工厂</li>\n<li>ConcreteFactory：具体工厂</li>\n<li>AbstractProduct：抽象产品</li>\n<li>Product：具体产品</li>\n</ul>\n<h3 id=\"源码导读-2\"><a href=\"#源码导读-2\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h3><p>我们可以看到 抽象工厂和工厂方法的区别是——抽象多了生产相关联产品的其他方法。可以理解为对工厂方法的一个升级，我们来看<code>HashMap</code>这个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;Object, Object&gt; objectHashMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">Set&lt;Map.Entry&lt;Object, Object&gt;&gt; entries = \t\t     objectHashMap.entrySet();</span><br><span class=\"line\">Collection&lt;Object&gt; values = objectHashMap.values();</span><br></pre></td></tr></table></figure>\n<p>这里<code>HashMap</code> 就是抽象工厂，它的<code>values()</code>和<code>entrySet()</code>就是两个工厂方法，<code>Collection&lt;Object&gt;</code>和<code>Set&lt;Map.Entry&lt;Object, Object&gt;&gt;</code>是产品。注意：<strong>抽象工厂中抽象的含义是对产品的抽象，不再是某个产品，而是某系列产品</strong>，工厂模式类命名一般以<code>factory</code>结尾。</p>"},{"title":"设计模式——桥接模式","date":"2019-07-17T15:02:40.000Z","_content":"\n桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。\n\n设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：\n\n1. 为每一种形状都提供一套各种颜色的版本。\n2. 根据实际需要对形状和颜色进行组合\n\n对于有两个变化维度（即两个变化的原因）的系统，采用第二种方案来进行设计系统中类的个数更少，且系统扩展更为方便。第二种方案即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。对于有两个变化维度（即两个变化的原因）的系统，采用桥接模式开发更为方便简洁。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。\n\n<!--more-->\n\n## 模式结构\n\n桥接模式包含如下角色：\n\n- Abstraction：抽象类，桥接类\n- RefinedAbstraction：扩充抽象类\n- Implementor：实现类，被桥接的接口\n- ConcreteImplementor：具体实现类\n\n## 源码导读\n\nJDBC是基于Java支持多种数据库的操作，但是不同数据库的自我实现和传输协议都不尽相同，难道Java为每一种数据库写一种接口去支持数据库厂商的实现，显然违背了精简设计的原则，这里Java做的是提供一套接口让厂商自己实现，一套接口给程序开发者调用，两者的结合就是经典的桥接模式。作为程序员操作jdbc是这样的：\n\n```java\n    Class.forName(\"com.mysql.jdbc.Driver\");\n    String url = \"\";\n    String user = \"\";\n    String password = \"\";\n    Connection con = DriverManager.getConnection(url, user, password);\n    Statement statement = connection.createStatement();\n    String sql = \"insert into student (name,age) VALUE ('\" + name + \"',\" + age + \")\";\n    statement.execute(sql);\n\n```\n\n我们来看看``部分源码\n\n```java\n private static Connection getConnection(String var0, Properties var1, Class<?> var2) throws SQLException {\n        ClassLoader var3 = var2 != null ? var2.getClassLoader() : null;\n        Class var4 = DriverManager.class;\n        synchronized(DriverManager.class) {\n            if (var3 == null) {\n                var3 = Thread.currentThread().getContextClassLoader();\n            }\n        }\n\n        if (var0 == null) {\n            throw new SQLException(\"The url cannot be null\", \"08001\");\n        } else {\n            println(\"DriverManager.getConnection(\\\"\" + var0 + \"\\\")\");\n            SQLException var10 = null;\n            Iterator var5 = registeredDrivers.iterator();\n\n            while(true) {\n                while(var5.hasNext()) {\n                    DriverInfo var6 = (DriverInfo)var5.next();\n                    if (isDriverAllowed(var6.driver, var3)) {\n                        try {\n                            println(\"    trying \" + var6.driver.getClass().getName());\n                            Connection var7 = var6.driver.connect(var0, var1);\n                            if (var7 != null) {\n                                println(\"getConnection returning \" + var6.driver.getClass().getName());\n                                return var7;\n                            }\n                        } catch (SQLException var8) {\n                            if (var10 == null) {\n                                var10 = var8;\n                            }\n                        }\n                    } else {\n                        println(\"    skipping: \" + var6.getClass().getName());\n                    }\n                }\n\n                if (var10 != null) {\n                    println(\"getConnection failed: \" + var10);\n                    throw var10;\n                }\n\n                println(\"getConnection: no suitable driver found for \" + var0);\n                throw new SQLException(\"No suitable driver found for \" + var0, \"08001\");\n            }\n        }\n    }\n\n```\n\n看这几行代码\n\n```java\n ClassLoader var3 = var2 != null ? var2.getClassLoader() : null;\n        Class var4 = DriverManager.class;\n        synchronized(DriverManager.class) {\n            if (var3 == null) {\n                var3 = Thread.currentThread().getContextClassLoader();\n            }\n        }\n\t ......\n     ......\nConnection var7 = var6.driver.connect(var0, var1);\n```\n\n\n\n其实这里`DriverManager`获得`Connection`是通过反射和类加载机制从数据库驱动包的`driver`中拿到连接，所以这里真正参与桥接模式的是`driver`，而`DriverManager`和桥接模式没有关系，`DriverManager`只是对`driver`的一个管理器。而我们作为使用者只去关心`Connection`，不会去关心`driver`，因为我们的操作都是通过操作`Connection`来实现的。这样分析下来这个桥接就清晰了逻辑——`java.sql.Driver`作为抽象桥类，而驱动包如`com.mysql.jdbc.Driver`具体的实现桥接类，而`Connection`是被桥接的对象。这里的两个维度是：\n\n- 数据库类型的不同（驱动不同）\n- 数据库的连接信息不同（URL，username,password）\n\n现在假设一个这样的场景-我们设计了一个框架，需要对外提供api,但是这个框架内部某个类需要频繁变更，很不稳定，但是我们提供的api不能一直变吧。如何将api的方法和频繁变更的代码隔离开呢，其实就可以考虑适配器模式或者桥接模式。\n\n","source":"_posts/design-3.md","raw":"---\ntitle: 设计模式——桥接模式\ndate: 2019-07-17 23:02:40\ntags: 设计模式\n---\n\n桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。\n\n设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：\n\n1. 为每一种形状都提供一套各种颜色的版本。\n2. 根据实际需要对形状和颜色进行组合\n\n对于有两个变化维度（即两个变化的原因）的系统，采用第二种方案来进行设计系统中类的个数更少，且系统扩展更为方便。第二种方案即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。对于有两个变化维度（即两个变化的原因）的系统，采用桥接模式开发更为方便简洁。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。\n\n<!--more-->\n\n## 模式结构\n\n桥接模式包含如下角色：\n\n- Abstraction：抽象类，桥接类\n- RefinedAbstraction：扩充抽象类\n- Implementor：实现类，被桥接的接口\n- ConcreteImplementor：具体实现类\n\n## 源码导读\n\nJDBC是基于Java支持多种数据库的操作，但是不同数据库的自我实现和传输协议都不尽相同，难道Java为每一种数据库写一种接口去支持数据库厂商的实现，显然违背了精简设计的原则，这里Java做的是提供一套接口让厂商自己实现，一套接口给程序开发者调用，两者的结合就是经典的桥接模式。作为程序员操作jdbc是这样的：\n\n```java\n    Class.forName(\"com.mysql.jdbc.Driver\");\n    String url = \"\";\n    String user = \"\";\n    String password = \"\";\n    Connection con = DriverManager.getConnection(url, user, password);\n    Statement statement = connection.createStatement();\n    String sql = \"insert into student (name,age) VALUE ('\" + name + \"',\" + age + \")\";\n    statement.execute(sql);\n\n```\n\n我们来看看``部分源码\n\n```java\n private static Connection getConnection(String var0, Properties var1, Class<?> var2) throws SQLException {\n        ClassLoader var3 = var2 != null ? var2.getClassLoader() : null;\n        Class var4 = DriverManager.class;\n        synchronized(DriverManager.class) {\n            if (var3 == null) {\n                var3 = Thread.currentThread().getContextClassLoader();\n            }\n        }\n\n        if (var0 == null) {\n            throw new SQLException(\"The url cannot be null\", \"08001\");\n        } else {\n            println(\"DriverManager.getConnection(\\\"\" + var0 + \"\\\")\");\n            SQLException var10 = null;\n            Iterator var5 = registeredDrivers.iterator();\n\n            while(true) {\n                while(var5.hasNext()) {\n                    DriverInfo var6 = (DriverInfo)var5.next();\n                    if (isDriverAllowed(var6.driver, var3)) {\n                        try {\n                            println(\"    trying \" + var6.driver.getClass().getName());\n                            Connection var7 = var6.driver.connect(var0, var1);\n                            if (var7 != null) {\n                                println(\"getConnection returning \" + var6.driver.getClass().getName());\n                                return var7;\n                            }\n                        } catch (SQLException var8) {\n                            if (var10 == null) {\n                                var10 = var8;\n                            }\n                        }\n                    } else {\n                        println(\"    skipping: \" + var6.getClass().getName());\n                    }\n                }\n\n                if (var10 != null) {\n                    println(\"getConnection failed: \" + var10);\n                    throw var10;\n                }\n\n                println(\"getConnection: no suitable driver found for \" + var0);\n                throw new SQLException(\"No suitable driver found for \" + var0, \"08001\");\n            }\n        }\n    }\n\n```\n\n看这几行代码\n\n```java\n ClassLoader var3 = var2 != null ? var2.getClassLoader() : null;\n        Class var4 = DriverManager.class;\n        synchronized(DriverManager.class) {\n            if (var3 == null) {\n                var3 = Thread.currentThread().getContextClassLoader();\n            }\n        }\n\t ......\n     ......\nConnection var7 = var6.driver.connect(var0, var1);\n```\n\n\n\n其实这里`DriverManager`获得`Connection`是通过反射和类加载机制从数据库驱动包的`driver`中拿到连接，所以这里真正参与桥接模式的是`driver`，而`DriverManager`和桥接模式没有关系，`DriverManager`只是对`driver`的一个管理器。而我们作为使用者只去关心`Connection`，不会去关心`driver`，因为我们的操作都是通过操作`Connection`来实现的。这样分析下来这个桥接就清晰了逻辑——`java.sql.Driver`作为抽象桥类，而驱动包如`com.mysql.jdbc.Driver`具体的实现桥接类，而`Connection`是被桥接的对象。这里的两个维度是：\n\n- 数据库类型的不同（驱动不同）\n- 数据库的连接信息不同（URL，username,password）\n\n现在假设一个这样的场景-我们设计了一个框架，需要对外提供api,但是这个框架内部某个类需要频繁变更，很不稳定，但是我们提供的api不能一直变吧。如何将api的方法和频繁变更的代码隔离开呢，其实就可以考虑适配器模式或者桥接模式。\n\n","slug":"design-3","published":1,"updated":"2021-01-11T07:31:23.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5p000h00widcwo3nft","content":"<p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p>\n<p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p>\n<ol>\n<li>为每一种形状都提供一套各种颜色的版本。</li>\n<li>根据实际需要对形状和颜色进行组合</li>\n</ol>\n<p>对于有两个变化维度（即两个变化的原因）的系统，采用第二种方案来进行设计系统中类的个数更少，且系统扩展更为方便。第二种方案即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。对于有两个变化维度（即两个变化的原因）的系统，采用桥接模式开发更为方便简洁。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>桥接模式包含如下角色：</p>\n<ul>\n<li>Abstraction：抽象类，桥接类</li>\n<li>RefinedAbstraction：扩充抽象类</li>\n<li>Implementor：实现类，被桥接的接口</li>\n<li>ConcreteImplementor：具体实现类</li>\n</ul>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>JDBC是基于Java支持多种数据库的操作，但是不同数据库的自我实现和传输协议都不尽相同，难道Java为每一种数据库写一种接口去支持数据库厂商的实现，显然违背了精简设计的原则，这里Java做的是提供一套接口让厂商自己实现，一套接口给程序开发者调用，两者的结合就是经典的桥接模式。作为程序员操作jdbc是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forName(<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class=\"line\">String url = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">String user = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">String password = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">Connection con = DriverManager.getConnection(url, user, password);</span><br><span class=\"line\">Statement statement = connection.createStatement();</span><br><span class=\"line\">String sql = <span class=\"string\">&quot;insert into student (name,age) VALUE (&#x27;&quot;</span> + name + <span class=\"string\">&quot;&#x27;,&quot;</span> + age + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">statement.execute(sql);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们来看看``部分源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">(String var0, Properties var1, Class&lt;?&gt; var2)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">       ClassLoader var3 = var2 != <span class=\"keyword\">null</span> ? var2.getClassLoader() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       Class var4 = DriverManager.class;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span>(DriverManager.class) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (var3 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               var3 = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (var0 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(<span class=\"string\">&quot;The url cannot be null&quot;</span>, <span class=\"string\">&quot;08001&quot;</span>);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           println(<span class=\"string\">&quot;DriverManager.getConnection(\\&quot;&quot;</span> + var0 + <span class=\"string\">&quot;\\&quot;)&quot;</span>);</span><br><span class=\"line\">           SQLException var10 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">           Iterator var5 = registeredDrivers.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">while</span>(var5.hasNext()) &#123;</span><br><span class=\"line\">                   DriverInfo var6 = (DriverInfo)var5.next();</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (isDriverAllowed(var6.driver, var3)) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                           println(<span class=\"string\">&quot;    trying &quot;</span> + var6.driver.getClass().getName());</span><br><span class=\"line\">                           Connection var7 = var6.driver.connect(var0, var1);</span><br><span class=\"line\">                           <span class=\"keyword\">if</span> (var7 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                               println(<span class=\"string\">&quot;getConnection returning &quot;</span> + var6.driver.getClass().getName());</span><br><span class=\"line\">                               <span class=\"keyword\">return</span> var7;</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125; <span class=\"keyword\">catch</span> (SQLException var8) &#123;</span><br><span class=\"line\">                           <span class=\"keyword\">if</span> (var10 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                               var10 = var8;</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                       println(<span class=\"string\">&quot;    skipping: &quot;</span> + var6.getClass().getName());</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (var10 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   println(<span class=\"string\">&quot;getConnection failed: &quot;</span> + var10);</span><br><span class=\"line\">                   <span class=\"keyword\">throw</span> var10;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               println(<span class=\"string\">&quot;getConnection: no suitable driver found for &quot;</span> + var0);</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(<span class=\"string\">&quot;No suitable driver found for &quot;</span> + var0, <span class=\"string\">&quot;08001&quot;</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>看这几行代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ClassLoader var3 = var2 != <span class=\"keyword\">null</span> ? var2.getClassLoader() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Class var4 = DriverManager.class;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(DriverManager.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var3 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                var3 = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t ......</span><br><span class=\"line\">     ......</span><br><span class=\"line\">Connection var7 = var6.driver.connect(var0, var1);</span><br></pre></td></tr></table></figure>\n\n\n<p>其实这里<code>DriverManager</code>获得<code>Connection</code>是通过反射和类加载机制从数据库驱动包的<code>driver</code>中拿到连接，所以这里真正参与桥接模式的是<code>driver</code>，而<code>DriverManager</code>和桥接模式没有关系，<code>DriverManager</code>只是对<code>driver</code>的一个管理器。而我们作为使用者只去关心<code>Connection</code>，不会去关心<code>driver</code>，因为我们的操作都是通过操作<code>Connection</code>来实现的。这样分析下来这个桥接就清晰了逻辑——<code>java.sql.Driver</code>作为抽象桥类，而驱动包如<code>com.mysql.jdbc.Driver</code>具体的实现桥接类，而<code>Connection</code>是被桥接的对象。这里的两个维度是：</p>\n<ul>\n<li>数据库类型的不同（驱动不同）</li>\n<li>数据库的连接信息不同（URL，username,password）</li>\n</ul>\n<p>现在假设一个这样的场景-我们设计了一个框架，需要对外提供api,但是这个框架内部某个类需要频繁变更，很不稳定，但是我们提供的api不能一直变吧。如何将api的方法和频繁变更的代码隔离开呢，其实就可以考虑适配器模式或者桥接模式。</p>\n","site":{"data":{}},"excerpt":"<p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p>\n<p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p>\n<ol>\n<li>为每一种形状都提供一套各种颜色的版本。</li>\n<li>根据实际需要对形状和颜色进行组合</li>\n</ol>\n<p>对于有两个变化维度（即两个变化的原因）的系统，采用第二种方案来进行设计系统中类的个数更少，且系统扩展更为方便。第二种方案即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。对于有两个变化维度（即两个变化的原因）的系统，采用桥接模式开发更为方便简洁。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p>","more":"<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>桥接模式包含如下角色：</p>\n<ul>\n<li>Abstraction：抽象类，桥接类</li>\n<li>RefinedAbstraction：扩充抽象类</li>\n<li>Implementor：实现类，被桥接的接口</li>\n<li>ConcreteImplementor：具体实现类</li>\n</ul>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>JDBC是基于Java支持多种数据库的操作，但是不同数据库的自我实现和传输协议都不尽相同，难道Java为每一种数据库写一种接口去支持数据库厂商的实现，显然违背了精简设计的原则，这里Java做的是提供一套接口让厂商自己实现，一套接口给程序开发者调用，两者的结合就是经典的桥接模式。作为程序员操作jdbc是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forName(<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class=\"line\">String url = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">String user = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">String password = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">Connection con = DriverManager.getConnection(url, user, password);</span><br><span class=\"line\">Statement statement = connection.createStatement();</span><br><span class=\"line\">String sql = <span class=\"string\">&quot;insert into student (name,age) VALUE (&#x27;&quot;</span> + name + <span class=\"string\">&quot;&#x27;,&quot;</span> + age + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">statement.execute(sql);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们来看看``部分源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">(String var0, Properties var1, Class&lt;?&gt; var2)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">       ClassLoader var3 = var2 != <span class=\"keyword\">null</span> ? var2.getClassLoader() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       Class var4 = DriverManager.class;</span><br><span class=\"line\">       <span class=\"keyword\">synchronized</span>(DriverManager.class) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (var3 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               var3 = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (var0 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(<span class=\"string\">&quot;The url cannot be null&quot;</span>, <span class=\"string\">&quot;08001&quot;</span>);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           println(<span class=\"string\">&quot;DriverManager.getConnection(\\&quot;&quot;</span> + var0 + <span class=\"string\">&quot;\\&quot;)&quot;</span>);</span><br><span class=\"line\">           SQLException var10 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">           Iterator var5 = registeredDrivers.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">while</span>(var5.hasNext()) &#123;</span><br><span class=\"line\">                   DriverInfo var6 = (DriverInfo)var5.next();</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (isDriverAllowed(var6.driver, var3)) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                           println(<span class=\"string\">&quot;    trying &quot;</span> + var6.driver.getClass().getName());</span><br><span class=\"line\">                           Connection var7 = var6.driver.connect(var0, var1);</span><br><span class=\"line\">                           <span class=\"keyword\">if</span> (var7 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                               println(<span class=\"string\">&quot;getConnection returning &quot;</span> + var6.driver.getClass().getName());</span><br><span class=\"line\">                               <span class=\"keyword\">return</span> var7;</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125; <span class=\"keyword\">catch</span> (SQLException var8) &#123;</span><br><span class=\"line\">                           <span class=\"keyword\">if</span> (var10 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                               var10 = var8;</span><br><span class=\"line\">                           &#125;</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                       println(<span class=\"string\">&quot;    skipping: &quot;</span> + var6.getClass().getName());</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (var10 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                   println(<span class=\"string\">&quot;getConnection failed: &quot;</span> + var10);</span><br><span class=\"line\">                   <span class=\"keyword\">throw</span> var10;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               println(<span class=\"string\">&quot;getConnection: no suitable driver found for &quot;</span> + var0);</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLException(<span class=\"string\">&quot;No suitable driver found for &quot;</span> + var0, <span class=\"string\">&quot;08001&quot;</span>);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>看这几行代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ClassLoader var3 = var2 != <span class=\"keyword\">null</span> ? var2.getClassLoader() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Class var4 = DriverManager.class;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(DriverManager.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (var3 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                var3 = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t ......</span><br><span class=\"line\">     ......</span><br><span class=\"line\">Connection var7 = var6.driver.connect(var0, var1);</span><br></pre></td></tr></table></figure>\n\n\n<p>其实这里<code>DriverManager</code>获得<code>Connection</code>是通过反射和类加载机制从数据库驱动包的<code>driver</code>中拿到连接，所以这里真正参与桥接模式的是<code>driver</code>，而<code>DriverManager</code>和桥接模式没有关系，<code>DriverManager</code>只是对<code>driver</code>的一个管理器。而我们作为使用者只去关心<code>Connection</code>，不会去关心<code>driver</code>，因为我们的操作都是通过操作<code>Connection</code>来实现的。这样分析下来这个桥接就清晰了逻辑——<code>java.sql.Driver</code>作为抽象桥类，而驱动包如<code>com.mysql.jdbc.Driver</code>具体的实现桥接类，而<code>Connection</code>是被桥接的对象。这里的两个维度是：</p>\n<ul>\n<li>数据库类型的不同（驱动不同）</li>\n<li>数据库的连接信息不同（URL，username,password）</li>\n</ul>\n<p>现在假设一个这样的场景-我们设计了一个框架，需要对外提供api,但是这个框架内部某个类需要频繁变更，很不稳定，但是我们提供的api不能一直变吧。如何将api的方法和频繁变更的代码隔离开呢，其实就可以考虑适配器模式或者桥接模式。</p>"},{"title":"设计模式-适配器","date":"2019-07-18T12:19:34.000Z","_content":"\n\n\n适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。\n\n## 模式结构\n\n适配器模式包含如下角色：\n\n- Target：目标抽象类\n- Adapter：适配器类\n- Adaptee：适配者类\n- Client：客户类\n\n<!--more-->\n\n## 源码导读\n\n我们都知道springMVC就用到了适配器模式，那他是怎么适配呢，我们来看看它的源码，首先我们要清楚springMVC的执行原理，它的整个流程我这里就不像述了，说一下关键的部分：\n\n1. `DispatcherServlte`会根据配置文件信息注册`HandlerAdapter`，如果在配置文件中没有配置，那么`DispatcherServlte`会获取`HandlerAdapter`的默认配置，如果是读取默认配置的话，`DispatcherServlte`会读取`DispatcherServlte.properties`文件,该文件中配置了三种`HandlerAdapter`：`HttpRequestHandlerAdapter`，`SimpleControllerHandlerAdapter`和`AnnotationMethodHandlerAdapter`。`DispatcherServlte`会将这三个`HandlerAdapter`对象存储到它的`handlerAdapters`这个集合属性中，这样就完成了`HandlerAdapter`的注册。\n2. `DispatcherServlte`会根据`handlerMapping`传过来的`controller`与已经注册好了的`HandlerAdapter`一一匹配，看哪一种`HandlerAdapter`是支持该controller类型的，如果找到了其中一种`HandlerAdapter`是支持传过来的`controller`类型，那么该`HandlerAdapter`会调用自己的handle方法，handle方法运用java的反射机制执行controller的具体方法来获得`ModelAndView`\n\n`DispatcherServlte`部分源码\n\n```java\npublic class DispatcherServlet extends FrameworkServlet {\n    ......\n    ......\n    @Nullable\n    private List<HandlerMapping> handlerMappings;\n    @Nullable\n    private List<HandlerAdapter> handlerAdapters;\n \tprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        HttpServletRequest processedRequest = request;\n        HandlerExecutionChain mappedHandler = null;\n        boolean multipartRequestParsed = false;\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n        try {\n            try {\n                ModelAndView mv = null;\n                Object dispatchException = null;\n\n                try {\n                    ......\n                    ......\n\n                    HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());\n                    ......\n                    ......\n\n                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n                    if (asyncManager.isConcurrentHandlingStarted()) {\n                        return;\n                    }\n\n                    this.applyDefaultViewName(processedRequest, mv);\n                    mappedHandler.applyPostHandle(processedRequest, response, mv);\n                } catch (Exception var20) {\n                    dispatchException = var20;\n                } catch (Throwable var21) {\n\t\t\t\t......\n                }\n\t\t\t......\n            } catch (Exception var22) {\n               ......\n            } catch (Throwable var23) {\n \t\t\t  ......\n            }\n\n        } finally {\n            ......\n            ......\n        }\n    }\n}\n```\n\n这里只放上比较关键的代码，我们可以看到当一个请求进入`doDispatch()`方法的时候，它先去`getHandlerAdapter()`中拿到适配器，这就是第二步中根据`handlerMapping`中的`controller`找到对应适配器。找到适配器后通过`ha.handle(processedRequest, response, mappedHandler.getHandler())`执行我们自己的`controller`，`mappedHandler.getHandler()`就是我们自己的`controller`。\n\n至于`handler()`如何知道该去执行controller中哪个方法，当然是通过注解去转换对应方法的。因此，这里的适配器模式还不是特别的纯粹，还结合了反射机制。`DispatcherServlte`属于客户端，我们的`Controller`属于被适配的类，`HandlerAdapter`属于适配器。\n\n现在我们假定需要写一个线程池任务调度框架，我们知道JDK自带的线程框架可以创建一个线程池，但是线程池只能传入实现`runnable`接口或者`callable`接口的对象。\n\n```java\nExecutorService cachedThreadPool = Executors.newCachedThreadPool();\ncachedThreadPool.execute(new Runnable() {\n    @Override\n     public void run() {\n     }\n})\n```\n\n那我们要咋样可以让客户端使用的时候无须继承`runnable`来使用我们的这个框架呢。你可以像springMVC一样使用适配器加注解。也可以提供一个实现`Runnable`接口的抽象适配器类，让客户端进行一定的配置来将普通的类适配到`Runnable`。\n\n关于适配器的使用方面还有很多，比如`spring security`的`WebSecurityConfigurerAdapter`和`netty`中的`ChannelInboundHandlerAdapter` 对于适配器模式类名一般都以`Adapter`结尾\n\n","source":"_posts/design-4.md","raw":"---\ntitle: 设计模式-适配器\ndate: 2019-07-18 20:19:34\ntags: 设计模式\n---\n\n\n\n适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。\n\n## 模式结构\n\n适配器模式包含如下角色：\n\n- Target：目标抽象类\n- Adapter：适配器类\n- Adaptee：适配者类\n- Client：客户类\n\n<!--more-->\n\n## 源码导读\n\n我们都知道springMVC就用到了适配器模式，那他是怎么适配呢，我们来看看它的源码，首先我们要清楚springMVC的执行原理，它的整个流程我这里就不像述了，说一下关键的部分：\n\n1. `DispatcherServlte`会根据配置文件信息注册`HandlerAdapter`，如果在配置文件中没有配置，那么`DispatcherServlte`会获取`HandlerAdapter`的默认配置，如果是读取默认配置的话，`DispatcherServlte`会读取`DispatcherServlte.properties`文件,该文件中配置了三种`HandlerAdapter`：`HttpRequestHandlerAdapter`，`SimpleControllerHandlerAdapter`和`AnnotationMethodHandlerAdapter`。`DispatcherServlte`会将这三个`HandlerAdapter`对象存储到它的`handlerAdapters`这个集合属性中，这样就完成了`HandlerAdapter`的注册。\n2. `DispatcherServlte`会根据`handlerMapping`传过来的`controller`与已经注册好了的`HandlerAdapter`一一匹配，看哪一种`HandlerAdapter`是支持该controller类型的，如果找到了其中一种`HandlerAdapter`是支持传过来的`controller`类型，那么该`HandlerAdapter`会调用自己的handle方法，handle方法运用java的反射机制执行controller的具体方法来获得`ModelAndView`\n\n`DispatcherServlte`部分源码\n\n```java\npublic class DispatcherServlet extends FrameworkServlet {\n    ......\n    ......\n    @Nullable\n    private List<HandlerMapping> handlerMappings;\n    @Nullable\n    private List<HandlerAdapter> handlerAdapters;\n \tprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        HttpServletRequest processedRequest = request;\n        HandlerExecutionChain mappedHandler = null;\n        boolean multipartRequestParsed = false;\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n        try {\n            try {\n                ModelAndView mv = null;\n                Object dispatchException = null;\n\n                try {\n                    ......\n                    ......\n\n                    HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());\n                    ......\n                    ......\n\n                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n                    if (asyncManager.isConcurrentHandlingStarted()) {\n                        return;\n                    }\n\n                    this.applyDefaultViewName(processedRequest, mv);\n                    mappedHandler.applyPostHandle(processedRequest, response, mv);\n                } catch (Exception var20) {\n                    dispatchException = var20;\n                } catch (Throwable var21) {\n\t\t\t\t......\n                }\n\t\t\t......\n            } catch (Exception var22) {\n               ......\n            } catch (Throwable var23) {\n \t\t\t  ......\n            }\n\n        } finally {\n            ......\n            ......\n        }\n    }\n}\n```\n\n这里只放上比较关键的代码，我们可以看到当一个请求进入`doDispatch()`方法的时候，它先去`getHandlerAdapter()`中拿到适配器，这就是第二步中根据`handlerMapping`中的`controller`找到对应适配器。找到适配器后通过`ha.handle(processedRequest, response, mappedHandler.getHandler())`执行我们自己的`controller`，`mappedHandler.getHandler()`就是我们自己的`controller`。\n\n至于`handler()`如何知道该去执行controller中哪个方法，当然是通过注解去转换对应方法的。因此，这里的适配器模式还不是特别的纯粹，还结合了反射机制。`DispatcherServlte`属于客户端，我们的`Controller`属于被适配的类，`HandlerAdapter`属于适配器。\n\n现在我们假定需要写一个线程池任务调度框架，我们知道JDK自带的线程框架可以创建一个线程池，但是线程池只能传入实现`runnable`接口或者`callable`接口的对象。\n\n```java\nExecutorService cachedThreadPool = Executors.newCachedThreadPool();\ncachedThreadPool.execute(new Runnable() {\n    @Override\n     public void run() {\n     }\n})\n```\n\n那我们要咋样可以让客户端使用的时候无须继承`runnable`来使用我们的这个框架呢。你可以像springMVC一样使用适配器加注解。也可以提供一个实现`Runnable`接口的抽象适配器类，让客户端进行一定的配置来将普通的类适配到`Runnable`。\n\n关于适配器的使用方面还有很多，比如`spring security`的`WebSecurityConfigurerAdapter`和`netty`中的`ChannelInboundHandlerAdapter` 对于适配器模式类名一般都以`Adapter`结尾\n\n","slug":"design-4","published":1,"updated":"2021-01-11T07:31:23.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5q000j00wi1a45agb0","content":"<p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>适配器模式包含如下角色：</p>\n<ul>\n<li>Target：目标抽象类</li>\n<li>Adapter：适配器类</li>\n<li>Adaptee：适配者类</li>\n<li>Client：客户类</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>我们都知道springMVC就用到了适配器模式，那他是怎么适配呢，我们来看看它的源码，首先我们要清楚springMVC的执行原理，它的整个流程我这里就不像述了，说一下关键的部分：</p>\n<ol>\n<li><code>DispatcherServlte</code>会根据配置文件信息注册<code>HandlerAdapter</code>，如果在配置文件中没有配置，那么<code>DispatcherServlte</code>会获取<code>HandlerAdapter</code>的默认配置，如果是读取默认配置的话，<code>DispatcherServlte</code>会读取<code>DispatcherServlte.properties</code>文件,该文件中配置了三种<code>HandlerAdapter</code>：<code>HttpRequestHandlerAdapter</code>，<code>SimpleControllerHandlerAdapter</code>和<code>AnnotationMethodHandlerAdapter</code>。<code>DispatcherServlte</code>会将这三个<code>HandlerAdapter</code>对象存储到它的<code>handlerAdapters</code>这个集合属性中，这样就完成了<code>HandlerAdapter</code>的注册。</li>\n<li><code>DispatcherServlte</code>会根据<code>handlerMapping</code>传过来的<code>controller</code>与已经注册好了的<code>HandlerAdapter</code>一一匹配，看哪一种<code>HandlerAdapter</code>是支持该controller类型的，如果找到了其中一种<code>HandlerAdapter</code>是支持传过来的<code>controller</code>类型，那么该<code>HandlerAdapter</code>会调用自己的handle方法，handle方法运用java的反射机制执行controller的具体方法来获得<code>ModelAndView</code></li>\n</ol>\n<p><code>DispatcherServlte</code>部分源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">FrameworkServlet</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class=\"line\"> \t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doDispatch</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        HttpServletRequest processedRequest = request;</span><br><span class=\"line\">        HandlerExecutionChain mappedHandler = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> multipartRequestParsed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                ModelAndView mv = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                Object dispatchException = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    ......</span><br><span class=\"line\">                    ......</span><br><span class=\"line\"></span><br><span class=\"line\">                    HandlerAdapter ha = <span class=\"keyword\">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class=\"line\">                    ......</span><br><span class=\"line\">                    ......</span><br><span class=\"line\"></span><br><span class=\"line\">                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class=\"line\">                    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception var20) &#123;</span><br><span class=\"line\">                    dispatchException = var20;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable var21) &#123;</span><br><span class=\"line\">\t\t\t\t......</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t......</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception var22) &#123;</span><br><span class=\"line\">               ......</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable var23) &#123;</span><br><span class=\"line\"> \t\t\t  ......</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只放上比较关键的代码，我们可以看到当一个请求进入<code>doDispatch()</code>方法的时候，它先去<code>getHandlerAdapter()</code>中拿到适配器，这就是第二步中根据<code>handlerMapping</code>中的<code>controller</code>找到对应适配器。找到适配器后通过<code>ha.handle(processedRequest, response, mappedHandler.getHandler())</code>执行我们自己的<code>controller</code>，<code>mappedHandler.getHandler()</code>就是我们自己的<code>controller</code>。</p>\n<p>至于<code>handler()</code>如何知道该去执行controller中哪个方法，当然是通过注解去转换对应方法的。因此，这里的适配器模式还不是特别的纯粹，还结合了反射机制。<code>DispatcherServlte</code>属于客户端，我们的<code>Controller</code>属于被适配的类，<code>HandlerAdapter</code>属于适配器。</p>\n<p>现在我们假定需要写一个线程池任务调度框架，我们知道JDK自带的线程框架可以创建一个线程池，但是线程池只能传入实现<code>runnable</code>接口或者<code>callable</code>接口的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\">cachedThreadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>那我们要咋样可以让客户端使用的时候无须继承<code>runnable</code>来使用我们的这个框架呢。你可以像springMVC一样使用适配器加注解。也可以提供一个实现<code>Runnable</code>接口的抽象适配器类，让客户端进行一定的配置来将普通的类适配到<code>Runnable</code>。</p>\n<p>关于适配器的使用方面还有很多，比如<code>spring security</code>的<code>WebSecurityConfigurerAdapter</code>和<code>netty</code>中的<code>ChannelInboundHandlerAdapter</code> 对于适配器模式类名一般都以<code>Adapter</code>结尾</p>\n","site":{"data":{}},"excerpt":"<p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>适配器模式包含如下角色：</p>\n<ul>\n<li>Target：目标抽象类</li>\n<li>Adapter：适配器类</li>\n<li>Adaptee：适配者类</li>\n<li>Client：客户类</li>\n</ul>","more":"<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>我们都知道springMVC就用到了适配器模式，那他是怎么适配呢，我们来看看它的源码，首先我们要清楚springMVC的执行原理，它的整个流程我这里就不像述了，说一下关键的部分：</p>\n<ol>\n<li><code>DispatcherServlte</code>会根据配置文件信息注册<code>HandlerAdapter</code>，如果在配置文件中没有配置，那么<code>DispatcherServlte</code>会获取<code>HandlerAdapter</code>的默认配置，如果是读取默认配置的话，<code>DispatcherServlte</code>会读取<code>DispatcherServlte.properties</code>文件,该文件中配置了三种<code>HandlerAdapter</code>：<code>HttpRequestHandlerAdapter</code>，<code>SimpleControllerHandlerAdapter</code>和<code>AnnotationMethodHandlerAdapter</code>。<code>DispatcherServlte</code>会将这三个<code>HandlerAdapter</code>对象存储到它的<code>handlerAdapters</code>这个集合属性中，这样就完成了<code>HandlerAdapter</code>的注册。</li>\n<li><code>DispatcherServlte</code>会根据<code>handlerMapping</code>传过来的<code>controller</code>与已经注册好了的<code>HandlerAdapter</code>一一匹配，看哪一种<code>HandlerAdapter</code>是支持该controller类型的，如果找到了其中一种<code>HandlerAdapter</code>是支持传过来的<code>controller</code>类型，那么该<code>HandlerAdapter</code>会调用自己的handle方法，handle方法运用java的反射机制执行controller的具体方法来获得<code>ModelAndView</code></li>\n</ol>\n<p><code>DispatcherServlte</code>部分源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">FrameworkServlet</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class=\"line\"> \t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doDispatch</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        HttpServletRequest processedRequest = request;</span><br><span class=\"line\">        HandlerExecutionChain mappedHandler = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> multipartRequestParsed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                ModelAndView mv = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                Object dispatchException = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    ......</span><br><span class=\"line\">                    ......</span><br><span class=\"line\"></span><br><span class=\"line\">                    HandlerAdapter ha = <span class=\"keyword\">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class=\"line\">                    ......</span><br><span class=\"line\">                    ......</span><br><span class=\"line\"></span><br><span class=\"line\">                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class=\"line\">                    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception var20) &#123;</span><br><span class=\"line\">                    dispatchException = var20;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable var21) &#123;</span><br><span class=\"line\">\t\t\t\t......</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t......</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception var22) &#123;</span><br><span class=\"line\">               ......</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable var23) &#123;</span><br><span class=\"line\"> \t\t\t  ......</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只放上比较关键的代码，我们可以看到当一个请求进入<code>doDispatch()</code>方法的时候，它先去<code>getHandlerAdapter()</code>中拿到适配器，这就是第二步中根据<code>handlerMapping</code>中的<code>controller</code>找到对应适配器。找到适配器后通过<code>ha.handle(processedRequest, response, mappedHandler.getHandler())</code>执行我们自己的<code>controller</code>，<code>mappedHandler.getHandler()</code>就是我们自己的<code>controller</code>。</p>\n<p>至于<code>handler()</code>如何知道该去执行controller中哪个方法，当然是通过注解去转换对应方法的。因此，这里的适配器模式还不是特别的纯粹，还结合了反射机制。<code>DispatcherServlte</code>属于客户端，我们的<code>Controller</code>属于被适配的类，<code>HandlerAdapter</code>属于适配器。</p>\n<p>现在我们假定需要写一个线程池任务调度框架，我们知道JDK自带的线程框架可以创建一个线程池，但是线程池只能传入实现<code>runnable</code>接口或者<code>callable</code>接口的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\">cachedThreadPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>那我们要咋样可以让客户端使用的时候无须继承<code>runnable</code>来使用我们的这个框架呢。你可以像springMVC一样使用适配器加注解。也可以提供一个实现<code>Runnable</code>接口的抽象适配器类，让客户端进行一定的配置来将普通的类适配到<code>Runnable</code>。</p>\n<p>关于适配器的使用方面还有很多，比如<code>spring security</code>的<code>WebSecurityConfigurerAdapter</code>和<code>netty</code>中的<code>ChannelInboundHandlerAdapter</code> 对于适配器模式类名一般都以<code>Adapter</code>结尾</p>"},{"title":"设计模式——单例模式","date":"2019-08-30T12:06:55.000Z","_content":"\n单例模式 （Singleton Pattern）使用的比较多，比如我们的 controller 和 service 都是单例的，但是其和标准的单例模式是有区别的。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n\n<!--more-->\n\n## 模式结构\n\n单例模式的结构很简单，只涉及到一个单例类，这个单例类的构造方法是私有的，该类自身定义了一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。\n\n## 源码导读\n\n单例模式分为懒汉单例和饿汉单例；饿汉单例代码很简单，顾名思义，饿汉单例就是类初始化的时候就将该单例创建，示例代码如下：\n\n```java\npublic class Singleton {\n\tprivate static final Singleton singleton = new Singleton();\n\t//限制产生多个对象\n\tprivate Singleton(){\t\n\t}\n\t//通过该方法获得实例对象\n\tpublic static Singleton getSingleton(){\n\t\treturn singleton;\n\t}\n\t//类中其他方法，尽量是 static\n\tpublic static void doSomething(){\n\t}\n}\n```\n\n但是懒汉单例就不那么简单了，懒汉单例是在访问这个类的实例的时候先判断这个类的实例是否创建好了，如果没创建好就要先创建这个单例。也就是说懒汉单例是第一次访问的的时候创建单例，而不是初始化阶段。这将会导致一个问题，如果在多线程场景下，多个线程同时访问这个单例都发现其未被创建，那么这些线程就会分别创建实例，那么这个单例模式就不那么单例了——实例被多次创建。在阿里开发手册中有两条就是和懒汉单例相关的，告诉我们要如何去避免这种情况，第六节的第一条 和第十二条：\n\n> (六)并发处理\n>\n> 1.【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 \n>\n> 说明：资源驱动类、工具类、单例工厂类都需要注意。 \n>\n> 12. 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优 \n>\n> 化问题隐患(可参考 The \"Double-Checked Locking is Broken\" Declaration)，推荐解 \n>\n> 决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。 \n>\n> 反例： \n>\n> ```java\n> class Singleton {  \n> \tprivate Helper helper = null;  \n> \tpublic Helper getHelper() {  \n> \t\tif (helper == null) synchronized(this) {  \n> \t\t\tif (helper == null)  \n> \t\t\thelper = new Helper();  \n> \t\t}  \n> \t\treturn helper;  \n> \t}  \n> // other methods and fields...  \n> \n> } \n> ```\n\n`volatile `关键字的作用和双重检查锁在我以往的博客中介绍过，文章地址`https://mp.weixin.qq.com/s/r52hmD71TtiJjlOzQUvRlA` 这篇博客介绍了并发的一些知识，小伙伴有空可以读一读。在这里 `volatile`  关键字的作用就是保证数据的可见性，双重检查锁是提高代码性能。下面我们分析一下手册中的反例：\n\n其中它的双重检测锁指的是这段代码：\n\n```java\nif (helper == null) synchronized(this) {  \n\t\t\tif (helper == null)  \n\t\t\thelper = new Helper();  \n\t\t}  \n```\n\n这里如果不用双重检测锁的话只能在整个` getHelper` 方法上上锁，因为这个方法必须要保证在并发情况下只有一个线程会执行`helper = new Helper(); `，这段代码。也就是说代码 会成为这样：\n\n```java\npublic synchronized Helper getHelper() {  \n\t\tif (helper == null)  {  \n\t\t\tif (helper == null)  \n\t\t\thelper = new Helper();  \n\t\t}  \n\t\treturn helper;  \n}  \n```\n\n整个方法上锁性能明显是不好的，锁的粒度变大了；双重检查锁里面为什么要做两次 if 判断呢，这个问题留给读者思考，并不是特别难的问题。但是反例里面没有考虑到可见性的问题——假设a线程和b线程同时访问 `getHelper` 方法，然后 b 线程被阻塞住，a线程发现`helper` 未被实例化，于是执行new方法，然后释放锁；此时b线程进来，或许我们直观的感受是b线程发现属性被实例化直接返回`helper`，但实际上不是，当一个线程修改了线程共享的公共资源的时候（此处是helper属性）其他线程未必会被通知到属性被修改，因此b线程有可能发现 `helper` 还是null 也有可能b线程知道 helper 被赋值了。使用`volatile` 就可以避免这种情况的发生。因此正确的代码应该是这样的：\n\n```java\nclass Singleton {  \n\tprivate volatile Helper helper = null;  \n\tpublic Helper getHelper() {  \n\t\t······\n\t}  \n// other methods and fields...  \n} \n```\n\n## 扩展\n\n单例模式到这里算是讲完了，我再扩展一下单例相关的知识点——问：service 和 controller 都是单例的，它们的代码也没有锁相关的东西，为什么是线程安全的？\n\n如果你jvm模型理解的还算透彻的话，这个问题就很好回答。通俗的说就是 service 或者 controller 里面都是方法，没有基本数据类型和字符串这样的属性。用专业术语回答就是：它们都是无状态的bean。其实bean的概念是在ejb规范里面提出来的，后面就被沿用了。感兴趣的小伙伴可以去查查资料，了解一下ejb规范里面的三种类型的bean。这里说一下什么是无状态的bean，什么是bean的状态。\n\n有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。其中道理相信小伙伴们能想明白，不在再细说。","source":"_posts/design-5.md","raw":"---\n\n\ntitle: 设计模式——单例模式\ndate: 2019-08-30 20:06:55\ntags: 设计模式\n---\n\n单例模式 （Singleton Pattern）使用的比较多，比如我们的 controller 和 service 都是单例的，但是其和标准的单例模式是有区别的。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n\n<!--more-->\n\n## 模式结构\n\n单例模式的结构很简单，只涉及到一个单例类，这个单例类的构造方法是私有的，该类自身定义了一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。\n\n## 源码导读\n\n单例模式分为懒汉单例和饿汉单例；饿汉单例代码很简单，顾名思义，饿汉单例就是类初始化的时候就将该单例创建，示例代码如下：\n\n```java\npublic class Singleton {\n\tprivate static final Singleton singleton = new Singleton();\n\t//限制产生多个对象\n\tprivate Singleton(){\t\n\t}\n\t//通过该方法获得实例对象\n\tpublic static Singleton getSingleton(){\n\t\treturn singleton;\n\t}\n\t//类中其他方法，尽量是 static\n\tpublic static void doSomething(){\n\t}\n}\n```\n\n但是懒汉单例就不那么简单了，懒汉单例是在访问这个类的实例的时候先判断这个类的实例是否创建好了，如果没创建好就要先创建这个单例。也就是说懒汉单例是第一次访问的的时候创建单例，而不是初始化阶段。这将会导致一个问题，如果在多线程场景下，多个线程同时访问这个单例都发现其未被创建，那么这些线程就会分别创建实例，那么这个单例模式就不那么单例了——实例被多次创建。在阿里开发手册中有两条就是和懒汉单例相关的，告诉我们要如何去避免这种情况，第六节的第一条 和第十二条：\n\n> (六)并发处理\n>\n> 1.【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 \n>\n> 说明：资源驱动类、工具类、单例工厂类都需要注意。 \n>\n> 12. 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优 \n>\n> 化问题隐患(可参考 The \"Double-Checked Locking is Broken\" Declaration)，推荐解 \n>\n> 决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。 \n>\n> 反例： \n>\n> ```java\n> class Singleton {  \n> \tprivate Helper helper = null;  \n> \tpublic Helper getHelper() {  \n> \t\tif (helper == null) synchronized(this) {  \n> \t\t\tif (helper == null)  \n> \t\t\thelper = new Helper();  \n> \t\t}  \n> \t\treturn helper;  \n> \t}  \n> // other methods and fields...  \n> \n> } \n> ```\n\n`volatile `关键字的作用和双重检查锁在我以往的博客中介绍过，文章地址`https://mp.weixin.qq.com/s/r52hmD71TtiJjlOzQUvRlA` 这篇博客介绍了并发的一些知识，小伙伴有空可以读一读。在这里 `volatile`  关键字的作用就是保证数据的可见性，双重检查锁是提高代码性能。下面我们分析一下手册中的反例：\n\n其中它的双重检测锁指的是这段代码：\n\n```java\nif (helper == null) synchronized(this) {  \n\t\t\tif (helper == null)  \n\t\t\thelper = new Helper();  \n\t\t}  \n```\n\n这里如果不用双重检测锁的话只能在整个` getHelper` 方法上上锁，因为这个方法必须要保证在并发情况下只有一个线程会执行`helper = new Helper(); `，这段代码。也就是说代码 会成为这样：\n\n```java\npublic synchronized Helper getHelper() {  \n\t\tif (helper == null)  {  \n\t\t\tif (helper == null)  \n\t\t\thelper = new Helper();  \n\t\t}  \n\t\treturn helper;  \n}  \n```\n\n整个方法上锁性能明显是不好的，锁的粒度变大了；双重检查锁里面为什么要做两次 if 判断呢，这个问题留给读者思考，并不是特别难的问题。但是反例里面没有考虑到可见性的问题——假设a线程和b线程同时访问 `getHelper` 方法，然后 b 线程被阻塞住，a线程发现`helper` 未被实例化，于是执行new方法，然后释放锁；此时b线程进来，或许我们直观的感受是b线程发现属性被实例化直接返回`helper`，但实际上不是，当一个线程修改了线程共享的公共资源的时候（此处是helper属性）其他线程未必会被通知到属性被修改，因此b线程有可能发现 `helper` 还是null 也有可能b线程知道 helper 被赋值了。使用`volatile` 就可以避免这种情况的发生。因此正确的代码应该是这样的：\n\n```java\nclass Singleton {  \n\tprivate volatile Helper helper = null;  \n\tpublic Helper getHelper() {  \n\t\t······\n\t}  \n// other methods and fields...  \n} \n```\n\n## 扩展\n\n单例模式到这里算是讲完了，我再扩展一下单例相关的知识点——问：service 和 controller 都是单例的，它们的代码也没有锁相关的东西，为什么是线程安全的？\n\n如果你jvm模型理解的还算透彻的话，这个问题就很好回答。通俗的说就是 service 或者 controller 里面都是方法，没有基本数据类型和字符串这样的属性。用专业术语回答就是：它们都是无状态的bean。其实bean的概念是在ejb规范里面提出来的，后面就被沿用了。感兴趣的小伙伴可以去查查资料，了解一下ejb规范里面的三种类型的bean。这里说一下什么是无状态的bean，什么是bean的状态。\n\n有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。其中道理相信小伙伴们能想明白，不在再细说。","slug":"design-5","published":1,"updated":"2021-01-11T07:31:23.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5r000l00wihuj30ltr","content":"<p>单例模式 （Singleton Pattern）使用的比较多，比如我们的 controller 和 service 都是单例的，但是其和标准的单例模式是有区别的。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>单例模式的结构很简单，只涉及到一个单例类，这个单例类的构造方法是私有的，该类自身定义了一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>单例模式分为懒汉单例和饿汉单例；饿汉单例代码很简单，顾名思义，饿汉单例就是类初始化的时候就将该单例创建，示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">\t<span class=\"comment\">//限制产生多个对象</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//通过该方法获得实例对象</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//类中其他方法，尽量是 static</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是懒汉单例就不那么简单了，懒汉单例是在访问这个类的实例的时候先判断这个类的实例是否创建好了，如果没创建好就要先创建这个单例。也就是说懒汉单例是第一次访问的的时候创建单例，而不是初始化阶段。这将会导致一个问题，如果在多线程场景下，多个线程同时访问这个单例都发现其未被创建，那么这些线程就会分别创建实例，那么这个单例模式就不那么单例了——实例被多次创建。在阿里开发手册中有两条就是和懒汉单例相关的，告诉我们要如何去避免这种情况，第六节的第一条 和第十二条：</p>\n<blockquote>\n<p>(六)并发处理</p>\n<p>1.【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 </p>\n<p>说明：资源驱动类、工具类、单例工厂类都需要注意。 </p>\n<ol start=\"12\">\n<li>【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优 </li>\n</ol>\n<p>化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐解 </p>\n<p>决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。 </p>\n<p>反例： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Helper helper = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Helper <span class=\"title\">getHelper</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>) <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">\t\t\thelper = <span class=\"keyword\">new</span> Helper();  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> helper;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"><span class=\"comment\">// other methods and fields...  </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p><code>volatile</code>关键字的作用和双重检查锁在我以往的博客中介绍过，文章地址<code>https://mp.weixin.qq.com/s/r52hmD71TtiJjlOzQUvRlA</code> 这篇博客介绍了并发的一些知识，小伙伴有空可以读一读。在这里 <code>volatile</code>  关键字的作用就是保证数据的可见性，双重检查锁是提高代码性能。下面我们分析一下手册中的反例：</p>\n</blockquote>\n<p>其中它的双重检测锁指的是这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>) <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">\t\t\thelper = <span class=\"keyword\">new</span> Helper();  </span><br><span class=\"line\">\t\t&#125;  </span><br></pre></td></tr></table></figure>\n<p>这里如果不用双重检测锁的话只能在整个<code>getHelper</code> 方法上上锁，因为这个方法必须要保证在并发情况下只有一个线程会执行<code>helper = new Helper();</code>，这段代码。也就是说代码 会成为这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Helper <span class=\"title\">getHelper</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>)  &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">\t\t\thelper = <span class=\"keyword\">new</span> Helper();  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> helper;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>整个方法上锁性能明显是不好的，锁的粒度变大了；双重检查锁里面为什么要做两次 if 判断呢，这个问题留给读者思考，并不是特别难的问题。但是反例里面没有考虑到可见性的问题——假设a线程和b线程同时访问 <code>getHelper</code> 方法，然后 b 线程被阻塞住，a线程发现<code>helper</code> 未被实例化，于是执行new方法，然后释放锁；此时b线程进来，或许我们直观的感受是b线程发现属性被实例化直接返回<code>helper</code>，但实际上不是，当一个线程修改了线程共享的公共资源的时候（此处是helper属性）其他线程未必会被通知到属性被修改，因此b线程有可能发现 <code>helper</code> 还是null 也有可能b线程知道 helper 被赋值了。使用<code>volatile</code> 就可以避免这种情况的发生。因此正确的代码应该是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Helper helper = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Helper <span class=\"title\">getHelper</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">\t\t······</span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"><span class=\"comment\">// other methods and fields...  </span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>单例模式到这里算是讲完了，我再扩展一下单例相关的知识点——问：service 和 controller 都是单例的，它们的代码也没有锁相关的东西，为什么是线程安全的？</p>\n<p>如果你jvm模型理解的还算透彻的话，这个问题就很好回答。通俗的说就是 service 或者 controller 里面都是方法，没有基本数据类型和字符串这样的属性。用专业术语回答就是：它们都是无状态的bean。其实bean的概念是在ejb规范里面提出来的，后面就被沿用了。感兴趣的小伙伴可以去查查资料，了解一下ejb规范里面的三种类型的bean。这里说一下什么是无状态的bean，什么是bean的状态。</p>\n<p>有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。其中道理相信小伙伴们能想明白，不在再细说。</p>\n","site":{"data":{}},"excerpt":"<p>单例模式 （Singleton Pattern）使用的比较多，比如我们的 controller 和 service 都是单例的，但是其和标准的单例模式是有区别的。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>","more":"<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>单例模式的结构很简单，只涉及到一个单例类，这个单例类的构造方法是私有的，该类自身定义了一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>单例模式分为懒汉单例和饿汉单例；饿汉单例代码很简单，顾名思义，饿汉单例就是类初始化的时候就将该单例创建，示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">\t<span class=\"comment\">//限制产生多个对象</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//通过该方法获得实例对象</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//类中其他方法，尽量是 static</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是懒汉单例就不那么简单了，懒汉单例是在访问这个类的实例的时候先判断这个类的实例是否创建好了，如果没创建好就要先创建这个单例。也就是说懒汉单例是第一次访问的的时候创建单例，而不是初始化阶段。这将会导致一个问题，如果在多线程场景下，多个线程同时访问这个单例都发现其未被创建，那么这些线程就会分别创建实例，那么这个单例模式就不那么单例了——实例被多次创建。在阿里开发手册中有两条就是和懒汉单例相关的，告诉我们要如何去避免这种情况，第六节的第一条 和第十二条：</p>\n<blockquote>\n<p>(六)并发处理</p>\n<p>1.【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 </p>\n<p>说明：资源驱动类、工具类、单例工厂类都需要注意。 </p>\n<ol start=\"12\">\n<li>【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优 </li>\n</ol>\n<p>化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐解 </p>\n<p>决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。 </p>\n<p>反例： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Helper helper = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Helper <span class=\"title\">getHelper</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>) <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">\t\t\thelper = <span class=\"keyword\">new</span> Helper();  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> helper;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"><span class=\"comment\">// other methods and fields...  </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p><code>volatile</code>关键字的作用和双重检查锁在我以往的博客中介绍过，文章地址<code>https://mp.weixin.qq.com/s/r52hmD71TtiJjlOzQUvRlA</code> 这篇博客介绍了并发的一些知识，小伙伴有空可以读一读。在这里 <code>volatile</code>  关键字的作用就是保证数据的可见性，双重检查锁是提高代码性能。下面我们分析一下手册中的反例：</p>\n</blockquote>\n<p>其中它的双重检测锁指的是这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>) <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">\t\t\thelper = <span class=\"keyword\">new</span> Helper();  </span><br><span class=\"line\">\t\t&#125;  </span><br></pre></td></tr></table></figure>\n<p>这里如果不用双重检测锁的话只能在整个<code>getHelper</code> 方法上上锁，因为这个方法必须要保证在并发情况下只有一个线程会执行<code>helper = new Helper();</code>，这段代码。也就是说代码 会成为这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Helper <span class=\"title\">getHelper</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>)  &#123;  </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (helper == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">\t\t\thelper = <span class=\"keyword\">new</span> Helper();  </span><br><span class=\"line\">\t\t&#125;  </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> helper;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>整个方法上锁性能明显是不好的，锁的粒度变大了；双重检查锁里面为什么要做两次 if 判断呢，这个问题留给读者思考，并不是特别难的问题。但是反例里面没有考虑到可见性的问题——假设a线程和b线程同时访问 <code>getHelper</code> 方法，然后 b 线程被阻塞住，a线程发现<code>helper</code> 未被实例化，于是执行new方法，然后释放锁；此时b线程进来，或许我们直观的感受是b线程发现属性被实例化直接返回<code>helper</code>，但实际上不是，当一个线程修改了线程共享的公共资源的时候（此处是helper属性）其他线程未必会被通知到属性被修改，因此b线程有可能发现 <code>helper</code> 还是null 也有可能b线程知道 helper 被赋值了。使用<code>volatile</code> 就可以避免这种情况的发生。因此正确的代码应该是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Helper helper = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Helper <span class=\"title\">getHelper</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">\t\t······</span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\"><span class=\"comment\">// other methods and fields...  </span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>单例模式到这里算是讲完了，我再扩展一下单例相关的知识点——问：service 和 controller 都是单例的，它们的代码也没有锁相关的东西，为什么是线程安全的？</p>\n<p>如果你jvm模型理解的还算透彻的话，这个问题就很好回答。通俗的说就是 service 或者 controller 里面都是方法，没有基本数据类型和字符串这样的属性。用专业术语回答就是：它们都是无状态的bean。其实bean的概念是在ejb规范里面提出来的，后面就被沿用了。感兴趣的小伙伴可以去查查资料，了解一下ejb规范里面的三种类型的bean。这里说一下什么是无状态的bean，什么是bean的状态。</p>\n<p>有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。其中道理相信小伙伴们能想明白，不在再细说。</p>"},{"title":"设计模式—门面模式","date":"2020-02-02T09:29:30.000Z","_content":"\n门面（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。\n\n门面模式又被称作外观模式，这个模式特点很鲜明，在生活中我们就能找到不少例子。比如110，我们生活中遇到困难或者危险等一系列问题，我们都是直接打110找警察同志，然后由公安局统一处理，对应不同的情况再细化到公安的各个部门去处理。\n\n<!--more-->\n\n## 模式结构\n\n门面模式是“迪米特法则”的应用，它的优点：\n\n1. 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。\n2. 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。\n3. 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。\n\n门面模式的缺点：\n\n1. 不能很好地限制客户使用子系统类。\n2. 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。\n\n它的结构如下：\n\n1. 外观（Facade）角色：为多个子系统对外提供一个共同的接口。\n2. 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。\n3. 客户端：通过一个外观角色访问各个子系统的功能。\n\n## 源码导读\n\n在 `servlet` 中 `httprequest` 使用的便是门面模式；我们想要 获得请求信息或者是使用请求的一些功能的时候，我们只需要找`HttpServletRequest` 这个接口就行，这个接口提供了获取请求头信息，请求方式，Context等信息：\n\n```\npublic interface HttpServletRequest extends ServletRequest {\n    String BASIC_AUTH = \"BASIC\";\n    String FORM_AUTH = \"FORM\";\n    String CLIENT_CERT_AUTH = \"CLIENT_CERT\";\n    String DIGEST_AUTH = \"DIGEST\";\n\n    String getAuthType();\n\n    Cookie[] getCookies();\n\n    long getDateHeader(String var1);\n\n    String getHeader(String var1);\n\n    Enumeration getHeaders(String var1);\n\n    Enumeration getHeaderNames();\n\n    int getIntHeader(String var1);\n\n    String getMethod();\n\n    String getPathInfo();\n\n    String getPathTranslated();\n\n    String getContextPath();\n\n    String getQueryString();\n\n    String getRemoteUser();\n\n    boolean isUserInRole(String var1);\n\n    Principal getUserPrincipal();\n\n    String getRequestedSessionId();\n\n    String getRequestURI();\n\n    StringBuffer getRequestURL();\n\n    String getServletPath();\n\n    HttpSession getSession(boolean var1);\n\n    HttpSession getSession();\n\n    boolean isRequestedSessionIdValid();\n\n    boolean isRequestedSessionIdFromCookie();\n\n    boolean isRequestedSessionIdFromURL();\n\n    /** @deprecated */\n    boolean isRequestedSessionIdFromUrl();\n}\n```\n\n而其实现类 `RequestFacade` 就是web封装的门面实现类：\n\n```\npublic class RequestFacade implements HttpServletRequest {\n     protected Request request = null;\n    protected static final StringManager sm = StringManager.getManager(RequestFacade.class);\n    ...\n}\n```\n\n当我们想要请求信息的时候就不必在取找其他类，第一时间想到的是从 `HttpServletRequest` 中获取。\n\n外观模式的使用场景：\n\n- 分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。\n- 外观模式可以屏蔽系统的复杂性，对外提供统一接口。\n- 当客户端依赖多个子系统时，提供一个门面可分离这种依赖性。","source":"_posts/design-6.md","raw":"---\ntitle: 设计模式—门面模式\ndate: 2020-02-02 17:29:30\ntags: 设计模式\n---\n\n门面（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。\n\n门面模式又被称作外观模式，这个模式特点很鲜明，在生活中我们就能找到不少例子。比如110，我们生活中遇到困难或者危险等一系列问题，我们都是直接打110找警察同志，然后由公安局统一处理，对应不同的情况再细化到公安的各个部门去处理。\n\n<!--more-->\n\n## 模式结构\n\n门面模式是“迪米特法则”的应用，它的优点：\n\n1. 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。\n2. 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。\n3. 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。\n\n门面模式的缺点：\n\n1. 不能很好地限制客户使用子系统类。\n2. 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。\n\n它的结构如下：\n\n1. 外观（Facade）角色：为多个子系统对外提供一个共同的接口。\n2. 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。\n3. 客户端：通过一个外观角色访问各个子系统的功能。\n\n## 源码导读\n\n在 `servlet` 中 `httprequest` 使用的便是门面模式；我们想要 获得请求信息或者是使用请求的一些功能的时候，我们只需要找`HttpServletRequest` 这个接口就行，这个接口提供了获取请求头信息，请求方式，Context等信息：\n\n```\npublic interface HttpServletRequest extends ServletRequest {\n    String BASIC_AUTH = \"BASIC\";\n    String FORM_AUTH = \"FORM\";\n    String CLIENT_CERT_AUTH = \"CLIENT_CERT\";\n    String DIGEST_AUTH = \"DIGEST\";\n\n    String getAuthType();\n\n    Cookie[] getCookies();\n\n    long getDateHeader(String var1);\n\n    String getHeader(String var1);\n\n    Enumeration getHeaders(String var1);\n\n    Enumeration getHeaderNames();\n\n    int getIntHeader(String var1);\n\n    String getMethod();\n\n    String getPathInfo();\n\n    String getPathTranslated();\n\n    String getContextPath();\n\n    String getQueryString();\n\n    String getRemoteUser();\n\n    boolean isUserInRole(String var1);\n\n    Principal getUserPrincipal();\n\n    String getRequestedSessionId();\n\n    String getRequestURI();\n\n    StringBuffer getRequestURL();\n\n    String getServletPath();\n\n    HttpSession getSession(boolean var1);\n\n    HttpSession getSession();\n\n    boolean isRequestedSessionIdValid();\n\n    boolean isRequestedSessionIdFromCookie();\n\n    boolean isRequestedSessionIdFromURL();\n\n    /** @deprecated */\n    boolean isRequestedSessionIdFromUrl();\n}\n```\n\n而其实现类 `RequestFacade` 就是web封装的门面实现类：\n\n```\npublic class RequestFacade implements HttpServletRequest {\n     protected Request request = null;\n    protected static final StringManager sm = StringManager.getManager(RequestFacade.class);\n    ...\n}\n```\n\n当我们想要请求信息的时候就不必在取找其他类，第一时间想到的是从 `HttpServletRequest` 中获取。\n\n外观模式的使用场景：\n\n- 分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。\n- 外观模式可以屏蔽系统的复杂性，对外提供统一接口。\n- 当客户端依赖多个子系统时，提供一个门面可分离这种依赖性。","slug":"design-6","published":1,"updated":"2021-01-11T07:31:23.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5r000m00wi7ut5fmhm","content":"<p>门面（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>\n<p>门面模式又被称作外观模式，这个模式特点很鲜明，在生活中我们就能找到不少例子。比如110，我们生活中遇到困难或者危险等一系列问题，我们都是直接打110找警察同志，然后由公安局统一处理，对应不同的情况再细化到公安的各个部门去处理。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>门面模式是“迪米特法则”的应用，它的优点：</p>\n<ol>\n<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>\n<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>\n<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>\n</ol>\n<p>门面模式的缺点：</p>\n<ol>\n<li>不能很好地限制客户使用子系统类。</li>\n<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>\n</ol>\n<p>它的结构如下：</p>\n<ol>\n<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>\n<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>\n<li>客户端：通过一个外观角色访问各个子系统的功能。</li>\n</ol>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>在 <code>servlet</code> 中 <code>httprequest</code> 使用的便是门面模式；我们想要 获得请求信息或者是使用请求的一些功能的时候，我们只需要找<code>HttpServletRequest</code> 这个接口就行，这个接口提供了获取请求头信息，请求方式，Context等信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface HttpServletRequest extends ServletRequest &#123;</span><br><span class=\"line\">    String BASIC_AUTH &#x3D; &quot;BASIC&quot;;</span><br><span class=\"line\">    String FORM_AUTH &#x3D; &quot;FORM&quot;;</span><br><span class=\"line\">    String CLIENT_CERT_AUTH &#x3D; &quot;CLIENT_CERT&quot;;</span><br><span class=\"line\">    String DIGEST_AUTH &#x3D; &quot;DIGEST&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String getAuthType();</span><br><span class=\"line\"></span><br><span class=\"line\">    Cookie[] getCookies();</span><br><span class=\"line\"></span><br><span class=\"line\">    long getDateHeader(String var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    String getHeader(String var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    Enumeration getHeaders(String var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    Enumeration getHeaderNames();</span><br><span class=\"line\"></span><br><span class=\"line\">    int getIntHeader(String var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    String getMethod();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getPathInfo();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getPathTranslated();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getContextPath();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getQueryString();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getRemoteUser();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean isUserInRole(String var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    Principal getUserPrincipal();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getRequestedSessionId();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getRequestURI();</span><br><span class=\"line\"></span><br><span class=\"line\">    StringBuffer getRequestURL();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getServletPath();</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpSession getSession(boolean var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpSession getSession();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean isRequestedSessionIdValid();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean isRequestedSessionIdFromCookie();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean isRequestedSessionIdFromURL();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;** @deprecated *&#x2F;</span><br><span class=\"line\">    boolean isRequestedSessionIdFromUrl();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而其实现类 <code>RequestFacade</code> 就是web封装的门面实现类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RequestFacade implements HttpServletRequest &#123;</span><br><span class=\"line\">     protected Request request &#x3D; null;</span><br><span class=\"line\">    protected static final StringManager sm &#x3D; StringManager.getManager(RequestFacade.class);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们想要请求信息的时候就不必在取找其他类，第一时间想到的是从 <code>HttpServletRequest</code> 中获取。</p>\n<p>外观模式的使用场景：</p>\n<ul>\n<li>分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>\n<li>外观模式可以屏蔽系统的复杂性，对外提供统一接口。</li>\n<li>当客户端依赖多个子系统时，提供一个门面可分离这种依赖性。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>门面（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>\n<p>门面模式又被称作外观模式，这个模式特点很鲜明，在生活中我们就能找到不少例子。比如110，我们生活中遇到困难或者危险等一系列问题，我们都是直接打110找警察同志，然后由公安局统一处理，对应不同的情况再细化到公安的各个部门去处理。</p>","more":"<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>门面模式是“迪米特法则”的应用，它的优点：</p>\n<ol>\n<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>\n<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>\n<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>\n</ol>\n<p>门面模式的缺点：</p>\n<ol>\n<li>不能很好地限制客户使用子系统类。</li>\n<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>\n</ol>\n<p>它的结构如下：</p>\n<ol>\n<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>\n<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>\n<li>客户端：通过一个外观角色访问各个子系统的功能。</li>\n</ol>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>在 <code>servlet</code> 中 <code>httprequest</code> 使用的便是门面模式；我们想要 获得请求信息或者是使用请求的一些功能的时候，我们只需要找<code>HttpServletRequest</code> 这个接口就行，这个接口提供了获取请求头信息，请求方式，Context等信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface HttpServletRequest extends ServletRequest &#123;</span><br><span class=\"line\">    String BASIC_AUTH &#x3D; &quot;BASIC&quot;;</span><br><span class=\"line\">    String FORM_AUTH &#x3D; &quot;FORM&quot;;</span><br><span class=\"line\">    String CLIENT_CERT_AUTH &#x3D; &quot;CLIENT_CERT&quot;;</span><br><span class=\"line\">    String DIGEST_AUTH &#x3D; &quot;DIGEST&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String getAuthType();</span><br><span class=\"line\"></span><br><span class=\"line\">    Cookie[] getCookies();</span><br><span class=\"line\"></span><br><span class=\"line\">    long getDateHeader(String var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    String getHeader(String var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    Enumeration getHeaders(String var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    Enumeration getHeaderNames();</span><br><span class=\"line\"></span><br><span class=\"line\">    int getIntHeader(String var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    String getMethod();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getPathInfo();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getPathTranslated();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getContextPath();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getQueryString();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getRemoteUser();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean isUserInRole(String var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    Principal getUserPrincipal();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getRequestedSessionId();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getRequestURI();</span><br><span class=\"line\"></span><br><span class=\"line\">    StringBuffer getRequestURL();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getServletPath();</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpSession getSession(boolean var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    HttpSession getSession();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean isRequestedSessionIdValid();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean isRequestedSessionIdFromCookie();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean isRequestedSessionIdFromURL();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;** @deprecated *&#x2F;</span><br><span class=\"line\">    boolean isRequestedSessionIdFromUrl();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而其实现类 <code>RequestFacade</code> 就是web封装的门面实现类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RequestFacade implements HttpServletRequest &#123;</span><br><span class=\"line\">     protected Request request &#x3D; null;</span><br><span class=\"line\">    protected static final StringManager sm &#x3D; StringManager.getManager(RequestFacade.class);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们想要请求信息的时候就不必在取找其他类，第一时间想到的是从 <code>HttpServletRequest</code> 中获取。</p>\n<p>外观模式的使用场景：</p>\n<ul>\n<li>分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>\n<li>外观模式可以屏蔽系统的复杂性，对外提供统一接口。</li>\n<li>当客户端依赖多个子系统时，提供一个门面可分离这种依赖性。</li>\n</ul>"},{"title":"设计模式—建造者模式(Builder)","date":"2020-02-02T09:31:32.000Z","_content":"\n建造者模式(Builder)是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。我们获得一个对象的时候不是直接new这个对象出来，而是对其建造者进行属性设置，然后建造者在根据设置建造出各个对象出来。建造者模式又可以称为生成器模式。\n\n<!--more-->\n\n## 模式结构\n\n一个标准的建造者模式包含如下角色：\n\n- Builder：抽象建造者\n- ConcreteBuilder：具体建造者\n- Director：指挥者\n- Product：产品角色\n\n## 源码导读\n\n建造者模式使用比较简单，场景也比较清晰。protobuf中protobuf对应的java类就是使用建造者模式来创建对象的。\n\n```\npublic static PersonEntity.Person create() {    PersonEntity.Person person = PersonEntity.Person.newBuilder()            .setId(1)            .setName(\"Pushy\")            .setEmail(\"1437876073@qq.com\")            .build();    System.out.println(person);    return person;}\n```\n\n一般建造者模式结合**链式编程**来使用，代码上更加美观。\n\n```\nspring security`中也有使用到建造者模式，其 `AuthenticationManagerBuilder`是 `AuthenticationManager`的建造者，我们可以通过配置 `AuthenticationManagerBuilder`来建造一个 `AuthenticationManager\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);    }}\n```\n\n我们来看看 `AuthenticationManagerBuilder`\n\n```\npublic class AuthenticationManagerBuilder extends AbstractConfiguredSecurityBuilder<AuthenticationManager, AuthenticationManagerBuilder> implements ProviderManagerBuilder<AuthenticationManagerBuilder> {    ......    ......     public final AuthenticationManager build() throws Exception {        if (this.building.compareAndSet(false, true)) {            this.object = this.doBuild();            return this.object;        } else {            throw new AlreadyBuiltException(\"This object has already been built\");        }    }}\n```\n\n这里抽象建造者是 `ProviderManagerBuilder`，具体建造者是 `AuthenticationManagerBuilder`，被建造的对象是 `AuthenticationManager` 建造方法是 `build()`方法。\n\n一般建造者模式中建造者类命名以 `builder`结尾，而建造方法命名为 `build()`。\n\nlombok中@builder就是对实体类使用创造者模式，如果你项目中用到了lombok那么使用建造者模式就很方便，一个注解搞定。","source":"_posts/design-7.md","raw":"---\ntitle: 设计模式—建造者模式(Builder)\ndate: 2020-02-02 17:31:32\ntags: 设计模式\n---\n\n建造者模式(Builder)是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。我们获得一个对象的时候不是直接new这个对象出来，而是对其建造者进行属性设置，然后建造者在根据设置建造出各个对象出来。建造者模式又可以称为生成器模式。\n\n<!--more-->\n\n## 模式结构\n\n一个标准的建造者模式包含如下角色：\n\n- Builder：抽象建造者\n- ConcreteBuilder：具体建造者\n- Director：指挥者\n- Product：产品角色\n\n## 源码导读\n\n建造者模式使用比较简单，场景也比较清晰。protobuf中protobuf对应的java类就是使用建造者模式来创建对象的。\n\n```\npublic static PersonEntity.Person create() {    PersonEntity.Person person = PersonEntity.Person.newBuilder()            .setId(1)            .setName(\"Pushy\")            .setEmail(\"1437876073@qq.com\")            .build();    System.out.println(person);    return person;}\n```\n\n一般建造者模式结合**链式编程**来使用，代码上更加美观。\n\n```\nspring security`中也有使用到建造者模式，其 `AuthenticationManagerBuilder`是 `AuthenticationManager`的建造者，我们可以通过配置 `AuthenticationManagerBuilder`来建造一个 `AuthenticationManager\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);    }}\n```\n\n我们来看看 `AuthenticationManagerBuilder`\n\n```\npublic class AuthenticationManagerBuilder extends AbstractConfiguredSecurityBuilder<AuthenticationManager, AuthenticationManagerBuilder> implements ProviderManagerBuilder<AuthenticationManagerBuilder> {    ......    ......     public final AuthenticationManager build() throws Exception {        if (this.building.compareAndSet(false, true)) {            this.object = this.doBuild();            return this.object;        } else {            throw new AlreadyBuiltException(\"This object has already been built\");        }    }}\n```\n\n这里抽象建造者是 `ProviderManagerBuilder`，具体建造者是 `AuthenticationManagerBuilder`，被建造的对象是 `AuthenticationManager` 建造方法是 `build()`方法。\n\n一般建造者模式中建造者类命名以 `builder`结尾，而建造方法命名为 `build()`。\n\nlombok中@builder就是对实体类使用创造者模式，如果你项目中用到了lombok那么使用建造者模式就很方便，一个注解搞定。","slug":"design-7","published":1,"updated":"2021-01-11T07:31:23.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5u000p00wi57mafomo","content":"<p>建造者模式(Builder)是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。我们获得一个对象的时候不是直接new这个对象出来，而是对其建造者进行属性设置，然后建造者在根据设置建造出各个对象出来。建造者模式又可以称为生成器模式。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>一个标准的建造者模式包含如下角色：</p>\n<ul>\n<li>Builder：抽象建造者</li>\n<li>ConcreteBuilder：具体建造者</li>\n<li>Director：指挥者</li>\n<li>Product：产品角色</li>\n</ul>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>建造者模式使用比较简单，场景也比较清晰。protobuf中protobuf对应的java类就是使用建造者模式来创建对象的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static PersonEntity.Person create() &#123;    PersonEntity.Person person &#x3D; PersonEntity.Person.newBuilder()            .setId(1)            .setName(&quot;Pushy&quot;)            .setEmail(&quot;1437876073@qq.com&quot;)            .build();    System.out.println(person);    return person;&#125;</span><br></pre></td></tr></table></figure>\n<p>一般建造者模式结合<strong>链式编程</strong>来使用，代码上更加美观。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring security&#96;中也有使用到建造者模式，其 &#96;AuthenticationManagerBuilder&#96;是 &#96;AuthenticationManager&#96;的建造者，我们可以通过配置 &#96;AuthenticationManagerBuilder&#96;来建造一个 &#96;AuthenticationManager</span><br><span class=\"line\">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);    &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看看 <code>AuthenticationManagerBuilder</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AuthenticationManagerBuilder extends AbstractConfiguredSecurityBuilder&lt;AuthenticationManager, AuthenticationManagerBuilder&gt; implements ProviderManagerBuilder&lt;AuthenticationManagerBuilder&gt; &#123;    ......    ......     public final AuthenticationManager build() throws Exception &#123;        if (this.building.compareAndSet(false, true)) &#123;            this.object &#x3D; this.doBuild();            return this.object;        &#125; else &#123;            throw new AlreadyBuiltException(&quot;This object has already been built&quot;);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>这里抽象建造者是 <code>ProviderManagerBuilder</code>，具体建造者是 <code>AuthenticationManagerBuilder</code>，被建造的对象是 <code>AuthenticationManager</code> 建造方法是 <code>build()</code>方法。</p>\n<p>一般建造者模式中建造者类命名以 <code>builder</code>结尾，而建造方法命名为 <code>build()</code>。</p>\n<p>lombok中@builder就是对实体类使用创造者模式，如果你项目中用到了lombok那么使用建造者模式就很方便，一个注解搞定。</p>\n","site":{"data":{}},"excerpt":"<p>建造者模式(Builder)是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。我们获得一个对象的时候不是直接new这个对象出来，而是对其建造者进行属性设置，然后建造者在根据设置建造出各个对象出来。建造者模式又可以称为生成器模式。</p>","more":"<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>一个标准的建造者模式包含如下角色：</p>\n<ul>\n<li>Builder：抽象建造者</li>\n<li>ConcreteBuilder：具体建造者</li>\n<li>Director：指挥者</li>\n<li>Product：产品角色</li>\n</ul>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>建造者模式使用比较简单，场景也比较清晰。protobuf中protobuf对应的java类就是使用建造者模式来创建对象的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static PersonEntity.Person create() &#123;    PersonEntity.Person person &#x3D; PersonEntity.Person.newBuilder()            .setId(1)            .setName(&quot;Pushy&quot;)            .setEmail(&quot;1437876073@qq.com&quot;)            .build();    System.out.println(person);    return person;&#125;</span><br></pre></td></tr></table></figure>\n<p>一般建造者模式结合<strong>链式编程</strong>来使用，代码上更加美观。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring security&#96;中也有使用到建造者模式，其 &#96;AuthenticationManagerBuilder&#96;是 &#96;AuthenticationManager&#96;的建造者，我们可以通过配置 &#96;AuthenticationManagerBuilder&#96;来建造一个 &#96;AuthenticationManager</span><br><span class=\"line\">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);    &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看看 <code>AuthenticationManagerBuilder</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AuthenticationManagerBuilder extends AbstractConfiguredSecurityBuilder&lt;AuthenticationManager, AuthenticationManagerBuilder&gt; implements ProviderManagerBuilder&lt;AuthenticationManagerBuilder&gt; &#123;    ......    ......     public final AuthenticationManager build() throws Exception &#123;        if (this.building.compareAndSet(false, true)) &#123;            this.object &#x3D; this.doBuild();            return this.object;        &#125; else &#123;            throw new AlreadyBuiltException(&quot;This object has already been built&quot;);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>这里抽象建造者是 <code>ProviderManagerBuilder</code>，具体建造者是 <code>AuthenticationManagerBuilder</code>，被建造的对象是 <code>AuthenticationManager</code> 建造方法是 <code>build()</code>方法。</p>\n<p>一般建造者模式中建造者类命名以 <code>builder</code>结尾，而建造方法命名为 <code>build()</code>。</p>\n<p>lombok中@builder就是对实体类使用创造者模式，如果你项目中用到了lombok那么使用建造者模式就很方便，一个注解搞定。</p>"},{"title":"设计模式-装饰器模式（Decorator）","date":"2020-02-02T09:33:29.000Z","_content":"\n装饰器（Decorator）模式指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。采用装饰模式扩展对象的功能比采用继承方式更加灵活；可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。但是装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。\n\n<!--more-->\n\n## 模式结构\n\n装饰器模式的角色如下：\n\n- 顶层接口\n- 被装饰者\n- 装饰器抽象类\n- 装饰器\n\n## 源码导读\n\n装饰器模式使用的典型就是io流了，前面适配器模式我们说到过io流使用了适配器模式，用于字节流转换到字符流；装饰器模式在io流中也是一个很经典的使用。其使用的地方就是给流装饰上缓存。以输入流为例， `BufferedInputStream`就是对 `FileInputStream`的装饰，我们看一下这段代码：\n\n```\nString file = \"out.txt\";        InputStream ins = new FileInputStream(file);     BufferedInputStream bufin= new BufferedInputStream(ins);     int b;     while((b=bufin.read())!=-1){         System.out.println(Integer.toHexString(b));    }\n```\n\n`BufferedInputStream` 源码：\n\n```\npublic class BufferedInputStream extends FilterInputStream {     public BufferedInputStream(InputStream in) {        this(in, DEFAULT_BUFFER_SIZE);    }    ......    public synchronized int read(byte b[], int off, int len) throws IOException{        ......    }}\n```\n\n它继承了 `FilterInputStream`，而 `FilterInputStream` 继承了 `InputStream`， `FileInputStream`也继承了 `InputStream` 。所以这里的角色关系为 `InputStream` 是顶层类（接口）， `FileInputStream` 是被装饰类， `BufferedInputStream` 是装饰类。`BufferedInputStream` 对 `FileInputStream`从 `InputStream`继承过来的方法进行了装饰，这里的。`FilterInputStream`占据的角色是装饰器抽象类，但其并不是个抽象类；这并不影响我们对其模式的理解。","source":"_posts/design-8.md","raw":"---\ntitle: 设计模式-装饰器模式（Decorator）\ndate: 2020-02-02 17:33:29\ntags: 设计模式\n---\n\n装饰器（Decorator）模式指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。采用装饰模式扩展对象的功能比采用继承方式更加灵活；可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。但是装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。\n\n<!--more-->\n\n## 模式结构\n\n装饰器模式的角色如下：\n\n- 顶层接口\n- 被装饰者\n- 装饰器抽象类\n- 装饰器\n\n## 源码导读\n\n装饰器模式使用的典型就是io流了，前面适配器模式我们说到过io流使用了适配器模式，用于字节流转换到字符流；装饰器模式在io流中也是一个很经典的使用。其使用的地方就是给流装饰上缓存。以输入流为例， `BufferedInputStream`就是对 `FileInputStream`的装饰，我们看一下这段代码：\n\n```\nString file = \"out.txt\";        InputStream ins = new FileInputStream(file);     BufferedInputStream bufin= new BufferedInputStream(ins);     int b;     while((b=bufin.read())!=-1){         System.out.println(Integer.toHexString(b));    }\n```\n\n`BufferedInputStream` 源码：\n\n```\npublic class BufferedInputStream extends FilterInputStream {     public BufferedInputStream(InputStream in) {        this(in, DEFAULT_BUFFER_SIZE);    }    ......    public synchronized int read(byte b[], int off, int len) throws IOException{        ......    }}\n```\n\n它继承了 `FilterInputStream`，而 `FilterInputStream` 继承了 `InputStream`， `FileInputStream`也继承了 `InputStream` 。所以这里的角色关系为 `InputStream` 是顶层类（接口）， `FileInputStream` 是被装饰类， `BufferedInputStream` 是装饰类。`BufferedInputStream` 对 `FileInputStream`从 `InputStream`继承过来的方法进行了装饰，这里的。`FilterInputStream`占据的角色是装饰器抽象类，但其并不是个抽象类；这并不影响我们对其模式的理解。","slug":"design-8","published":1,"updated":"2021-01-11T07:31:23.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5u000r00wif744cy8o","content":"<p>装饰器（Decorator）模式指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。采用装饰模式扩展对象的功能比采用继承方式更加灵活；可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。但是装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>装饰器模式的角色如下：</p>\n<ul>\n<li>顶层接口</li>\n<li>被装饰者</li>\n<li>装饰器抽象类</li>\n<li>装饰器</li>\n</ul>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>装饰器模式使用的典型就是io流了，前面适配器模式我们说到过io流使用了适配器模式，用于字节流转换到字符流；装饰器模式在io流中也是一个很经典的使用。其使用的地方就是给流装饰上缓存。以输入流为例， <code>BufferedInputStream</code>就是对 <code>FileInputStream</code>的装饰，我们看一下这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String file &#x3D; &quot;out.txt&quot;;        InputStream ins &#x3D; new FileInputStream(file);     BufferedInputStream bufin&#x3D; new BufferedInputStream(ins);     int b;     while((b&#x3D;bufin.read())!&#x3D;-1)&#123;         System.out.println(Integer.toHexString(b));    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>BufferedInputStream</code> 源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BufferedInputStream extends FilterInputStream &#123;     public BufferedInputStream(InputStream in) &#123;        this(in, DEFAULT_BUFFER_SIZE);    &#125;    ......    public synchronized int read(byte b[], int off, int len) throws IOException&#123;        ......    &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>它继承了 <code>FilterInputStream</code>，而 <code>FilterInputStream</code> 继承了 <code>InputStream</code>， <code>FileInputStream</code>也继承了 <code>InputStream</code> 。所以这里的角色关系为 <code>InputStream</code> 是顶层类（接口）， <code>FileInputStream</code> 是被装饰类， <code>BufferedInputStream</code> 是装饰类。<code>BufferedInputStream</code> 对 <code>FileInputStream</code>从 <code>InputStream</code>继承过来的方法进行了装饰，这里的。<code>FilterInputStream</code>占据的角色是装饰器抽象类，但其并不是个抽象类；这并不影响我们对其模式的理解。</p>\n","site":{"data":{}},"excerpt":"<p>装饰器（Decorator）模式指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。采用装饰模式扩展对象的功能比采用继承方式更加灵活；可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。但是装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>","more":"<h2 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h2><p>装饰器模式的角色如下：</p>\n<ul>\n<li>顶层接口</li>\n<li>被装饰者</li>\n<li>装饰器抽象类</li>\n<li>装饰器</li>\n</ul>\n<h2 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h2><p>装饰器模式使用的典型就是io流了，前面适配器模式我们说到过io流使用了适配器模式，用于字节流转换到字符流；装饰器模式在io流中也是一个很经典的使用。其使用的地方就是给流装饰上缓存。以输入流为例， <code>BufferedInputStream</code>就是对 <code>FileInputStream</code>的装饰，我们看一下这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String file &#x3D; &quot;out.txt&quot;;        InputStream ins &#x3D; new FileInputStream(file);     BufferedInputStream bufin&#x3D; new BufferedInputStream(ins);     int b;     while((b&#x3D;bufin.read())!&#x3D;-1)&#123;         System.out.println(Integer.toHexString(b));    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>BufferedInputStream</code> 源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class BufferedInputStream extends FilterInputStream &#123;     public BufferedInputStream(InputStream in) &#123;        this(in, DEFAULT_BUFFER_SIZE);    &#125;    ......    public synchronized int read(byte b[], int off, int len) throws IOException&#123;        ......    &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>它继承了 <code>FilterInputStream</code>，而 <code>FilterInputStream</code> 继承了 <code>InputStream</code>， <code>FileInputStream</code>也继承了 <code>InputStream</code> 。所以这里的角色关系为 <code>InputStream</code> 是顶层类（接口）， <code>FileInputStream</code> 是被装饰类， <code>BufferedInputStream</code> 是装饰类。<code>BufferedInputStream</code> 对 <code>FileInputStream</code>从 <code>InputStream</code>继承过来的方法进行了装饰，这里的。<code>FilterInputStream</code>占据的角色是装饰器抽象类，但其并不是个抽象类；这并不影响我们对其模式的理解。</p>"},{"title":"设计模式-组合模式（Composite）","date":"2020-02-02T09:34:18.000Z","_content":"\n组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系。组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；\n\n<!--more-->\n\n# 模式结构\n\n- 顶层抽象：树枝或者树叶的抽象接口\n- 树枝：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。\n- 树叶：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件\n\n\n\n# 源码导读\n\n组合模式分为透明模式和安全模式；透明模式是在顶层抽象中声明了所有管理子对象的方法，树叶节点点和树枝节点对于客户端来说没有区别。安全模式是在顶层抽象中只声明叶子和树枝公有的抽象方法，而将对叶子和树枝的管理方法实现到对应的类中，因此客户端就需要区分该节点是树枝还是叶子从而调用对应的方法。\n\n对组合模式来说，List Set等这些集合类属于不那么严格的组合模式。由于没有找到太好的源码，因此我在这里分别对透明模式和安全模式组合说明\n\n透明模式：\n\n```\npublic abstract class Component{\n    private String name;\n    public Component(string name)\n    {\n        this.name = name;\n    }\n\n    public abstract boolean Add(Component component);\n\n    public abstract boolean Remove(Component component);\n\n    public String getName(){\n        return name;\n    }\n}\n\npublic class Branch extend Component{\n    private List<Component> tree=new ArrayList<>();\n\n    public Branch(String name){\n        super(name);\n    }\n\n    public boolean add(Componet component){\n        tree.add(component);\n        return true;\n    }\n\n    public boolean Remove(Component component){\n        tree.remove(component);\n        return true;\n    }\n}\n\npublic class Leaf extend Component{\n\n     public Leaf(String name){\n        super(name);\n    }\n\n     public boolean add(Componet component){\n        return false;\n    }\n\n    public boolean Remove(Component component){\n        return false;\n    }\n\n}\n```\n\n安全模式：\n\n```\npublic abstract class Component{\n    private String name;\n    public Component(string name)\n    {\n        this.name = name;\n    }\n\n    public String getName(){\n        return name;\n    }\n\n\n}\n\npublic class Branch extend Component{\n    private List<Component> tree=new ArrayList<>();\n\n    public Branch(String name){\n        super(name);\n    }\n\n    public boolean add(Componet component){\n        tree.add(component);\n        return true;\n    }\n\n    public boolean Remove(Component component){\n        tree.remove(component);\n        return true;\n    }\n\n    public List<Component> getTree(){\n        return tree;\n    }\n}\n\npublic class Leaf extend Component{\n\n     public Leaf(String name){\n        super(name);\n    }\n\n\n}\n```\n\n组合模式适用的场景为需要表述一个系统（组件）的整体与部分的结构层次的场合；组合模式可对客户端隐藏组合对象和单个对象的不同，以便客户端可以使用用统一的接口使用组合结构中的所有对象，对于该类场合也适用于组合模式","source":"_posts/design-9.md","raw":"---\ntitle: 设计模式-组合模式（Composite）\ndate: 2020-02-02 17:34:18\ntags: 设计模式\n---\n\n组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系。组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；\n\n<!--more-->\n\n# 模式结构\n\n- 顶层抽象：树枝或者树叶的抽象接口\n- 树枝：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。\n- 树叶：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件\n\n\n\n# 源码导读\n\n组合模式分为透明模式和安全模式；透明模式是在顶层抽象中声明了所有管理子对象的方法，树叶节点点和树枝节点对于客户端来说没有区别。安全模式是在顶层抽象中只声明叶子和树枝公有的抽象方法，而将对叶子和树枝的管理方法实现到对应的类中，因此客户端就需要区分该节点是树枝还是叶子从而调用对应的方法。\n\n对组合模式来说，List Set等这些集合类属于不那么严格的组合模式。由于没有找到太好的源码，因此我在这里分别对透明模式和安全模式组合说明\n\n透明模式：\n\n```\npublic abstract class Component{\n    private String name;\n    public Component(string name)\n    {\n        this.name = name;\n    }\n\n    public abstract boolean Add(Component component);\n\n    public abstract boolean Remove(Component component);\n\n    public String getName(){\n        return name;\n    }\n}\n\npublic class Branch extend Component{\n    private List<Component> tree=new ArrayList<>();\n\n    public Branch(String name){\n        super(name);\n    }\n\n    public boolean add(Componet component){\n        tree.add(component);\n        return true;\n    }\n\n    public boolean Remove(Component component){\n        tree.remove(component);\n        return true;\n    }\n}\n\npublic class Leaf extend Component{\n\n     public Leaf(String name){\n        super(name);\n    }\n\n     public boolean add(Componet component){\n        return false;\n    }\n\n    public boolean Remove(Component component){\n        return false;\n    }\n\n}\n```\n\n安全模式：\n\n```\npublic abstract class Component{\n    private String name;\n    public Component(string name)\n    {\n        this.name = name;\n    }\n\n    public String getName(){\n        return name;\n    }\n\n\n}\n\npublic class Branch extend Component{\n    private List<Component> tree=new ArrayList<>();\n\n    public Branch(String name){\n        super(name);\n    }\n\n    public boolean add(Componet component){\n        tree.add(component);\n        return true;\n    }\n\n    public boolean Remove(Component component){\n        tree.remove(component);\n        return true;\n    }\n\n    public List<Component> getTree(){\n        return tree;\n    }\n}\n\npublic class Leaf extend Component{\n\n     public Leaf(String name){\n        super(name);\n    }\n\n\n}\n```\n\n组合模式适用的场景为需要表述一个系统（组件）的整体与部分的结构层次的场合；组合模式可对客户端隐藏组合对象和单个对象的不同，以便客户端可以使用用统一的接口使用组合结构中的所有对象，对于该类场合也适用于组合模式","slug":"design-9","published":1,"updated":"2021-01-11T07:31:23.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5v000u00wi17lv02ct","content":"<p>组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系。组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</p>\n<a id=\"more\"></a>\n\n<h1 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h1><ul>\n<li>顶层抽象：树枝或者树叶的抽象接口</li>\n<li>树枝：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li>\n<li>树叶：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件</li>\n</ul>\n<h1 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h1><p>组合模式分为透明模式和安全模式；透明模式是在顶层抽象中声明了所有管理子对象的方法，树叶节点点和树枝节点对于客户端来说没有区别。安全模式是在顶层抽象中只声明叶子和树枝公有的抽象方法，而将对叶子和树枝的管理方法实现到对应的类中，因此客户端就需要区分该节点是树枝还是叶子从而调用对应的方法。</p>\n<p>对组合模式来说，List Set等这些集合类属于不那么严格的组合模式。由于没有找到太好的源码，因此我在这里分别对透明模式和安全模式组合说明</p>\n<p>透明模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class Component&#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    public Component(string name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.name &#x3D; name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract boolean Add(Component component);</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract boolean Remove(Component component);</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName()&#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Branch extend Component&#123;</span><br><span class=\"line\">    private List&lt;Component&gt; tree&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public Branch(String name)&#123;</span><br><span class=\"line\">        super(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean add(Componet component)&#123;</span><br><span class=\"line\">        tree.add(component);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean Remove(Component component)&#123;</span><br><span class=\"line\">        tree.remove(component);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Leaf extend Component&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     public Leaf(String name)&#123;</span><br><span class=\"line\">        super(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     public boolean add(Componet component)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean Remove(Component component)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>安全模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class Component&#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    public Component(string name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.name &#x3D; name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName()&#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Branch extend Component&#123;</span><br><span class=\"line\">    private List&lt;Component&gt; tree&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public Branch(String name)&#123;</span><br><span class=\"line\">        super(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean add(Componet component)&#123;</span><br><span class=\"line\">        tree.add(component);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean Remove(Component component)&#123;</span><br><span class=\"line\">        tree.remove(component);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Component&gt; getTree()&#123;</span><br><span class=\"line\">        return tree;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Leaf extend Component&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     public Leaf(String name)&#123;</span><br><span class=\"line\">        super(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>组合模式适用的场景为需要表述一个系统（组件）的整体与部分的结构层次的场合；组合模式可对客户端隐藏组合对象和单个对象的不同，以便客户端可以使用用统一的接口使用组合结构中的所有对象，对于该类场合也适用于组合模式</p>\n","site":{"data":{}},"excerpt":"<p>组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系。组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</p>","more":"<h1 id=\"模式结构\"><a href=\"#模式结构\" class=\"headerlink\" title=\"模式结构\"></a>模式结构</h1><ul>\n<li>顶层抽象：树枝或者树叶的抽象接口</li>\n<li>树枝：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li>\n<li>树叶：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件</li>\n</ul>\n<h1 id=\"源码导读\"><a href=\"#源码导读\" class=\"headerlink\" title=\"源码导读\"></a>源码导读</h1><p>组合模式分为透明模式和安全模式；透明模式是在顶层抽象中声明了所有管理子对象的方法，树叶节点点和树枝节点对于客户端来说没有区别。安全模式是在顶层抽象中只声明叶子和树枝公有的抽象方法，而将对叶子和树枝的管理方法实现到对应的类中，因此客户端就需要区分该节点是树枝还是叶子从而调用对应的方法。</p>\n<p>对组合模式来说，List Set等这些集合类属于不那么严格的组合模式。由于没有找到太好的源码，因此我在这里分别对透明模式和安全模式组合说明</p>\n<p>透明模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class Component&#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    public Component(string name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.name &#x3D; name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract boolean Add(Component component);</span><br><span class=\"line\"></span><br><span class=\"line\">    public abstract boolean Remove(Component component);</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName()&#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Branch extend Component&#123;</span><br><span class=\"line\">    private List&lt;Component&gt; tree&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public Branch(String name)&#123;</span><br><span class=\"line\">        super(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean add(Componet component)&#123;</span><br><span class=\"line\">        tree.add(component);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean Remove(Component component)&#123;</span><br><span class=\"line\">        tree.remove(component);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Leaf extend Component&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     public Leaf(String name)&#123;</span><br><span class=\"line\">        super(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     public boolean add(Componet component)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean Remove(Component component)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>安全模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class Component&#123;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    public Component(string name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        this.name &#x3D; name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName()&#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Branch extend Component&#123;</span><br><span class=\"line\">    private List&lt;Component&gt; tree&#x3D;new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public Branch(String name)&#123;</span><br><span class=\"line\">        super(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean add(Componet component)&#123;</span><br><span class=\"line\">        tree.add(component);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean Remove(Component component)&#123;</span><br><span class=\"line\">        tree.remove(component);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;Component&gt; getTree()&#123;</span><br><span class=\"line\">        return tree;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Leaf extend Component&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     public Leaf(String name)&#123;</span><br><span class=\"line\">        super(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>组合模式适用的场景为需要表述一个系统（组件）的整体与部分的结构层次的场合；组合模式可对客户端隐藏组合对象和单个对象的不同，以便客户端可以使用用统一的接口使用组合结构中的所有对象，对于该类场合也适用于组合模式</p>"},{"title":"dubbo学习笔记","date":"2019-04-26T09:29:58.000Z","_content":"\ndubbo 架构介绍\n\n注册中心 服务提供者 消费者 管理者 容器\n\nregistry provider consumer monitor container\n\n<!--more-->\n\n# dubbo 环境搭建 \n\n## 安装zk\n\nconf文件下创建 zoo.cfg\n\n配置dataDir \n\nbin下zkServer zkCli\n\n测试  \n\n```shell\nget / \nls /\ncreate -e /test 123456\nget /test\n```\n\n安装监控中心 下载 <https://github.com/apache/incubator-dubbo-admin/tree/master> 切换到master分支\n\n打 jar包\n\n## 项目构建\n\ndubbo版本问题\n\ndubbo 2.6以前是阿里巴巴 dubbo\n\n因此 dubbo 的dubbo-spring-boot-starter存在两个对应的版本 \n\n官方是这样说的：\n\n> 如果您现在使用的Dubbo版本低于2.7.0，请使用如下对应版本的Dubbo Spring Boot：\n>\n> | Dubbo Spring Boot                                            | Dubbo  | Spring Boot |\n> | ------------------------------------------------------------ | ------ | ----------- |\n> | [0.2.1.RELEASE](https://github.com/apache/incubator-dubbo-spring-boot-project/tree/0.2.x) | 2.6.5+ | 2.x         |\n> | [0.1.2.RELEASE](https://github.com/apache/incubator-dubbo-spring-boot-project/tree/0.1.x) | 2.6.5+ | 1.x         |\n>\n> \n\n其实就是如果用 阿里巴巴dubbo 则需要使用\n\n```xml\n<dependency>\n    <groupId>com.alibaba.boot</groupId>\n    <artifactId>dubbo-spring-boot-starter</artifactId>\n</dependency>\n```\n\n这个starter\n\n如果是 鸟毛dubbo则\n\n```xml\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo-spring-boot-starter</artifactId>\n</dependency>\n```\n\nalibaba 0.2的stater配置\n\n```properties\n#  服务名\ndubbo.application.name=demo-provider\n# 注册中心地址\ndubbo.registry.address=zookeeper://127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20880\ndubbo.provider.timeout=10000\ndubbo.provider.retries=3\ndubbo.provider.delay=-1\nserver.port=8082\n```\n\nalibaba 2的 stater的配置\n\n```properties\nspring.dubbo.application.id=live-dubbo-provider\nspring.dubbo.application.name=live-dubbo-provider\nspring.dubbo.registry.address=zookeeper://127.0.0.1:2181\nspring.dubbo.server=true\nspring.dubbo.protocol.name=dubbo\nspring.dubbo.protocol.port=20880\nserver.port=8081\n```\n\n需要引入zk客户端依赖：com.101tec 和curator-framework\n\n这里不介绍鸟毛的dubbo配置，在nacos整合dubbo中说明\n\n## 监控中心\n\n[dubbo-monitor-simple](https://github.com/apache/incubator-dubbo-admin/tree/master/dubbo-monitor-simple)\n\ndubbo-admin 管理平台 `<http://localhost:7001/governance/services>`\n\n# dubbo架构\n\n[dubbo架构图](<http://dubbo.apache.org/zh-cn/docs/dev/design.html>)\n\ndubbo 绑定端口，通道初始化，注册到选择器上 选择器监听 acccept事件\n\n处理数据 客户端生成channel \n\nbusiness\n\n​\t\t接口\n\nrpc\n\n​\t配置层 收集配置数据\n\n​\t服务代理层 代理调用方法\n\n​\tregistry 注册中心\n\n​\tcluster 路由层 负载均衡层\n\n​\tmoniter 监控层 \n\n​\tprotocol远程调用层\n\n​\t调用层核心  invoker protocol  exporter\n\nremothing 远程通信层 ，架起管道 封装数据。netty框架工作在这\n\nserialize 序列化层\n\n\n\n","source":"_posts/dubbo-1.md","raw":"---\ntitle: dubbo学习笔记\ndate: 2019-04-26 17:29:58\ntags: cloud\n---\n\ndubbo 架构介绍\n\n注册中心 服务提供者 消费者 管理者 容器\n\nregistry provider consumer monitor container\n\n<!--more-->\n\n# dubbo 环境搭建 \n\n## 安装zk\n\nconf文件下创建 zoo.cfg\n\n配置dataDir \n\nbin下zkServer zkCli\n\n测试  \n\n```shell\nget / \nls /\ncreate -e /test 123456\nget /test\n```\n\n安装监控中心 下载 <https://github.com/apache/incubator-dubbo-admin/tree/master> 切换到master分支\n\n打 jar包\n\n## 项目构建\n\ndubbo版本问题\n\ndubbo 2.6以前是阿里巴巴 dubbo\n\n因此 dubbo 的dubbo-spring-boot-starter存在两个对应的版本 \n\n官方是这样说的：\n\n> 如果您现在使用的Dubbo版本低于2.7.0，请使用如下对应版本的Dubbo Spring Boot：\n>\n> | Dubbo Spring Boot                                            | Dubbo  | Spring Boot |\n> | ------------------------------------------------------------ | ------ | ----------- |\n> | [0.2.1.RELEASE](https://github.com/apache/incubator-dubbo-spring-boot-project/tree/0.2.x) | 2.6.5+ | 2.x         |\n> | [0.1.2.RELEASE](https://github.com/apache/incubator-dubbo-spring-boot-project/tree/0.1.x) | 2.6.5+ | 1.x         |\n>\n> \n\n其实就是如果用 阿里巴巴dubbo 则需要使用\n\n```xml\n<dependency>\n    <groupId>com.alibaba.boot</groupId>\n    <artifactId>dubbo-spring-boot-starter</artifactId>\n</dependency>\n```\n\n这个starter\n\n如果是 鸟毛dubbo则\n\n```xml\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo-spring-boot-starter</artifactId>\n</dependency>\n```\n\nalibaba 0.2的stater配置\n\n```properties\n#  服务名\ndubbo.application.name=demo-provider\n# 注册中心地址\ndubbo.registry.address=zookeeper://127.0.0.1:2181\ndubbo.protocol.name=dubbo\ndubbo.protocol.port=20880\ndubbo.provider.timeout=10000\ndubbo.provider.retries=3\ndubbo.provider.delay=-1\nserver.port=8082\n```\n\nalibaba 2的 stater的配置\n\n```properties\nspring.dubbo.application.id=live-dubbo-provider\nspring.dubbo.application.name=live-dubbo-provider\nspring.dubbo.registry.address=zookeeper://127.0.0.1:2181\nspring.dubbo.server=true\nspring.dubbo.protocol.name=dubbo\nspring.dubbo.protocol.port=20880\nserver.port=8081\n```\n\n需要引入zk客户端依赖：com.101tec 和curator-framework\n\n这里不介绍鸟毛的dubbo配置，在nacos整合dubbo中说明\n\n## 监控中心\n\n[dubbo-monitor-simple](https://github.com/apache/incubator-dubbo-admin/tree/master/dubbo-monitor-simple)\n\ndubbo-admin 管理平台 `<http://localhost:7001/governance/services>`\n\n# dubbo架构\n\n[dubbo架构图](<http://dubbo.apache.org/zh-cn/docs/dev/design.html>)\n\ndubbo 绑定端口，通道初始化，注册到选择器上 选择器监听 acccept事件\n\n处理数据 客户端生成channel \n\nbusiness\n\n​\t\t接口\n\nrpc\n\n​\t配置层 收集配置数据\n\n​\t服务代理层 代理调用方法\n\n​\tregistry 注册中心\n\n​\tcluster 路由层 负载均衡层\n\n​\tmoniter 监控层 \n\n​\tprotocol远程调用层\n\n​\t调用层核心  invoker protocol  exporter\n\nremothing 远程通信层 ，架起管道 封装数据。netty框架工作在这\n\nserialize 序列化层\n\n\n\n","slug":"dubbo-1","published":1,"updated":"2021-01-11T07:31:23.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5w000w00wi35r1h4io","content":"<p>dubbo 架构介绍</p>\n<p>注册中心 服务提供者 消费者 管理者 容器</p>\n<p>registry provider consumer monitor container</p>\n<a id=\"more\"></a>\n\n<h1 id=\"dubbo-环境搭建\"><a href=\"#dubbo-环境搭建\" class=\"headerlink\" title=\"dubbo 环境搭建\"></a>dubbo 环境搭建</h1><h2 id=\"安装zk\"><a href=\"#安装zk\" class=\"headerlink\" title=\"安装zk\"></a>安装zk</h2><p>conf文件下创建 zoo.cfg</p>\n<p>配置dataDir </p>\n<p>bin下zkServer zkCli</p>\n<p>测试  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get / </span><br><span class=\"line\">ls /</span><br><span class=\"line\">create -e /test 123456</span><br><span class=\"line\">get /test</span><br></pre></td></tr></table></figure>\n<p>安装监控中心 下载 <a href=\"https://github.com/apache/incubator-dubbo-admin/tree/master\">https://github.com/apache/incubator-dubbo-admin/tree/master</a> 切换到master分支</p>\n<p>打 jar包</p>\n<h2 id=\"项目构建\"><a href=\"#项目构建\" class=\"headerlink\" title=\"项目构建\"></a>项目构建</h2><p>dubbo版本问题</p>\n<p>dubbo 2.6以前是阿里巴巴 dubbo</p>\n<p>因此 dubbo 的dubbo-spring-boot-starter存在两个对应的版本 </p>\n<p>官方是这样说的：</p>\n<blockquote>\n<p>如果您现在使用的Dubbo版本低于2.7.0，请使用如下对应版本的Dubbo Spring Boot：</p>\n<table>\n<thead>\n<tr>\n<th>Dubbo Spring Boot</th>\n<th>Dubbo</th>\n<th>Spring Boot</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://github.com/apache/incubator-dubbo-spring-boot-project/tree/0.2.x\">0.2.1.RELEASE</a></td>\n<td>2.6.5+</td>\n<td>2.x</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/apache/incubator-dubbo-spring-boot-project/tree/0.1.x\">0.1.2.RELEASE</a></td>\n<td>2.6.5+</td>\n<td>1.x</td>\n</tr>\n</tbody></table>\n</blockquote>\n<p>其实就是如果用 阿里巴巴dubbo 则需要使用</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这个starter</p>\n<p>如果是 鸟毛dubbo则</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>alibaba 0.2的stater配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  服务名</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">demo-provider</span></span><br><span class=\"line\"><span class=\"comment\"># 注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20880</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.provider.timeout</span>=<span class=\"string\">10000</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.provider.retries</span>=<span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.provider.delay</span>=<span class=\"string\">-1</span></span><br><span class=\"line\"><span class=\"meta\">server.port</span>=<span class=\"string\">8082</span></span><br></pre></td></tr></table></figure>\n<p>alibaba 2的 stater的配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.dubbo.application.id</span>=<span class=\"string\">live-dubbo-provider</span></span><br><span class=\"line\"><span class=\"meta\">spring.dubbo.application.name</span>=<span class=\"string\">live-dubbo-provider</span></span><br><span class=\"line\"><span class=\"meta\">spring.dubbo.registry.address</span>=<span class=\"string\">zookeeper://127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">spring.dubbo.server</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"meta\">spring.dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">spring.dubbo.protocol.port</span>=<span class=\"string\">20880</span></span><br><span class=\"line\"><span class=\"meta\">server.port</span>=<span class=\"string\">8081</span></span><br></pre></td></tr></table></figure>\n<p>需要引入zk客户端依赖：com.101tec 和curator-framework</p>\n<p>这里不介绍鸟毛的dubbo配置，在nacos整合dubbo中说明</p>\n<h2 id=\"监控中心\"><a href=\"#监控中心\" class=\"headerlink\" title=\"监控中心\"></a>监控中心</h2><p><a href=\"https://github.com/apache/incubator-dubbo-admin/tree/master/dubbo-monitor-simple\">dubbo-monitor-simple</a></p>\n<p>dubbo-admin 管理平台 <code>&lt;http://localhost:7001/governance/services&gt;</code></p>\n<h1 id=\"dubbo架构\"><a href=\"#dubbo架构\" class=\"headerlink\" title=\"dubbo架构\"></a>dubbo架构</h1><p><a href=\"http://dubbo.apache.org/zh-cn/docs/dev/design.html\">dubbo架构图</a></p>\n<p>dubbo 绑定端口，通道初始化，注册到选择器上 选择器监听 acccept事件</p>\n<p>处理数据 客户端生成channel </p>\n<p>business</p>\n<p>​        接口</p>\n<p>rpc</p>\n<p>​    配置层 收集配置数据</p>\n<p>​    服务代理层 代理调用方法</p>\n<p>​    registry 注册中心</p>\n<p>​    cluster 路由层 负载均衡层</p>\n<p>​    moniter 监控层 </p>\n<p>​    protocol远程调用层</p>\n<p>​    调用层核心  invoker protocol  exporter</p>\n<p>remothing 远程通信层 ，架起管道 封装数据。netty框架工作在这</p>\n<p>serialize 序列化层</p>\n","site":{"data":{}},"excerpt":"<p>dubbo 架构介绍</p>\n<p>注册中心 服务提供者 消费者 管理者 容器</p>\n<p>registry provider consumer monitor container</p>","more":"<h1 id=\"dubbo-环境搭建\"><a href=\"#dubbo-环境搭建\" class=\"headerlink\" title=\"dubbo 环境搭建\"></a>dubbo 环境搭建</h1><h2 id=\"安装zk\"><a href=\"#安装zk\" class=\"headerlink\" title=\"安装zk\"></a>安装zk</h2><p>conf文件下创建 zoo.cfg</p>\n<p>配置dataDir </p>\n<p>bin下zkServer zkCli</p>\n<p>测试  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get / </span><br><span class=\"line\">ls /</span><br><span class=\"line\">create -e /test 123456</span><br><span class=\"line\">get /test</span><br></pre></td></tr></table></figure>\n<p>安装监控中心 下载 <a href=\"https://github.com/apache/incubator-dubbo-admin/tree/master\">https://github.com/apache/incubator-dubbo-admin/tree/master</a> 切换到master分支</p>\n<p>打 jar包</p>\n<h2 id=\"项目构建\"><a href=\"#项目构建\" class=\"headerlink\" title=\"项目构建\"></a>项目构建</h2><p>dubbo版本问题</p>\n<p>dubbo 2.6以前是阿里巴巴 dubbo</p>\n<p>因此 dubbo 的dubbo-spring-boot-starter存在两个对应的版本 </p>\n<p>官方是这样说的：</p>\n<blockquote>\n<p>如果您现在使用的Dubbo版本低于2.7.0，请使用如下对应版本的Dubbo Spring Boot：</p>\n<table>\n<thead>\n<tr>\n<th>Dubbo Spring Boot</th>\n<th>Dubbo</th>\n<th>Spring Boot</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://github.com/apache/incubator-dubbo-spring-boot-project/tree/0.2.x\">0.2.1.RELEASE</a></td>\n<td>2.6.5+</td>\n<td>2.x</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/apache/incubator-dubbo-spring-boot-project/tree/0.1.x\">0.1.2.RELEASE</a></td>\n<td>2.6.5+</td>\n<td>1.x</td>\n</tr>\n</tbody></table>\n</blockquote>\n<p>其实就是如果用 阿里巴巴dubbo 则需要使用</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这个starter</p>\n<p>如果是 鸟毛dubbo则</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>alibaba 0.2的stater配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  服务名</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.application.name</span>=<span class=\"string\">demo-provider</span></span><br><span class=\"line\"><span class=\"comment\"># 注册中心地址</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.registry.address</span>=<span class=\"string\">zookeeper://127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.protocol.port</span>=<span class=\"string\">20880</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.provider.timeout</span>=<span class=\"string\">10000</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.provider.retries</span>=<span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"meta\">dubbo.provider.delay</span>=<span class=\"string\">-1</span></span><br><span class=\"line\"><span class=\"meta\">server.port</span>=<span class=\"string\">8082</span></span><br></pre></td></tr></table></figure>\n<p>alibaba 2的 stater的配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.dubbo.application.id</span>=<span class=\"string\">live-dubbo-provider</span></span><br><span class=\"line\"><span class=\"meta\">spring.dubbo.application.name</span>=<span class=\"string\">live-dubbo-provider</span></span><br><span class=\"line\"><span class=\"meta\">spring.dubbo.registry.address</span>=<span class=\"string\">zookeeper://127.0.0.1:2181</span></span><br><span class=\"line\"><span class=\"meta\">spring.dubbo.server</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"meta\">spring.dubbo.protocol.name</span>=<span class=\"string\">dubbo</span></span><br><span class=\"line\"><span class=\"meta\">spring.dubbo.protocol.port</span>=<span class=\"string\">20880</span></span><br><span class=\"line\"><span class=\"meta\">server.port</span>=<span class=\"string\">8081</span></span><br></pre></td></tr></table></figure>\n<p>需要引入zk客户端依赖：com.101tec 和curator-framework</p>\n<p>这里不介绍鸟毛的dubbo配置，在nacos整合dubbo中说明</p>\n<h2 id=\"监控中心\"><a href=\"#监控中心\" class=\"headerlink\" title=\"监控中心\"></a>监控中心</h2><p><a href=\"https://github.com/apache/incubator-dubbo-admin/tree/master/dubbo-monitor-simple\">dubbo-monitor-simple</a></p>\n<p>dubbo-admin 管理平台 <code>&lt;http://localhost:7001/governance/services&gt;</code></p>\n<h1 id=\"dubbo架构\"><a href=\"#dubbo架构\" class=\"headerlink\" title=\"dubbo架构\"></a>dubbo架构</h1><p><a href=\"http://dubbo.apache.org/zh-cn/docs/dev/design.html\">dubbo架构图</a></p>\n<p>dubbo 绑定端口，通道初始化，注册到选择器上 选择器监听 acccept事件</p>\n<p>处理数据 客户端生成channel </p>\n<p>business</p>\n<p>​        接口</p>\n<p>rpc</p>\n<p>​    配置层 收集配置数据</p>\n<p>​    服务代理层 代理调用方法</p>\n<p>​    registry 注册中心</p>\n<p>​    cluster 路由层 负载均衡层</p>\n<p>​    moniter 监控层 </p>\n<p>​    protocol远程调用层</p>\n<p>​    调用层核心  invoker protocol  exporter</p>\n<p>remothing 远程通信层 ，架起管道 封装数据。netty框架工作在这</p>\n<p>serialize 序列化层</p>"},{"title":"dubbo运维相关知识","date":"2019-05-27T09:36:27.000Z","_content":"\n**重要**\n\n[架构图](<http://dubbo.apache.org/zh-cn/docs/dev/design.html>)\n\n### 启动时检查\n\nDubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 `check=\"true\"`。\n\n<!--more-->\n\n### 配置方式\n\njava -D 启动时配置》dubbo.xml（application.properties）》dubbo.properties\n\ndubbo.properties\n\n### 配置超时设置。\n\n@reference（timeout ）dubbo.consummer\n\n调用超时抛异常 方法级优先 接口次之，全局次之 级别一样消费方优先，提供方次之。\n\n### 配置重试次数\n\n@reference retries=3\n\n### dubbo 多版本控制\n\n么两边分别在@service @@Reference注解上定义版本号\n\n### 本地存根\n\n远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub [[1\\]](http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn1)，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。\n\n```java\npackage com.foo;\npublic class BarServiceStub implements BarService {\n    private final BarService barService;\n    \n    // 构造函数传入真正的远程代理对象\n    public BarServiceStub(BarService barService){\n        this.barService = barService;\n    }\n \n    public String sayHello(String name) {\n        // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等\n        try {\n            return barService.sayHello(name);\n        } catch (Exception e) {\n            // 你可以容错，可以做任何AOP拦截事项\n            return \"容错数据\";\n        }\n    }\n}\n```\n\n","source":"_posts/dubbo-2.md","raw":"---\ntitle: dubbo运维相关知识\ndate: 2019-05-27 17:36:27\ntags: cloud\n---\n\n**重要**\n\n[架构图](<http://dubbo.apache.org/zh-cn/docs/dev/design.html>)\n\n### 启动时检查\n\nDubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 `check=\"true\"`。\n\n<!--more-->\n\n### 配置方式\n\njava -D 启动时配置》dubbo.xml（application.properties）》dubbo.properties\n\ndubbo.properties\n\n### 配置超时设置。\n\n@reference（timeout ）dubbo.consummer\n\n调用超时抛异常 方法级优先 接口次之，全局次之 级别一样消费方优先，提供方次之。\n\n### 配置重试次数\n\n@reference retries=3\n\n### dubbo 多版本控制\n\n么两边分别在@service @@Reference注解上定义版本号\n\n### 本地存根\n\n远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub [[1\\]](http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn1)，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。\n\n```java\npackage com.foo;\npublic class BarServiceStub implements BarService {\n    private final BarService barService;\n    \n    // 构造函数传入真正的远程代理对象\n    public BarServiceStub(BarService barService){\n        this.barService = barService;\n    }\n \n    public String sayHello(String name) {\n        // 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等\n        try {\n            return barService.sayHello(name);\n        } catch (Exception e) {\n            // 你可以容错，可以做任何AOP拦截事项\n            return \"容错数据\";\n        }\n    }\n}\n```\n\n","slug":"dubbo-2","published":1,"updated":"2021-01-11T07:31:23.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5x000z00wi103xbsdz","content":"<p><strong>重要</strong></p>\n<p><a href=\"http://dubbo.apache.org/zh-cn/docs/dev/design.html\">架构图</a></p>\n<h3 id=\"启动时检查\"><a href=\"#启动时检查\" class=\"headerlink\" title=\"启动时检查\"></a>启动时检查</h3><p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 <code>check=&quot;true&quot;</code>。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"配置方式\"><a href=\"#配置方式\" class=\"headerlink\" title=\"配置方式\"></a>配置方式</h3><p>java -D 启动时配置》dubbo.xml（application.properties）》dubbo.properties</p>\n<p>dubbo.properties</p>\n<h3 id=\"配置超时设置。\"><a href=\"#配置超时设置。\" class=\"headerlink\" title=\"配置超时设置。\"></a>配置超时设置。</h3><p>@reference（timeout ）dubbo.consummer</p>\n<p>调用超时抛异常 方法级优先 接口次之，全局次之 级别一样消费方优先，提供方次之。</p>\n<h3 id=\"配置重试次数\"><a href=\"#配置重试次数\" class=\"headerlink\" title=\"配置重试次数\"></a>配置重试次数</h3><p>@reference retries=3</p>\n<h3 id=\"dubbo-多版本控制\"><a href=\"#dubbo-多版本控制\" class=\"headerlink\" title=\"dubbo 多版本控制\"></a>dubbo 多版本控制</h3><p>么两边分别在@service @@Reference注解上定义版本号</p>\n<h3 id=\"本地存根\"><a href=\"#本地存根\" class=\"headerlink\" title=\"本地存根\"></a>本地存根</h3><p>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub <a href=\"http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn1\">[1]</a>，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.foo;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BarServiceStub</span> <span class=\"keyword\">implements</span> <span class=\"title\">BarService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BarService barService;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造函数传入真正的远程代理对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BarServiceStub</span><span class=\"params\">(BarService barService)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.barService = barService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sayHello</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> barService.sayHello(name);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 你可以容错，可以做任何AOP拦截事项</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;容错数据&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><strong>重要</strong></p>\n<p><a href=\"http://dubbo.apache.org/zh-cn/docs/dev/design.html\">架构图</a></p>\n<h3 id=\"启动时检查\"><a href=\"#启动时检查\" class=\"headerlink\" title=\"启动时检查\"></a>启动时检查</h3><p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 <code>check=&quot;true&quot;</code>。</p>","more":"<h3 id=\"配置方式\"><a href=\"#配置方式\" class=\"headerlink\" title=\"配置方式\"></a>配置方式</h3><p>java -D 启动时配置》dubbo.xml（application.properties）》dubbo.properties</p>\n<p>dubbo.properties</p>\n<h3 id=\"配置超时设置。\"><a href=\"#配置超时设置。\" class=\"headerlink\" title=\"配置超时设置。\"></a>配置超时设置。</h3><p>@reference（timeout ）dubbo.consummer</p>\n<p>调用超时抛异常 方法级优先 接口次之，全局次之 级别一样消费方优先，提供方次之。</p>\n<h3 id=\"配置重试次数\"><a href=\"#配置重试次数\" class=\"headerlink\" title=\"配置重试次数\"></a>配置重试次数</h3><p>@reference retries=3</p>\n<h3 id=\"dubbo-多版本控制\"><a href=\"#dubbo-多版本控制\" class=\"headerlink\" title=\"dubbo 多版本控制\"></a>dubbo 多版本控制</h3><p>么两边分别在@service @@Reference注解上定义版本号</p>\n<h3 id=\"本地存根\"><a href=\"#本地存根\" class=\"headerlink\" title=\"本地存根\"></a>本地存根</h3><p>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 ThreadLocal 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 Stub，客户端生成 Proxy 实例，会把 Proxy 通过构造函数传给 Stub <a href=\"http://dubbo.apache.org/zh-cn/docs/user/demos/local-stub.html#fn1\">[1]</a>，然后把 Stub 暴露给用户，Stub 可以决定要不要去调 Proxy。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.foo;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BarServiceStub</span> <span class=\"keyword\">implements</span> <span class=\"title\">BarService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BarService barService;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 构造函数传入真正的远程代理对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BarServiceStub</span><span class=\"params\">(BarService barService)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.barService = barService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sayHello</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 此代码在客户端执行, 你可以在客户端做ThreadLocal本地缓存，或预先验证参数是否合法，等等</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> barService.sayHello(name);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 你可以容错，可以做任何AOP拦截事项</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;容错数据&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"java动态代理","date":"2019-05-13T01:58:38.000Z","_content":"\n### 什么是代理\n&emsp; &emsp;代理是一种软件设计模式，这种设计模式不直接访问被代理对象，而访问被代理对象的方法，详尽的解释可参考《java设计模式之禅》，里面的解释还是很通俗的。给个《java设计模式之禅》下载地址：https://pan.baidu.com/s/1GdFmZSx67HjKl_OhkwjqNg\n\n&emsp; &emsp;在JDK中提供了实现动态代理模式的机制，cglib也是一个用于实现动态代理的框架，在这里我介绍jdk自带的动态代理机制是如何使用的。先上代码再慢慢解释：\n\n<!--more-->\n\n```java\n// 定义一个接口，接口中只有一个抽象方法，这个方法便是将要被代理的方法\npublic interface Subject {\n  String test(String string);\n}\n\n```\n\n```java\n// 定义 一个类实现这个方法，方法里写上自己的逻辑。\npublic class SubjectImpl implements Subject {\n\n  @Override\n  public String test(String string) {\n      String test=string+string;\n      return test;\n  }\n}\n```\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n// 定义一个代理类，这个代理必须要实现invocaHandler 接口，用以指定这个类为一个代理类\npublic class MyProxy implements InvocationHandler {\n    private Object target;\n    public MyProxy( Object target){\n        this.target=target;\n    }\n    // 实现 invoke方法，这个方法将是后面代码中实际执行的方法\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"开始执行动态代理\");\n        Object result=method.invoke(target,args);\n        return  result;\n    }\n    // Proxy类为反射机制中的一个类，用于获得代理对象\n    public <T> T getProxy(){\n      /* newProxyInstance方法的参数解释：\n      ** 被代理对象的类加载器：target.getClass().getClassLoader()\n      ** 被代理的方法：target.getClass().getInterfaces()\n      **代理对象：this\n      */\n        return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);\n    }\n}\n```\n\n```java\npublic static void main(String[] args) {\n        // 创建一个被代理对象\n       Subject subject=new SubjectImpl();\n       // 创建一个代理对象\n       Subject proxy=new MyProxy(subject).getProxy();\n       // 调用代理的方法\n       System.out.println(proxy.test(\"test\"));\n   }\n```\n输出结果：\n```java\n开始执行动态代理\ntesttest\n\n```\n&emsp; &emsp;我们知道spring 的AOP是通过动态代理实现的,现在让我们好好分析一下动态代理，示例中定义了一个接口 Subject，一个继承接口的SubjectImpl类,一个实现了InvocationHandler的MyProxy类，并调用了Proxy.newProxyInstance方法。Subject定义了将要被代理执行的方法，SubjectImpl是被代理的类（雇主），MyProxy类是代理执行的类（跑腿的），它的invoke(Object proxy, Method method, Object[] args)方法便是实际被执行的方法，它的第一个参数proxy作用：\n> - 可以使用反射获取代理对象的信息（也就是proxy.getClass().getName()）\n> - 可以将代理对象返回以进行连续调用，这就是proxy存在的目的，因为this并不是代理对象(MyProxy虽然是代理的类，但代理对象是 Proxy.newProxyInstance方法生成的。)。\n\nmethod 是被代理的方法类型对象，args是方法的参数数组。通过Proxy.newProxyInstance生成代理类后就可以执行其中的代理方法了。\n\n\n&emsp; &emsp;如果我们直接执行SubjectImpl.test()方法则只返回一个字符串，但使用动态代理我们可以在方法执行前和执行后加上自己的逻辑，这样大大提高了代码的复用性；想一想，如果你写了一堆方法，方法里很多代码是一样的，这样的代码是不是很丑？好，现在你把重复的代码单独抽出来做一个方法，但这样你的每个方法都被写死了，和那个公共的方法耦合在一起，这样很不灵活。如果我突然想一部分方法的公共方法是a(),一部分方法的公共方法是b(),那改起来很麻烦，扩展性很差。使用动态代理就很好的解决了这个问题，被代理对象可以任意指定，代理的逻辑可以任意实现，二者互相独立互不影响，并且可以由客户端任意进行组合，这就是所谓的动态。","source":"_posts/gclib.md","raw":"---\ntitle: java动态代理\ndate: 2019-05-13 09:58:38\ntags: 设计模式\n---\n\n### 什么是代理\n&emsp; &emsp;代理是一种软件设计模式，这种设计模式不直接访问被代理对象，而访问被代理对象的方法，详尽的解释可参考《java设计模式之禅》，里面的解释还是很通俗的。给个《java设计模式之禅》下载地址：https://pan.baidu.com/s/1GdFmZSx67HjKl_OhkwjqNg\n\n&emsp; &emsp;在JDK中提供了实现动态代理模式的机制，cglib也是一个用于实现动态代理的框架，在这里我介绍jdk自带的动态代理机制是如何使用的。先上代码再慢慢解释：\n\n<!--more-->\n\n```java\n// 定义一个接口，接口中只有一个抽象方法，这个方法便是将要被代理的方法\npublic interface Subject {\n  String test(String string);\n}\n\n```\n\n```java\n// 定义 一个类实现这个方法，方法里写上自己的逻辑。\npublic class SubjectImpl implements Subject {\n\n  @Override\n  public String test(String string) {\n      String test=string+string;\n      return test;\n  }\n}\n```\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n// 定义一个代理类，这个代理必须要实现invocaHandler 接口，用以指定这个类为一个代理类\npublic class MyProxy implements InvocationHandler {\n    private Object target;\n    public MyProxy( Object target){\n        this.target=target;\n    }\n    // 实现 invoke方法，这个方法将是后面代码中实际执行的方法\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"开始执行动态代理\");\n        Object result=method.invoke(target,args);\n        return  result;\n    }\n    // Proxy类为反射机制中的一个类，用于获得代理对象\n    public <T> T getProxy(){\n      /* newProxyInstance方法的参数解释：\n      ** 被代理对象的类加载器：target.getClass().getClassLoader()\n      ** 被代理的方法：target.getClass().getInterfaces()\n      **代理对象：this\n      */\n        return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);\n    }\n}\n```\n\n```java\npublic static void main(String[] args) {\n        // 创建一个被代理对象\n       Subject subject=new SubjectImpl();\n       // 创建一个代理对象\n       Subject proxy=new MyProxy(subject).getProxy();\n       // 调用代理的方法\n       System.out.println(proxy.test(\"test\"));\n   }\n```\n输出结果：\n```java\n开始执行动态代理\ntesttest\n\n```\n&emsp; &emsp;我们知道spring 的AOP是通过动态代理实现的,现在让我们好好分析一下动态代理，示例中定义了一个接口 Subject，一个继承接口的SubjectImpl类,一个实现了InvocationHandler的MyProxy类，并调用了Proxy.newProxyInstance方法。Subject定义了将要被代理执行的方法，SubjectImpl是被代理的类（雇主），MyProxy类是代理执行的类（跑腿的），它的invoke(Object proxy, Method method, Object[] args)方法便是实际被执行的方法，它的第一个参数proxy作用：\n> - 可以使用反射获取代理对象的信息（也就是proxy.getClass().getName()）\n> - 可以将代理对象返回以进行连续调用，这就是proxy存在的目的，因为this并不是代理对象(MyProxy虽然是代理的类，但代理对象是 Proxy.newProxyInstance方法生成的。)。\n\nmethod 是被代理的方法类型对象，args是方法的参数数组。通过Proxy.newProxyInstance生成代理类后就可以执行其中的代理方法了。\n\n\n&emsp; &emsp;如果我们直接执行SubjectImpl.test()方法则只返回一个字符串，但使用动态代理我们可以在方法执行前和执行后加上自己的逻辑，这样大大提高了代码的复用性；想一想，如果你写了一堆方法，方法里很多代码是一样的，这样的代码是不是很丑？好，现在你把重复的代码单独抽出来做一个方法，但这样你的每个方法都被写死了，和那个公共的方法耦合在一起，这样很不灵活。如果我突然想一部分方法的公共方法是a(),一部分方法的公共方法是b(),那改起来很麻烦，扩展性很差。使用动态代理就很好的解决了这个问题，被代理对象可以任意指定，代理的逻辑可以任意实现，二者互相独立互不影响，并且可以由客户端任意进行组合，这就是所谓的动态。","slug":"gclib","published":1,"updated":"2021-01-11T07:31:23.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5y001100wi6b4684on","content":"<h3 id=\"什么是代理\"><a href=\"#什么是代理\" class=\"headerlink\" title=\"什么是代理\"></a>什么是代理</h3><p>&emsp; &emsp;代理是一种软件设计模式，这种设计模式不直接访问被代理对象，而访问被代理对象的方法，详尽的解释可参考《java设计模式之禅》，里面的解释还是很通俗的。给个《java设计模式之禅》下载地址：<a href=\"https://pan.baidu.com/s/1GdFmZSx67HjKl_OhkwjqNg\">https://pan.baidu.com/s/1GdFmZSx67HjKl_OhkwjqNg</a></p>\n<p>&emsp; &emsp;在JDK中提供了实现动态代理模式的机制，cglib也是一个用于实现动态代理的框架，在这里我介绍jdk自带的动态代理机制是如何使用的。先上代码再慢慢解释：</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个接口，接口中只有一个抽象方法，这个方法便是将要被代理的方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">(String string)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义 一个类实现这个方法，方法里写上自己的逻辑。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubjectImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">(String string)</span> </span>&#123;</span><br><span class=\"line\">      String test=string+string;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> test;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"><span class=\"comment\">// 定义一个代理类，这个代理必须要实现invocaHandler 接口，用以指定这个类为一个代理类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyProxy</span><span class=\"params\">( Object target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target=target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 实现 invoke方法，这个方法将是后面代码中实际执行的方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;开始执行动态代理&quot;</span>);</span><br><span class=\"line\">        Object result=method.invoke(target,args);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Proxy类为反射机制中的一个类，用于获得代理对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/* newProxyInstance方法的参数解释：</span></span><br><span class=\"line\"><span class=\"comment\">      ** 被代理对象的类加载器：target.getClass().getClassLoader()</span></span><br><span class=\"line\"><span class=\"comment\">      ** 被代理的方法：target.getClass().getInterfaces()</span></span><br><span class=\"line\"><span class=\"comment\">      **代理对象：this</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个被代理对象</span></span><br><span class=\"line\">       Subject subject=<span class=\"keyword\">new</span> SubjectImpl();</span><br><span class=\"line\">       <span class=\"comment\">// 创建一个代理对象</span></span><br><span class=\"line\">       Subject proxy=<span class=\"keyword\">new</span> MyProxy(subject).getProxy();</span><br><span class=\"line\">       <span class=\"comment\">// 调用代理的方法</span></span><br><span class=\"line\">       System.out.println(proxy.test(<span class=\"string\">&quot;test&quot;</span>));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始执行动态代理</span><br><span class=\"line\">testtest</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>&emsp; &emsp;我们知道spring 的AOP是通过动态代理实现的,现在让我们好好分析一下动态代理，示例中定义了一个接口 Subject，一个继承接口的SubjectImpl类,一个实现了InvocationHandler的MyProxy类，并调用了Proxy.newProxyInstance方法。Subject定义了将要被代理执行的方法，SubjectImpl是被代理的类（雇主），MyProxy类是代理执行的类（跑腿的），它的invoke(Object proxy, Method method, Object[] args)方法便是实际被执行的方法，它的第一个参数proxy作用：</p>\n<blockquote>\n<ul>\n<li>可以使用反射获取代理对象的信息（也就是proxy.getClass().getName()）</li>\n<li>可以将代理对象返回以进行连续调用，这就是proxy存在的目的，因为this并不是代理对象(MyProxy虽然是代理的类，但代理对象是 Proxy.newProxyInstance方法生成的。)。</li>\n</ul>\n</blockquote>\n<p>method 是被代理的方法类型对象，args是方法的参数数组。通过Proxy.newProxyInstance生成代理类后就可以执行其中的代理方法了。</p>\n<p>&emsp; &emsp;如果我们直接执行SubjectImpl.test()方法则只返回一个字符串，但使用动态代理我们可以在方法执行前和执行后加上自己的逻辑，这样大大提高了代码的复用性；想一想，如果你写了一堆方法，方法里很多代码是一样的，这样的代码是不是很丑？好，现在你把重复的代码单独抽出来做一个方法，但这样你的每个方法都被写死了，和那个公共的方法耦合在一起，这样很不灵活。如果我突然想一部分方法的公共方法是a(),一部分方法的公共方法是b(),那改起来很麻烦，扩展性很差。使用动态代理就很好的解决了这个问题，被代理对象可以任意指定，代理的逻辑可以任意实现，二者互相独立互不影响，并且可以由客户端任意进行组合，这就是所谓的动态。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是代理\"><a href=\"#什么是代理\" class=\"headerlink\" title=\"什么是代理\"></a>什么是代理</h3><p>&emsp; &emsp;代理是一种软件设计模式，这种设计模式不直接访问被代理对象，而访问被代理对象的方法，详尽的解释可参考《java设计模式之禅》，里面的解释还是很通俗的。给个《java设计模式之禅》下载地址：<a href=\"https://pan.baidu.com/s/1GdFmZSx67HjKl_OhkwjqNg\">https://pan.baidu.com/s/1GdFmZSx67HjKl_OhkwjqNg</a></p>\n<p>&emsp; &emsp;在JDK中提供了实现动态代理模式的机制，cglib也是一个用于实现动态代理的框架，在这里我介绍jdk自带的动态代理机制是如何使用的。先上代码再慢慢解释：</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个接口，接口中只有一个抽象方法，这个方法便是将要被代理的方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">test</span><span class=\"params\">(String string)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义 一个类实现这个方法，方法里写上自己的逻辑。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubjectImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">(String string)</span> </span>&#123;</span><br><span class=\"line\">      String test=string+string;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> test;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br><span class=\"line\"><span class=\"comment\">// 定义一个代理类，这个代理必须要实现invocaHandler 接口，用以指定这个类为一个代理类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyProxy</span><span class=\"params\">( Object target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target=target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 实现 invoke方法，这个方法将是后面代码中实际执行的方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;开始执行动态代理&quot;</span>);</span><br><span class=\"line\">        Object result=method.invoke(target,args);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Proxy类为反射机制中的一个类，用于获得代理对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/* newProxyInstance方法的参数解释：</span></span><br><span class=\"line\"><span class=\"comment\">      ** 被代理对象的类加载器：target.getClass().getClassLoader()</span></span><br><span class=\"line\"><span class=\"comment\">      ** 被代理的方法：target.getClass().getInterfaces()</span></span><br><span class=\"line\"><span class=\"comment\">      **代理对象：this</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个被代理对象</span></span><br><span class=\"line\">       Subject subject=<span class=\"keyword\">new</span> SubjectImpl();</span><br><span class=\"line\">       <span class=\"comment\">// 创建一个代理对象</span></span><br><span class=\"line\">       Subject proxy=<span class=\"keyword\">new</span> MyProxy(subject).getProxy();</span><br><span class=\"line\">       <span class=\"comment\">// 调用代理的方法</span></span><br><span class=\"line\">       System.out.println(proxy.test(<span class=\"string\">&quot;test&quot;</span>));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开始执行动态代理</span><br><span class=\"line\">testtest</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>&emsp; &emsp;我们知道spring 的AOP是通过动态代理实现的,现在让我们好好分析一下动态代理，示例中定义了一个接口 Subject，一个继承接口的SubjectImpl类,一个实现了InvocationHandler的MyProxy类，并调用了Proxy.newProxyInstance方法。Subject定义了将要被代理执行的方法，SubjectImpl是被代理的类（雇主），MyProxy类是代理执行的类（跑腿的），它的invoke(Object proxy, Method method, Object[] args)方法便是实际被执行的方法，它的第一个参数proxy作用：</p>\n<blockquote>\n<ul>\n<li>可以使用反射获取代理对象的信息（也就是proxy.getClass().getName()）</li>\n<li>可以将代理对象返回以进行连续调用，这就是proxy存在的目的，因为this并不是代理对象(MyProxy虽然是代理的类，但代理对象是 Proxy.newProxyInstance方法生成的。)。</li>\n</ul>\n</blockquote>\n<p>method 是被代理的方法类型对象，args是方法的参数数组。通过Proxy.newProxyInstance生成代理类后就可以执行其中的代理方法了。</p>\n<p>&emsp; &emsp;如果我们直接执行SubjectImpl.test()方法则只返回一个字符串，但使用动态代理我们可以在方法执行前和执行后加上自己的逻辑，这样大大提高了代码的复用性；想一想，如果你写了一堆方法，方法里很多代码是一样的，这样的代码是不是很丑？好，现在你把重复的代码单独抽出来做一个方法，但这样你的每个方法都被写死了，和那个公共的方法耦合在一起，这样很不灵活。如果我突然想一部分方法的公共方法是a(),一部分方法的公共方法是b(),那改起来很麻烦，扩展性很差。使用动态代理就很好的解决了这个问题，被代理对象可以任意指定，代理的逻辑可以任意实现，二者互相独立互不影响，并且可以由客户端任意进行组合，这就是所谓的动态。</p>"},{"title":"git subtree多项目合并试验","date":"2019-05-05T08:48:52.000Z","_content":"\n## 说明\n\ngit subtree可将多个git项目合并在一起，可解决protobuf更新的问题；\n\n打包maven私有仓库也可行，但是maven私有仓库不适合频繁更新，而protobuf更新会很频繁。\n\n## 测试\n\n``` shell\n\ngit clone一个新项目\n\ngit remote add <name> <url> 添加一个远程仓库\n\ngit subtree add --prefix=<dir> <name> master --squash\n\ngit push 会把子仓库的文件提交，合情合理\n\n# 更新子仓库的方法\n\ngit subtree push --prefix=<dir> <name> master\n\n```\n\n<!--more-->\n\n命令一览\n\n```linux\ngit subtree add   --prefix=<prefix> <commit>\ngit subtree add   --prefix=<prefix> <repository> <ref>\ngit subtree pull  --prefix=<prefix> <repository> <ref>\ngit subtree push  --prefix=<prefix> <repository> <ref>\ngit subtree merge --prefix=<prefix> <commit>\ngit subtree split --prefix=<prefix> [OPTIONS] [<commit>]\n```\n\n由于不能使用idea 来操作子仓库，需要掌握手动解决冲突的方法\n\n git 知识复习\n\ngit checkout -b xxx\n\ngit branch xxx\n\ngit merge xxx\ngit init \ngit config\ngit remote add test\ngit push -u test master\n\n\n## gitflow\n\n- master 测试\n- develop 开发\n- feature 功能\n- release 测试\n- hotfix 补丁\n\nv0.1 ----- v0.2----------v0.3\n\n​              develop------ v0.3\n\n​                                   v0.3----hotfix -----v0.3\n\n​                                     v0.3----release ---v0.3\n\n​                                    v0.3-----feature -----------------------v0.4\n\n## over\n\n自此，protobuf的文件同步找到了一个较好的解决方法\n\n","source":"_posts/git-subtree.md","raw":"---\ntitle: git subtree多项目合并试验\ndate: 2019-05-05 16:48:52\ntags: tool\n---\n\n## 说明\n\ngit subtree可将多个git项目合并在一起，可解决protobuf更新的问题；\n\n打包maven私有仓库也可行，但是maven私有仓库不适合频繁更新，而protobuf更新会很频繁。\n\n## 测试\n\n``` shell\n\ngit clone一个新项目\n\ngit remote add <name> <url> 添加一个远程仓库\n\ngit subtree add --prefix=<dir> <name> master --squash\n\ngit push 会把子仓库的文件提交，合情合理\n\n# 更新子仓库的方法\n\ngit subtree push --prefix=<dir> <name> master\n\n```\n\n<!--more-->\n\n命令一览\n\n```linux\ngit subtree add   --prefix=<prefix> <commit>\ngit subtree add   --prefix=<prefix> <repository> <ref>\ngit subtree pull  --prefix=<prefix> <repository> <ref>\ngit subtree push  --prefix=<prefix> <repository> <ref>\ngit subtree merge --prefix=<prefix> <commit>\ngit subtree split --prefix=<prefix> [OPTIONS] [<commit>]\n```\n\n由于不能使用idea 来操作子仓库，需要掌握手动解决冲突的方法\n\n git 知识复习\n\ngit checkout -b xxx\n\ngit branch xxx\n\ngit merge xxx\ngit init \ngit config\ngit remote add test\ngit push -u test master\n\n\n## gitflow\n\n- master 测试\n- develop 开发\n- feature 功能\n- release 测试\n- hotfix 补丁\n\nv0.1 ----- v0.2----------v0.3\n\n​              develop------ v0.3\n\n​                                   v0.3----hotfix -----v0.3\n\n​                                     v0.3----release ---v0.3\n\n​                                    v0.3-----feature -----------------------v0.4\n\n## over\n\n自此，protobuf的文件同步找到了一个较好的解决方法\n\n","slug":"git-subtree","published":1,"updated":"2021-01-11T07:31:23.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5y001400wi9z2s0e8z","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>git subtree可将多个git项目合并在一起，可解决protobuf更新的问题；</p>\n<p>打包maven私有仓库也可行，但是maven私有仓库不适合频繁更新，而protobuf更新会很频繁。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">git clone一个新项目</span><br><span class=\"line\"></span><br><span class=\"line\">git remote add &lt;name&gt; &lt;url&gt; 添加一个远程仓库</span><br><span class=\"line\"></span><br><span class=\"line\">git subtree add --prefix=&lt;dir&gt; &lt;name&gt; master --squash</span><br><span class=\"line\"></span><br><span class=\"line\">git push 会把子仓库的文件提交，合情合理</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 更新子仓库的方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">git subtree push --prefix=&lt;dir&gt; &lt;name&gt; master</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n\n<p>命令一览</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree add   --prefix&#x3D;&lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\">git subtree add   --prefix&#x3D;&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\">git subtree pull  --prefix&#x3D;&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\">git subtree push  --prefix&#x3D;&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\">git subtree merge --prefix&#x3D;&lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\">git subtree split --prefix&#x3D;&lt;prefix&gt; [OPTIONS] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure>\n<p>由于不能使用idea 来操作子仓库，需要掌握手动解决冲突的方法</p>\n<p> git 知识复习</p>\n<p>git checkout -b xxx</p>\n<p>git branch xxx</p>\n<p>git merge xxx<br>git init<br>git config<br>git remote add test<br>git push -u test master</p>\n<h2 id=\"gitflow\"><a href=\"#gitflow\" class=\"headerlink\" title=\"gitflow\"></a>gitflow</h2><ul>\n<li>master 测试</li>\n<li>develop 开发</li>\n<li>feature 功能</li>\n<li>release 测试</li>\n<li>hotfix 补丁</li>\n</ul>\n<p>v0.1 —– v0.2———-v0.3</p>\n<p>​              develop—— v0.3</p>\n<p>​                                   v0.3—-hotfix —–v0.3</p>\n<p>​                                     v0.3—-release —v0.3</p>\n<p>​                                    v0.3—–feature ———————–v0.4</p>\n<h2 id=\"over\"><a href=\"#over\" class=\"headerlink\" title=\"over\"></a>over</h2><p>自此，protobuf的文件同步找到了一个较好的解决方法</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>git subtree可将多个git项目合并在一起，可解决protobuf更新的问题；</p>\n<p>打包maven私有仓库也可行，但是maven私有仓库不适合频繁更新，而protobuf更新会很频繁。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">git clone一个新项目</span><br><span class=\"line\"></span><br><span class=\"line\">git remote add &lt;name&gt; &lt;url&gt; 添加一个远程仓库</span><br><span class=\"line\"></span><br><span class=\"line\">git subtree add --prefix=&lt;dir&gt; &lt;name&gt; master --squash</span><br><span class=\"line\"></span><br><span class=\"line\">git push 会把子仓库的文件提交，合情合理</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 更新子仓库的方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">git subtree push --prefix=&lt;dir&gt; &lt;name&gt; master</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","more":"<p>命令一览</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree add   --prefix&#x3D;&lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\">git subtree add   --prefix&#x3D;&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\">git subtree pull  --prefix&#x3D;&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\">git subtree push  --prefix&#x3D;&lt;prefix&gt; &lt;repository&gt; &lt;ref&gt;</span><br><span class=\"line\">git subtree merge --prefix&#x3D;&lt;prefix&gt; &lt;commit&gt;</span><br><span class=\"line\">git subtree split --prefix&#x3D;&lt;prefix&gt; [OPTIONS] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure>\n<p>由于不能使用idea 来操作子仓库，需要掌握手动解决冲突的方法</p>\n<p> git 知识复习</p>\n<p>git checkout -b xxx</p>\n<p>git branch xxx</p>\n<p>git merge xxx<br>git init<br>git config<br>git remote add test<br>git push -u test master</p>\n<h2 id=\"gitflow\"><a href=\"#gitflow\" class=\"headerlink\" title=\"gitflow\"></a>gitflow</h2><ul>\n<li>master 测试</li>\n<li>develop 开发</li>\n<li>feature 功能</li>\n<li>release 测试</li>\n<li>hotfix 补丁</li>\n</ul>\n<p>v0.1 —– v0.2———-v0.3</p>\n<p>​              develop—— v0.3</p>\n<p>​                                   v0.3—-hotfix —–v0.3</p>\n<p>​                                     v0.3—-release —v0.3</p>\n<p>​                                    v0.3—–feature ———————–v0.4</p>\n<h2 id=\"over\"><a href=\"#over\" class=\"headerlink\" title=\"over\"></a>over</h2><p>自此，protobuf的文件同步找到了一个较好的解决方法</p>"},{"title":"git","date":"2019-05-24T06:24:56.000Z","_content":"\n#### 初始化并提交到远程\n\ngit init <br>\ngit config --global user.name\"ssss\"\ngit add README.md <br>\ngit commit -m \"first commit\" <br>\ngit remote add origin https://github.com/Xanthuim/nodejs_express_sample.git <br>\ngit push -u origin master <br>（$ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了）\n\n<!--more-->\n\ngit branch --set-upstream-to master origin/master或者git fetch关联远程分支，然后git pull origin master --allow-unrelated-histories强制合并\n\n#### 远程仓库初始化并关联本地\n\ngit clone url<br>\ngit config --global user.name\"ss\"<br>\ngit push<br>\n\n#### HEAD的含义\n\n代表当前仓库版本号<br>\nHEAD^ 和HEAD~<br>\nHEAD^+数字表示当前提交的父提交。具体是第几个父提交共同过^+数字指定，EAD^1第一个父提交，该语法只能用于合并(merge)的提交记录，因为一个通过合并产生的commit对象才有多个父提交。\nHEAD~(等同于HEAD^,注意没有加数字)表当前提交的上一个提交。<br>\n如果想获取一个提交的第几个父提交使用HEAD^+数字,想获取一个提交的上几个提交使用HEAD~。HEAD^和HEAD~或HEAD^^和HEAD~~并没有区别，只有HEAD^+数字才和HEAD~有区别。\n\n#### $ git reset 撤销方式\n\ngit reset --soft 版本号<br>\n只撤销本地仓库数据到版本号 <br>\ngit reset --mixed 版本号<br>\n撤销本地和暂存区仓库到版本号<br>\ngit reset --hard 版本号<br>\n撤销 工作区 暂存区 本地仓库到版本号<br>\ngit reset --hard origin/master<br>\n####\n\nHEAD的含义：代表当前仓库最新版本。HEAD^ 和HEAD~的意义和区别HEAD^+数字表示当前提交的父提交。具体是第几个父提交共同过^+数字指定，EAD^1第一个父提交，该语法只能用于合并(merge)的提交记录，因为一个通过合并产生的commit对象才有多个父提交。HEAD~(等同于HEAD^,注意没有加数字)表当前提交的上一个提交。<br>如果想获取一个提交的第几个父提交使用HEAD^+数字,想获取一个提交的上几个提交使用HEAD~。HEAD^和HEAD~或HEAD^^和HEAD~~并没有区别，只有HEAD^+数字才和HEAD~有区别。 git reset 撤销方式git reset --soft 版本号只撤销本地仓库数据到版本号git reset --mixed 版本号该方式为默认方式（即git reset 版本号）撤销本地和暂存区仓库到版本号git reset --hard 版本号撤销 工作区 暂存区 本地仓库到版本号git reset --hard origin/master远程仓库代码覆盖工作区 暂存区 本地仓库以上指令都不会对未归入git控制的文件进行管理也就是从未add过的文件git是不会去删除撤销它的撤销单个文件的修改git reset HEAD xxx.txt本地覆盖暂存区的代码git checkout xxx.txtgit checkout .将暂存区的代码覆盖工作区 “.”是通配所有文件\n\ngit 强制pull \n\ngit pull origin master --allow-unrelated-histories \n\ngit 强制push git push -f \n\n合并\n\ngit merge origin master \n\ngit status\n\ngit 保存工作区修改 不提交\n\ngit stash save \"xxx\" （入栈，工作区代码放入到stash中）\n\ngit stash pop (出栈，从stash中拿保存的代码)","source":"_posts/git.md","raw":"---\ntitle: git\ndate: 2019-05-24 14:24:56\ntags: tool\n---\n\n#### 初始化并提交到远程\n\ngit init <br>\ngit config --global user.name\"ssss\"\ngit add README.md <br>\ngit commit -m \"first commit\" <br>\ngit remote add origin https://github.com/Xanthuim/nodejs_express_sample.git <br>\ngit push -u origin master <br>（$ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了）\n\n<!--more-->\n\ngit branch --set-upstream-to master origin/master或者git fetch关联远程分支，然后git pull origin master --allow-unrelated-histories强制合并\n\n#### 远程仓库初始化并关联本地\n\ngit clone url<br>\ngit config --global user.name\"ss\"<br>\ngit push<br>\n\n#### HEAD的含义\n\n代表当前仓库版本号<br>\nHEAD^ 和HEAD~<br>\nHEAD^+数字表示当前提交的父提交。具体是第几个父提交共同过^+数字指定，EAD^1第一个父提交，该语法只能用于合并(merge)的提交记录，因为一个通过合并产生的commit对象才有多个父提交。\nHEAD~(等同于HEAD^,注意没有加数字)表当前提交的上一个提交。<br>\n如果想获取一个提交的第几个父提交使用HEAD^+数字,想获取一个提交的上几个提交使用HEAD~。HEAD^和HEAD~或HEAD^^和HEAD~~并没有区别，只有HEAD^+数字才和HEAD~有区别。\n\n#### $ git reset 撤销方式\n\ngit reset --soft 版本号<br>\n只撤销本地仓库数据到版本号 <br>\ngit reset --mixed 版本号<br>\n撤销本地和暂存区仓库到版本号<br>\ngit reset --hard 版本号<br>\n撤销 工作区 暂存区 本地仓库到版本号<br>\ngit reset --hard origin/master<br>\n####\n\nHEAD的含义：代表当前仓库最新版本。HEAD^ 和HEAD~的意义和区别HEAD^+数字表示当前提交的父提交。具体是第几个父提交共同过^+数字指定，EAD^1第一个父提交，该语法只能用于合并(merge)的提交记录，因为一个通过合并产生的commit对象才有多个父提交。HEAD~(等同于HEAD^,注意没有加数字)表当前提交的上一个提交。<br>如果想获取一个提交的第几个父提交使用HEAD^+数字,想获取一个提交的上几个提交使用HEAD~。HEAD^和HEAD~或HEAD^^和HEAD~~并没有区别，只有HEAD^+数字才和HEAD~有区别。 git reset 撤销方式git reset --soft 版本号只撤销本地仓库数据到版本号git reset --mixed 版本号该方式为默认方式（即git reset 版本号）撤销本地和暂存区仓库到版本号git reset --hard 版本号撤销 工作区 暂存区 本地仓库到版本号git reset --hard origin/master远程仓库代码覆盖工作区 暂存区 本地仓库以上指令都不会对未归入git控制的文件进行管理也就是从未add过的文件git是不会去删除撤销它的撤销单个文件的修改git reset HEAD xxx.txt本地覆盖暂存区的代码git checkout xxx.txtgit checkout .将暂存区的代码覆盖工作区 “.”是通配所有文件\n\ngit 强制pull \n\ngit pull origin master --allow-unrelated-histories \n\ngit 强制push git push -f \n\n合并\n\ngit merge origin master \n\ngit status\n\ngit 保存工作区修改 不提交\n\ngit stash save \"xxx\" （入栈，工作区代码放入到stash中）\n\ngit stash pop (出栈，从stash中拿保存的代码)","slug":"git","published":1,"updated":"2021-01-11T07:31:23.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh5z001600wi615zex7s","content":"<h4 id=\"初始化并提交到远程\"><a href=\"#初始化并提交到远程\" class=\"headerlink\" title=\"初始化并提交到远程\"></a>初始化并提交到远程</h4><p>git init <br><br>git config –global user.name”ssss”<br>git add README.md <br><br>git commit -m “first commit” <br><br>git remote add origin <a href=\"https://github.com/Xanthuim/nodejs_express_sample.git\">https://github.com/Xanthuim/nodejs_express_sample.git</a> <br><br>git push -u origin master <br>（$ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了）</p>\n<a id=\"more\"></a>\n\n<p>git branch –set-upstream-to master origin/master或者git fetch关联远程分支，然后git pull origin master –allow-unrelated-histories强制合并</p>\n<h4 id=\"远程仓库初始化并关联本地\"><a href=\"#远程仓库初始化并关联本地\" class=\"headerlink\" title=\"远程仓库初始化并关联本地\"></a>远程仓库初始化并关联本地</h4><p>git clone url<br><br>git config –global user.name”ss”<br><br>git push<br></p>\n<h4 id=\"HEAD的含义\"><a href=\"#HEAD的含义\" class=\"headerlink\" title=\"HEAD的含义\"></a>HEAD的含义</h4><p>代表当前仓库版本号<br><br>HEAD^ 和HEAD<del><br><br>HEAD^+数字表示当前提交的父提交。具体是第几个父提交共同过^+数字指定，EAD^1第一个父提交，该语法只能用于合并(merge)的提交记录，因为一个通过合并产生的commit对象才有多个父提交。<br>HEAD</del>(等同于HEAD^,注意没有加数字)表当前提交的上一个提交。<br><br>如果想获取一个提交的第几个父提交使用HEAD^+数字,想获取一个提交的上几个提交使用HEAD<del>。HEAD^和HEAD</del>或HEAD^^和HEAD<del>并没有区别，只有HEAD^+数字才和HEAD</del>有区别。</p>\n<h4 id=\"git-reset-撤销方式\"><a href=\"#git-reset-撤销方式\" class=\"headerlink\" title=\"$ git reset 撤销方式\"></a>$ git reset 撤销方式</h4><p>git reset –soft 版本号<br><br>只撤销本地仓库数据到版本号 <br><br>git reset –mixed 版本号<br><br>撤销本地和暂存区仓库到版本号<br><br>git reset –hard 版本号<br><br>撤销 工作区 暂存区 本地仓库到版本号<br><br>git reset –hard origin/master<br><br>####</p>\n<p>HEAD的含义：代表当前仓库最新版本。HEAD^ 和HEAD<del>的意义和区别HEAD^+数字表示当前提交的父提交。具体是第几个父提交共同过^+数字指定，EAD^1第一个父提交，该语法只能用于合并(merge)的提交记录，因为一个通过合并产生的commit对象才有多个父提交。HEAD</del>(等同于HEAD^,注意没有加数字)表当前提交的上一个提交。<br>如果想获取一个提交的第几个父提交使用HEAD^+数字,想获取一个提交的上几个提交使用HEAD<del>。HEAD^和HEAD</del>或HEAD^^和HEAD<del>并没有区别，只有HEAD^+数字才和HEAD</del>有区别。 git reset 撤销方式git reset –soft 版本号只撤销本地仓库数据到版本号git reset –mixed 版本号该方式为默认方式（即git reset 版本号）撤销本地和暂存区仓库到版本号git reset –hard 版本号撤销 工作区 暂存区 本地仓库到版本号git reset –hard origin/master远程仓库代码覆盖工作区 暂存区 本地仓库以上指令都不会对未归入git控制的文件进行管理也就是从未add过的文件git是不会去删除撤销它的撤销单个文件的修改git reset HEAD xxx.txt本地覆盖暂存区的代码git checkout xxx.txtgit checkout .将暂存区的代码覆盖工作区 “.”是通配所有文件</p>\n<p>git 强制pull </p>\n<p>git pull origin master –allow-unrelated-histories </p>\n<p>git 强制push git push -f </p>\n<p>合并</p>\n<p>git merge origin master </p>\n<p>git status</p>\n<p>git 保存工作区修改 不提交</p>\n<p>git stash save “xxx” （入栈，工作区代码放入到stash中）</p>\n<p>git stash pop (出栈，从stash中拿保存的代码)</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"初始化并提交到远程\"><a href=\"#初始化并提交到远程\" class=\"headerlink\" title=\"初始化并提交到远程\"></a>初始化并提交到远程</h4><p>git init <br><br>git config –global user.name”ssss”<br>git add README.md <br><br>git commit -m “first commit” <br><br>git remote add origin <a href=\"https://github.com/Xanthuim/nodejs_express_sample.git\">https://github.com/Xanthuim/nodejs_express_sample.git</a> <br><br>git push -u origin master <br>（$ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了）</p>","more":"<p>git branch –set-upstream-to master origin/master或者git fetch关联远程分支，然后git pull origin master –allow-unrelated-histories强制合并</p>\n<h4 id=\"远程仓库初始化并关联本地\"><a href=\"#远程仓库初始化并关联本地\" class=\"headerlink\" title=\"远程仓库初始化并关联本地\"></a>远程仓库初始化并关联本地</h4><p>git clone url<br><br>git config –global user.name”ss”<br><br>git push<br></p>\n<h4 id=\"HEAD的含义\"><a href=\"#HEAD的含义\" class=\"headerlink\" title=\"HEAD的含义\"></a>HEAD的含义</h4><p>代表当前仓库版本号<br><br>HEAD^ 和HEAD<del><br><br>HEAD^+数字表示当前提交的父提交。具体是第几个父提交共同过^+数字指定，EAD^1第一个父提交，该语法只能用于合并(merge)的提交记录，因为一个通过合并产生的commit对象才有多个父提交。<br>HEAD</del>(等同于HEAD^,注意没有加数字)表当前提交的上一个提交。<br><br>如果想获取一个提交的第几个父提交使用HEAD^+数字,想获取一个提交的上几个提交使用HEAD<del>。HEAD^和HEAD</del>或HEAD^^和HEAD<del>并没有区别，只有HEAD^+数字才和HEAD</del>有区别。</p>\n<h4 id=\"git-reset-撤销方式\"><a href=\"#git-reset-撤销方式\" class=\"headerlink\" title=\"$ git reset 撤销方式\"></a>$ git reset 撤销方式</h4><p>git reset –soft 版本号<br><br>只撤销本地仓库数据到版本号 <br><br>git reset –mixed 版本号<br><br>撤销本地和暂存区仓库到版本号<br><br>git reset –hard 版本号<br><br>撤销 工作区 暂存区 本地仓库到版本号<br><br>git reset –hard origin/master<br><br>####</p>\n<p>HEAD的含义：代表当前仓库最新版本。HEAD^ 和HEAD<del>的意义和区别HEAD^+数字表示当前提交的父提交。具体是第几个父提交共同过^+数字指定，EAD^1第一个父提交，该语法只能用于合并(merge)的提交记录，因为一个通过合并产生的commit对象才有多个父提交。HEAD</del>(等同于HEAD^,注意没有加数字)表当前提交的上一个提交。<br>如果想获取一个提交的第几个父提交使用HEAD^+数字,想获取一个提交的上几个提交使用HEAD<del>。HEAD^和HEAD</del>或HEAD^^和HEAD<del>并没有区别，只有HEAD^+数字才和HEAD</del>有区别。 git reset 撤销方式git reset –soft 版本号只撤销本地仓库数据到版本号git reset –mixed 版本号该方式为默认方式（即git reset 版本号）撤销本地和暂存区仓库到版本号git reset –hard 版本号撤销 工作区 暂存区 本地仓库到版本号git reset –hard origin/master远程仓库代码覆盖工作区 暂存区 本地仓库以上指令都不会对未归入git控制的文件进行管理也就是从未add过的文件git是不会去删除撤销它的撤销单个文件的修改git reset HEAD xxx.txt本地覆盖暂存区的代码git checkout xxx.txtgit checkout .将暂存区的代码覆盖工作区 “.”是通配所有文件</p>\n<p>git 强制pull </p>\n<p>git pull origin master –allow-unrelated-histories </p>\n<p>git 强制push git push -f </p>\n<p>合并</p>\n<p>git merge origin master </p>\n<p>git status</p>\n<p>git 保存工作区修改 不提交</p>\n<p>git stash save “xxx” （入栈，工作区代码放入到stash中）</p>\n<p>git stash pop (出栈，从stash中拿保存的代码)</p>"},{"title":"grpc+springboot+gradle学习笔记","date":"2019-05-14T03:07:53.000Z","_content":"\n#  前言\n\n前段时间写了一篇关于nacos的文章，本人还是很期待nacos成长起来的。nacos在其官方文档里面说nacos未来会支持grpc，正好我对grpc也抱有极大兴趣，于是基于springboot和gradle做了一个小demo对它们进行了整合，初步研究了一下，期待nacos成熟起来，组成一套Spring Cloud+gradle+nacos+grpc+sentinel的完全体。这篇博客的目的是知识储备，并不是讨论解决开发中某些问题。\n\n# 正文\n\n弄了一天，得到一个结论，gradle+grpc+git subtree 不是目前的我能驾驭的，弃文；等对gradle足够熟练再回来弄。\n","source":"_posts/grpc-learn.md","raw":"---\ntitle: grpc+springboot+gradle学习笔记\ndate: 2019-05-14 11:07:53\ntags: developing\n---\n\n#  前言\n\n前段时间写了一篇关于nacos的文章，本人还是很期待nacos成长起来的。nacos在其官方文档里面说nacos未来会支持grpc，正好我对grpc也抱有极大兴趣，于是基于springboot和gradle做了一个小demo对它们进行了整合，初步研究了一下，期待nacos成熟起来，组成一套Spring Cloud+gradle+nacos+grpc+sentinel的完全体。这篇博客的目的是知识储备，并不是讨论解决开发中某些问题。\n\n# 正文\n\n弄了一天，得到一个结论，gradle+grpc+git subtree 不是目前的我能驾驭的，弃文；等对gradle足够熟练再回来弄。\n","slug":"grpc-learn","published":1,"updated":"2021-01-11T07:31:23.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh60001900wie6u3af6u","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前段时间写了一篇关于nacos的文章，本人还是很期待nacos成长起来的。nacos在其官方文档里面说nacos未来会支持grpc，正好我对grpc也抱有极大兴趣，于是基于springboot和gradle做了一个小demo对它们进行了整合，初步研究了一下，期待nacos成熟起来，组成一套Spring Cloud+gradle+nacos+grpc+sentinel的完全体。这篇博客的目的是知识储备，并不是讨论解决开发中某些问题。</p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><p>弄了一天，得到一个结论，gradle+grpc+git subtree 不是目前的我能驾驭的，弃文；等对gradle足够熟练再回来弄。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前段时间写了一篇关于nacos的文章，本人还是很期待nacos成长起来的。nacos在其官方文档里面说nacos未来会支持grpc，正好我对grpc也抱有极大兴趣，于是基于springboot和gradle做了一个小demo对它们进行了整合，初步研究了一下，期待nacos成熟起来，组成一套Spring Cloud+gradle+nacos+grpc+sentinel的完全体。这篇博客的目的是知识储备，并不是讨论解决开发中某些问题。</p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><p>弄了一天，得到一个结论，gradle+grpc+git subtree 不是目前的我能驾驭的，弃文；等对gradle足够熟练再回来弄。</p>\n"},{"title":"xxx","date":"2019-03-28T02:44:50.000Z","_content":"\n????????????????????????????????????????????????","source":"_posts/hello-world.md","raw":"---\ntitle: xxx\ndate: 2019-03-28 10:44:50\ntags: 苟？\n---\n\n????????????????????????????????????????????????","slug":"hello-world","published":1,"updated":"2021-01-11T07:31:23.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh61001b00wibcnhf72e","content":"<p>????????????????????????????????????????????????</p>\n","site":{"data":{}},"excerpt":"","more":"<p>????????????????????????????????????????????????</p>\n"},{"title":"gradle+idea 快速上手","date":"2019-05-15T09:29:58.000Z","_content":"\n## gradle介绍\n\nGradle是一个构建工具，定位和maven一样，用于管理项目依赖和构建项目。和maven比起来的优势是：语法更灵活，更方便管理项目（个人很讨厌XML）。\n\ngradle具有以下特点：\n\n- 按约定声明构建和建设；\n- 强大的支持多工程的构建；\n- 强大的依赖管理（基于Apache Ivy），提供最大的便利去构建工程；\n- 全力支持已有的 Maven 或者Ivy仓库基础建设；\n- 支持传递性依赖管理； \t\n- 基于groovy脚本构建，groovy简单易学； \t\n- 具有广泛的领域模型支持构建； \n- 易迁移； \n- 自由和开放源码；\n\n<!--more-->\n\n可以说是maven有得gradle也有，maven没有的gradle也有。gradle在windows下安装也很简单，和maven一样：\n\n1. 从[gradle官网](<https://gradle.org/releases/>) 下载安装包并解压\n2. 将解压的文件夹路径配置到环境变量，先添加一个`GRADLE_HOME` 然后在path下添加 `%GRADLE_HOME%\\bin`\n3. cmd跑 `gradle -v` 查看配置是否成功\n4. [gradle 用户手册](<https://docs.gradle.org/current/userguide/userguide.html>) 方便平时查询相关操作\n\n## gradle的基本使用\n\nidea中已经集成gradle环境，你可以使用idea来构建gradle项目也可以通过命令行来使用gradle。在idea中 file-> setting ->搜索框输入gradle可查看gradle相关配置。\n\n### 使用gradle新建项目\n\n新建普通项目：\n![new_normal.png](https://upload-images.jianshu.io/upload_images/13612520-7aec3520435c32c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n新建springboot项目：\n\n在如下图界面时选择`Gradle Project`即可 \n\n![springboot.png](https://upload-images.jianshu.io/upload_images/13612520-cd7434a02af3bd86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### gradle项目结构及配置文件说明\n\n使用idea创建的gradle项目如图：\n![dir.png](https://upload-images.jianshu.io/upload_images/13612520-681237c249232a34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\nsrc结构和maven无异，不再介绍；gradle文件夹 存放gradle wrapper相关文件；build.gradle相当于maven里面的pom.xml，setting.gradle用于多模块的配置。\n\ngradle wrapper是gradle项目构建工具，它能在本地没有gradle的情况下，从远程下载gradle并自动解压缩以构建项目，自动管理gradle版本。`gradle-wrapper.properties`是gradle wrapper的配置，`distributionUrl`指定本地没有配置gradle的情况下从哪下载gradle，`distributionBase`指定gradle下载和缓存jar的根目录，默认用户目录。在实际使用中我们一般不直接使用gradle，而是使用gradle wrapper,而对于idea而言我们可以不去关心两者区别，idea的gradle环境是基于gradle wrapper的\n\nbuild.gradle结构\n\n```groovy\nplugins {\n    id 'java'\n}\ngroup 'com.muggle'\nversion '1.0-SNAPSHOT'\nsourceCompatibility = 1.8\nrepositories {\n    // mavenCentral()\n    maven { url \"http://maven.aliyun.com/nexus/content/groups/public/\" }\n}\ndependencies {\n    testCompile group: 'junit', name: 'junit', version: '4.12'\n}\n\n```\n\n节点说明\n\n- sourceCompatibility：指定编译.java文件的jdk版本\n- plugins：插件配置；格式为`id «plugin id» version «plugin version» [apply «false»]` Gradle的核心插件只需提供id的简称就可以\n- repositories：仓库配置，`mavenCentral()`代表中央仓库，你也可以用`maven{url  ‘<url>’}`的方式添加一个仓库\n- dependencies：依赖的坐标集合\n\n### dependencies说明\n\n在idea中，你复制好maven的xml格式依赖 直接粘贴到`dependencies`节点里面它会自动调整成`compile 'groupId :artifactId:version' `而不需要我们手动去改（但似乎有个时候不管用）。\n\n在gradle中，项目依赖的格式为`作用范修饰符 'groupId:artifactId:version'`，作用范围修饰符包括\n\n1. complie：编译范围依赖在所有的 classpath 中可用，同时它们也会被打包，这个是最常用的\n2. runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。\n3. testComplie：测试期编译需要的附加依赖\n4. testRuntime：测试运行期需要\n\n### gradle打包\n![build.png](https://upload-images.jianshu.io/upload_images/13612520-d99c0ddc3495634b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n和在idea中使用maven一样，点击右侧gradle标签可看到上图相关gradle的操作，build对应的是`./gradlew build`命令；右键运行build会生成一个build文件夹 class文件和jar包都在里面。\n\n## groovy 语言简单学习\n\nGroovy 和java有很大程度上相似，学习成本低，只是为了更好使用gradle 简单学习Groovy \n\n在idea中打开groovy console 点击 tool->groovy console 打开\n\n![groovy.png](https://upload-images.jianshu.io/upload_images/13612520-3d8398f4cdb5af0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n写第一个程序\n\n```groovy\n// 这是一行注释\nprintln (\"test\")\n// 简写\nprintln \"ssssss\"\n```\n\nctrl+enter 执行代码\n\nlist map的应用\n\n```groovy\n// 定义变量 相当于var 弱类型\ndef i=15\nprintln(i)\ndef s =\"nihao\"\nprintln s\n// 集合定义\ndef list=['s','a']\n// 添加元素\nlist << 'c'\n// 取出 元素\nprintln list.get(0)\nprintln list.get(0)\n// map\ndef map=['key':'value']\nprintln map.get('key')\n// 添\nmap.test='add'\nprintln map.get('test')\n```\n\n闭包的语法\n\n```groovy\n// 闭包 相当于函数式编程\ndef close1={\n    println \"你好\"\n}\n// 方法定义\ndef test(Closure closure){\n    closure()\n}\n//使用闭包\ntest(close1)\n// 带参闭包\ndef  close2={\n    v-> println v+v+v\n}\ndef test2(Closure closure){\n    closure(\"sss\")\n}\n//使用带参闭包\ntest2(close2)\n// 占位符\ndef close3={\n    v->\n        println(\"test $v \")\n}\ntest2(close3)\n```\n\n## gradle 实践\n\n### 多模块\n\n在idea中构建多模块很简单，和maven操作一样，但项目结构有所不同。在父模块中有一个`settings.gradle`文件，指定了子模块包含哪些，而需要继承给子模块的东西需要在父模块`build.gradle`中配置`subprojects`闭包。\n\n父模块`build.gradle` 示例\n\n\n\n```groovy\n\nplugins {\n    id 'java'\n}\ngroup 'com.muggle'\nversion '1.0-SNAPSHOT'\nsourceCompatibility = 1.8\nrepositories {\n    mavenCentral()\n}\nsubprojects {\n    apply plugin: 'java'\n    apply plugin: 'idea'\n\n    version = '1.0'\n    // JVM 版本号要求\n    sourceCompatibility = 1.8\n    targetCompatibility = 1.8\n    // java编译的时候缺省状态下会因为中文字符而失败\n    [compileJava,compileTestJava,javadoc]*.options*.encoding = 'UTF-8'\n    //相当于maven的properties\n    ext {\n        springVersion = '4.3.3.RELEASE'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        // 通用依赖\n        compile(\n                \"org.springframework:spring-context:$springVersion\",\n                \"org.springframework:spring-orm:$springVersion\",\n        )\n        // 依赖maven中不存在的jar\n        ext.jarTree = fileTree(dir: 'libs', include: '**/*.jar')\n        // 测试依赖\n        testCompile(\n                \"org.springframework:spring-test:$springVersion\",\n                \"junit:junit:4.12\"\n        )\n    }\n    // 显示当前项目下所有用于 compile 的 jar.\n    task listJars(description: 'Display all compile jars.') << {\n        configurations.compile.each { File file -> println file.name }\n    }\n}\n```\n\n子模块模块之间相互依赖方式：\n\n```groovy\ndependencies{  \n    // 这个子模块 依赖 test 模块\n    compile project(\":test\")  \n}  \n```\n\n如果项目需要达成war包 添加插件`apply plugin: 'war'`。\n\n### task\n\ntask是gradle中的任务，包括任务动作(task action)和任务依赖(task dependency)。task代表细分的下来的构建任务：编译classes、生成jar包相关信息等一些任务。所以我们能编写task来控制打包过程。task和task之间也存在依赖关系，通过`task dependency`来指定。\n\n其实build指令本质就是执行各个task，在做protobuf开发的开发的时候我就可以通过配置task来在指定指定位置生成对应的java代码。\n\ntask 示例代码\n\n```java\ntask first {\n    doLast {\n        println \">>>>>>>>>>>>>>\"\n    }\n}\n```\n右击idea右侧gradle中的first执行task\n\n\t\t\t\t![demo.png](https://upload-images.jianshu.io/upload_images/13612520-25ae17571ab12d27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n控制台输出：\n```java\n\n> Task :first\n>>>>>>>>>>>>>>\n\n```\n\n\n\n## 总结\n\ngradle相较maven来说更灵活，但现在市场占有率最大的还是maven，gradle在安卓开发的领域使用比较多。看过spring源码的就知道，spring就是用gradle来管理的。读完本篇博客后我希望你能顺畅的使用gradle构建一个普通的java项目、一个springboot项目、一个多模块项目。感谢阅读。","source":"_posts/gradle.md","raw":"---\ntitle: gradle+idea 快速上手\ndate: 2019-05-15 17:29:58\ntags: tool\n---\n\n## gradle介绍\n\nGradle是一个构建工具，定位和maven一样，用于管理项目依赖和构建项目。和maven比起来的优势是：语法更灵活，更方便管理项目（个人很讨厌XML）。\n\ngradle具有以下特点：\n\n- 按约定声明构建和建设；\n- 强大的支持多工程的构建；\n- 强大的依赖管理（基于Apache Ivy），提供最大的便利去构建工程；\n- 全力支持已有的 Maven 或者Ivy仓库基础建设；\n- 支持传递性依赖管理； \t\n- 基于groovy脚本构建，groovy简单易学； \t\n- 具有广泛的领域模型支持构建； \n- 易迁移； \n- 自由和开放源码；\n\n<!--more-->\n\n可以说是maven有得gradle也有，maven没有的gradle也有。gradle在windows下安装也很简单，和maven一样：\n\n1. 从[gradle官网](<https://gradle.org/releases/>) 下载安装包并解压\n2. 将解压的文件夹路径配置到环境变量，先添加一个`GRADLE_HOME` 然后在path下添加 `%GRADLE_HOME%\\bin`\n3. cmd跑 `gradle -v` 查看配置是否成功\n4. [gradle 用户手册](<https://docs.gradle.org/current/userguide/userguide.html>) 方便平时查询相关操作\n\n## gradle的基本使用\n\nidea中已经集成gradle环境，你可以使用idea来构建gradle项目也可以通过命令行来使用gradle。在idea中 file-> setting ->搜索框输入gradle可查看gradle相关配置。\n\n### 使用gradle新建项目\n\n新建普通项目：\n![new_normal.png](https://upload-images.jianshu.io/upload_images/13612520-7aec3520435c32c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n新建springboot项目：\n\n在如下图界面时选择`Gradle Project`即可 \n\n![springboot.png](https://upload-images.jianshu.io/upload_images/13612520-cd7434a02af3bd86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### gradle项目结构及配置文件说明\n\n使用idea创建的gradle项目如图：\n![dir.png](https://upload-images.jianshu.io/upload_images/13612520-681237c249232a34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\nsrc结构和maven无异，不再介绍；gradle文件夹 存放gradle wrapper相关文件；build.gradle相当于maven里面的pom.xml，setting.gradle用于多模块的配置。\n\ngradle wrapper是gradle项目构建工具，它能在本地没有gradle的情况下，从远程下载gradle并自动解压缩以构建项目，自动管理gradle版本。`gradle-wrapper.properties`是gradle wrapper的配置，`distributionUrl`指定本地没有配置gradle的情况下从哪下载gradle，`distributionBase`指定gradle下载和缓存jar的根目录，默认用户目录。在实际使用中我们一般不直接使用gradle，而是使用gradle wrapper,而对于idea而言我们可以不去关心两者区别，idea的gradle环境是基于gradle wrapper的\n\nbuild.gradle结构\n\n```groovy\nplugins {\n    id 'java'\n}\ngroup 'com.muggle'\nversion '1.0-SNAPSHOT'\nsourceCompatibility = 1.8\nrepositories {\n    // mavenCentral()\n    maven { url \"http://maven.aliyun.com/nexus/content/groups/public/\" }\n}\ndependencies {\n    testCompile group: 'junit', name: 'junit', version: '4.12'\n}\n\n```\n\n节点说明\n\n- sourceCompatibility：指定编译.java文件的jdk版本\n- plugins：插件配置；格式为`id «plugin id» version «plugin version» [apply «false»]` Gradle的核心插件只需提供id的简称就可以\n- repositories：仓库配置，`mavenCentral()`代表中央仓库，你也可以用`maven{url  ‘<url>’}`的方式添加一个仓库\n- dependencies：依赖的坐标集合\n\n### dependencies说明\n\n在idea中，你复制好maven的xml格式依赖 直接粘贴到`dependencies`节点里面它会自动调整成`compile 'groupId :artifactId:version' `而不需要我们手动去改（但似乎有个时候不管用）。\n\n在gradle中，项目依赖的格式为`作用范修饰符 'groupId:artifactId:version'`，作用范围修饰符包括\n\n1. complie：编译范围依赖在所有的 classpath 中可用，同时它们也会被打包，这个是最常用的\n2. runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。\n3. testComplie：测试期编译需要的附加依赖\n4. testRuntime：测试运行期需要\n\n### gradle打包\n![build.png](https://upload-images.jianshu.io/upload_images/13612520-d99c0ddc3495634b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n和在idea中使用maven一样，点击右侧gradle标签可看到上图相关gradle的操作，build对应的是`./gradlew build`命令；右键运行build会生成一个build文件夹 class文件和jar包都在里面。\n\n## groovy 语言简单学习\n\nGroovy 和java有很大程度上相似，学习成本低，只是为了更好使用gradle 简单学习Groovy \n\n在idea中打开groovy console 点击 tool->groovy console 打开\n\n![groovy.png](https://upload-images.jianshu.io/upload_images/13612520-3d8398f4cdb5af0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n写第一个程序\n\n```groovy\n// 这是一行注释\nprintln (\"test\")\n// 简写\nprintln \"ssssss\"\n```\n\nctrl+enter 执行代码\n\nlist map的应用\n\n```groovy\n// 定义变量 相当于var 弱类型\ndef i=15\nprintln(i)\ndef s =\"nihao\"\nprintln s\n// 集合定义\ndef list=['s','a']\n// 添加元素\nlist << 'c'\n// 取出 元素\nprintln list.get(0)\nprintln list.get(0)\n// map\ndef map=['key':'value']\nprintln map.get('key')\n// 添\nmap.test='add'\nprintln map.get('test')\n```\n\n闭包的语法\n\n```groovy\n// 闭包 相当于函数式编程\ndef close1={\n    println \"你好\"\n}\n// 方法定义\ndef test(Closure closure){\n    closure()\n}\n//使用闭包\ntest(close1)\n// 带参闭包\ndef  close2={\n    v-> println v+v+v\n}\ndef test2(Closure closure){\n    closure(\"sss\")\n}\n//使用带参闭包\ntest2(close2)\n// 占位符\ndef close3={\n    v->\n        println(\"test $v \")\n}\ntest2(close3)\n```\n\n## gradle 实践\n\n### 多模块\n\n在idea中构建多模块很简单，和maven操作一样，但项目结构有所不同。在父模块中有一个`settings.gradle`文件，指定了子模块包含哪些，而需要继承给子模块的东西需要在父模块`build.gradle`中配置`subprojects`闭包。\n\n父模块`build.gradle` 示例\n\n\n\n```groovy\n\nplugins {\n    id 'java'\n}\ngroup 'com.muggle'\nversion '1.0-SNAPSHOT'\nsourceCompatibility = 1.8\nrepositories {\n    mavenCentral()\n}\nsubprojects {\n    apply plugin: 'java'\n    apply plugin: 'idea'\n\n    version = '1.0'\n    // JVM 版本号要求\n    sourceCompatibility = 1.8\n    targetCompatibility = 1.8\n    // java编译的时候缺省状态下会因为中文字符而失败\n    [compileJava,compileTestJava,javadoc]*.options*.encoding = 'UTF-8'\n    //相当于maven的properties\n    ext {\n        springVersion = '4.3.3.RELEASE'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        // 通用依赖\n        compile(\n                \"org.springframework:spring-context:$springVersion\",\n                \"org.springframework:spring-orm:$springVersion\",\n        )\n        // 依赖maven中不存在的jar\n        ext.jarTree = fileTree(dir: 'libs', include: '**/*.jar')\n        // 测试依赖\n        testCompile(\n                \"org.springframework:spring-test:$springVersion\",\n                \"junit:junit:4.12\"\n        )\n    }\n    // 显示当前项目下所有用于 compile 的 jar.\n    task listJars(description: 'Display all compile jars.') << {\n        configurations.compile.each { File file -> println file.name }\n    }\n}\n```\n\n子模块模块之间相互依赖方式：\n\n```groovy\ndependencies{  \n    // 这个子模块 依赖 test 模块\n    compile project(\":test\")  \n}  \n```\n\n如果项目需要达成war包 添加插件`apply plugin: 'war'`。\n\n### task\n\ntask是gradle中的任务，包括任务动作(task action)和任务依赖(task dependency)。task代表细分的下来的构建任务：编译classes、生成jar包相关信息等一些任务。所以我们能编写task来控制打包过程。task和task之间也存在依赖关系，通过`task dependency`来指定。\n\n其实build指令本质就是执行各个task，在做protobuf开发的开发的时候我就可以通过配置task来在指定指定位置生成对应的java代码。\n\ntask 示例代码\n\n```java\ntask first {\n    doLast {\n        println \">>>>>>>>>>>>>>\"\n    }\n}\n```\n右击idea右侧gradle中的first执行task\n\n\t\t\t\t![demo.png](https://upload-images.jianshu.io/upload_images/13612520-25ae17571ab12d27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n控制台输出：\n```java\n\n> Task :first\n>>>>>>>>>>>>>>\n\n```\n\n\n\n## 总结\n\ngradle相较maven来说更灵活，但现在市场占有率最大的还是maven，gradle在安卓开发的领域使用比较多。看过spring源码的就知道，spring就是用gradle来管理的。读完本篇博客后我希望你能顺畅的使用gradle构建一个普通的java项目、一个springboot项目、一个多模块项目。感谢阅读。","slug":"gradle","published":1,"updated":"2021-01-11T07:31:23.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh62001e00wi5eoi29wd","content":"<h2 id=\"gradle介绍\"><a href=\"#gradle介绍\" class=\"headerlink\" title=\"gradle介绍\"></a>gradle介绍</h2><p>Gradle是一个构建工具，定位和maven一样，用于管理项目依赖和构建项目。和maven比起来的优势是：语法更灵活，更方便管理项目（个人很讨厌XML）。</p>\n<p>gradle具有以下特点：</p>\n<ul>\n<li>按约定声明构建和建设；</li>\n<li>强大的支持多工程的构建；</li>\n<li>强大的依赖管理（基于Apache Ivy），提供最大的便利去构建工程；</li>\n<li>全力支持已有的 Maven 或者Ivy仓库基础建设；</li>\n<li>支持传递性依赖管理；     </li>\n<li>基于groovy脚本构建，groovy简单易学；     </li>\n<li>具有广泛的领域模型支持构建； </li>\n<li>易迁移； </li>\n<li>自由和开放源码；</li>\n</ul>\n<a id=\"more\"></a>\n\n<p>可以说是maven有得gradle也有，maven没有的gradle也有。gradle在windows下安装也很简单，和maven一样：</p>\n<ol>\n<li>从<a href=\"https://gradle.org/releases/\">gradle官网</a> 下载安装包并解压</li>\n<li>将解压的文件夹路径配置到环境变量，先添加一个<code>GRADLE_HOME</code> 然后在path下添加 <code>%GRADLE_HOME%\\bin</code></li>\n<li>cmd跑 <code>gradle -v</code> 查看配置是否成功</li>\n<li><a href=\"https://docs.gradle.org/current/userguide/userguide.html\">gradle 用户手册</a> 方便平时查询相关操作</li>\n</ol>\n<h2 id=\"gradle的基本使用\"><a href=\"#gradle的基本使用\" class=\"headerlink\" title=\"gradle的基本使用\"></a>gradle的基本使用</h2><p>idea中已经集成gradle环境，你可以使用idea来构建gradle项目也可以通过命令行来使用gradle。在idea中 file-&gt; setting -&gt;搜索框输入gradle可查看gradle相关配置。</p>\n<h3 id=\"使用gradle新建项目\"><a href=\"#使用gradle新建项目\" class=\"headerlink\" title=\"使用gradle新建项目\"></a>使用gradle新建项目</h3><p>新建普通项目：<br><img src=\"https://upload-images.jianshu.io/upload_images/13612520-7aec3520435c32c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"new_normal.png\"><br>新建springboot项目：</p>\n<p>在如下图界面时选择<code>Gradle Project</code>即可 </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-cd7434a02af3bd86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"springboot.png\"></p>\n<h3 id=\"gradle项目结构及配置文件说明\"><a href=\"#gradle项目结构及配置文件说明\" class=\"headerlink\" title=\"gradle项目结构及配置文件说明\"></a>gradle项目结构及配置文件说明</h3><p>使用idea创建的gradle项目如图：<br><img src=\"https://upload-images.jianshu.io/upload_images/13612520-681237c249232a34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"dir.png\"></p>\n<p>src结构和maven无异，不再介绍；gradle文件夹 存放gradle wrapper相关文件；build.gradle相当于maven里面的pom.xml，setting.gradle用于多模块的配置。</p>\n<p>gradle wrapper是gradle项目构建工具，它能在本地没有gradle的情况下，从远程下载gradle并自动解压缩以构建项目，自动管理gradle版本。<code>gradle-wrapper.properties</code>是gradle wrapper的配置，<code>distributionUrl</code>指定本地没有配置gradle的情况下从哪下载gradle，<code>distributionBase</code>指定gradle下载和缓存jar的根目录，默认用户目录。在实际使用中我们一般不直接使用gradle，而是使用gradle wrapper,而对于idea而言我们可以不去关心两者区别，idea的gradle环境是基于gradle wrapper的</p>\n<p>build.gradle结构</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">group <span class=\"string\">&#x27;com.muggle&#x27;</span></span><br><span class=\"line\">version <span class=\"string\">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class=\"line\">sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    <span class=\"comment\">// mavenCentral()</span></span><br><span class=\"line\">    maven &#123; url <span class=\"string\">&quot;http://maven.aliyun.com/nexus/content/groups/public/&quot;</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    testCompile <span class=\"attr\">group:</span> <span class=\"string\">&#x27;junit&#x27;</span>, <span class=\"attr\">name:</span> <span class=\"string\">&#x27;junit&#x27;</span>, <span class=\"attr\">version:</span> <span class=\"string\">&#x27;4.12&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>节点说明</p>\n<ul>\n<li>sourceCompatibility：指定编译.java文件的jdk版本</li>\n<li>plugins：插件配置；格式为<code>id «plugin id» version «plugin version» [apply «false»]</code> Gradle的核心插件只需提供id的简称就可以</li>\n<li>repositories：仓库配置，<code>mavenCentral()</code>代表中央仓库，你也可以用<code>maven&#123;url  ‘&lt;url&gt;’&#125;</code>的方式添加一个仓库</li>\n<li>dependencies：依赖的坐标集合</li>\n</ul>\n<h3 id=\"dependencies说明\"><a href=\"#dependencies说明\" class=\"headerlink\" title=\"dependencies说明\"></a>dependencies说明</h3><p>在idea中，你复制好maven的xml格式依赖 直接粘贴到<code>dependencies</code>节点里面它会自动调整成<code>compile &#39;groupId :artifactId:version&#39;</code>而不需要我们手动去改（但似乎有个时候不管用）。</p>\n<p>在gradle中，项目依赖的格式为<code>作用范修饰符 &#39;groupId:artifactId:version&#39;</code>，作用范围修饰符包括</p>\n<ol>\n<li>complie：编译范围依赖在所有的 classpath 中可用，同时它们也会被打包，这个是最常用的</li>\n<li>runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。</li>\n<li>testComplie：测试期编译需要的附加依赖</li>\n<li>testRuntime：测试运行期需要</li>\n</ol>\n<h3 id=\"gradle打包\"><a href=\"#gradle打包\" class=\"headerlink\" title=\"gradle打包\"></a>gradle打包</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-d99c0ddc3495634b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"build.png\"><br>和在idea中使用maven一样，点击右侧gradle标签可看到上图相关gradle的操作，build对应的是<code>./gradlew build</code>命令；右键运行build会生成一个build文件夹 class文件和jar包都在里面。</p>\n<h2 id=\"groovy-语言简单学习\"><a href=\"#groovy-语言简单学习\" class=\"headerlink\" title=\"groovy 语言简单学习\"></a>groovy 语言简单学习</h2><p>Groovy 和java有很大程度上相似，学习成本低，只是为了更好使用gradle 简单学习Groovy </p>\n<p>在idea中打开groovy console 点击 tool-&gt;groovy console 打开</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-3d8398f4cdb5af0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"groovy.png\"></p>\n<p>写第一个程序</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一行注释</span></span><br><span class=\"line\">println (<span class=\"string\">&quot;test&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 简写</span></span><br><span class=\"line\">println <span class=\"string\">&quot;ssssss&quot;</span></span><br></pre></td></tr></table></figure>\n<p>ctrl+enter 执行代码</p>\n<p>list map的应用</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义变量 相当于var 弱类型</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> i=<span class=\"number\">15</span></span><br><span class=\"line\">println(i)</span><br><span class=\"line\"><span class=\"keyword\">def</span> s =<span class=\"string\">&quot;nihao&quot;</span></span><br><span class=\"line\">println s</span><br><span class=\"line\"><span class=\"comment\">// 集合定义</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> list=[<span class=\"string\">&#x27;s&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">list &lt;&lt; <span class=\"string\">&#x27;c&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 取出 元素</span></span><br><span class=\"line\">println list.get(<span class=\"number\">0</span>)</span><br><span class=\"line\">println list.get(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// map</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> map=[<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>]</span><br><span class=\"line\">println map.get(<span class=\"string\">&#x27;key&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 添</span></span><br><span class=\"line\">map.test=<span class=\"string\">&#x27;add&#x27;</span></span><br><span class=\"line\">println map.get(<span class=\"string\">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>闭包的语法</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 闭包 相当于函数式编程</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> close1=&#123;</span><br><span class=\"line\">    println <span class=\"string\">&quot;你好&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 方法定义</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> test(Closure closure)&#123;</span><br><span class=\"line\">    closure()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用闭包</span></span><br><span class=\"line\">test(close1)</span><br><span class=\"line\"><span class=\"comment\">// 带参闭包</span></span><br><span class=\"line\"><span class=\"keyword\">def</span>  close2=&#123;</span><br><span class=\"line\">    v-&gt; println v+v+v</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> test2(Closure closure)&#123;</span><br><span class=\"line\">    closure(<span class=\"string\">&quot;sss&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用带参闭包</span></span><br><span class=\"line\">test2(close2)</span><br><span class=\"line\"><span class=\"comment\">// 占位符</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> close3=&#123;</span><br><span class=\"line\">    v-&gt;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;test $v &quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test2(close3)</span><br></pre></td></tr></table></figure>\n<h2 id=\"gradle-实践\"><a href=\"#gradle-实践\" class=\"headerlink\" title=\"gradle 实践\"></a>gradle 实践</h2><h3 id=\"多模块\"><a href=\"#多模块\" class=\"headerlink\" title=\"多模块\"></a>多模块</h3><p>在idea中构建多模块很简单，和maven操作一样，但项目结构有所不同。在父模块中有一个<code>settings.gradle</code>文件，指定了子模块包含哪些，而需要继承给子模块的东西需要在父模块<code>build.gradle</code>中配置<code>subprojects</code>闭包。</p>\n<p>父模块<code>build.gradle</code> 示例</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">group <span class=\"string\">&#x27;com.muggle&#x27;</span></span><br><span class=\"line\">version <span class=\"string\">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class=\"line\">sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">    apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;idea&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    version = <span class=\"string\">&#x27;1.0&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// JVM 版本号要求</span></span><br><span class=\"line\">    sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">    targetCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">    <span class=\"comment\">// java编译的时候缺省状态下会因为中文字符而失败</span></span><br><span class=\"line\">    [compileJava,compileTestJava,javadoc]*.options*.encoding = <span class=\"string\">&#x27;UTF-8&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//相当于maven的properties</span></span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        springVersion = <span class=\"string\">&#x27;4.3.3.RELEASE&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通用依赖</span></span><br><span class=\"line\">        compile(</span><br><span class=\"line\">                <span class=\"string\">&quot;org.springframework:spring-context:$springVersion&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;org.springframework:spring-orm:$springVersion&quot;</span>,</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"comment\">// 依赖maven中不存在的jar</span></span><br><span class=\"line\">        ext.jarTree = fileTree(<span class=\"attr\">dir:</span> <span class=\"string\">&#x27;libs&#x27;</span>, <span class=\"attr\">include:</span> <span class=\"string\">&#x27;**/*.jar&#x27;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 测试依赖</span></span><br><span class=\"line\">        testCompile(</span><br><span class=\"line\">                <span class=\"string\">&quot;org.springframework:spring-test:$springVersion&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;junit:junit:4.12&quot;</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 显示当前项目下所有用于 compile 的 jar.</span></span><br><span class=\"line\">    task listJars(<span class=\"attr\">description:</span> <span class=\"string\">&#x27;Display all compile jars.&#x27;</span>) &lt;&lt; &#123;</span><br><span class=\"line\">        configurations.compile.each &#123; File file -&gt; println file.name &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>子模块模块之间相互依赖方式：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 这个子模块 依赖 test 模块</span></span><br><span class=\"line\">    compile project(<span class=\"string\">&quot;:test&quot;</span>)  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>如果项目需要达成war包 添加插件<code>apply plugin: &#39;war&#39;</code>。</p>\n<h3 id=\"task\"><a href=\"#task\" class=\"headerlink\" title=\"task\"></a>task</h3><p>task是gradle中的任务，包括任务动作(task action)和任务依赖(task dependency)。task代表细分的下来的构建任务：编译classes、生成jar包相关信息等一些任务。所以我们能编写task来控制打包过程。task和task之间也存在依赖关系，通过<code>task dependency</code>来指定。</p>\n<p>其实build指令本质就是执行各个task，在做protobuf开发的开发的时候我就可以通过配置task来在指定指定位置生成对应的java代码。</p>\n<p>task 示例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task first &#123;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        println <span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>右击idea右侧gradle中的first执行task</p>\n<pre><code>![demo.png](https://upload-images.jianshu.io/upload_images/13612520-25ae17571ab12d27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></pre><p>控制台输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; Task :first</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>gradle相较maven来说更灵活，但现在市场占有率最大的还是maven，gradle在安卓开发的领域使用比较多。看过spring源码的就知道，spring就是用gradle来管理的。读完本篇博客后我希望你能顺畅的使用gradle构建一个普通的java项目、一个springboot项目、一个多模块项目。感谢阅读。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"gradle介绍\"><a href=\"#gradle介绍\" class=\"headerlink\" title=\"gradle介绍\"></a>gradle介绍</h2><p>Gradle是一个构建工具，定位和maven一样，用于管理项目依赖和构建项目。和maven比起来的优势是：语法更灵活，更方便管理项目（个人很讨厌XML）。</p>\n<p>gradle具有以下特点：</p>\n<ul>\n<li>按约定声明构建和建设；</li>\n<li>强大的支持多工程的构建；</li>\n<li>强大的依赖管理（基于Apache Ivy），提供最大的便利去构建工程；</li>\n<li>全力支持已有的 Maven 或者Ivy仓库基础建设；</li>\n<li>支持传递性依赖管理；     </li>\n<li>基于groovy脚本构建，groovy简单易学；     </li>\n<li>具有广泛的领域模型支持构建； </li>\n<li>易迁移； </li>\n<li>自由和开放源码；</li>\n</ul>","more":"<p>可以说是maven有得gradle也有，maven没有的gradle也有。gradle在windows下安装也很简单，和maven一样：</p>\n<ol>\n<li>从<a href=\"https://gradle.org/releases/\">gradle官网</a> 下载安装包并解压</li>\n<li>将解压的文件夹路径配置到环境变量，先添加一个<code>GRADLE_HOME</code> 然后在path下添加 <code>%GRADLE_HOME%\\bin</code></li>\n<li>cmd跑 <code>gradle -v</code> 查看配置是否成功</li>\n<li><a href=\"https://docs.gradle.org/current/userguide/userguide.html\">gradle 用户手册</a> 方便平时查询相关操作</li>\n</ol>\n<h2 id=\"gradle的基本使用\"><a href=\"#gradle的基本使用\" class=\"headerlink\" title=\"gradle的基本使用\"></a>gradle的基本使用</h2><p>idea中已经集成gradle环境，你可以使用idea来构建gradle项目也可以通过命令行来使用gradle。在idea中 file-&gt; setting -&gt;搜索框输入gradle可查看gradle相关配置。</p>\n<h3 id=\"使用gradle新建项目\"><a href=\"#使用gradle新建项目\" class=\"headerlink\" title=\"使用gradle新建项目\"></a>使用gradle新建项目</h3><p>新建普通项目：<br><img src=\"https://upload-images.jianshu.io/upload_images/13612520-7aec3520435c32c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"new_normal.png\"><br>新建springboot项目：</p>\n<p>在如下图界面时选择<code>Gradle Project</code>即可 </p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-cd7434a02af3bd86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"springboot.png\"></p>\n<h3 id=\"gradle项目结构及配置文件说明\"><a href=\"#gradle项目结构及配置文件说明\" class=\"headerlink\" title=\"gradle项目结构及配置文件说明\"></a>gradle项目结构及配置文件说明</h3><p>使用idea创建的gradle项目如图：<br><img src=\"https://upload-images.jianshu.io/upload_images/13612520-681237c249232a34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"dir.png\"></p>\n<p>src结构和maven无异，不再介绍；gradle文件夹 存放gradle wrapper相关文件；build.gradle相当于maven里面的pom.xml，setting.gradle用于多模块的配置。</p>\n<p>gradle wrapper是gradle项目构建工具，它能在本地没有gradle的情况下，从远程下载gradle并自动解压缩以构建项目，自动管理gradle版本。<code>gradle-wrapper.properties</code>是gradle wrapper的配置，<code>distributionUrl</code>指定本地没有配置gradle的情况下从哪下载gradle，<code>distributionBase</code>指定gradle下载和缓存jar的根目录，默认用户目录。在实际使用中我们一般不直接使用gradle，而是使用gradle wrapper,而对于idea而言我们可以不去关心两者区别，idea的gradle环境是基于gradle wrapper的</p>\n<p>build.gradle结构</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">group <span class=\"string\">&#x27;com.muggle&#x27;</span></span><br><span class=\"line\">version <span class=\"string\">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class=\"line\">sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    <span class=\"comment\">// mavenCentral()</span></span><br><span class=\"line\">    maven &#123; url <span class=\"string\">&quot;http://maven.aliyun.com/nexus/content/groups/public/&quot;</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    testCompile <span class=\"attr\">group:</span> <span class=\"string\">&#x27;junit&#x27;</span>, <span class=\"attr\">name:</span> <span class=\"string\">&#x27;junit&#x27;</span>, <span class=\"attr\">version:</span> <span class=\"string\">&#x27;4.12&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>节点说明</p>\n<ul>\n<li>sourceCompatibility：指定编译.java文件的jdk版本</li>\n<li>plugins：插件配置；格式为<code>id «plugin id» version «plugin version» [apply «false»]</code> Gradle的核心插件只需提供id的简称就可以</li>\n<li>repositories：仓库配置，<code>mavenCentral()</code>代表中央仓库，你也可以用<code>maven&#123;url  ‘&lt;url&gt;’&#125;</code>的方式添加一个仓库</li>\n<li>dependencies：依赖的坐标集合</li>\n</ul>\n<h3 id=\"dependencies说明\"><a href=\"#dependencies说明\" class=\"headerlink\" title=\"dependencies说明\"></a>dependencies说明</h3><p>在idea中，你复制好maven的xml格式依赖 直接粘贴到<code>dependencies</code>节点里面它会自动调整成<code>compile &#39;groupId :artifactId:version&#39;</code>而不需要我们手动去改（但似乎有个时候不管用）。</p>\n<p>在gradle中，项目依赖的格式为<code>作用范修饰符 &#39;groupId:artifactId:version&#39;</code>，作用范围修饰符包括</p>\n<ol>\n<li>complie：编译范围依赖在所有的 classpath 中可用，同时它们也会被打包，这个是最常用的</li>\n<li>runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。</li>\n<li>testComplie：测试期编译需要的附加依赖</li>\n<li>testRuntime：测试运行期需要</li>\n</ol>\n<h3 id=\"gradle打包\"><a href=\"#gradle打包\" class=\"headerlink\" title=\"gradle打包\"></a>gradle打包</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-d99c0ddc3495634b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"build.png\"><br>和在idea中使用maven一样，点击右侧gradle标签可看到上图相关gradle的操作，build对应的是<code>./gradlew build</code>命令；右键运行build会生成一个build文件夹 class文件和jar包都在里面。</p>\n<h2 id=\"groovy-语言简单学习\"><a href=\"#groovy-语言简单学习\" class=\"headerlink\" title=\"groovy 语言简单学习\"></a>groovy 语言简单学习</h2><p>Groovy 和java有很大程度上相似，学习成本低，只是为了更好使用gradle 简单学习Groovy </p>\n<p>在idea中打开groovy console 点击 tool-&gt;groovy console 打开</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-3d8398f4cdb5af0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"groovy.png\"></p>\n<p>写第一个程序</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一行注释</span></span><br><span class=\"line\">println (<span class=\"string\">&quot;test&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 简写</span></span><br><span class=\"line\">println <span class=\"string\">&quot;ssssss&quot;</span></span><br></pre></td></tr></table></figure>\n<p>ctrl+enter 执行代码</p>\n<p>list map的应用</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义变量 相当于var 弱类型</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> i=<span class=\"number\">15</span></span><br><span class=\"line\">println(i)</span><br><span class=\"line\"><span class=\"keyword\">def</span> s =<span class=\"string\">&quot;nihao&quot;</span></span><br><span class=\"line\">println s</span><br><span class=\"line\"><span class=\"comment\">// 集合定义</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> list=[<span class=\"string\">&#x27;s&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">list &lt;&lt; <span class=\"string\">&#x27;c&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 取出 元素</span></span><br><span class=\"line\">println list.get(<span class=\"number\">0</span>)</span><br><span class=\"line\">println list.get(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// map</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> map=[<span class=\"string\">&#x27;key&#x27;</span>:<span class=\"string\">&#x27;value&#x27;</span>]</span><br><span class=\"line\">println map.get(<span class=\"string\">&#x27;key&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 添</span></span><br><span class=\"line\">map.test=<span class=\"string\">&#x27;add&#x27;</span></span><br><span class=\"line\">println map.get(<span class=\"string\">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>闭包的语法</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 闭包 相当于函数式编程</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> close1=&#123;</span><br><span class=\"line\">    println <span class=\"string\">&quot;你好&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 方法定义</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> test(Closure closure)&#123;</span><br><span class=\"line\">    closure()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用闭包</span></span><br><span class=\"line\">test(close1)</span><br><span class=\"line\"><span class=\"comment\">// 带参闭包</span></span><br><span class=\"line\"><span class=\"keyword\">def</span>  close2=&#123;</span><br><span class=\"line\">    v-&gt; println v+v+v</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> test2(Closure closure)&#123;</span><br><span class=\"line\">    closure(<span class=\"string\">&quot;sss&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用带参闭包</span></span><br><span class=\"line\">test2(close2)</span><br><span class=\"line\"><span class=\"comment\">// 占位符</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> close3=&#123;</span><br><span class=\"line\">    v-&gt;</span><br><span class=\"line\">        println(<span class=\"string\">&quot;test $v &quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test2(close3)</span><br></pre></td></tr></table></figure>\n<h2 id=\"gradle-实践\"><a href=\"#gradle-实践\" class=\"headerlink\" title=\"gradle 实践\"></a>gradle 实践</h2><h3 id=\"多模块\"><a href=\"#多模块\" class=\"headerlink\" title=\"多模块\"></a>多模块</h3><p>在idea中构建多模块很简单，和maven操作一样，但项目结构有所不同。在父模块中有一个<code>settings.gradle</code>文件，指定了子模块包含哪些，而需要继承给子模块的东西需要在父模块<code>build.gradle</code>中配置<code>subprojects</code>闭包。</p>\n<p>父模块<code>build.gradle</code> 示例</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">plugins &#123;</span><br><span class=\"line\">    id <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">group <span class=\"string\">&#x27;com.muggle&#x27;</span></span><br><span class=\"line\">version <span class=\"string\">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class=\"line\">sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">subprojects &#123;</span><br><span class=\"line\">    apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;java&#x27;</span></span><br><span class=\"line\">    apply <span class=\"attr\">plugin:</span> <span class=\"string\">&#x27;idea&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    version = <span class=\"string\">&#x27;1.0&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// JVM 版本号要求</span></span><br><span class=\"line\">    sourceCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">    targetCompatibility = <span class=\"number\">1.8</span></span><br><span class=\"line\">    <span class=\"comment\">// java编译的时候缺省状态下会因为中文字符而失败</span></span><br><span class=\"line\">    [compileJava,compileTestJava,javadoc]*.options*.encoding = <span class=\"string\">&#x27;UTF-8&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">//相当于maven的properties</span></span><br><span class=\"line\">    ext &#123;</span><br><span class=\"line\">        springVersion = <span class=\"string\">&#x27;4.3.3.RELEASE&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通用依赖</span></span><br><span class=\"line\">        compile(</span><br><span class=\"line\">                <span class=\"string\">&quot;org.springframework:spring-context:$springVersion&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;org.springframework:spring-orm:$springVersion&quot;</span>,</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"comment\">// 依赖maven中不存在的jar</span></span><br><span class=\"line\">        ext.jarTree = fileTree(<span class=\"attr\">dir:</span> <span class=\"string\">&#x27;libs&#x27;</span>, <span class=\"attr\">include:</span> <span class=\"string\">&#x27;**/*.jar&#x27;</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 测试依赖</span></span><br><span class=\"line\">        testCompile(</span><br><span class=\"line\">                <span class=\"string\">&quot;org.springframework:spring-test:$springVersion&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;junit:junit:4.12&quot;</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 显示当前项目下所有用于 compile 的 jar.</span></span><br><span class=\"line\">    task listJars(<span class=\"attr\">description:</span> <span class=\"string\">&#x27;Display all compile jars.&#x27;</span>) &lt;&lt; &#123;</span><br><span class=\"line\">        configurations.compile.each &#123; File file -&gt; println file.name &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>子模块模块之间相互依赖方式：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 这个子模块 依赖 test 模块</span></span><br><span class=\"line\">    compile project(<span class=\"string\">&quot;:test&quot;</span>)  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>如果项目需要达成war包 添加插件<code>apply plugin: &#39;war&#39;</code>。</p>\n<h3 id=\"task\"><a href=\"#task\" class=\"headerlink\" title=\"task\"></a>task</h3><p>task是gradle中的任务，包括任务动作(task action)和任务依赖(task dependency)。task代表细分的下来的构建任务：编译classes、生成jar包相关信息等一些任务。所以我们能编写task来控制打包过程。task和task之间也存在依赖关系，通过<code>task dependency</code>来指定。</p>\n<p>其实build指令本质就是执行各个task，在做protobuf开发的开发的时候我就可以通过配置task来在指定指定位置生成对应的java代码。</p>\n<p>task 示例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task first &#123;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        println <span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>右击idea右侧gradle中的first执行task</p>\n<pre><code>![demo.png](https://upload-images.jianshu.io/upload_images/13612520-25ae17571ab12d27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code></pre><p>控制台输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; Task :first</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>gradle相较maven来说更灵活，但现在市场占有率最大的还是maven，gradle在安卓开发的领域使用比较多。看过spring源码的就知道，spring就是用gradle来管理的。读完本篇博客后我希望你能顺畅的使用gradle构建一个普通的java项目、一个springboot项目、一个多模块项目。感谢阅读。</p>"},{"title":"好文收集","date":"2019-04-27T09:13:56.000Z","_content":"\n**此文记录了平时觉得写得很好的博客**\n\n[事物传播机制的一个实验](<https://segmentfault.com/a/1190000013341344#articleHeader16>)\n\n[guava使用教程](https://www.yiibai.com/guava)\n\n<!--more-->\n\n[梯子教程](https://ssr.tools/269)\n\n[数据校验框架](https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#_code_methoddescriptor_code_and_code_constructordescriptor_code)\n\n[springboot二次封装](https://juejin.im/post/5cbfadeae51d456e425dd9cf)  ----里面的一些做法我不是很认同\n\n[分布式事物](https://www.cnblogs.com/jiangyu666/p/8522547.html)\n\n[flowable用户手册](https://tkjohn.github.io/flowable-userguide/#_changing_the_database_and_connection_pool)\n\n[关于应用优化的一些思考](https://zhuanlan.zhihu.com/p/24726196)\n\n[spring依赖注入的一个黑科技用法](https://blog.csdn.net/wo541075754/article/details/71514427)\n\n[谷歌白嫖教程](https://suchenrain.github.io/en/posts/37388/)\n\n[springboot异步](http://blog.didispace.com/springbootasync/) -----话说程序员DD的博客质量挺高\n\n[一个大佬的博客](https://blog.lqdev.cn/) ----干货很多，很低调\n\n[江南一点雨的es大作](https://mp.weixin.qq.com/s/Qy0q-IKJFZ0DwL7vMjBi1A) —— 江大师的redis docker 也写的很棒\n\n[java spi](https://www.cnblogs.com/huzi007/p/6679215.html)\n\n[库存设计的思考](<https://my.oschina.net/yangyishe/blog/1927466>)\n\n[Seata-Cient](<https://mp.weixin.qq.com/s/OYzwKcGrpc8Spt-wlVssSQ>)\n\n[oauth2](<https://segmentfault.com/a/1190000014687027>)  [oauth2](<https://www.cnblogs.com/LOVE0612/p/9913336.html>)\n\n","source":"_posts/home-2.md","raw":"---\ntitle: 好文收集\ndate: 2019-04-27 17:13:56\ntags: home\n---\n\n**此文记录了平时觉得写得很好的博客**\n\n[事物传播机制的一个实验](<https://segmentfault.com/a/1190000013341344#articleHeader16>)\n\n[guava使用教程](https://www.yiibai.com/guava)\n\n<!--more-->\n\n[梯子教程](https://ssr.tools/269)\n\n[数据校验框架](https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#_code_methoddescriptor_code_and_code_constructordescriptor_code)\n\n[springboot二次封装](https://juejin.im/post/5cbfadeae51d456e425dd9cf)  ----里面的一些做法我不是很认同\n\n[分布式事物](https://www.cnblogs.com/jiangyu666/p/8522547.html)\n\n[flowable用户手册](https://tkjohn.github.io/flowable-userguide/#_changing_the_database_and_connection_pool)\n\n[关于应用优化的一些思考](https://zhuanlan.zhihu.com/p/24726196)\n\n[spring依赖注入的一个黑科技用法](https://blog.csdn.net/wo541075754/article/details/71514427)\n\n[谷歌白嫖教程](https://suchenrain.github.io/en/posts/37388/)\n\n[springboot异步](http://blog.didispace.com/springbootasync/) -----话说程序员DD的博客质量挺高\n\n[一个大佬的博客](https://blog.lqdev.cn/) ----干货很多，很低调\n\n[江南一点雨的es大作](https://mp.weixin.qq.com/s/Qy0q-IKJFZ0DwL7vMjBi1A) —— 江大师的redis docker 也写的很棒\n\n[java spi](https://www.cnblogs.com/huzi007/p/6679215.html)\n\n[库存设计的思考](<https://my.oschina.net/yangyishe/blog/1927466>)\n\n[Seata-Cient](<https://mp.weixin.qq.com/s/OYzwKcGrpc8Spt-wlVssSQ>)\n\n[oauth2](<https://segmentfault.com/a/1190000014687027>)  [oauth2](<https://www.cnblogs.com/LOVE0612/p/9913336.html>)\n\n","slug":"home-2","published":1,"updated":"2021-01-11T07:31:23.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh64001g00wi57hq4kex","content":"<p><strong>此文记录了平时觉得写得很好的博客</strong></p>\n<p><a href=\"https://segmentfault.com/a/1190000013341344#articleHeader16\">事物传播机制的一个实验</a></p>\n<p><a href=\"https://www.yiibai.com/guava\">guava使用教程</a></p>\n<a id=\"more\"></a>\n\n<p><a href=\"https://ssr.tools/269\">梯子教程</a></p>\n<p><a href=\"https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#_code_methoddescriptor_code_and_code_constructordescriptor_code\">数据校验框架</a></p>\n<p><a href=\"https://juejin.im/post/5cbfadeae51d456e425dd9cf\">springboot二次封装</a>  —-里面的一些做法我不是很认同</p>\n<p><a href=\"https://www.cnblogs.com/jiangyu666/p/8522547.html\">分布式事物</a></p>\n<p><a href=\"https://tkjohn.github.io/flowable-userguide/#_changing_the_database_and_connection_pool\">flowable用户手册</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/24726196\">关于应用优化的一些思考</a></p>\n<p><a href=\"https://blog.csdn.net/wo541075754/article/details/71514427\">spring依赖注入的一个黑科技用法</a></p>\n<p><a href=\"https://suchenrain.github.io/en/posts/37388/\">谷歌白嫖教程</a></p>\n<p><a href=\"http://blog.didispace.com/springbootasync/\">springboot异步</a> —–话说程序员DD的博客质量挺高</p>\n<p><a href=\"https://blog.lqdev.cn/\">一个大佬的博客</a> —-干货很多，很低调</p>\n<p><a href=\"https://mp.weixin.qq.com/s/Qy0q-IKJFZ0DwL7vMjBi1A\">江南一点雨的es大作</a> —— 江大师的redis docker 也写的很棒</p>\n<p><a href=\"https://www.cnblogs.com/huzi007/p/6679215.html\">java spi</a></p>\n<p><a href=\"https://my.oschina.net/yangyishe/blog/1927466\">库存设计的思考</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/OYzwKcGrpc8Spt-wlVssSQ\">Seata-Cient</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000014687027\">oauth2</a>  <a href=\"https://www.cnblogs.com/LOVE0612/p/9913336.html\">oauth2</a></p>\n","site":{"data":{}},"excerpt":"<p><strong>此文记录了平时觉得写得很好的博客</strong></p>\n<p><a href=\"https://segmentfault.com/a/1190000013341344#articleHeader16\">事物传播机制的一个实验</a></p>\n<p><a href=\"https://www.yiibai.com/guava\">guava使用教程</a></p>","more":"<p><a href=\"https://ssr.tools/269\">梯子教程</a></p>\n<p><a href=\"https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#_code_methoddescriptor_code_and_code_constructordescriptor_code\">数据校验框架</a></p>\n<p><a href=\"https://juejin.im/post/5cbfadeae51d456e425dd9cf\">springboot二次封装</a>  —-里面的一些做法我不是很认同</p>\n<p><a href=\"https://www.cnblogs.com/jiangyu666/p/8522547.html\">分布式事物</a></p>\n<p><a href=\"https://tkjohn.github.io/flowable-userguide/#_changing_the_database_and_connection_pool\">flowable用户手册</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/24726196\">关于应用优化的一些思考</a></p>\n<p><a href=\"https://blog.csdn.net/wo541075754/article/details/71514427\">spring依赖注入的一个黑科技用法</a></p>\n<p><a href=\"https://suchenrain.github.io/en/posts/37388/\">谷歌白嫖教程</a></p>\n<p><a href=\"http://blog.didispace.com/springbootasync/\">springboot异步</a> —–话说程序员DD的博客质量挺高</p>\n<p><a href=\"https://blog.lqdev.cn/\">一个大佬的博客</a> —-干货很多，很低调</p>\n<p><a href=\"https://mp.weixin.qq.com/s/Qy0q-IKJFZ0DwL7vMjBi1A\">江南一点雨的es大作</a> —— 江大师的redis docker 也写的很棒</p>\n<p><a href=\"https://www.cnblogs.com/huzi007/p/6679215.html\">java spi</a></p>\n<p><a href=\"https://my.oschina.net/yangyishe/blog/1927466\">库存设计的思考</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s/OYzwKcGrpc8Spt-wlVssSQ\">Seata-Cient</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000014687027\">oauth2</a>  <a href=\"https://www.cnblogs.com/LOVE0612/p/9913336.html\">oauth2</a></p>"},{"title":"草稿箱","date":"2019-03-27T03:53:49.000Z","_content":"\n```\n/*\n    * 第一个问题：虽然被包装过的list是线程安全的，但返回的list获得的Iterator仍然是线程不安全的，所以仍然要用Synchronized代码块包裹起来。\n\n至于第二个问题，其实上面的文章链接也有提到, 大意是：与其所有（多线程）要用到该list都加上Synchronized修饰，还不如直接使用安全的collection更聪明。\n\n也就是说，如果不使用Iterator迭代器的话，使用了安全的collection以后，其实我们不需要再用Synchronized代码块修饰了，这样使用上更方便。\n\n反过来说，使用Iterator迭代器的话，似乎也没必要用Collections.synchronizedList的方法来包装了——反正都是必须要使用Synchronized代码块包起来的。\n\n所以总的来说，Collections.synchronizedXX这种做法，适合不需要使用Iterator、对性能要求也不高的情况。\n    *\n    * */\n\n\n\n/*\n*\n*  这就是所谓的线程安全的类，在多线程中一样会有问题，那这是为什么呢。后来在一篇博文当中看到了说Vector的contains方法和remove方法之前不具备原子性，这点给了提示。\n*  我现在认为出错的原因是在get和remove之间并没有在以上环境中做到同步，比方说，一个线程的get（2）操作发生时，正好遇到了remove操作的正在进行，这时get（2）这个操作就会阻塞，\n*  等待remove操作释放锁之后去操作。如果这时候remove操作的正好是remov（2）这个操作，等到去get的时候，这个元素已经没有了，get自然就只能是空欢喜一场。\n    这里原因找到了，就该说解决办法了，在说解决办法之前，可能还会困惑，说好的线程安全呢，\n    我的理解是，线程安全并不代表使用安全，在实际使用时还是需要考虑当前环境中是否会出现问题的。那么问题来了，java提供线程安全的某些类的意义在哪里呢，反正还是会出问题。\n    这就显得比较鸡肋了，但是也不能说没有意义，毕竟写程序还是要独立思考的。\n    解决办法就比较简单了，在两个线程的run方法里加上synchronized (testVector)，这样就会使得读取、删除线程中只会有一个对testVector进行操作，也就不会有上述情况出现。\n    从这个错误来看的话，编程一定要谨慎，使用到的技术一定要深入了解，不能说不出问题，但是在出了问题之后能找出原因并解决，\n    如果没有这个把握就不要轻易去使用，尤其在正式项目中，可能会让你欲哭无泪啊！\n\n* */\n```\n\n## 队列\n\n- deque 双端对列\n- queue 阻塞队列 ArrayBlockingQueue ：一个由数组支持的有界队列。LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。\n- PriorityQueue 和 ConcurrentLinkedQueue 非阻塞队列","source":"_posts/home-3.md","raw":"---\ntitle: 草稿箱\ndate: 2019-03-27 11:53:49\ntags: home\n---\n\n```\n/*\n    * 第一个问题：虽然被包装过的list是线程安全的，但返回的list获得的Iterator仍然是线程不安全的，所以仍然要用Synchronized代码块包裹起来。\n\n至于第二个问题，其实上面的文章链接也有提到, 大意是：与其所有（多线程）要用到该list都加上Synchronized修饰，还不如直接使用安全的collection更聪明。\n\n也就是说，如果不使用Iterator迭代器的话，使用了安全的collection以后，其实我们不需要再用Synchronized代码块修饰了，这样使用上更方便。\n\n反过来说，使用Iterator迭代器的话，似乎也没必要用Collections.synchronizedList的方法来包装了——反正都是必须要使用Synchronized代码块包起来的。\n\n所以总的来说，Collections.synchronizedXX这种做法，适合不需要使用Iterator、对性能要求也不高的情况。\n    *\n    * */\n\n\n\n/*\n*\n*  这就是所谓的线程安全的类，在多线程中一样会有问题，那这是为什么呢。后来在一篇博文当中看到了说Vector的contains方法和remove方法之前不具备原子性，这点给了提示。\n*  我现在认为出错的原因是在get和remove之间并没有在以上环境中做到同步，比方说，一个线程的get（2）操作发生时，正好遇到了remove操作的正在进行，这时get（2）这个操作就会阻塞，\n*  等待remove操作释放锁之后去操作。如果这时候remove操作的正好是remov（2）这个操作，等到去get的时候，这个元素已经没有了，get自然就只能是空欢喜一场。\n    这里原因找到了，就该说解决办法了，在说解决办法之前，可能还会困惑，说好的线程安全呢，\n    我的理解是，线程安全并不代表使用安全，在实际使用时还是需要考虑当前环境中是否会出现问题的。那么问题来了，java提供线程安全的某些类的意义在哪里呢，反正还是会出问题。\n    这就显得比较鸡肋了，但是也不能说没有意义，毕竟写程序还是要独立思考的。\n    解决办法就比较简单了，在两个线程的run方法里加上synchronized (testVector)，这样就会使得读取、删除线程中只会有一个对testVector进行操作，也就不会有上述情况出现。\n    从这个错误来看的话，编程一定要谨慎，使用到的技术一定要深入了解，不能说不出问题，但是在出了问题之后能找出原因并解决，\n    如果没有这个把握就不要轻易去使用，尤其在正式项目中，可能会让你欲哭无泪啊！\n\n* */\n```\n\n## 队列\n\n- deque 双端对列\n- queue 阻塞队列 ArrayBlockingQueue ：一个由数组支持的有界队列。LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。\n- PriorityQueue 和 ConcurrentLinkedQueue 非阻塞队列","slug":"home-3","published":1,"updated":"2021-01-11T07:31:23.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh65001j00wic5pien8r","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\">    * 第一个问题：虽然被包装过的list是线程安全的，但返回的list获得的Iterator仍然是线程不安全的，所以仍然要用Synchronized代码块包裹起来。</span><br><span class=\"line\"></span><br><span class=\"line\">至于第二个问题，其实上面的文章链接也有提到, 大意是：与其所有（多线程）要用到该list都加上Synchronized修饰，还不如直接使用安全的collection更聪明。</span><br><span class=\"line\"></span><br><span class=\"line\">也就是说，如果不使用Iterator迭代器的话，使用了安全的collection以后，其实我们不需要再用Synchronized代码块修饰了，这样使用上更方便。</span><br><span class=\"line\"></span><br><span class=\"line\">反过来说，使用Iterator迭代器的话，似乎也没必要用Collections.synchronizedList的方法来包装了——反正都是必须要使用Synchronized代码块包起来的。</span><br><span class=\"line\"></span><br><span class=\"line\">所以总的来说，Collections.synchronizedXX这种做法，适合不需要使用Iterator、对性能要求也不高的情况。</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\">*</span><br><span class=\"line\">*  这就是所谓的线程安全的类，在多线程中一样会有问题，那这是为什么呢。后来在一篇博文当中看到了说Vector的contains方法和remove方法之前不具备原子性，这点给了提示。</span><br><span class=\"line\">*  我现在认为出错的原因是在get和remove之间并没有在以上环境中做到同步，比方说，一个线程的get（2）操作发生时，正好遇到了remove操作的正在进行，这时get（2）这个操作就会阻塞，</span><br><span class=\"line\">*  等待remove操作释放锁之后去操作。如果这时候remove操作的正好是remov（2）这个操作，等到去get的时候，这个元素已经没有了，get自然就只能是空欢喜一场。</span><br><span class=\"line\">    这里原因找到了，就该说解决办法了，在说解决办法之前，可能还会困惑，说好的线程安全呢，</span><br><span class=\"line\">    我的理解是，线程安全并不代表使用安全，在实际使用时还是需要考虑当前环境中是否会出现问题的。那么问题来了，java提供线程安全的某些类的意义在哪里呢，反正还是会出问题。</span><br><span class=\"line\">    这就显得比较鸡肋了，但是也不能说没有意义，毕竟写程序还是要独立思考的。</span><br><span class=\"line\">    解决办法就比较简单了，在两个线程的run方法里加上synchronized (testVector)，这样就会使得读取、删除线程中只会有一个对testVector进行操作，也就不会有上述情况出现。</span><br><span class=\"line\">    从这个错误来看的话，编程一定要谨慎，使用到的技术一定要深入了解，不能说不出问题，但是在出了问题之后能找出原因并解决，</span><br><span class=\"line\">    如果没有这个把握就不要轻易去使用，尤其在正式项目中，可能会让你欲哭无泪啊！</span><br><span class=\"line\"></span><br><span class=\"line\">* *&#x2F;</span><br></pre></td></tr></table></figure>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li>deque 双端对列</li>\n<li>queue 阻塞队列 ArrayBlockingQueue ：一个由数组支持的有界队列。LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。</li>\n<li>PriorityQueue 和 ConcurrentLinkedQueue 非阻塞队列</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*</span><br><span class=\"line\">    * 第一个问题：虽然被包装过的list是线程安全的，但返回的list获得的Iterator仍然是线程不安全的，所以仍然要用Synchronized代码块包裹起来。</span><br><span class=\"line\"></span><br><span class=\"line\">至于第二个问题，其实上面的文章链接也有提到, 大意是：与其所有（多线程）要用到该list都加上Synchronized修饰，还不如直接使用安全的collection更聪明。</span><br><span class=\"line\"></span><br><span class=\"line\">也就是说，如果不使用Iterator迭代器的话，使用了安全的collection以后，其实我们不需要再用Synchronized代码块修饰了，这样使用上更方便。</span><br><span class=\"line\"></span><br><span class=\"line\">反过来说，使用Iterator迭代器的话，似乎也没必要用Collections.synchronizedList的方法来包装了——反正都是必须要使用Synchronized代码块包起来的。</span><br><span class=\"line\"></span><br><span class=\"line\">所以总的来说，Collections.synchronizedXX这种做法，适合不需要使用Iterator、对性能要求也不高的情况。</span><br><span class=\"line\">    *</span><br><span class=\"line\">    * *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\">*</span><br><span class=\"line\">*  这就是所谓的线程安全的类，在多线程中一样会有问题，那这是为什么呢。后来在一篇博文当中看到了说Vector的contains方法和remove方法之前不具备原子性，这点给了提示。</span><br><span class=\"line\">*  我现在认为出错的原因是在get和remove之间并没有在以上环境中做到同步，比方说，一个线程的get（2）操作发生时，正好遇到了remove操作的正在进行，这时get（2）这个操作就会阻塞，</span><br><span class=\"line\">*  等待remove操作释放锁之后去操作。如果这时候remove操作的正好是remov（2）这个操作，等到去get的时候，这个元素已经没有了，get自然就只能是空欢喜一场。</span><br><span class=\"line\">    这里原因找到了，就该说解决办法了，在说解决办法之前，可能还会困惑，说好的线程安全呢，</span><br><span class=\"line\">    我的理解是，线程安全并不代表使用安全，在实际使用时还是需要考虑当前环境中是否会出现问题的。那么问题来了，java提供线程安全的某些类的意义在哪里呢，反正还是会出问题。</span><br><span class=\"line\">    这就显得比较鸡肋了，但是也不能说没有意义，毕竟写程序还是要独立思考的。</span><br><span class=\"line\">    解决办法就比较简单了，在两个线程的run方法里加上synchronized (testVector)，这样就会使得读取、删除线程中只会有一个对testVector进行操作，也就不会有上述情况出现。</span><br><span class=\"line\">    从这个错误来看的话，编程一定要谨慎，使用到的技术一定要深入了解，不能说不出问题，但是在出了问题之后能找出原因并解决，</span><br><span class=\"line\">    如果没有这个把握就不要轻易去使用，尤其在正式项目中，可能会让你欲哭无泪啊！</span><br><span class=\"line\"></span><br><span class=\"line\">* *&#x2F;</span><br></pre></td></tr></table></figure>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li>deque 双端对列</li>\n<li>queue 阻塞队列 ArrayBlockingQueue ：一个由数组支持的有界队列。LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。</li>\n<li>PriorityQueue 和 ConcurrentLinkedQueue 非阻塞队列</li>\n</ul>\n"},{"title":" home","date":"2019-03-20T01:24:25.000Z","_content":"\n## 博主信息\n\n#### 公众号：六个核弹\n\n![六个核弹](https://oscimg.oschina.net/oscnet/c61536f9b3d186f75ef7bdd5f468c2bfb08.jpg)\n\n**邮箱**：1977339740@qq.com  &emsp; isocket@outlook.com(常用)\n\n**微信**: b3duZXJhbmRzZWxm（base64解码后便是）\n\n**职业**：java程序猿\n\n**项目**：[poseidon-cloud](https://github.com/muggle0/poseidon-cloud)\n\n**笔名**： muggle\n\n<!--more-->\n\n## 序：\n\n  &emsp;&emsp;从高中的时候就养成了写日记的习惯（也不能叫日记，并不是每天都写，断断续续，两三天一篇或者一周一篇），日记内容并不是什么很高大上的东西，就一些生活琐事之类的；因为文笔不是很好，写出来的东西基本上都很普通。后来到大学再到毕业至今，就很少写日记了——懒是一方面，工作忙是一方面；倒是经常会挤出一些时间写写技术博客之类的东西，偶尔还能收到别人的赞，还能和评论区读者互动，乐在其中。在这些博客论坛发表文章不好的是我的博客会变得碎片化，不成体系；而且在专业博客论坛里边写一些其他东西似乎也不太合适——没有写日记那么自由了。因此就弄出了这个博客，想和大家分享一些技术上和生活上的东西，希望能给大家工作和生活上带来些帮助。\n   &emsp;&emsp;我是一个还算喜欢交流的人吧（自我这么认为，其实偶尔也会化身自闭型选手），大佬们可以加我微信交流，话痨型选手等你哦。这个私人博客从形式上来说会比较随意，不会有那种很严肃很官方的东西，我希望我写的东西都是很直白便于理解的。为了方便读者阅读，我会维护一个目录和标签，读者可以根据目录或者标签来选择自己需要的文章来阅读，这样既节省了读者的时间，也能使我的文档更成体系。当然，如果小伙伴想投稿我也是欢迎的，不过稿费嘛，我是负担不起啦，稿费福利后期再说吧，就这么多，感谢阅读。\n\n<br>\n### -- 4月27日更新\n\n经过一个多月的努力攒了不少文章，小小的有点成就感。突然产生了一个想法，把这个博客打造完善，把javaSe，javaEE和微服务，中间件这些东西都补全。在个人博客上写东西相比微信公众号来说自由度更高，更利于阅读，但是也不利于传播，而且注定不会像公众号那样会产生收益。如果我的博客能对别人有帮助，我就愿意做下去。\n\n## 标签说明（点击目录可查看所有标签）\n\n- tool ：一些开发工具相关的文章\n- 苟？：写着玩的东西\n- security：spring-security 和spring-security-oauth2相关的文章\n- photo：相册\n- log：日志框架的文章\n- springboot：springboot系列文章\n- thread：多线程相关文章\n- netty：netty相关的文章\n- jvm：虚拟机相关文章\n- cloud：微服务相关文章\n- springboot：springboot相关的文章\n- 算法：算法相关文章\n- 设计模式：设计模式相关文章\n- javaee：java后端开发技术相关的文章\n- javase：java基础相关文章\n- developing：未写完的文章\n\n## 佛系更新，勿念\n\n<br>\n\n#### 愿你生命中有足够多的云翳,去制作一个美丽的黄昏\n","source":"_posts/home.md","raw":"---\ntitle: ' home'\ndate: 2019-03-20 09:24:25\ntags: home\n---\n\n## 博主信息\n\n#### 公众号：六个核弹\n\n![六个核弹](https://oscimg.oschina.net/oscnet/c61536f9b3d186f75ef7bdd5f468c2bfb08.jpg)\n\n**邮箱**：1977339740@qq.com  &emsp; isocket@outlook.com(常用)\n\n**微信**: b3duZXJhbmRzZWxm（base64解码后便是）\n\n**职业**：java程序猿\n\n**项目**：[poseidon-cloud](https://github.com/muggle0/poseidon-cloud)\n\n**笔名**： muggle\n\n<!--more-->\n\n## 序：\n\n  &emsp;&emsp;从高中的时候就养成了写日记的习惯（也不能叫日记，并不是每天都写，断断续续，两三天一篇或者一周一篇），日记内容并不是什么很高大上的东西，就一些生活琐事之类的；因为文笔不是很好，写出来的东西基本上都很普通。后来到大学再到毕业至今，就很少写日记了——懒是一方面，工作忙是一方面；倒是经常会挤出一些时间写写技术博客之类的东西，偶尔还能收到别人的赞，还能和评论区读者互动，乐在其中。在这些博客论坛发表文章不好的是我的博客会变得碎片化，不成体系；而且在专业博客论坛里边写一些其他东西似乎也不太合适——没有写日记那么自由了。因此就弄出了这个博客，想和大家分享一些技术上和生活上的东西，希望能给大家工作和生活上带来些帮助。\n   &emsp;&emsp;我是一个还算喜欢交流的人吧（自我这么认为，其实偶尔也会化身自闭型选手），大佬们可以加我微信交流，话痨型选手等你哦。这个私人博客从形式上来说会比较随意，不会有那种很严肃很官方的东西，我希望我写的东西都是很直白便于理解的。为了方便读者阅读，我会维护一个目录和标签，读者可以根据目录或者标签来选择自己需要的文章来阅读，这样既节省了读者的时间，也能使我的文档更成体系。当然，如果小伙伴想投稿我也是欢迎的，不过稿费嘛，我是负担不起啦，稿费福利后期再说吧，就这么多，感谢阅读。\n\n<br>\n### -- 4月27日更新\n\n经过一个多月的努力攒了不少文章，小小的有点成就感。突然产生了一个想法，把这个博客打造完善，把javaSe，javaEE和微服务，中间件这些东西都补全。在个人博客上写东西相比微信公众号来说自由度更高，更利于阅读，但是也不利于传播，而且注定不会像公众号那样会产生收益。如果我的博客能对别人有帮助，我就愿意做下去。\n\n## 标签说明（点击目录可查看所有标签）\n\n- tool ：一些开发工具相关的文章\n- 苟？：写着玩的东西\n- security：spring-security 和spring-security-oauth2相关的文章\n- photo：相册\n- log：日志框架的文章\n- springboot：springboot系列文章\n- thread：多线程相关文章\n- netty：netty相关的文章\n- jvm：虚拟机相关文章\n- cloud：微服务相关文章\n- springboot：springboot相关的文章\n- 算法：算法相关文章\n- 设计模式：设计模式相关文章\n- javaee：java后端开发技术相关的文章\n- javase：java基础相关文章\n- developing：未写完的文章\n\n## 佛系更新，勿念\n\n<br>\n\n#### 愿你生命中有足够多的云翳,去制作一个美丽的黄昏\n","slug":"home","published":1,"updated":"2021-01-11T07:31:23.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh66001l00wi7ywb4vfd","content":"<h2 id=\"博主信息\"><a href=\"#博主信息\" class=\"headerlink\" title=\"博主信息\"></a>博主信息</h2><h4 id=\"公众号：六个核弹\"><a href=\"#公众号：六个核弹\" class=\"headerlink\" title=\"公众号：六个核弹\"></a>公众号：六个核弹</h4><p><img src=\"https://oscimg.oschina.net/oscnet/c61536f9b3d186f75ef7bdd5f468c2bfb08.jpg\" alt=\"六个核弹\"></p>\n<p><strong>邮箱</strong>：1977339740@qq.com  &emsp; <a href=\"mailto:isocket@outlook.com\">isocket@outlook.com</a>(常用)</p>\n<p><strong>微信</strong>: b3duZXJhbmRzZWxm（base64解码后便是）</p>\n<p><strong>职业</strong>：java程序猿</p>\n<p><strong>项目</strong>：<a href=\"https://github.com/muggle0/poseidon-cloud\">poseidon-cloud</a></p>\n<p><strong>笔名</strong>： muggle</p>\n<a id=\"more\"></a>\n\n<h2 id=\"序：\"><a href=\"#序：\" class=\"headerlink\" title=\"序：\"></a>序：</h2><p>  &emsp;&emsp;从高中的时候就养成了写日记的习惯（也不能叫日记，并不是每天都写，断断续续，两三天一篇或者一周一篇），日记内容并不是什么很高大上的东西，就一些生活琐事之类的；因为文笔不是很好，写出来的东西基本上都很普通。后来到大学再到毕业至今，就很少写日记了——懒是一方面，工作忙是一方面；倒是经常会挤出一些时间写写技术博客之类的东西，偶尔还能收到别人的赞，还能和评论区读者互动，乐在其中。在这些博客论坛发表文章不好的是我的博客会变得碎片化，不成体系；而且在专业博客论坛里边写一些其他东西似乎也不太合适——没有写日记那么自由了。因此就弄出了这个博客，想和大家分享一些技术上和生活上的东西，希望能给大家工作和生活上带来些帮助。<br>   &emsp;&emsp;我是一个还算喜欢交流的人吧（自我这么认为，其实偶尔也会化身自闭型选手），大佬们可以加我微信交流，话痨型选手等你哦。这个私人博客从形式上来说会比较随意，不会有那种很严肃很官方的东西，我希望我写的东西都是很直白便于理解的。为了方便读者阅读，我会维护一个目录和标签，读者可以根据目录或者标签来选择自己需要的文章来阅读，这样既节省了读者的时间，也能使我的文档更成体系。当然，如果小伙伴想投稿我也是欢迎的，不过稿费嘛，我是负担不起啦，稿费福利后期再说吧，就这么多，感谢阅读。</p>\n<br>\n### -- 4月27日更新\n\n<p>经过一个多月的努力攒了不少文章，小小的有点成就感。突然产生了一个想法，把这个博客打造完善，把javaSe，javaEE和微服务，中间件这些东西都补全。在个人博客上写东西相比微信公众号来说自由度更高，更利于阅读，但是也不利于传播，而且注定不会像公众号那样会产生收益。如果我的博客能对别人有帮助，我就愿意做下去。</p>\n<h2 id=\"标签说明（点击目录可查看所有标签）\"><a href=\"#标签说明（点击目录可查看所有标签）\" class=\"headerlink\" title=\"标签说明（点击目录可查看所有标签）\"></a>标签说明（点击目录可查看所有标签）</h2><ul>\n<li>tool ：一些开发工具相关的文章</li>\n<li>苟？：写着玩的东西</li>\n<li>security：spring-security 和spring-security-oauth2相关的文章</li>\n<li>photo：相册</li>\n<li>log：日志框架的文章</li>\n<li>springboot：springboot系列文章</li>\n<li>thread：多线程相关文章</li>\n<li>netty：netty相关的文章</li>\n<li>jvm：虚拟机相关文章</li>\n<li>cloud：微服务相关文章</li>\n<li>springboot：springboot相关的文章</li>\n<li>算法：算法相关文章</li>\n<li>设计模式：设计模式相关文章</li>\n<li>javaee：java后端开发技术相关的文章</li>\n<li>javase：java基础相关文章</li>\n<li>developing：未写完的文章</li>\n</ul>\n<h2 id=\"佛系更新，勿念\"><a href=\"#佛系更新，勿念\" class=\"headerlink\" title=\"佛系更新，勿念\"></a>佛系更新，勿念</h2><br>\n\n<h4 id=\"愿你生命中有足够多的云翳-去制作一个美丽的黄昏\"><a href=\"#愿你生命中有足够多的云翳-去制作一个美丽的黄昏\" class=\"headerlink\" title=\"愿你生命中有足够多的云翳,去制作一个美丽的黄昏\"></a>愿你生命中有足够多的云翳,去制作一个美丽的黄昏</h4>","site":{"data":{}},"excerpt":"<h2 id=\"博主信息\"><a href=\"#博主信息\" class=\"headerlink\" title=\"博主信息\"></a>博主信息</h2><h4 id=\"公众号：六个核弹\"><a href=\"#公众号：六个核弹\" class=\"headerlink\" title=\"公众号：六个核弹\"></a>公众号：六个核弹</h4><p><img src=\"https://oscimg.oschina.net/oscnet/c61536f9b3d186f75ef7bdd5f468c2bfb08.jpg\" alt=\"六个核弹\"></p>\n<p><strong>邮箱</strong>：1977339740@qq.com  &emsp; <a href=\"mailto:isocket@outlook.com\">isocket@outlook.com</a>(常用)</p>\n<p><strong>微信</strong>: b3duZXJhbmRzZWxm（base64解码后便是）</p>\n<p><strong>职业</strong>：java程序猿</p>\n<p><strong>项目</strong>：<a href=\"https://github.com/muggle0/poseidon-cloud\">poseidon-cloud</a></p>\n<p><strong>笔名</strong>： muggle</p>","more":"<h2 id=\"序：\"><a href=\"#序：\" class=\"headerlink\" title=\"序：\"></a>序：</h2><p>  &emsp;&emsp;从高中的时候就养成了写日记的习惯（也不能叫日记，并不是每天都写，断断续续，两三天一篇或者一周一篇），日记内容并不是什么很高大上的东西，就一些生活琐事之类的；因为文笔不是很好，写出来的东西基本上都很普通。后来到大学再到毕业至今，就很少写日记了——懒是一方面，工作忙是一方面；倒是经常会挤出一些时间写写技术博客之类的东西，偶尔还能收到别人的赞，还能和评论区读者互动，乐在其中。在这些博客论坛发表文章不好的是我的博客会变得碎片化，不成体系；而且在专业博客论坛里边写一些其他东西似乎也不太合适——没有写日记那么自由了。因此就弄出了这个博客，想和大家分享一些技术上和生活上的东西，希望能给大家工作和生活上带来些帮助。<br>   &emsp;&emsp;我是一个还算喜欢交流的人吧（自我这么认为，其实偶尔也会化身自闭型选手），大佬们可以加我微信交流，话痨型选手等你哦。这个私人博客从形式上来说会比较随意，不会有那种很严肃很官方的东西，我希望我写的东西都是很直白便于理解的。为了方便读者阅读，我会维护一个目录和标签，读者可以根据目录或者标签来选择自己需要的文章来阅读，这样既节省了读者的时间，也能使我的文档更成体系。当然，如果小伙伴想投稿我也是欢迎的，不过稿费嘛，我是负担不起啦，稿费福利后期再说吧，就这么多，感谢阅读。</p>\n<br>\n### -- 4月27日更新\n\n<p>经过一个多月的努力攒了不少文章，小小的有点成就感。突然产生了一个想法，把这个博客打造完善，把javaSe，javaEE和微服务，中间件这些东西都补全。在个人博客上写东西相比微信公众号来说自由度更高，更利于阅读，但是也不利于传播，而且注定不会像公众号那样会产生收益。如果我的博客能对别人有帮助，我就愿意做下去。</p>\n<h2 id=\"标签说明（点击目录可查看所有标签）\"><a href=\"#标签说明（点击目录可查看所有标签）\" class=\"headerlink\" title=\"标签说明（点击目录可查看所有标签）\"></a>标签说明（点击目录可查看所有标签）</h2><ul>\n<li>tool ：一些开发工具相关的文章</li>\n<li>苟？：写着玩的东西</li>\n<li>security：spring-security 和spring-security-oauth2相关的文章</li>\n<li>photo：相册</li>\n<li>log：日志框架的文章</li>\n<li>springboot：springboot系列文章</li>\n<li>thread：多线程相关文章</li>\n<li>netty：netty相关的文章</li>\n<li>jvm：虚拟机相关文章</li>\n<li>cloud：微服务相关文章</li>\n<li>springboot：springboot相关的文章</li>\n<li>算法：算法相关文章</li>\n<li>设计模式：设计模式相关文章</li>\n<li>javaee：java后端开发技术相关的文章</li>\n<li>javase：java基础相关文章</li>\n<li>developing：未写完的文章</li>\n</ul>\n<h2 id=\"佛系更新，勿念\"><a href=\"#佛系更新，勿念\" class=\"headerlink\" title=\"佛系更新，勿念\"></a>佛系更新，勿念</h2><br>\n\n<h4 id=\"愿你生命中有足够多的云翳-去制作一个美丽的黄昏\"><a href=\"#愿你生命中有足够多的云翳-去制作一个美丽的黄昏\" class=\"headerlink\" title=\"愿你生命中有足够多的云翳,去制作一个美丽的黄昏\"></a>愿你生命中有足够多的云翳,去制作一个美丽的黄昏</h4>"},{"title":"接口幂等性问题","date":"2019-03-20T05:57:12.000Z","_content":"\n在数学里，幂等有两种主要的定义：在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。如，乘法运算下，0和1符合的自乘运算符和幂等，即s*s=s某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x))=f(x)在计算机中，表示对同一个过程应用相同的参数多次和应用一次产生的效果是一样，这样的过程即被称为满足幂等性在分布式和前后端分离的的项目中，对于restful风格的接口，我们需要保证其接口的幂等性，说白了就是就是一个接口被反复调用不会影响最终结果；为什么呢，因为前后端分离的项目可能会发生这样的场景：前端发出一个请求，但这个请求被阻塞了，然后其重试机制再次发起请求，而恰好此时被阻塞的那个请求又好了，那么这个时候，会对后端发起连续两次请求；对于 get，put,delete 都没问题，连续的两次或者三次都不会影响请求处理结果，但post就有问题了；它会往数据库插入两条数据。\n\n<!--more-->\n\n这显然不是正确的处理结果。在分布式和前后端分离的项目中，前端数据对后端来说都是不可信的。因此有一个机制来保证接口的幂等性是很有必要的。按照restful规范定义的接口，使用http方法，应该严格遵循http方法语义：方法幂等性对应CRUD操作POST不安全且不幂等CGET安全且幂等RPUT不安全但幂等UDELETE不安全但幂等D幂等实现方法：使用全局唯一ID:（数据库唯一索引，或者redis保存一个key）就是根据业务的操作和内容生成一个全局ID，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、Redis等。如果存在则表示该方法已经执行。使用全局唯一ID是一个通用方案，可以支持插入、更新、删除业务操作。但是这个方案看起来很美但是实现起来比较麻烦，下面的方案适用于特定的场景，但是实现起来比较简单。去重表：这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，用以记录订单支付信息，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。这个方法其实也是用到唯一ID，与上面全局唯一ID不同的是，他是针对具体单个业务流程的，实现起来相对简单。版本控制：对数据库表加入版本号形成乐观锁，更新操作时必须拿到正确的版本号才能更新成功。\n\n","source":"_posts/javaee-1.md","raw":"---\ntitle: 接口幂等性问题\ndate: 2019-03-20 13:57:12\ntags: javaee\n---\n\n在数学里，幂等有两种主要的定义：在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。如，乘法运算下，0和1符合的自乘运算符和幂等，即s*s=s某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x))=f(x)在计算机中，表示对同一个过程应用相同的参数多次和应用一次产生的效果是一样，这样的过程即被称为满足幂等性在分布式和前后端分离的的项目中，对于restful风格的接口，我们需要保证其接口的幂等性，说白了就是就是一个接口被反复调用不会影响最终结果；为什么呢，因为前后端分离的项目可能会发生这样的场景：前端发出一个请求，但这个请求被阻塞了，然后其重试机制再次发起请求，而恰好此时被阻塞的那个请求又好了，那么这个时候，会对后端发起连续两次请求；对于 get，put,delete 都没问题，连续的两次或者三次都不会影响请求处理结果，但post就有问题了；它会往数据库插入两条数据。\n\n<!--more-->\n\n这显然不是正确的处理结果。在分布式和前后端分离的项目中，前端数据对后端来说都是不可信的。因此有一个机制来保证接口的幂等性是很有必要的。按照restful规范定义的接口，使用http方法，应该严格遵循http方法语义：方法幂等性对应CRUD操作POST不安全且不幂等CGET安全且幂等RPUT不安全但幂等UDELETE不安全但幂等D幂等实现方法：使用全局唯一ID:（数据库唯一索引，或者redis保存一个key）就是根据业务的操作和内容生成一个全局ID，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、Redis等。如果存在则表示该方法已经执行。使用全局唯一ID是一个通用方案，可以支持插入、更新、删除业务操作。但是这个方案看起来很美但是实现起来比较麻烦，下面的方案适用于特定的场景，但是实现起来比较简单。去重表：这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，用以记录订单支付信息，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。这个方法其实也是用到唯一ID，与上面全局唯一ID不同的是，他是针对具体单个业务流程的，实现起来相对简单。版本控制：对数据库表加入版本号形成乐观锁，更新操作时必须拿到正确的版本号才能更新成功。\n\n","slug":"javaee-1","published":1,"updated":"2021-01-11T07:31:23.304Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh67001o00wicqmegxww","content":"<p>在数学里，幂等有两种主要的定义：在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。如，乘法运算下，0和1符合的自乘运算符和幂等，即s*s=s某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x))=f(x)在计算机中，表示对同一个过程应用相同的参数多次和应用一次产生的效果是一样，这样的过程即被称为满足幂等性在分布式和前后端分离的的项目中，对于restful风格的接口，我们需要保证其接口的幂等性，说白了就是就是一个接口被反复调用不会影响最终结果；为什么呢，因为前后端分离的项目可能会发生这样的场景：前端发出一个请求，但这个请求被阻塞了，然后其重试机制再次发起请求，而恰好此时被阻塞的那个请求又好了，那么这个时候，会对后端发起连续两次请求；对于 get，put,delete 都没问题，连续的两次或者三次都不会影响请求处理结果，但post就有问题了；它会往数据库插入两条数据。</p>\n<a id=\"more\"></a>\n\n<p>这显然不是正确的处理结果。在分布式和前后端分离的项目中，前端数据对后端来说都是不可信的。因此有一个机制来保证接口的幂等性是很有必要的。按照restful规范定义的接口，使用http方法，应该严格遵循http方法语义：方法幂等性对应CRUD操作POST不安全且不幂等CGET安全且幂等RPUT不安全但幂等UDELETE不安全但幂等D幂等实现方法：使用全局唯一ID:（数据库唯一索引，或者redis保存一个key）就是根据业务的操作和内容生成一个全局ID，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、Redis等。如果存在则表示该方法已经执行。使用全局唯一ID是一个通用方案，可以支持插入、更新、删除业务操作。但是这个方案看起来很美但是实现起来比较麻烦，下面的方案适用于特定的场景，但是实现起来比较简单。去重表：这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，用以记录订单支付信息，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。这个方法其实也是用到唯一ID，与上面全局唯一ID不同的是，他是针对具体单个业务流程的，实现起来相对简单。版本控制：对数据库表加入版本号形成乐观锁，更新操作时必须拿到正确的版本号才能更新成功。</p>\n","site":{"data":{}},"excerpt":"<p>在数学里，幂等有两种主要的定义：在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。如，乘法运算下，0和1符合的自乘运算符和幂等，即s*s=s某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x))=f(x)在计算机中，表示对同一个过程应用相同的参数多次和应用一次产生的效果是一样，这样的过程即被称为满足幂等性在分布式和前后端分离的的项目中，对于restful风格的接口，我们需要保证其接口的幂等性，说白了就是就是一个接口被反复调用不会影响最终结果；为什么呢，因为前后端分离的项目可能会发生这样的场景：前端发出一个请求，但这个请求被阻塞了，然后其重试机制再次发起请求，而恰好此时被阻塞的那个请求又好了，那么这个时候，会对后端发起连续两次请求；对于 get，put,delete 都没问题，连续的两次或者三次都不会影响请求处理结果，但post就有问题了；它会往数据库插入两条数据。</p>","more":"<p>这显然不是正确的处理结果。在分布式和前后端分离的项目中，前端数据对后端来说都是不可信的。因此有一个机制来保证接口的幂等性是很有必要的。按照restful规范定义的接口，使用http方法，应该严格遵循http方法语义：方法幂等性对应CRUD操作POST不安全且不幂等CGET安全且幂等RPUT不安全但幂等UDELETE不安全但幂等D幂等实现方法：使用全局唯一ID:（数据库唯一索引，或者redis保存一个key）就是根据业务的操作和内容生成一个全局ID，在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、Redis等。如果存在则表示该方法已经执行。使用全局唯一ID是一个通用方案，可以支持插入、更新、删除业务操作。但是这个方案看起来很美但是实现起来比较麻烦，下面的方案适用于特定的场景，但是实现起来比较简单。去重表：这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，用以记录订单支付信息，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。这个方法其实也是用到唯一ID，与上面全局唯一ID不同的是，他是针对具体单个业务流程的，实现起来相对简单。版本控制：对数据库表加入版本号形成乐观锁，更新操作时必须拿到正确的版本号才能更新成功。</p>"},{"title":"java-code","date":"2020-09-07T06:58:05.000Z","_content":"\n\n# 操作码介绍\n\n我们都知在Java中我们的类会被编译成字节码然后放到虚拟机中去执行，字节码里面的内容其实我们也是可以去“阅读”的，方法就是通过 jdk自带的工具翻译成操作码。在操作码中我们能看到一些我们平时看不到的关于java的秘密。\n\nJava虚拟机的指令由一个字节长度的的数字以及跟随其后的零至多个代表此操作所需的参数构成。即：Java指令 = 操作码 + 操作数。Java虚拟机本身是采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。通过阅读操作码我们能直观的看到一些方法的执行过程。\n\n<!--more-->\n\n## 查看操作码\n我们随便找一个 .class 文件(我这里是Test.class)，然后在命令行执行:\n\n```java\njavap -v -l -p -s -sysinfo  -constants Test.class\n```\n`Test.java` 源码为：\n\n```java\npublic class Test {\n    private String a;\n    private static final String STR=\"hello word\";\n    public static void main(String[] args) {\n        System.out.println(STR);\n    }\n}\n\n```\n\n执行指令后可在命令行窗口看到:\n```java\nClassfile /G:Test.class\n  Last modified 2020-8-9; size 585 bytes\n  MD5 checksum 09bb7ece9c879902984714504494a9e3\n  Compiled from \"Test.java\"\npublic class Test\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #6.#24         // java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;\n   #3 = Class              #27            // Test\n   #4 = String             #28            // hello word\n   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(Ljava/lang/String;)V\n   #6 = Class              #31            // java/lang/Object\n   #7 = Utf8               a\n   #8 = Utf8               Ljava/lang/String;\n   #9 = Utf8               STR\n  #10 = Utf8               ConstantValue\n  #11 = Utf8               <init>\n  #12 = Utf8               ()V\n  #13 = Utf8               Code\n  #14 = Utf8               LineNumberTable\n  #15 = Utf8               LocalVariableTable\n  #16 = Utf8               this\n  #17 = Utf8               LTest;\n  #18 = Utf8               main\n  #19 = Utf8               ([Ljava/lang/String;)V\n  #20 = Utf8               args\n  #21 = Utf8               [Ljava/lang/String;\n  #22 = Utf8               SourceFile\n  #23 = Utf8               Test.java\n  #24 = NameAndType        #11:#12        // \"<init>\":()V\n  #25 = Class              #32            // java/lang/System\n  #26 = NameAndType        #33:#34        // out:Ljava/io/PrintStream;\n  #27 = Utf8               Test\n  #28 = Utf8               hello word\n  #29 = Class              #35            // java/io/PrintStream\n  #30 = NameAndType        #36:#37        // println:(Ljava/lang/String;)V\n  #31 = Utf8               java/lang/Object\n  #32 = Utf8               java/lang/System\n  #33 = Utf8               out\n  #34 = Utf8               Ljava/io/PrintStream;\n  #35 = Utf8               java/io/PrintStream\n  #36 = Utf8               println\n  #37 = Utf8               (Ljava/lang/String;)V\n{\n  private java.lang.String a;\n    descriptor: Ljava/lang/String;\n    flags: ACC_PRIVATE\n\n  private static final java.lang.String STR = \"hello word\";\n    descriptor: Ljava/lang/String;\n    flags: ACC_PRIVATE, ACC_STATIC, ACC_FINAL\n    ConstantValue: String hello word\n\n  public Test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 1: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   LTest;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         3: ldc           #4                  // String hello word\n         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n         8: return\n      LineNumberTable:\n        line 5: 0\n        line 6: 8\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       9     0  args   [Ljava/lang/String;\n}\n```\n有的小伙伴可能没有将 jdk的bin目录配置到环境变量，执行`javap`指令的时候识别不了该指令，我们只需要指定指令的全路径就ok了，比如我的 bin 目录是 `C:\\jdk\\bin` 那我的指令就是 `C:\\jdk\\bin\\javap.exe -v -l -p -s -sy、sinfo  -constants Test.class`。javap 指令的参数含义可以通过 `javap -help`查看 这里不多做介绍。\n\n## 操作码阅读指南\n\n通过命令行窗口输出的内容分为以下几个部分：\n- Classfile 是一些类信息，\n- Constant pool 是编译时常量池，`Constant pool` 中我们能看到方法信息、变量信息、关键字信息等，\n- {} 里面的内容是方法的一些执行指令。\n\n我们将字节码文件翻译成了操作码，里面的信息量很大，别着急，我们一点点的去解读。Classfile部分是一些类信息，这一部分不是我们研究的重点，因此我这里不做太多介绍。\n阅读操作码我们需要去查阅操作码指令表，在网上就能搜到。我在这里罗列一些比较重要的操作码。\n\n数据类型相关\n\n- iload指令用于从局部变量表中加载int型的数据到操作数栈中；\n- fload指令则是从局部变量表中加载float类型的数据到操作数栈中；\n- i代表int类型，l代表long类型，s代表short类型，b代表byte类型，a代表reference类型；以此类推\n\n加载和存储指令相关\n\n- 将一个局部变量加载到操作数栈，有iload、iload_<n>、lload、lload_<n>、aload、aload_<n>等\n- 将一个数值从操作数栈存储到局部变量表，有istore、istore_<n>、lstore、lstore_<n>、astore、astore_<n>等\n- 将一个常量加载到操作数栈，有bipush、sipush、ldc、aconst_null、iconst_<i>等\n\n运算指令相关\n\n- 加法指令 iadd、ladd、fadd、dadd，\n- 减法指令 isub、lsub、fsub、dsub，\n- 乘法指令 imul、lmul、fmul、dmul，\n- 除法指令 idiv、ldiv、fdiv、ddiv，\n- 求余指令 irem、lrem、frem、drem\n- 取反指令 ineg、lneg、fneg、dneg\n- 位指令 ior、lor 是或运算，iand、land 是与运算 ixor、lxor 是异或运算\n- 其他 iinc 是自增运算 dcmpg、dcmpl、fcmpg、fcmpl、lcmp 是比较运算\n\n操作数栈指令\n- 出栈指令 pop、pop2 \n- 复制压栈 dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2\n- 将栈最顶端的两个数值互换 swap\n- 条件分支 ifeq、iflt、ifle、ifne \n- 无条件分支 goto、goto_w、jsr、jsr_w、ret\n- 复合条件分支tableswitch、lookupswitch\n\n方法调用相关\n- 方法返回值类型表示方式 ()V 表示 void 方法  ()Ljava/lang/String 表示 返回 String 类型，()I 表示返回int类型，以此类推\n- invokevirtual指令用于调用对象的实例方法，\n- invokeinterface指令用于调用接口方法，\n- invokespecial指令用于调用一些需要特殊处理的实例方法\n- invokestatic指令用于调用静态方法\n- invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法\n- athrow指令用来实现显式抛出异常的操作\n- monitorenter和monitorexit两条指令来支持synchronized关键字的语义\n\n## 操作码相关源码解读\n\n前文提到过操作码可以看到 java 的一些秘密，下面我们由难到易解读几个案例。\n\n**案例一 this 关键字的加载时机**\n\n我们思考下面一段代码：\n\n```java\npublic class Test {\n    private String test;\n    \n    {\n        System.out.println(\"执行动态代码块\");\n        this.test=\"执行动态代码块\";\n    }\n    \n    public Test(){\n        System.out.println(test);\n    }\n}\n\n```\n这段代码相信有工作经验的朋友都研究过，但是现在我们不是来讨论代码的额执行顺序，而是讨论另外一个问题：为什么动态代码块里面可以用 this 关键字？ 我们思考一下，this代指当前对象，而构造函数还没有执行我们哪来的对象？那还没有对象，我们的this又指向谁？这是一个值得思考的问题。那我们来看看这段代码的操作码吧：\n\n```java\n public Test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         7: ldc           #3                  // String 执行动态代码块\n         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        12: aload_0\n        13: ldc           #3                  // String 执行动态代码块\n        15: putfield      #5                  // Field test:Ljava/lang/String;\n        18: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n        21: aload_0\n        22: getfield      #5                  // Field test:Ljava/lang/String;\n        25: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        28: return\n      LineNumberTable:\n        line 9: 0\n        line 5: 4\n        line 6: 12\n        line 10: 18\n        line 11: 28\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      29     0  this   LTest;\n```\n我们仔细阅读发现，其实它的构造方法组成并不是我们在类里面看到的那样，第一步先执行 `aload_0` 然后 通过`invokespecial` 指令调用了 对象初始化方法 `<init>` ，然后再是正真的执行我们构造函数自己的逻辑。注意了，这里的 `aload_0` 就是加载this关键字，也就是其实动态代码块是直接编译在构造函数之中的，而且 this关键字的产生是对象产生的第一步；也就是说我们创建的对象从操作码的角度来讲，首先就是先加载一个 this 上来，然后再初始化对象，再实例化对象。\n\n案例二 sychornized 关键字原理。\n\nsychornized 从操作码的层面来观察是比较直观的，我们百度sychornized关键字原理的时候，通常是这么解释的：jvm基于进入和退出 `Monitor` 对象来实现方法同步和代码块同步，而这个 `Monitor` 是存储在Java对象头里的。\n我们理解起来可能比较抽象，让我们读操作码来分析吧：\n\n同步方法：\n```java\n    public static  void testSyn(int i){\n        synchronized(Test.class){\n            System.out.println(\">>>>>>>>>>>>>>>>>\");\n        }\n    }\n```\n\n对应的部分操作码：\n```java\n public static void testSyn(int);\n    descriptor: (I)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: ldc           #6                  // class Test\n         2: dup\n         3: astore_1\n         4: monitorenter\n         5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         8: ldc           #7                  // String >>>>>>>>>>>>>>>>>\n        10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        13: aload_1\n        14: monitorexit\n        15: goto          23\n        18: astore_2\n        19: aload_1\n        20: monitorexit\n        21: aload_2\n        22: athrow\n        23: return\n```\n结合前文的操作码指令介绍，我们可以看到同步代码块的执行过程，先执行 monitorenter 指令获取锁，当获取锁成功，执行下面的指令，最后 monitorexit 释放锁，monitorenter 被jvm封装成一个完整指令，其执行原理就是前面所说的内容，而再往深究的话就是通过互斥原语（CPU lock 指令加 对象头锁标记位）来实现的。\n\n案例三 对象初始化死锁。\n\n这是一个很有意思的题，在b站上能搜到它的操作码分析视频，关键字  小马哥每日一问 2019.07.18 期 。我把题目贴出来，大佬们自己动手研究一下，阅后习题：\n\n```java\npublic class Test {\n  private static boolean initialized=false;\n  \n  static {\n      Thread t=new Thread(()-> initialized=true);\n      t.start();\n      try {\n          t.join();\n      }catch (InterruptedException e){\n          throw new AssertionError(e);\n      }\n  }\n\n    public static void main(String[] args) {\n        System.out.println(initialized);\n    }\n}\n\n以上程序输出内容是？\n\n1. true\n2. false\n3. 编译错误\n4. 以上答案都不对\n\n```\n上面这个题目是很有意思的，小伙伴们仔细研究一下。","source":"_posts/java-code.md","raw":"---\ntitle: java-code\ndate: 2020-09-07 14:58:05\ntags: javase\n---\n\n\n# 操作码介绍\n\n我们都知在Java中我们的类会被编译成字节码然后放到虚拟机中去执行，字节码里面的内容其实我们也是可以去“阅读”的，方法就是通过 jdk自带的工具翻译成操作码。在操作码中我们能看到一些我们平时看不到的关于java的秘密。\n\nJava虚拟机的指令由一个字节长度的的数字以及跟随其后的零至多个代表此操作所需的参数构成。即：Java指令 = 操作码 + 操作数。Java虚拟机本身是采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。通过阅读操作码我们能直观的看到一些方法的执行过程。\n\n<!--more-->\n\n## 查看操作码\n我们随便找一个 .class 文件(我这里是Test.class)，然后在命令行执行:\n\n```java\njavap -v -l -p -s -sysinfo  -constants Test.class\n```\n`Test.java` 源码为：\n\n```java\npublic class Test {\n    private String a;\n    private static final String STR=\"hello word\";\n    public static void main(String[] args) {\n        System.out.println(STR);\n    }\n}\n\n```\n\n执行指令后可在命令行窗口看到:\n```java\nClassfile /G:Test.class\n  Last modified 2020-8-9; size 585 bytes\n  MD5 checksum 09bb7ece9c879902984714504494a9e3\n  Compiled from \"Test.java\"\npublic class Test\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #6.#24         // java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;\n   #3 = Class              #27            // Test\n   #4 = String             #28            // hello word\n   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(Ljava/lang/String;)V\n   #6 = Class              #31            // java/lang/Object\n   #7 = Utf8               a\n   #8 = Utf8               Ljava/lang/String;\n   #9 = Utf8               STR\n  #10 = Utf8               ConstantValue\n  #11 = Utf8               <init>\n  #12 = Utf8               ()V\n  #13 = Utf8               Code\n  #14 = Utf8               LineNumberTable\n  #15 = Utf8               LocalVariableTable\n  #16 = Utf8               this\n  #17 = Utf8               LTest;\n  #18 = Utf8               main\n  #19 = Utf8               ([Ljava/lang/String;)V\n  #20 = Utf8               args\n  #21 = Utf8               [Ljava/lang/String;\n  #22 = Utf8               SourceFile\n  #23 = Utf8               Test.java\n  #24 = NameAndType        #11:#12        // \"<init>\":()V\n  #25 = Class              #32            // java/lang/System\n  #26 = NameAndType        #33:#34        // out:Ljava/io/PrintStream;\n  #27 = Utf8               Test\n  #28 = Utf8               hello word\n  #29 = Class              #35            // java/io/PrintStream\n  #30 = NameAndType        #36:#37        // println:(Ljava/lang/String;)V\n  #31 = Utf8               java/lang/Object\n  #32 = Utf8               java/lang/System\n  #33 = Utf8               out\n  #34 = Utf8               Ljava/io/PrintStream;\n  #35 = Utf8               java/io/PrintStream\n  #36 = Utf8               println\n  #37 = Utf8               (Ljava/lang/String;)V\n{\n  private java.lang.String a;\n    descriptor: Ljava/lang/String;\n    flags: ACC_PRIVATE\n\n  private static final java.lang.String STR = \"hello word\";\n    descriptor: Ljava/lang/String;\n    flags: ACC_PRIVATE, ACC_STATIC, ACC_FINAL\n    ConstantValue: String hello word\n\n  public Test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 1: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   LTest;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         3: ldc           #4                  // String hello word\n         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n         8: return\n      LineNumberTable:\n        line 5: 0\n        line 6: 8\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       9     0  args   [Ljava/lang/String;\n}\n```\n有的小伙伴可能没有将 jdk的bin目录配置到环境变量，执行`javap`指令的时候识别不了该指令，我们只需要指定指令的全路径就ok了，比如我的 bin 目录是 `C:\\jdk\\bin` 那我的指令就是 `C:\\jdk\\bin\\javap.exe -v -l -p -s -sy、sinfo  -constants Test.class`。javap 指令的参数含义可以通过 `javap -help`查看 这里不多做介绍。\n\n## 操作码阅读指南\n\n通过命令行窗口输出的内容分为以下几个部分：\n- Classfile 是一些类信息，\n- Constant pool 是编译时常量池，`Constant pool` 中我们能看到方法信息、变量信息、关键字信息等，\n- {} 里面的内容是方法的一些执行指令。\n\n我们将字节码文件翻译成了操作码，里面的信息量很大，别着急，我们一点点的去解读。Classfile部分是一些类信息，这一部分不是我们研究的重点，因此我这里不做太多介绍。\n阅读操作码我们需要去查阅操作码指令表，在网上就能搜到。我在这里罗列一些比较重要的操作码。\n\n数据类型相关\n\n- iload指令用于从局部变量表中加载int型的数据到操作数栈中；\n- fload指令则是从局部变量表中加载float类型的数据到操作数栈中；\n- i代表int类型，l代表long类型，s代表short类型，b代表byte类型，a代表reference类型；以此类推\n\n加载和存储指令相关\n\n- 将一个局部变量加载到操作数栈，有iload、iload_<n>、lload、lload_<n>、aload、aload_<n>等\n- 将一个数值从操作数栈存储到局部变量表，有istore、istore_<n>、lstore、lstore_<n>、astore、astore_<n>等\n- 将一个常量加载到操作数栈，有bipush、sipush、ldc、aconst_null、iconst_<i>等\n\n运算指令相关\n\n- 加法指令 iadd、ladd、fadd、dadd，\n- 减法指令 isub、lsub、fsub、dsub，\n- 乘法指令 imul、lmul、fmul、dmul，\n- 除法指令 idiv、ldiv、fdiv、ddiv，\n- 求余指令 irem、lrem、frem、drem\n- 取反指令 ineg、lneg、fneg、dneg\n- 位指令 ior、lor 是或运算，iand、land 是与运算 ixor、lxor 是异或运算\n- 其他 iinc 是自增运算 dcmpg、dcmpl、fcmpg、fcmpl、lcmp 是比较运算\n\n操作数栈指令\n- 出栈指令 pop、pop2 \n- 复制压栈 dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2\n- 将栈最顶端的两个数值互换 swap\n- 条件分支 ifeq、iflt、ifle、ifne \n- 无条件分支 goto、goto_w、jsr、jsr_w、ret\n- 复合条件分支tableswitch、lookupswitch\n\n方法调用相关\n- 方法返回值类型表示方式 ()V 表示 void 方法  ()Ljava/lang/String 表示 返回 String 类型，()I 表示返回int类型，以此类推\n- invokevirtual指令用于调用对象的实例方法，\n- invokeinterface指令用于调用接口方法，\n- invokespecial指令用于调用一些需要特殊处理的实例方法\n- invokestatic指令用于调用静态方法\n- invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法\n- athrow指令用来实现显式抛出异常的操作\n- monitorenter和monitorexit两条指令来支持synchronized关键字的语义\n\n## 操作码相关源码解读\n\n前文提到过操作码可以看到 java 的一些秘密，下面我们由难到易解读几个案例。\n\n**案例一 this 关键字的加载时机**\n\n我们思考下面一段代码：\n\n```java\npublic class Test {\n    private String test;\n    \n    {\n        System.out.println(\"执行动态代码块\");\n        this.test=\"执行动态代码块\";\n    }\n    \n    public Test(){\n        System.out.println(test);\n    }\n}\n\n```\n这段代码相信有工作经验的朋友都研究过，但是现在我们不是来讨论代码的额执行顺序，而是讨论另外一个问题：为什么动态代码块里面可以用 this 关键字？ 我们思考一下，this代指当前对象，而构造函数还没有执行我们哪来的对象？那还没有对象，我们的this又指向谁？这是一个值得思考的问题。那我们来看看这段代码的操作码吧：\n\n```java\n public Test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         7: ldc           #3                  // String 执行动态代码块\n         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        12: aload_0\n        13: ldc           #3                  // String 执行动态代码块\n        15: putfield      #5                  // Field test:Ljava/lang/String;\n        18: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n        21: aload_0\n        22: getfield      #5                  // Field test:Ljava/lang/String;\n        25: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        28: return\n      LineNumberTable:\n        line 9: 0\n        line 5: 4\n        line 6: 12\n        line 10: 18\n        line 11: 28\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      29     0  this   LTest;\n```\n我们仔细阅读发现，其实它的构造方法组成并不是我们在类里面看到的那样，第一步先执行 `aload_0` 然后 通过`invokespecial` 指令调用了 对象初始化方法 `<init>` ，然后再是正真的执行我们构造函数自己的逻辑。注意了，这里的 `aload_0` 就是加载this关键字，也就是其实动态代码块是直接编译在构造函数之中的，而且 this关键字的产生是对象产生的第一步；也就是说我们创建的对象从操作码的角度来讲，首先就是先加载一个 this 上来，然后再初始化对象，再实例化对象。\n\n案例二 sychornized 关键字原理。\n\nsychornized 从操作码的层面来观察是比较直观的，我们百度sychornized关键字原理的时候，通常是这么解释的：jvm基于进入和退出 `Monitor` 对象来实现方法同步和代码块同步，而这个 `Monitor` 是存储在Java对象头里的。\n我们理解起来可能比较抽象，让我们读操作码来分析吧：\n\n同步方法：\n```java\n    public static  void testSyn(int i){\n        synchronized(Test.class){\n            System.out.println(\">>>>>>>>>>>>>>>>>\");\n        }\n    }\n```\n\n对应的部分操作码：\n```java\n public static void testSyn(int);\n    descriptor: (I)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: ldc           #6                  // class Test\n         2: dup\n         3: astore_1\n         4: monitorenter\n         5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         8: ldc           #7                  // String >>>>>>>>>>>>>>>>>\n        10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        13: aload_1\n        14: monitorexit\n        15: goto          23\n        18: astore_2\n        19: aload_1\n        20: monitorexit\n        21: aload_2\n        22: athrow\n        23: return\n```\n结合前文的操作码指令介绍，我们可以看到同步代码块的执行过程，先执行 monitorenter 指令获取锁，当获取锁成功，执行下面的指令，最后 monitorexit 释放锁，monitorenter 被jvm封装成一个完整指令，其执行原理就是前面所说的内容，而再往深究的话就是通过互斥原语（CPU lock 指令加 对象头锁标记位）来实现的。\n\n案例三 对象初始化死锁。\n\n这是一个很有意思的题，在b站上能搜到它的操作码分析视频，关键字  小马哥每日一问 2019.07.18 期 。我把题目贴出来，大佬们自己动手研究一下，阅后习题：\n\n```java\npublic class Test {\n  private static boolean initialized=false;\n  \n  static {\n      Thread t=new Thread(()-> initialized=true);\n      t.start();\n      try {\n          t.join();\n      }catch (InterruptedException e){\n          throw new AssertionError(e);\n      }\n  }\n\n    public static void main(String[] args) {\n        System.out.println(initialized);\n    }\n}\n\n以上程序输出内容是？\n\n1. true\n2. false\n3. 编译错误\n4. 以上答案都不对\n\n```\n上面这个题目是很有意思的，小伙伴们仔细研究一下。","slug":"java-code","published":1,"updated":"2021-01-11T07:31:23.304Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh67001q00wi4quocb5c","content":"<h1 id=\"操作码介绍\"><a href=\"#操作码介绍\" class=\"headerlink\" title=\"操作码介绍\"></a>操作码介绍</h1><p>我们都知在Java中我们的类会被编译成字节码然后放到虚拟机中去执行，字节码里面的内容其实我们也是可以去“阅读”的，方法就是通过 jdk自带的工具翻译成操作码。在操作码中我们能看到一些我们平时看不到的关于java的秘密。</p>\n<p>Java虚拟机的指令由一个字节长度的的数字以及跟随其后的零至多个代表此操作所需的参数构成。即：Java指令 = 操作码 + 操作数。Java虚拟机本身是采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。通过阅读操作码我们能直观的看到一些方法的执行过程。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"查看操作码\"><a href=\"#查看操作码\" class=\"headerlink\" title=\"查看操作码\"></a>查看操作码</h2><p>我们随便找一个 .class 文件(我这里是Test.class)，然后在命令行执行:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javap -v -l -p -s -sysinfo  -constants Test.class</span><br></pre></td></tr></table></figure>\n<p><code>Test.java</code> 源码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String a;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String STR=<span class=\"string\">&quot;hello word&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(STR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行指令后可在命令行窗口看到:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Classfile /G:Test.class</span><br><span class=\"line\">  Last modified <span class=\"number\">2020</span>-<span class=\"number\">8</span>-<span class=\"number\">9</span>; size <span class=\"number\">585</span> bytes</span><br><span class=\"line\">  MD5 checksum 09bb7ece9c879902984714504494a9e3</span><br><span class=\"line\">  Compiled from <span class=\"string\">&quot;Test.java&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span></span><br><span class=\"line\">  minor version: 0</span><br><span class=\"line\">  major version: <span class=\"number\">52</span></span><br><span class=\"line\">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class=\"line\">Constant pool:</span><br><span class=\"line\">   #1 = Methodref          #6.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class=\"line\">   #2 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">   #3 = Class              #27            // Test</span><br><span class=\"line\">   #4 = String             #28            // hello word</span><br><span class=\"line\">   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">   #6 = Class              #31            // java/lang/Object</span><br><span class=\"line\">   #7 = Utf8               a</span><br><span class=\"line\">   #8 = Utf8               Ljava/lang/String;</span><br><span class=\"line\">   #9 = Utf8               STR</span><br><span class=\"line\">  #10 = Utf8               ConstantValue</span><br><span class=\"line\">  #11 = Utf8               &lt;init&gt;</span><br><span class=\"line\">  #12 = Utf8               ()V</span><br><span class=\"line\">  #13 = Utf8               Code</span><br><span class=\"line\">  #14 = Utf8               LineNumberTable</span><br><span class=\"line\">  #15 = Utf8               LocalVariableTable</span><br><span class=\"line\">  #16 = Utf8               this</span><br><span class=\"line\">  #17 = Utf8               LTest;</span><br><span class=\"line\">  #18 = Utf8               main</span><br><span class=\"line\">  #19 = Utf8               ([Ljava/lang/String;)V</span><br><span class=\"line\">  #20 = Utf8               args</span><br><span class=\"line\">  #21 = Utf8               [Ljava/lang/String;</span><br><span class=\"line\">  #22 = Utf8               SourceFile</span><br><span class=\"line\">  #23 = Utf8               Test.java</span><br><span class=\"line\">  #24 = NameAndType        #11:#12        // &quot;&lt;init&gt;&quot;:()V</span><br><span class=\"line\">  #25 = Class              #32            // java/lang/System</span><br><span class=\"line\">  #26 = NameAndType        #33:#34        // out:Ljava/io/PrintStream;</span><br><span class=\"line\">  #27 = Utf8               Test</span><br><span class=\"line\">  #28 = Utf8               hello word</span><br><span class=\"line\">  #29 = Class              #35            // java/io/PrintStream</span><br><span class=\"line\">  #30 = NameAndType        #36:#37        // println:(Ljava/lang/String;)V</span><br><span class=\"line\">  #31 = Utf8               java/lang/Object</span><br><span class=\"line\">  #32 = Utf8               java/lang/System</span><br><span class=\"line\">  #33 = Utf8               out</span><br><span class=\"line\">  #34 = Utf8               Ljava/io/PrintStream;</span><br><span class=\"line\">  #35 = Utf8               java/io/PrintStream</span><br><span class=\"line\">  #36 = Utf8               println</span><br><span class=\"line\">  #37 = Utf8               (Ljava/lang/String;)V</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> java.lang.String a;</span><br><span class=\"line\">    descriptor: Ljava/lang/String;</span><br><span class=\"line\">    flags: ACC_PRIVATE</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> java.lang.String STR = <span class=\"string\">&quot;hello word&quot;</span>;</span><br><span class=\"line\">    descriptor: Ljava/lang/String;</span><br><span class=\"line\">    flags: ACC_PRIVATE, ACC_STATIC, ACC_FINAL</span><br><span class=\"line\">    ConstantValue: String hello word</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">1</span>: <span class=\"number\">0</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">5</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   LTest;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">    descriptor: ([Ljava/lang/String;)V</span><br><span class=\"line\">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">         3: ldc           #4                  // String hello word</span><br><span class=\"line\">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">5</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">6</span>: <span class=\"number\">8</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">9</span>     <span class=\"number\">0</span>  args   [Ljava/lang/String;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有的小伙伴可能没有将 jdk的bin目录配置到环境变量，执行<code>javap</code>指令的时候识别不了该指令，我们只需要指定指令的全路径就ok了，比如我的 bin 目录是 <code>C:\\jdk\\bin</code> 那我的指令就是 <code>C:\\jdk\\bin\\javap.exe -v -l -p -s -sy、sinfo  -constants Test.class</code>。javap 指令的参数含义可以通过 <code>javap -help</code>查看 这里不多做介绍。</p>\n<h2 id=\"操作码阅读指南\"><a href=\"#操作码阅读指南\" class=\"headerlink\" title=\"操作码阅读指南\"></a>操作码阅读指南</h2><p>通过命令行窗口输出的内容分为以下几个部分：</p>\n<ul>\n<li>Classfile 是一些类信息，</li>\n<li>Constant pool 是编译时常量池，<code>Constant pool</code> 中我们能看到方法信息、变量信息、关键字信息等，</li>\n<li>{} 里面的内容是方法的一些执行指令。</li>\n</ul>\n<p>我们将字节码文件翻译成了操作码，里面的信息量很大，别着急，我们一点点的去解读。Classfile部分是一些类信息，这一部分不是我们研究的重点，因此我这里不做太多介绍。<br>阅读操作码我们需要去查阅操作码指令表，在网上就能搜到。我在这里罗列一些比较重要的操作码。</p>\n<p>数据类型相关</p>\n<ul>\n<li>iload指令用于从局部变量表中加载int型的数据到操作数栈中；</li>\n<li>fload指令则是从局部变量表中加载float类型的数据到操作数栈中；</li>\n<li>i代表int类型，l代表long类型，s代表short类型，b代表byte类型，a代表reference类型；以此类推</li>\n</ul>\n<p>加载和存储指令相关</p>\n<ul>\n<li>将一个局部变量加载到操作数栈，有iload、iload_<n>、lload、lload_<n>、aload、aload_<n>等</li>\n<li>将一个数值从操作数栈存储到局部变量表，有istore、istore_<n>、lstore、lstore_<n>、astore、astore_<n>等</li>\n<li>将一个常量加载到操作数栈，有bipush、sipush、ldc、aconst_null、iconst_<i>等</li>\n</ul>\n<p>运算指令相关</p>\n<ul>\n<li>加法指令 iadd、ladd、fadd、dadd，</li>\n<li>减法指令 isub、lsub、fsub、dsub，</li>\n<li>乘法指令 imul、lmul、fmul、dmul，</li>\n<li>除法指令 idiv、ldiv、fdiv、ddiv，</li>\n<li>求余指令 irem、lrem、frem、drem</li>\n<li>取反指令 ineg、lneg、fneg、dneg</li>\n<li>位指令 ior、lor 是或运算，iand、land 是与运算 ixor、lxor 是异或运算</li>\n<li>其他 iinc 是自增运算 dcmpg、dcmpl、fcmpg、fcmpl、lcmp 是比较运算</li>\n</ul>\n<p>操作数栈指令</p>\n<ul>\n<li>出栈指令 pop、pop2 </li>\n<li>复制压栈 dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li>\n<li>将栈最顶端的两个数值互换 swap</li>\n<li>条件分支 ifeq、iflt、ifle、ifne </li>\n<li>无条件分支 goto、goto_w、jsr、jsr_w、ret</li>\n<li>复合条件分支tableswitch、lookupswitch</li>\n</ul>\n<p>方法调用相关</p>\n<ul>\n<li>方法返回值类型表示方式 ()V 表示 void 方法  ()Ljava/lang/String 表示 返回 String 类型，()I 表示返回int类型，以此类推</li>\n<li>invokevirtual指令用于调用对象的实例方法，</li>\n<li>invokeinterface指令用于调用接口方法，</li>\n<li>invokespecial指令用于调用一些需要特殊处理的实例方法</li>\n<li>invokestatic指令用于调用静态方法</li>\n<li>invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法</li>\n<li>athrow指令用来实现显式抛出异常的操作</li>\n<li>monitorenter和monitorexit两条指令来支持synchronized关键字的语义</li>\n</ul>\n<h2 id=\"操作码相关源码解读\"><a href=\"#操作码相关源码解读\" class=\"headerlink\" title=\"操作码相关源码解读\"></a>操作码相关源码解读</h2><p>前文提到过操作码可以看到 java 的一些秘密，下面我们由难到易解读几个案例。</p>\n<p><strong>案例一 this 关键字的加载时机</strong></p>\n<p>我们思考下面一段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String test;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行动态代码块&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.test=<span class=\"string\">&quot;执行动态代码块&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(test);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这段代码相信有工作经验的朋友都研究过，但是现在我们不是来讨论代码的额执行顺序，而是讨论另外一个问题：为什么动态代码块里面可以用 this 关键字？ 我们思考一下，this代指当前对象，而构造函数还没有执行我们哪来的对象？那还没有对象，我们的this又指向谁？这是一个值得思考的问题。那我们来看看这段代码的操作码吧：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   descriptor: ()V</span><br><span class=\"line\">   flags: ACC_PUBLIC</span><br><span class=\"line\">   Code:</span><br><span class=\"line\">     stack=<span class=\"number\">2</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class=\"line\">        4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">        7: ldc           #3                  // String 执行动态代码块</span><br><span class=\"line\">        9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">       <span class=\"number\">12</span>: aload_0</span><br><span class=\"line\">       13: ldc           #3                  // String 执行动态代码块</span><br><span class=\"line\">       15: putfield      #5                  // Field test:Ljava/lang/String;</span><br><span class=\"line\">       18: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">       <span class=\"number\">21</span>: aload_0</span><br><span class=\"line\">       22: getfield      #5                  // Field test:Ljava/lang/String;</span><br><span class=\"line\">       25: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">       <span class=\"number\">28</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">     LineNumberTable:</span><br><span class=\"line\">       line <span class=\"number\">9</span>: <span class=\"number\">0</span></span><br><span class=\"line\">       line <span class=\"number\">5</span>: <span class=\"number\">4</span></span><br><span class=\"line\">       line <span class=\"number\">6</span>: <span class=\"number\">12</span></span><br><span class=\"line\">       line <span class=\"number\">10</span>: <span class=\"number\">18</span></span><br><span class=\"line\">       line <span class=\"number\">11</span>: <span class=\"number\">28</span></span><br><span class=\"line\">     LocalVariableTable:</span><br><span class=\"line\">       Start  Length  Slot  Name   Signature</span><br><span class=\"line\">           <span class=\"number\">0</span>      <span class=\"number\">29</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   LTest;</span><br></pre></td></tr></table></figure>\n<p>我们仔细阅读发现，其实它的构造方法组成并不是我们在类里面看到的那样，第一步先执行 <code>aload_0</code> 然后 通过<code>invokespecial</code> 指令调用了 对象初始化方法 <code>&lt;init&gt;</code> ，然后再是正真的执行我们构造函数自己的逻辑。注意了，这里的 <code>aload_0</code> 就是加载this关键字，也就是其实动态代码块是直接编译在构造函数之中的，而且 this关键字的产生是对象产生的第一步；也就是说我们创建的对象从操作码的角度来讲，首先就是先加载一个 this 上来，然后再初始化对象，再实例化对象。</p>\n<p>案例二 sychornized 关键字原理。</p>\n<p>sychornized 从操作码的层面来观察是比较直观的，我们百度sychornized关键字原理的时候，通常是这么解释的：jvm基于进入和退出 <code>Monitor</code> 对象来实现方法同步和代码块同步，而这个 <code>Monitor</code> 是存储在Java对象头里的。<br>我们理解起来可能比较抽象，让我们读操作码来分析吧：</p>\n<p>同步方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  <span class=\"keyword\">void</span> <span class=\"title\">testSyn</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(Test.class)&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对应的部分操作码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testSyn</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\">   descriptor: (I)V</span><br><span class=\"line\">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class=\"line\">   Code:</span><br><span class=\"line\">     stack=<span class=\"number\">2</span>, locals=<span class=\"number\">3</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">        0: ldc           #6                  // class Test</span><br><span class=\"line\">        <span class=\"number\">2</span>: dup</span><br><span class=\"line\">        <span class=\"number\">3</span>: astore_1</span><br><span class=\"line\">        <span class=\"number\">4</span>: monitorenter</span><br><span class=\"line\">        5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">        8: ldc           #7                  // String &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">       10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">       <span class=\"number\">13</span>: aload_1</span><br><span class=\"line\">       <span class=\"number\">14</span>: monitorexit</span><br><span class=\"line\">       <span class=\"number\">15</span>: goto          <span class=\"number\">23</span></span><br><span class=\"line\">       <span class=\"number\">18</span>: astore_2</span><br><span class=\"line\">       <span class=\"number\">19</span>: aload_1</span><br><span class=\"line\">       <span class=\"number\">20</span>: monitorexit</span><br><span class=\"line\">       <span class=\"number\">21</span>: aload_2</span><br><span class=\"line\">       <span class=\"number\">22</span>: athrow</span><br><span class=\"line\">       <span class=\"number\">23</span>: <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p>结合前文的操作码指令介绍，我们可以看到同步代码块的执行过程，先执行 monitorenter 指令获取锁，当获取锁成功，执行下面的指令，最后 monitorexit 释放锁，monitorenter 被jvm封装成一个完整指令，其执行原理就是前面所说的内容，而再往深究的话就是通过互斥原语（CPU lock 指令加 对象头锁标记位）来实现的。</p>\n<p>案例三 对象初始化死锁。</p>\n<p>这是一个很有意思的题，在b站上能搜到它的操作码分析视频，关键字  小马哥每日一问 2019.07.18 期 。我把题目贴出来，大佬们自己动手研究一下，阅后习题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> initialized=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">      Thread t=<span class=\"keyword\">new</span> Thread(()-&gt; initialized=<span class=\"keyword\">true</span>);</span><br><span class=\"line\">      t.start();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          t.join();</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(initialized);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">以上程序输出内容是？</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">true</span></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">false</span></span><br><span class=\"line\"><span class=\"number\">3.</span> 编译错误</span><br><span class=\"line\"><span class=\"number\">4.</span> 以上答案都不对</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上面这个题目是很有意思的，小伙伴们仔细研究一下。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"操作码介绍\"><a href=\"#操作码介绍\" class=\"headerlink\" title=\"操作码介绍\"></a>操作码介绍</h1><p>我们都知在Java中我们的类会被编译成字节码然后放到虚拟机中去执行，字节码里面的内容其实我们也是可以去“阅读”的，方法就是通过 jdk自带的工具翻译成操作码。在操作码中我们能看到一些我们平时看不到的关于java的秘密。</p>\n<p>Java虚拟机的指令由一个字节长度的的数字以及跟随其后的零至多个代表此操作所需的参数构成。即：Java指令 = 操作码 + 操作数。Java虚拟机本身是采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。通过阅读操作码我们能直观的看到一些方法的执行过程。</p>","more":"<h2 id=\"查看操作码\"><a href=\"#查看操作码\" class=\"headerlink\" title=\"查看操作码\"></a>查看操作码</h2><p>我们随便找一个 .class 文件(我这里是Test.class)，然后在命令行执行:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javap -v -l -p -s -sysinfo  -constants Test.class</span><br></pre></td></tr></table></figure>\n<p><code>Test.java</code> 源码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String a;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String STR=<span class=\"string\">&quot;hello word&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(STR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>执行指令后可在命令行窗口看到:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Classfile /G:Test.class</span><br><span class=\"line\">  Last modified <span class=\"number\">2020</span>-<span class=\"number\">8</span>-<span class=\"number\">9</span>; size <span class=\"number\">585</span> bytes</span><br><span class=\"line\">  MD5 checksum 09bb7ece9c879902984714504494a9e3</span><br><span class=\"line\">  Compiled from <span class=\"string\">&quot;Test.java&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span></span><br><span class=\"line\">  minor version: 0</span><br><span class=\"line\">  major version: <span class=\"number\">52</span></span><br><span class=\"line\">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class=\"line\">Constant pool:</span><br><span class=\"line\">   #1 = Methodref          #6.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class=\"line\">   #2 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">   #3 = Class              #27            // Test</span><br><span class=\"line\">   #4 = String             #28            // hello word</span><br><span class=\"line\">   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">   #6 = Class              #31            // java/lang/Object</span><br><span class=\"line\">   #7 = Utf8               a</span><br><span class=\"line\">   #8 = Utf8               Ljava/lang/String;</span><br><span class=\"line\">   #9 = Utf8               STR</span><br><span class=\"line\">  #10 = Utf8               ConstantValue</span><br><span class=\"line\">  #11 = Utf8               &lt;init&gt;</span><br><span class=\"line\">  #12 = Utf8               ()V</span><br><span class=\"line\">  #13 = Utf8               Code</span><br><span class=\"line\">  #14 = Utf8               LineNumberTable</span><br><span class=\"line\">  #15 = Utf8               LocalVariableTable</span><br><span class=\"line\">  #16 = Utf8               this</span><br><span class=\"line\">  #17 = Utf8               LTest;</span><br><span class=\"line\">  #18 = Utf8               main</span><br><span class=\"line\">  #19 = Utf8               ([Ljava/lang/String;)V</span><br><span class=\"line\">  #20 = Utf8               args</span><br><span class=\"line\">  #21 = Utf8               [Ljava/lang/String;</span><br><span class=\"line\">  #22 = Utf8               SourceFile</span><br><span class=\"line\">  #23 = Utf8               Test.java</span><br><span class=\"line\">  #24 = NameAndType        #11:#12        // &quot;&lt;init&gt;&quot;:()V</span><br><span class=\"line\">  #25 = Class              #32            // java/lang/System</span><br><span class=\"line\">  #26 = NameAndType        #33:#34        // out:Ljava/io/PrintStream;</span><br><span class=\"line\">  #27 = Utf8               Test</span><br><span class=\"line\">  #28 = Utf8               hello word</span><br><span class=\"line\">  #29 = Class              #35            // java/io/PrintStream</span><br><span class=\"line\">  #30 = NameAndType        #36:#37        // println:(Ljava/lang/String;)V</span><br><span class=\"line\">  #31 = Utf8               java/lang/Object</span><br><span class=\"line\">  #32 = Utf8               java/lang/System</span><br><span class=\"line\">  #33 = Utf8               out</span><br><span class=\"line\">  #34 = Utf8               Ljava/io/PrintStream;</span><br><span class=\"line\">  #35 = Utf8               java/io/PrintStream</span><br><span class=\"line\">  #36 = Utf8               println</span><br><span class=\"line\">  #37 = Utf8               (Ljava/lang/String;)V</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> java.lang.String a;</span><br><span class=\"line\">    descriptor: Ljava/lang/String;</span><br><span class=\"line\">    flags: ACC_PRIVATE</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> java.lang.String STR = <span class=\"string\">&quot;hello word&quot;</span>;</span><br><span class=\"line\">    descriptor: Ljava/lang/String;</span><br><span class=\"line\">    flags: ACC_PRIVATE, ACC_STATIC, ACC_FINAL</span><br><span class=\"line\">    ConstantValue: String hello word</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">1</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class=\"line\">         <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">1</span>: <span class=\"number\">0</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">5</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   LTest;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">    descriptor: ([Ljava/lang/String;)V</span><br><span class=\"line\">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">         3: ldc           #4                  // String hello word</span><br><span class=\"line\">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">5</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">6</span>: <span class=\"number\">8</span></span><br><span class=\"line\">      LocalVariableTable:</span><br><span class=\"line\">        Start  Length  Slot  Name   Signature</span><br><span class=\"line\">            <span class=\"number\">0</span>       <span class=\"number\">9</span>     <span class=\"number\">0</span>  args   [Ljava/lang/String;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有的小伙伴可能没有将 jdk的bin目录配置到环境变量，执行<code>javap</code>指令的时候识别不了该指令，我们只需要指定指令的全路径就ok了，比如我的 bin 目录是 <code>C:\\jdk\\bin</code> 那我的指令就是 <code>C:\\jdk\\bin\\javap.exe -v -l -p -s -sy、sinfo  -constants Test.class</code>。javap 指令的参数含义可以通过 <code>javap -help</code>查看 这里不多做介绍。</p>\n<h2 id=\"操作码阅读指南\"><a href=\"#操作码阅读指南\" class=\"headerlink\" title=\"操作码阅读指南\"></a>操作码阅读指南</h2><p>通过命令行窗口输出的内容分为以下几个部分：</p>\n<ul>\n<li>Classfile 是一些类信息，</li>\n<li>Constant pool 是编译时常量池，<code>Constant pool</code> 中我们能看到方法信息、变量信息、关键字信息等，</li>\n<li>{} 里面的内容是方法的一些执行指令。</li>\n</ul>\n<p>我们将字节码文件翻译成了操作码，里面的信息量很大，别着急，我们一点点的去解读。Classfile部分是一些类信息，这一部分不是我们研究的重点，因此我这里不做太多介绍。<br>阅读操作码我们需要去查阅操作码指令表，在网上就能搜到。我在这里罗列一些比较重要的操作码。</p>\n<p>数据类型相关</p>\n<ul>\n<li>iload指令用于从局部变量表中加载int型的数据到操作数栈中；</li>\n<li>fload指令则是从局部变量表中加载float类型的数据到操作数栈中；</li>\n<li>i代表int类型，l代表long类型，s代表short类型，b代表byte类型，a代表reference类型；以此类推</li>\n</ul>\n<p>加载和存储指令相关</p>\n<ul>\n<li>将一个局部变量加载到操作数栈，有iload、iload_<n>、lload、lload_<n>、aload、aload_<n>等</li>\n<li>将一个数值从操作数栈存储到局部变量表，有istore、istore_<n>、lstore、lstore_<n>、astore、astore_<n>等</li>\n<li>将一个常量加载到操作数栈，有bipush、sipush、ldc、aconst_null、iconst_<i>等</li>\n</ul>\n<p>运算指令相关</p>\n<ul>\n<li>加法指令 iadd、ladd、fadd、dadd，</li>\n<li>减法指令 isub、lsub、fsub、dsub，</li>\n<li>乘法指令 imul、lmul、fmul、dmul，</li>\n<li>除法指令 idiv、ldiv、fdiv、ddiv，</li>\n<li>求余指令 irem、lrem、frem、drem</li>\n<li>取反指令 ineg、lneg、fneg、dneg</li>\n<li>位指令 ior、lor 是或运算，iand、land 是与运算 ixor、lxor 是异或运算</li>\n<li>其他 iinc 是自增运算 dcmpg、dcmpl、fcmpg、fcmpl、lcmp 是比较运算</li>\n</ul>\n<p>操作数栈指令</p>\n<ul>\n<li>出栈指令 pop、pop2 </li>\n<li>复制压栈 dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li>\n<li>将栈最顶端的两个数值互换 swap</li>\n<li>条件分支 ifeq、iflt、ifle、ifne </li>\n<li>无条件分支 goto、goto_w、jsr、jsr_w、ret</li>\n<li>复合条件分支tableswitch、lookupswitch</li>\n</ul>\n<p>方法调用相关</p>\n<ul>\n<li>方法返回值类型表示方式 ()V 表示 void 方法  ()Ljava/lang/String 表示 返回 String 类型，()I 表示返回int类型，以此类推</li>\n<li>invokevirtual指令用于调用对象的实例方法，</li>\n<li>invokeinterface指令用于调用接口方法，</li>\n<li>invokespecial指令用于调用一些需要特殊处理的实例方法</li>\n<li>invokestatic指令用于调用静态方法</li>\n<li>invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法</li>\n<li>athrow指令用来实现显式抛出异常的操作</li>\n<li>monitorenter和monitorexit两条指令来支持synchronized关键字的语义</li>\n</ul>\n<h2 id=\"操作码相关源码解读\"><a href=\"#操作码相关源码解读\" class=\"headerlink\" title=\"操作码相关源码解读\"></a>操作码相关源码解读</h2><p>前文提到过操作码可以看到 java 的一些秘密，下面我们由难到易解读几个案例。</p>\n<p><strong>案例一 this 关键字的加载时机</strong></p>\n<p>我们思考下面一段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String test;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行动态代码块&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.test=<span class=\"string\">&quot;执行动态代码块&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(test);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这段代码相信有工作经验的朋友都研究过，但是现在我们不是来讨论代码的额执行顺序，而是讨论另外一个问题：为什么动态代码块里面可以用 this 关键字？ 我们思考一下，this代指当前对象，而构造函数还没有执行我们哪来的对象？那还没有对象，我们的this又指向谁？这是一个值得思考的问题。那我们来看看这段代码的操作码吧：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   descriptor: ()V</span><br><span class=\"line\">   flags: ACC_PUBLIC</span><br><span class=\"line\">   Code:</span><br><span class=\"line\">     stack=<span class=\"number\">2</span>, locals=<span class=\"number\">1</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">        1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class=\"line\">        4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">        7: ldc           #3                  // String 执行动态代码块</span><br><span class=\"line\">        9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">       <span class=\"number\">12</span>: aload_0</span><br><span class=\"line\">       13: ldc           #3                  // String 执行动态代码块</span><br><span class=\"line\">       15: putfield      #5                  // Field test:Ljava/lang/String;</span><br><span class=\"line\">       18: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">       <span class=\"number\">21</span>: aload_0</span><br><span class=\"line\">       22: getfield      #5                  // Field test:Ljava/lang/String;</span><br><span class=\"line\">       25: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">       <span class=\"number\">28</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">     LineNumberTable:</span><br><span class=\"line\">       line <span class=\"number\">9</span>: <span class=\"number\">0</span></span><br><span class=\"line\">       line <span class=\"number\">5</span>: <span class=\"number\">4</span></span><br><span class=\"line\">       line <span class=\"number\">6</span>: <span class=\"number\">12</span></span><br><span class=\"line\">       line <span class=\"number\">10</span>: <span class=\"number\">18</span></span><br><span class=\"line\">       line <span class=\"number\">11</span>: <span class=\"number\">28</span></span><br><span class=\"line\">     LocalVariableTable:</span><br><span class=\"line\">       Start  Length  Slot  Name   Signature</span><br><span class=\"line\">           <span class=\"number\">0</span>      <span class=\"number\">29</span>     <span class=\"number\">0</span>  <span class=\"keyword\">this</span>   LTest;</span><br></pre></td></tr></table></figure>\n<p>我们仔细阅读发现，其实它的构造方法组成并不是我们在类里面看到的那样，第一步先执行 <code>aload_0</code> 然后 通过<code>invokespecial</code> 指令调用了 对象初始化方法 <code>&lt;init&gt;</code> ，然后再是正真的执行我们构造函数自己的逻辑。注意了，这里的 <code>aload_0</code> 就是加载this关键字，也就是其实动态代码块是直接编译在构造函数之中的，而且 this关键字的产生是对象产生的第一步；也就是说我们创建的对象从操作码的角度来讲，首先就是先加载一个 this 上来，然后再初始化对象，再实例化对象。</p>\n<p>案例二 sychornized 关键字原理。</p>\n<p>sychornized 从操作码的层面来观察是比较直观的，我们百度sychornized关键字原理的时候，通常是这么解释的：jvm基于进入和退出 <code>Monitor</code> 对象来实现方法同步和代码块同步，而这个 <code>Monitor</code> 是存储在Java对象头里的。<br>我们理解起来可能比较抽象，让我们读操作码来分析吧：</p>\n<p>同步方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  <span class=\"keyword\">void</span> <span class=\"title\">testSyn</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(Test.class)&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对应的部分操作码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testSyn</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\">   descriptor: (I)V</span><br><span class=\"line\">   flags: ACC_PUBLIC, ACC_STATIC</span><br><span class=\"line\">   Code:</span><br><span class=\"line\">     stack=<span class=\"number\">2</span>, locals=<span class=\"number\">3</span>, args_size=<span class=\"number\">1</span></span><br><span class=\"line\">        0: ldc           #6                  // class Test</span><br><span class=\"line\">        <span class=\"number\">2</span>: dup</span><br><span class=\"line\">        <span class=\"number\">3</span>: astore_1</span><br><span class=\"line\">        <span class=\"number\">4</span>: monitorenter</span><br><span class=\"line\">        5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">        8: ldc           #7                  // String &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">       10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">       <span class=\"number\">13</span>: aload_1</span><br><span class=\"line\">       <span class=\"number\">14</span>: monitorexit</span><br><span class=\"line\">       <span class=\"number\">15</span>: goto          <span class=\"number\">23</span></span><br><span class=\"line\">       <span class=\"number\">18</span>: astore_2</span><br><span class=\"line\">       <span class=\"number\">19</span>: aload_1</span><br><span class=\"line\">       <span class=\"number\">20</span>: monitorexit</span><br><span class=\"line\">       <span class=\"number\">21</span>: aload_2</span><br><span class=\"line\">       <span class=\"number\">22</span>: athrow</span><br><span class=\"line\">       <span class=\"number\">23</span>: <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p>结合前文的操作码指令介绍，我们可以看到同步代码块的执行过程，先执行 monitorenter 指令获取锁，当获取锁成功，执行下面的指令，最后 monitorexit 释放锁，monitorenter 被jvm封装成一个完整指令，其执行原理就是前面所说的内容，而再往深究的话就是通过互斥原语（CPU lock 指令加 对象头锁标记位）来实现的。</p>\n<p>案例三 对象初始化死锁。</p>\n<p>这是一个很有意思的题，在b站上能搜到它的操作码分析视频，关键字  小马哥每日一问 2019.07.18 期 。我把题目贴出来，大佬们自己动手研究一下，阅后习题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> initialized=<span class=\"keyword\">false</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">      Thread t=<span class=\"keyword\">new</span> Thread(()-&gt; initialized=<span class=\"keyword\">true</span>);</span><br><span class=\"line\">      t.start();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          t.join();</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(initialized);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">以上程序输出内容是？</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span> <span class=\"keyword\">true</span></span><br><span class=\"line\"><span class=\"number\">2.</span> <span class=\"keyword\">false</span></span><br><span class=\"line\"><span class=\"number\">3.</span> 编译错误</span><br><span class=\"line\"><span class=\"number\">4.</span> 以上答案都不对</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>上面这个题目是很有意思的，小伙伴们仔细研究一下。</p>"},{"title":"jvm基础篇一之内存区域","date":"2019-04-23T02:12:53.000Z","_content":"作者：muggle\n## 运行时数据区域\n &emsp; &emsp;想要了解jvm，那对其内存分配管理的学习是必不可少的；java虚拟机在执行java程序的时候会把它所管理的内存划分成若干数据区域。这些区域有着不同的功能、用途、创建/销毁时间。java虚拟机所分配管理的内存区域如图1所示\n\n###  程序计数器\n&emsp; &emsp;程序计数器是一块比较小的内存空间，它可以看做是当前线程所执行的字节码的执行位置的指针。在虚拟机中字节码，解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的指令；虚拟机完成分支、循环、跳转、异常处理、线程恢复等功能都需要依靠它。\n&emsp; &emsp;我们知道jvm多线程是通过线程的轮流切换并分配处理器执行时间的的方式来实现的，在任何时刻，一个处理器都只会执行一条线程中的指令。为了使线程被切换后能恢复到正确的执行位置，每条线程的程序计数器都应该是独立的，各条线程之间的计数器互不干涉，独立存储————程序计数器的内存区域为线程私有的内存。<br/>\n&emsp; &emsp;如果线程正在执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器的值则为空。此内存区域是唯一一个在jvm规范中没有规定任何OutOfMemoryerror情况的区域\n\n<!--more-->\n\n###  java虚拟机栈\n&emsp; &emsp;java虚拟机栈为线程私有的内存，其生命周期与线程相同。每个方法在执行的时候会创建一个栈帧用于存储局部变量表、操作数栈、方法出口等信息。每一个方法从调用到执行完成，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。其局部变量表存放了方法编译期可知的各种基本数据类型、对象引用、returnAddress类型（指向一条字节码指令的地址）jvm规范中，这个区域规定了两种异常状况：StackOverflowError和OutOfMemoryError。\n###  本地方法栈\n&emsp; &emsp;本地方法栈的作用和虚拟机栈的作用很相似，它们的区别在于虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为执行本地方法服务。有的虚拟机直接把本地方法栈和虚拟机栈二合一。与虚拟机栈一样，本地方法栈的异常也有两个：StackOverflowError和OutOfMemoryError。\n###  java堆区\n&emsp; &emsp;java堆是虚拟机所管理的内存中最大的一块，它是被所有线程共享的一块内存区域，该区域在虚拟机启动的时候创建。这个区域的唯一目的就是存放对象实例。java堆是垃圾收集器工作的主要区域，由于垃圾收集器基本都采用分代收集的算法，所以java堆从垃圾收集器的角度来划分可以细分为新生代和老年代；从内存分配的角度来看，线程共享的java堆可能划分出多个线程私有的分配缓冲区。<br/>\n&emsp; &emsp;java堆区可以是物理上不连续的内存空间，只要逻辑上是连续的即可；一般而言我们的虚拟机java堆内存不是固定大小的，是可以扩展的。如果在堆中没有足够内存分配给对象实例，并且堆内存无法再扩展时，虚拟机将会抛出OutOfMemoryError异常。\n###  方法区\n&emsp; &emsp;方法区与java堆区一样是各个线程共享的内存区域，这个区域存储了类信息、常量、静态变量等数据。java虚拟机规范中把方法区描述为堆得一部分逻辑，它又有一个名字——非堆，目的是与普通java堆进行区分。相对而言垃圾收集器在这个区域很少活动，因此一部分人把这个区域叫做“永久代”。这个区域的内存回收目标主要是针对常量池的回收和类型的卸载，然而类型卸载的条件是很苛刻的。该区域和和java堆区一样，当内存不够分配时会抛出OutOfMemoryError.\n###  运行时常量池\n&emsp; &emsp;运行时常量池是方法区的一部分；一个Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是编译时常量池，用于存放编译期生成的常量。编译时常量池在类被加载后会放入方法区的运行时常量池中。与编译期常量池不同的是，运运行时常量池是动态的，运行期间产生的新的常量也会被放入这个区域，如：String类的intern()方法。\n\n### 小结\n&emsp; &emsp;该篇对jvm内存只能算一个概览，给小伙伴们介绍了一些概念性的东西，很多地方是值得去深入研究的，比如具体一个对象实例是如何被分配到堆内存的，类的加载过程，方法执行时方法栈的入栈与出栈的具体过程······。jvm博大精深，我在这提供一个梗概，小伙伴们如果有时间可以细细推敲推敲。","source":"_posts/jvm-1.md","raw":"---\ntitle: jvm基础篇一之内存区域\ndate: 2019-04-23 10:12:53\ntags: jvm\n---\n作者：muggle\n## 运行时数据区域\n &emsp; &emsp;想要了解jvm，那对其内存分配管理的学习是必不可少的；java虚拟机在执行java程序的时候会把它所管理的内存划分成若干数据区域。这些区域有着不同的功能、用途、创建/销毁时间。java虚拟机所分配管理的内存区域如图1所示\n\n###  程序计数器\n&emsp; &emsp;程序计数器是一块比较小的内存空间，它可以看做是当前线程所执行的字节码的执行位置的指针。在虚拟机中字节码，解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的指令；虚拟机完成分支、循环、跳转、异常处理、线程恢复等功能都需要依靠它。\n&emsp; &emsp;我们知道jvm多线程是通过线程的轮流切换并分配处理器执行时间的的方式来实现的，在任何时刻，一个处理器都只会执行一条线程中的指令。为了使线程被切换后能恢复到正确的执行位置，每条线程的程序计数器都应该是独立的，各条线程之间的计数器互不干涉，独立存储————程序计数器的内存区域为线程私有的内存。<br/>\n&emsp; &emsp;如果线程正在执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器的值则为空。此内存区域是唯一一个在jvm规范中没有规定任何OutOfMemoryerror情况的区域\n\n<!--more-->\n\n###  java虚拟机栈\n&emsp; &emsp;java虚拟机栈为线程私有的内存，其生命周期与线程相同。每个方法在执行的时候会创建一个栈帧用于存储局部变量表、操作数栈、方法出口等信息。每一个方法从调用到执行完成，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。其局部变量表存放了方法编译期可知的各种基本数据类型、对象引用、returnAddress类型（指向一条字节码指令的地址）jvm规范中，这个区域规定了两种异常状况：StackOverflowError和OutOfMemoryError。\n###  本地方法栈\n&emsp; &emsp;本地方法栈的作用和虚拟机栈的作用很相似，它们的区别在于虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为执行本地方法服务。有的虚拟机直接把本地方法栈和虚拟机栈二合一。与虚拟机栈一样，本地方法栈的异常也有两个：StackOverflowError和OutOfMemoryError。\n###  java堆区\n&emsp; &emsp;java堆是虚拟机所管理的内存中最大的一块，它是被所有线程共享的一块内存区域，该区域在虚拟机启动的时候创建。这个区域的唯一目的就是存放对象实例。java堆是垃圾收集器工作的主要区域，由于垃圾收集器基本都采用分代收集的算法，所以java堆从垃圾收集器的角度来划分可以细分为新生代和老年代；从内存分配的角度来看，线程共享的java堆可能划分出多个线程私有的分配缓冲区。<br/>\n&emsp; &emsp;java堆区可以是物理上不连续的内存空间，只要逻辑上是连续的即可；一般而言我们的虚拟机java堆内存不是固定大小的，是可以扩展的。如果在堆中没有足够内存分配给对象实例，并且堆内存无法再扩展时，虚拟机将会抛出OutOfMemoryError异常。\n###  方法区\n&emsp; &emsp;方法区与java堆区一样是各个线程共享的内存区域，这个区域存储了类信息、常量、静态变量等数据。java虚拟机规范中把方法区描述为堆得一部分逻辑，它又有一个名字——非堆，目的是与普通java堆进行区分。相对而言垃圾收集器在这个区域很少活动，因此一部分人把这个区域叫做“永久代”。这个区域的内存回收目标主要是针对常量池的回收和类型的卸载，然而类型卸载的条件是很苛刻的。该区域和和java堆区一样，当内存不够分配时会抛出OutOfMemoryError.\n###  运行时常量池\n&emsp; &emsp;运行时常量池是方法区的一部分；一个Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是编译时常量池，用于存放编译期生成的常量。编译时常量池在类被加载后会放入方法区的运行时常量池中。与编译期常量池不同的是，运运行时常量池是动态的，运行期间产生的新的常量也会被放入这个区域，如：String类的intern()方法。\n\n### 小结\n&emsp; &emsp;该篇对jvm内存只能算一个概览，给小伙伴们介绍了一些概念性的东西，很多地方是值得去深入研究的，比如具体一个对象实例是如何被分配到堆内存的，类的加载过程，方法执行时方法栈的入栈与出栈的具体过程······。jvm博大精深，我在这提供一个梗概，小伙伴们如果有时间可以细细推敲推敲。","slug":"jvm-1","published":1,"updated":"2021-01-11T07:31:23.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh68001t00wi3k9rg2hd","content":"<p>作者：muggle</p>\n<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><p> &emsp; &emsp;想要了解jvm，那对其内存分配管理的学习是必不可少的；java虚拟机在执行java程序的时候会把它所管理的内存划分成若干数据区域。这些区域有着不同的功能、用途、创建/销毁时间。java虚拟机所分配管理的内存区域如图1所示</p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>&emsp; &emsp;程序计数器是一块比较小的内存空间，它可以看做是当前线程所执行的字节码的执行位置的指针。在虚拟机中字节码，解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的指令；虚拟机完成分支、循环、跳转、异常处理、线程恢复等功能都需要依靠它。<br>&emsp; &emsp;我们知道jvm多线程是通过线程的轮流切换并分配处理器执行时间的的方式来实现的，在任何时刻，一个处理器都只会执行一条线程中的指令。为了使线程被切换后能恢复到正确的执行位置，每条线程的程序计数器都应该是独立的，各条线程之间的计数器互不干涉，独立存储————程序计数器的内存区域为线程私有的内存。<br/><br>&emsp; &emsp;如果线程正在执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器的值则为空。此内存区域是唯一一个在jvm规范中没有规定任何OutOfMemoryerror情况的区域</p>\n<a id=\"more\"></a>\n\n<h3 id=\"java虚拟机栈\"><a href=\"#java虚拟机栈\" class=\"headerlink\" title=\"java虚拟机栈\"></a>java虚拟机栈</h3><p>&emsp; &emsp;java虚拟机栈为线程私有的内存，其生命周期与线程相同。每个方法在执行的时候会创建一个栈帧用于存储局部变量表、操作数栈、方法出口等信息。每一个方法从调用到执行完成，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。其局部变量表存放了方法编译期可知的各种基本数据类型、对象引用、returnAddress类型（指向一条字节码指令的地址）jvm规范中，这个区域规定了两种异常状况：StackOverflowError和OutOfMemoryError。</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>&emsp; &emsp;本地方法栈的作用和虚拟机栈的作用很相似，它们的区别在于虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为执行本地方法服务。有的虚拟机直接把本地方法栈和虚拟机栈二合一。与虚拟机栈一样，本地方法栈的异常也有两个：StackOverflowError和OutOfMemoryError。</p>\n<h3 id=\"java堆区\"><a href=\"#java堆区\" class=\"headerlink\" title=\"java堆区\"></a>java堆区</h3><p>&emsp; &emsp;java堆是虚拟机所管理的内存中最大的一块，它是被所有线程共享的一块内存区域，该区域在虚拟机启动的时候创建。这个区域的唯一目的就是存放对象实例。java堆是垃圾收集器工作的主要区域，由于垃圾收集器基本都采用分代收集的算法，所以java堆从垃圾收集器的角度来划分可以细分为新生代和老年代；从内存分配的角度来看，线程共享的java堆可能划分出多个线程私有的分配缓冲区。<br/><br>&emsp; &emsp;java堆区可以是物理上不连续的内存空间，只要逻辑上是连续的即可；一般而言我们的虚拟机java堆内存不是固定大小的，是可以扩展的。如果在堆中没有足够内存分配给对象实例，并且堆内存无法再扩展时，虚拟机将会抛出OutOfMemoryError异常。</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>&emsp; &emsp;方法区与java堆区一样是各个线程共享的内存区域，这个区域存储了类信息、常量、静态变量等数据。java虚拟机规范中把方法区描述为堆得一部分逻辑，它又有一个名字——非堆，目的是与普通java堆进行区分。相对而言垃圾收集器在这个区域很少活动，因此一部分人把这个区域叫做“永久代”。这个区域的内存回收目标主要是针对常量池的回收和类型的卸载，然而类型卸载的条件是很苛刻的。该区域和和java堆区一样，当内存不够分配时会抛出OutOfMemoryError.</p>\n<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h3><p>&emsp; &emsp;运行时常量池是方法区的一部分；一个Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是编译时常量池，用于存放编译期生成的常量。编译时常量池在类被加载后会放入方法区的运行时常量池中。与编译期常量池不同的是，运运行时常量池是动态的，运行期间产生的新的常量也会被放入这个区域，如：String类的intern()方法。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>&emsp; &emsp;该篇对jvm内存只能算一个概览，给小伙伴们介绍了一些概念性的东西，很多地方是值得去深入研究的，比如具体一个对象实例是如何被分配到堆内存的，类的加载过程，方法执行时方法栈的入栈与出栈的具体过程······。jvm博大精深，我在这提供一个梗概，小伙伴们如果有时间可以细细推敲推敲。</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><p> &emsp; &emsp;想要了解jvm，那对其内存分配管理的学习是必不可少的；java虚拟机在执行java程序的时候会把它所管理的内存划分成若干数据区域。这些区域有着不同的功能、用途、创建/销毁时间。java虚拟机所分配管理的内存区域如图1所示</p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>&emsp; &emsp;程序计数器是一块比较小的内存空间，它可以看做是当前线程所执行的字节码的执行位置的指针。在虚拟机中字节码，解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的指令；虚拟机完成分支、循环、跳转、异常处理、线程恢复等功能都需要依靠它。<br>&emsp; &emsp;我们知道jvm多线程是通过线程的轮流切换并分配处理器执行时间的的方式来实现的，在任何时刻，一个处理器都只会执行一条线程中的指令。为了使线程被切换后能恢复到正确的执行位置，每条线程的程序计数器都应该是独立的，各条线程之间的计数器互不干涉，独立存储————程序计数器的内存区域为线程私有的内存。<br/><br>&emsp; &emsp;如果线程正在执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器的值则为空。此内存区域是唯一一个在jvm规范中没有规定任何OutOfMemoryerror情况的区域</p>","more":"<h3 id=\"java虚拟机栈\"><a href=\"#java虚拟机栈\" class=\"headerlink\" title=\"java虚拟机栈\"></a>java虚拟机栈</h3><p>&emsp; &emsp;java虚拟机栈为线程私有的内存，其生命周期与线程相同。每个方法在执行的时候会创建一个栈帧用于存储局部变量表、操作数栈、方法出口等信息。每一个方法从调用到执行完成，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。其局部变量表存放了方法编译期可知的各种基本数据类型、对象引用、returnAddress类型（指向一条字节码指令的地址）jvm规范中，这个区域规定了两种异常状况：StackOverflowError和OutOfMemoryError。</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>&emsp; &emsp;本地方法栈的作用和虚拟机栈的作用很相似，它们的区别在于虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为执行本地方法服务。有的虚拟机直接把本地方法栈和虚拟机栈二合一。与虚拟机栈一样，本地方法栈的异常也有两个：StackOverflowError和OutOfMemoryError。</p>\n<h3 id=\"java堆区\"><a href=\"#java堆区\" class=\"headerlink\" title=\"java堆区\"></a>java堆区</h3><p>&emsp; &emsp;java堆是虚拟机所管理的内存中最大的一块，它是被所有线程共享的一块内存区域，该区域在虚拟机启动的时候创建。这个区域的唯一目的就是存放对象实例。java堆是垃圾收集器工作的主要区域，由于垃圾收集器基本都采用分代收集的算法，所以java堆从垃圾收集器的角度来划分可以细分为新生代和老年代；从内存分配的角度来看，线程共享的java堆可能划分出多个线程私有的分配缓冲区。<br/><br>&emsp; &emsp;java堆区可以是物理上不连续的内存空间，只要逻辑上是连续的即可；一般而言我们的虚拟机java堆内存不是固定大小的，是可以扩展的。如果在堆中没有足够内存分配给对象实例，并且堆内存无法再扩展时，虚拟机将会抛出OutOfMemoryError异常。</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>&emsp; &emsp;方法区与java堆区一样是各个线程共享的内存区域，这个区域存储了类信息、常量、静态变量等数据。java虚拟机规范中把方法区描述为堆得一部分逻辑，它又有一个名字——非堆，目的是与普通java堆进行区分。相对而言垃圾收集器在这个区域很少活动，因此一部分人把这个区域叫做“永久代”。这个区域的内存回收目标主要是针对常量池的回收和类型的卸载，然而类型卸载的条件是很苛刻的。该区域和和java堆区一样，当内存不够分配时会抛出OutOfMemoryError.</p>\n<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h3><p>&emsp; &emsp;运行时常量池是方法区的一部分；一个Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是编译时常量池，用于存放编译期生成的常量。编译时常量池在类被加载后会放入方法区的运行时常量池中。与编译期常量池不同的是，运运行时常量池是动态的，运行期间产生的新的常量也会被放入这个区域，如：String类的intern()方法。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>&emsp; &emsp;该篇对jvm内存只能算一个概览，给小伙伴们介绍了一些概念性的东西，很多地方是值得去深入研究的，比如具体一个对象实例是如何被分配到堆内存的，类的加载过程，方法执行时方法栈的入栈与出栈的具体过程······。jvm博大精深，我在这提供一个梗概，小伙伴们如果有时间可以细细推敲推敲。</p>"},{"title":"jvm基础篇二之对象","date":"2019-04-23T02:17:43.000Z","_content":"\n作者：muggle\n\n###  对象的创建\n\n&emsp; &emsp;在语言层面上，创建一个对象通常是通过new关键字来创建，在虚拟机中遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过；如果没有的话就会先加载这个类；类加载检查完后，虚拟机将会为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，在堆中为对象划分一块内存出来。\n\n&emsp; &emsp;虚拟机给对象分配内存的方式有两种——“指针碰撞”的方式和“空闲列表”的方式。如果java堆内存是绝对规整的，所有用过的内存放在一边，未使用的内存放在另一边，中间放一个指针作为指示器，那分配内存就只是把指针向未使用区域挪一段与对象大小相等的距离；这种分配方式叫指针碰撞式，如图1所示。\n<!--more-->\n\n![图1：指针碰撞式内存分配方式](http://upload-images.jianshu.io/upload_images/13612520-35177fc9f287a7f3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们知道，堆内存随时都可能被垃圾收集器回收的，当内存被回收后堆内存就可能不是连续的了，所以当采用指针碰撞的方式时，垃圾收集器必须有内存整理的功能，能对垃圾回收后的零散内存进行整理。而空闲列表的方式则不需要垃圾收集有这个功能，采用这种方式时虚拟机会维护一张表，用于记录那些内存是可用的，当需要分配内存时就从表中找出一块足够的内存进行分配，并记录在表上。\n\n&emsp; &emsp;内存分配完成后，虚拟机需要将分配到的内存空间都初始化；接下来虚拟机会对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希值、对象的GC的分代年龄等信息。这些信息存在对象的对象头之中。完成这些工作后，从虚拟机的角度来看一个新的对象就产生了，但从程序的角度来看对象创建才刚刚开始，对象尚未执行初始化方法，各个字段都还未赋值，接下来会执行初始化方法，只有在执行初始化方法后，一个真正可用的对象才算是被创建。\n### 对象的内存\n在HotSpot虚拟机中，对象在内存中分为三块区域：对象头、实例数据、和对齐填充。对象头包括两部分信息，第一部分用于存储对象自身运行的运行时数据，如哈希码、GC分代年龄、锁状态标志线程持有的锁等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例\n。接下来的实例数据部分是对象真正存储的有效信息，也是在代码中所定义的各个字段的内容。这些字段无论是在父类那继承过来的还是子类里定义都要记录下来。第三部分对齐填充不是必然存在的，它仅仅起占位符的作用，用以填充内存。\n### 对象的访问定位\n  &emsp; &emsp;建立对象是为了使用对象，我们的java程序需要通过栈上的reference来操作堆上的对象。通过reference来访问对象的方法有两种——使用句柄和直接指针。在虚拟机执行一个方法时，虚拟机栈 中会为方法分配一个 局部变量表，一个操作数栈；局部变量表是用于保存函数的参数以及局部变量的，其保存的类型有boolean、byte、char、short、int、float、reference和returnAddress八种；方法在执行的过程中，会有各种各样的字节码指令往操作数栈中执行入栈和出栈操作，完成数据的运算。基本数据类型直接存储到变量表中。那reference是如何找到引用的对象的呢？\n\n  &emsp; &emsp;如果使用句柄的话，那么会在java堆中划分一块内存来作为句柄池，reference中存储的是句柄的地址，而句柄中包含了对象的具体地址信息，如图2所示\n![图:2：通过句柄访问对象](http://upload-images.jianshu.io/upload_images/13612520-444340fc1999cdc6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  &emsp; &emsp;如果使用直接指针访问，那么java堆对象的布局则如图3所示；\n![图3：通过直接指针访问对象](http://upload-images.jianshu.io/upload_images/13612520-cfd7ee35d69ee849?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 小结\n  &emsp; &emsp;对象的内存分布使用情况就介绍到这，感兴趣的小伙伴可以自己画一画当虚拟机执行递归方法时的堆栈运行状况的示意图。","source":"_posts/jvm-2.md","raw":"---\ntitle: jvm基础篇二之对象\ndate: 2019-04-23 10:17:43\ntags: jvm\n---\n\n作者：muggle\n\n###  对象的创建\n\n&emsp; &emsp;在语言层面上，创建一个对象通常是通过new关键字来创建，在虚拟机中遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过；如果没有的话就会先加载这个类；类加载检查完后，虚拟机将会为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，在堆中为对象划分一块内存出来。\n\n&emsp; &emsp;虚拟机给对象分配内存的方式有两种——“指针碰撞”的方式和“空闲列表”的方式。如果java堆内存是绝对规整的，所有用过的内存放在一边，未使用的内存放在另一边，中间放一个指针作为指示器，那分配内存就只是把指针向未使用区域挪一段与对象大小相等的距离；这种分配方式叫指针碰撞式，如图1所示。\n<!--more-->\n\n![图1：指针碰撞式内存分配方式](http://upload-images.jianshu.io/upload_images/13612520-35177fc9f287a7f3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们知道，堆内存随时都可能被垃圾收集器回收的，当内存被回收后堆内存就可能不是连续的了，所以当采用指针碰撞的方式时，垃圾收集器必须有内存整理的功能，能对垃圾回收后的零散内存进行整理。而空闲列表的方式则不需要垃圾收集有这个功能，采用这种方式时虚拟机会维护一张表，用于记录那些内存是可用的，当需要分配内存时就从表中找出一块足够的内存进行分配，并记录在表上。\n\n&emsp; &emsp;内存分配完成后，虚拟机需要将分配到的内存空间都初始化；接下来虚拟机会对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希值、对象的GC的分代年龄等信息。这些信息存在对象的对象头之中。完成这些工作后，从虚拟机的角度来看一个新的对象就产生了，但从程序的角度来看对象创建才刚刚开始，对象尚未执行初始化方法，各个字段都还未赋值，接下来会执行初始化方法，只有在执行初始化方法后，一个真正可用的对象才算是被创建。\n### 对象的内存\n在HotSpot虚拟机中，对象在内存中分为三块区域：对象头、实例数据、和对齐填充。对象头包括两部分信息，第一部分用于存储对象自身运行的运行时数据，如哈希码、GC分代年龄、锁状态标志线程持有的锁等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例\n。接下来的实例数据部分是对象真正存储的有效信息，也是在代码中所定义的各个字段的内容。这些字段无论是在父类那继承过来的还是子类里定义都要记录下来。第三部分对齐填充不是必然存在的，它仅仅起占位符的作用，用以填充内存。\n### 对象的访问定位\n  &emsp; &emsp;建立对象是为了使用对象，我们的java程序需要通过栈上的reference来操作堆上的对象。通过reference来访问对象的方法有两种——使用句柄和直接指针。在虚拟机执行一个方法时，虚拟机栈 中会为方法分配一个 局部变量表，一个操作数栈；局部变量表是用于保存函数的参数以及局部变量的，其保存的类型有boolean、byte、char、short、int、float、reference和returnAddress八种；方法在执行的过程中，会有各种各样的字节码指令往操作数栈中执行入栈和出栈操作，完成数据的运算。基本数据类型直接存储到变量表中。那reference是如何找到引用的对象的呢？\n\n  &emsp; &emsp;如果使用句柄的话，那么会在java堆中划分一块内存来作为句柄池，reference中存储的是句柄的地址，而句柄中包含了对象的具体地址信息，如图2所示\n![图:2：通过句柄访问对象](http://upload-images.jianshu.io/upload_images/13612520-444340fc1999cdc6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  &emsp; &emsp;如果使用直接指针访问，那么java堆对象的布局则如图3所示；\n![图3：通过直接指针访问对象](http://upload-images.jianshu.io/upload_images/13612520-cfd7ee35d69ee849?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 小结\n  &emsp; &emsp;对象的内存分布使用情况就介绍到这，感兴趣的小伙伴可以自己画一画当虚拟机执行递归方法时的堆栈运行状况的示意图。","slug":"jvm-2","published":1,"updated":"2021-01-11T07:31:23.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh69001v00wi729845ou","content":"<p>作者：muggle</p>\n<h3 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h3><p>&emsp; &emsp;在语言层面上，创建一个对象通常是通过new关键字来创建，在虚拟机中遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过；如果没有的话就会先加载这个类；类加载检查完后，虚拟机将会为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，在堆中为对象划分一块内存出来。</p>\n<p>&emsp; &emsp;虚拟机给对象分配内存的方式有两种——“指针碰撞”的方式和“空闲列表”的方式。如果java堆内存是绝对规整的，所有用过的内存放在一边，未使用的内存放在另一边，中间放一个指针作为指示器，那分配内存就只是把指针向未使用区域挪一段与对象大小相等的距离；这种分配方式叫指针碰撞式，如图1所示。</p>\n<a id=\"more\"></a>\n\n<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-35177fc9f287a7f3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图1：指针碰撞式内存分配方式\"></p>\n<p>我们知道，堆内存随时都可能被垃圾收集器回收的，当内存被回收后堆内存就可能不是连续的了，所以当采用指针碰撞的方式时，垃圾收集器必须有内存整理的功能，能对垃圾回收后的零散内存进行整理。而空闲列表的方式则不需要垃圾收集有这个功能，采用这种方式时虚拟机会维护一张表，用于记录那些内存是可用的，当需要分配内存时就从表中找出一块足够的内存进行分配，并记录在表上。</p>\n<p>&emsp; &emsp;内存分配完成后，虚拟机需要将分配到的内存空间都初始化；接下来虚拟机会对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希值、对象的GC的分代年龄等信息。这些信息存在对象的对象头之中。完成这些工作后，从虚拟机的角度来看一个新的对象就产生了，但从程序的角度来看对象创建才刚刚开始，对象尚未执行初始化方法，各个字段都还未赋值，接下来会执行初始化方法，只有在执行初始化方法后，一个真正可用的对象才算是被创建。</p>\n<h3 id=\"对象的内存\"><a href=\"#对象的内存\" class=\"headerlink\" title=\"对象的内存\"></a>对象的内存</h3><p>在HotSpot虚拟机中，对象在内存中分为三块区域：对象头、实例数据、和对齐填充。对象头包括两部分信息，第一部分用于存储对象自身运行的运行时数据，如哈希码、GC分代年龄、锁状态标志线程持有的锁等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例<br>。接下来的实例数据部分是对象真正存储的有效信息，也是在代码中所定义的各个字段的内容。这些字段无论是在父类那继承过来的还是子类里定义都要记录下来。第三部分对齐填充不是必然存在的，它仅仅起占位符的作用，用以填充内存。</p>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h3><p>  &emsp; &emsp;建立对象是为了使用对象，我们的java程序需要通过栈上的reference来操作堆上的对象。通过reference来访问对象的方法有两种——使用句柄和直接指针。在虚拟机执行一个方法时，虚拟机栈 中会为方法分配一个 局部变量表，一个操作数栈；局部变量表是用于保存函数的参数以及局部变量的，其保存的类型有boolean、byte、char、short、int、float、reference和returnAddress八种；方法在执行的过程中，会有各种各样的字节码指令往操作数栈中执行入栈和出栈操作，完成数据的运算。基本数据类型直接存储到变量表中。那reference是如何找到引用的对象的呢？</p>\n<p>  &emsp; &emsp;如果使用句柄的话，那么会在java堆中划分一块内存来作为句柄池，reference中存储的是句柄的地址，而句柄中包含了对象的具体地址信息，如图2所示<br><img src=\"http://upload-images.jianshu.io/upload_images/13612520-444340fc1999cdc6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图:2：通过句柄访问对象\"></p>\n<p>  &emsp; &emsp;如果使用直接指针访问，那么java堆对象的布局则如图3所示；<br><img src=\"http://upload-images.jianshu.io/upload_images/13612520-cfd7ee35d69ee849?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图3：通过直接指针访问对象\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>  &emsp; &emsp;对象的内存分布使用情况就介绍到这，感兴趣的小伙伴可以自己画一画当虚拟机执行递归方法时的堆栈运行状况的示意图。</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h3 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h3><p>&emsp; &emsp;在语言层面上，创建一个对象通常是通过new关键字来创建，在虚拟机中遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过；如果没有的话就会先加载这个类；类加载检查完后，虚拟机将会为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，在堆中为对象划分一块内存出来。</p>\n<p>&emsp; &emsp;虚拟机给对象分配内存的方式有两种——“指针碰撞”的方式和“空闲列表”的方式。如果java堆内存是绝对规整的，所有用过的内存放在一边，未使用的内存放在另一边，中间放一个指针作为指示器，那分配内存就只是把指针向未使用区域挪一段与对象大小相等的距离；这种分配方式叫指针碰撞式，如图1所示。</p>","more":"<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-35177fc9f287a7f3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图1：指针碰撞式内存分配方式\"></p>\n<p>我们知道，堆内存随时都可能被垃圾收集器回收的，当内存被回收后堆内存就可能不是连续的了，所以当采用指针碰撞的方式时，垃圾收集器必须有内存整理的功能，能对垃圾回收后的零散内存进行整理。而空闲列表的方式则不需要垃圾收集有这个功能，采用这种方式时虚拟机会维护一张表，用于记录那些内存是可用的，当需要分配内存时就从表中找出一块足够的内存进行分配，并记录在表上。</p>\n<p>&emsp; &emsp;内存分配完成后，虚拟机需要将分配到的内存空间都初始化；接下来虚拟机会对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希值、对象的GC的分代年龄等信息。这些信息存在对象的对象头之中。完成这些工作后，从虚拟机的角度来看一个新的对象就产生了，但从程序的角度来看对象创建才刚刚开始，对象尚未执行初始化方法，各个字段都还未赋值，接下来会执行初始化方法，只有在执行初始化方法后，一个真正可用的对象才算是被创建。</p>\n<h3 id=\"对象的内存\"><a href=\"#对象的内存\" class=\"headerlink\" title=\"对象的内存\"></a>对象的内存</h3><p>在HotSpot虚拟机中，对象在内存中分为三块区域：对象头、实例数据、和对齐填充。对象头包括两部分信息，第一部分用于存储对象自身运行的运行时数据，如哈希码、GC分代年龄、锁状态标志线程持有的锁等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例<br>。接下来的实例数据部分是对象真正存储的有效信息，也是在代码中所定义的各个字段的内容。这些字段无论是在父类那继承过来的还是子类里定义都要记录下来。第三部分对齐填充不是必然存在的，它仅仅起占位符的作用，用以填充内存。</p>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h3><p>  &emsp; &emsp;建立对象是为了使用对象，我们的java程序需要通过栈上的reference来操作堆上的对象。通过reference来访问对象的方法有两种——使用句柄和直接指针。在虚拟机执行一个方法时，虚拟机栈 中会为方法分配一个 局部变量表，一个操作数栈；局部变量表是用于保存函数的参数以及局部变量的，其保存的类型有boolean、byte、char、short、int、float、reference和returnAddress八种；方法在执行的过程中，会有各种各样的字节码指令往操作数栈中执行入栈和出栈操作，完成数据的运算。基本数据类型直接存储到变量表中。那reference是如何找到引用的对象的呢？</p>\n<p>  &emsp; &emsp;如果使用句柄的话，那么会在java堆中划分一块内存来作为句柄池，reference中存储的是句柄的地址，而句柄中包含了对象的具体地址信息，如图2所示<br><img src=\"http://upload-images.jianshu.io/upload_images/13612520-444340fc1999cdc6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图:2：通过句柄访问对象\"></p>\n<p>  &emsp; &emsp;如果使用直接指针访问，那么java堆对象的布局则如图3所示；<br><img src=\"http://upload-images.jianshu.io/upload_images/13612520-cfd7ee35d69ee849?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图3：通过直接指针访问对象\"></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>  &emsp; &emsp;对象的内存分布使用情况就介绍到这，感兴趣的小伙伴可以自己画一画当虚拟机执行递归方法时的堆栈运行状况的示意图。</p>"},{"title":"jvm基础篇三之垃圾收集器","date":"2019-04-24T02:49:15.000Z","_content":"\n\n##  垃圾收集器介绍\n&emsp; &emsp;java内存在运行时被分为多个区域，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程生成和销毁；每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，在这几个区域内就不需要过多考虑回收问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而堆区就不一样了，我们只有在程序运行的时候才能知道哪些对象会被创建，这部分内存是动态分配的，垃圾收集器主要关注的也就是这部分内存。\n\n<!--more-->\n\n##  垃圾收集器算法\n&emsp; &emsp;jdk11刚发布不久，这个版本发布了一款新的垃圾收集器——G1垃圾收集器,这款垃圾收集器有很多优异的特性，我会在后文做介绍，这里先从简单的慢慢说起。\n\n&emsp; &emsp;引用计数算法是最初垃圾收集器采用的算法，也是相对简单的一种算法，其原理是：给对象中添加一个引用计数器，每当有一个地方引用它的时候这个计数器就加一；当引用失效，计数器就减一；任何时刻计数器为0则该对象就会被垃圾收集器回收。这种算法的缺点是当对象之间相互循环引用的时候，对象将永远不会被回收。举个例子——有类TestOne,类TestTwo;它们互相是对方的成员，如下：\n```java\n public static void main(String[] args) {\n    TestOne testOne=new TestOne();\n    TestTwo testTwo=new TestTwo();\n    testOne.obj=testTwo;\n    testTwo.obj=testOne;\n    testOne=null;\n    testTwo=null;\n}\n\n```\n理论上当代码执行到testTwo=null的时候 new TestOne() new TestTwo() 两块内存应该要被回收的，但是因为它们相互引用对方导致引用计数器不为0，所以这两块内存没有引用指向它们却无法被回收——这便是这种算法所存在的问题。\n\n&emsp; &emsp;可达性分析算法是使用比较广泛的算法。这个算法的基本思路是通过一系列的称为“GC Roots”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称作引用链；当一个对象和GC Roots之间不存在引用链的时候，这个对象将被回收；也就是说一个存活的对象向上追溯它的引用链，其头部必然是GC Roots,如果不是将被回收。在虚拟机中可以作为GC Roots的可以是：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象，本地方法栈中Native方法引用的对象；在堆区一个存活的对象被这些对象所直接引用或间接引用(引用又分为强引用、软引用、弱引用、、虚引用，引用强调依次降低，感兴趣的可以详细了解一下)。\n&emsp; &emsp;当一个对象的引用链中没有GC Roots的时候并不会被马上回收，第一次他会被标记并筛选，当对象没有覆盖finalize()方法或该方法已经被虚拟机调用过，那么它会被放入一个叫做F-Queue的队列中等待被虚拟机自动回收；否则虚拟机会执行finalize()方法——当我们没有重写finalize()方法时，对象内存自然被回收掉，如果重写了这个方法，那么结果就会变得很有趣，下面做一个示例：\n```java\npublic class Main {\n    public static  Main test=null;\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println(\"执行了一次 finalize()\");\n        Main.test=this;\n    }\n\n    public static void main(String[] args) {\n        test=new Main();\n        // 让test失去 GC RootS\n        test=null;\n        // 调用 finalize()方法\n        System.gc();\n        // sleep一会确保finalize()方法执行\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // 因为在finalize()方法中重新将this(也就是 new Main())赋值给了test 所以没被回收\n        if(test!=null){\n            System.out.println(\"对象存活了下来\");\n        }else{\n            System.out.println(\"对象死了\");\n        }\n        // 再来一次\n        test=null;\n        System.gc();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // 这一次却死了，因为finalize()方法已经被执行过，虚拟机直接将对象扔到 F-Queue里面等待回收\n        if(test!=null){\n            System.out.println(\"对象存活了下来\");\n        }else{\n            System.out.println(\"对象死了\");\n        }\n    }\n\n}\n```\n运行结果：\n> 执行了一次 finalize()<br/>\n> 对象存活了下来<br/>\n> 对象死了\n\n##  回收方法区\n&emsp; &emsp;因为方法区的内存回收条件很苛刻，因此方法区被人称作永久代，在这个区域回收的内存主要为废弃的常量和无用的类；那么如何判定一个常量是否废弃呢？比如当一个字符串进入了常量池，但没有任何地方引用它，如果此时发生了内存回收，那么这个常量就会被清除出常量池——发生场景：一个类有一个成员 pubulic static String test=\"aaa\";当这个类被加载的时候\"aaa\"进入常量池，当其他地方没有字符串等于\"aaa\"的时候并且此时这个类由于某种原因被卸载掉，此时这个\"aaa\"将会被回收。如何判定一个类是无用的类呢？需要满足三个条件：\n   > 该类所有的实例都被回收<br/>\n   >    加载该类的ClassLoader已经被回收\n   >    <br/>该类的Class对象没在任何地方被引用，无法通过反射访问该类\n\n## 写在末尾\n   &emsp; &emsp;本来还想写垃圾回收的算法的，结果时间不太够，那就留在下一次写吧。微信留言功能不能开通，有没有大佬指点一下是怎么回事？开通留言和大佬们沟通一波岂不是美滋滋。","source":"_posts/jvm-3.md","raw":"---\ntitle: jvm基础篇三之垃圾收集器\ndate: 2019-04-24 10:49:15\ntags: jvm\n---\n\n\n##  垃圾收集器介绍\n&emsp; &emsp;java内存在运行时被分为多个区域，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程生成和销毁；每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，在这几个区域内就不需要过多考虑回收问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而堆区就不一样了，我们只有在程序运行的时候才能知道哪些对象会被创建，这部分内存是动态分配的，垃圾收集器主要关注的也就是这部分内存。\n\n<!--more-->\n\n##  垃圾收集器算法\n&emsp; &emsp;jdk11刚发布不久，这个版本发布了一款新的垃圾收集器——G1垃圾收集器,这款垃圾收集器有很多优异的特性，我会在后文做介绍，这里先从简单的慢慢说起。\n\n&emsp; &emsp;引用计数算法是最初垃圾收集器采用的算法，也是相对简单的一种算法，其原理是：给对象中添加一个引用计数器，每当有一个地方引用它的时候这个计数器就加一；当引用失效，计数器就减一；任何时刻计数器为0则该对象就会被垃圾收集器回收。这种算法的缺点是当对象之间相互循环引用的时候，对象将永远不会被回收。举个例子——有类TestOne,类TestTwo;它们互相是对方的成员，如下：\n```java\n public static void main(String[] args) {\n    TestOne testOne=new TestOne();\n    TestTwo testTwo=new TestTwo();\n    testOne.obj=testTwo;\n    testTwo.obj=testOne;\n    testOne=null;\n    testTwo=null;\n}\n\n```\n理论上当代码执行到testTwo=null的时候 new TestOne() new TestTwo() 两块内存应该要被回收的，但是因为它们相互引用对方导致引用计数器不为0，所以这两块内存没有引用指向它们却无法被回收——这便是这种算法所存在的问题。\n\n&emsp; &emsp;可达性分析算法是使用比较广泛的算法。这个算法的基本思路是通过一系列的称为“GC Roots”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称作引用链；当一个对象和GC Roots之间不存在引用链的时候，这个对象将被回收；也就是说一个存活的对象向上追溯它的引用链，其头部必然是GC Roots,如果不是将被回收。在虚拟机中可以作为GC Roots的可以是：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象，本地方法栈中Native方法引用的对象；在堆区一个存活的对象被这些对象所直接引用或间接引用(引用又分为强引用、软引用、弱引用、、虚引用，引用强调依次降低，感兴趣的可以详细了解一下)。\n&emsp; &emsp;当一个对象的引用链中没有GC Roots的时候并不会被马上回收，第一次他会被标记并筛选，当对象没有覆盖finalize()方法或该方法已经被虚拟机调用过，那么它会被放入一个叫做F-Queue的队列中等待被虚拟机自动回收；否则虚拟机会执行finalize()方法——当我们没有重写finalize()方法时，对象内存自然被回收掉，如果重写了这个方法，那么结果就会变得很有趣，下面做一个示例：\n```java\npublic class Main {\n    public static  Main test=null;\n\n    @Override\n    protected void finalize() throws Throwable {\n        super.finalize();\n        System.out.println(\"执行了一次 finalize()\");\n        Main.test=this;\n    }\n\n    public static void main(String[] args) {\n        test=new Main();\n        // 让test失去 GC RootS\n        test=null;\n        // 调用 finalize()方法\n        System.gc();\n        // sleep一会确保finalize()方法执行\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // 因为在finalize()方法中重新将this(也就是 new Main())赋值给了test 所以没被回收\n        if(test!=null){\n            System.out.println(\"对象存活了下来\");\n        }else{\n            System.out.println(\"对象死了\");\n        }\n        // 再来一次\n        test=null;\n        System.gc();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // 这一次却死了，因为finalize()方法已经被执行过，虚拟机直接将对象扔到 F-Queue里面等待回收\n        if(test!=null){\n            System.out.println(\"对象存活了下来\");\n        }else{\n            System.out.println(\"对象死了\");\n        }\n    }\n\n}\n```\n运行结果：\n> 执行了一次 finalize()<br/>\n> 对象存活了下来<br/>\n> 对象死了\n\n##  回收方法区\n&emsp; &emsp;因为方法区的内存回收条件很苛刻，因此方法区被人称作永久代，在这个区域回收的内存主要为废弃的常量和无用的类；那么如何判定一个常量是否废弃呢？比如当一个字符串进入了常量池，但没有任何地方引用它，如果此时发生了内存回收，那么这个常量就会被清除出常量池——发生场景：一个类有一个成员 pubulic static String test=\"aaa\";当这个类被加载的时候\"aaa\"进入常量池，当其他地方没有字符串等于\"aaa\"的时候并且此时这个类由于某种原因被卸载掉，此时这个\"aaa\"将会被回收。如何判定一个类是无用的类呢？需要满足三个条件：\n   > 该类所有的实例都被回收<br/>\n   >    加载该类的ClassLoader已经被回收\n   >    <br/>该类的Class对象没在任何地方被引用，无法通过反射访问该类\n\n## 写在末尾\n   &emsp; &emsp;本来还想写垃圾回收的算法的，结果时间不太够，那就留在下一次写吧。微信留言功能不能开通，有没有大佬指点一下是怎么回事？开通留言和大佬们沟通一波岂不是美滋滋。","slug":"jvm-3","published":1,"updated":"2021-01-11T07:31:23.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6a001y00wi50bv7cov","content":"<h2 id=\"垃圾收集器介绍\"><a href=\"#垃圾收集器介绍\" class=\"headerlink\" title=\"垃圾收集器介绍\"></a>垃圾收集器介绍</h2><p>&emsp; &emsp;java内存在运行时被分为多个区域，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程生成和销毁；每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，在这几个区域内就不需要过多考虑回收问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而堆区就不一样了，我们只有在程序运行的时候才能知道哪些对象会被创建，这部分内存是动态分配的，垃圾收集器主要关注的也就是这部分内存。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"垃圾收集器算法\"><a href=\"#垃圾收集器算法\" class=\"headerlink\" title=\"垃圾收集器算法\"></a>垃圾收集器算法</h2><p>&emsp; &emsp;jdk11刚发布不久，这个版本发布了一款新的垃圾收集器——G1垃圾收集器,这款垃圾收集器有很多优异的特性，我会在后文做介绍，这里先从简单的慢慢说起。</p>\n<p>&emsp; &emsp;引用计数算法是最初垃圾收集器采用的算法，也是相对简单的一种算法，其原理是：给对象中添加一个引用计数器，每当有一个地方引用它的时候这个计数器就加一；当引用失效，计数器就减一；任何时刻计数器为0则该对象就会被垃圾收集器回收。这种算法的缺点是当对象之间相互循环引用的时候，对象将永远不会被回收。举个例子——有类TestOne,类TestTwo;它们互相是对方的成员，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    TestOne testOne=<span class=\"keyword\">new</span> TestOne();</span><br><span class=\"line\">    TestTwo testTwo=<span class=\"keyword\">new</span> TestTwo();</span><br><span class=\"line\">    testOne.obj=testTwo;</span><br><span class=\"line\">    testTwo.obj=testOne;</span><br><span class=\"line\">    testOne=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    testTwo=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>理论上当代码执行到testTwo=null的时候 new TestOne() new TestTwo() 两块内存应该要被回收的，但是因为它们相互引用对方导致引用计数器不为0，所以这两块内存没有引用指向它们却无法被回收——这便是这种算法所存在的问题。</p>\n<p>&emsp; &emsp;可达性分析算法是使用比较广泛的算法。这个算法的基本思路是通过一系列的称为“GC Roots”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称作引用链；当一个对象和GC Roots之间不存在引用链的时候，这个对象将被回收；也就是说一个存活的对象向上追溯它的引用链，其头部必然是GC Roots,如果不是将被回收。在虚拟机中可以作为GC Roots的可以是：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象，本地方法栈中Native方法引用的对象；在堆区一个存活的对象被这些对象所直接引用或间接引用(引用又分为强引用、软引用、弱引用、、虚引用，引用强调依次降低，感兴趣的可以详细了解一下)。<br>&emsp; &emsp;当一个对象的引用链中没有GC Roots的时候并不会被马上回收，第一次他会被标记并筛选，当对象没有覆盖finalize()方法或该方法已经被虚拟机调用过，那么它会被放入一个叫做F-Queue的队列中等待被虚拟机自动回收；否则虚拟机会执行finalize()方法——当我们没有重写finalize()方法时，对象内存自然被回收掉，如果重写了这个方法，那么结果就会变得很有趣，下面做一个示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  Main test=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行了一次 finalize()&quot;</span>);</span><br><span class=\"line\">        Main.test=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        test=<span class=\"keyword\">new</span> Main();</span><br><span class=\"line\">        <span class=\"comment\">// 让test失去 GC RootS</span></span><br><span class=\"line\">        test=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 finalize()方法</span></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"comment\">// sleep一会确保finalize()方法执行</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 因为在finalize()方法中重新将this(也就是 new Main())赋值给了test 所以没被回收</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(test!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;对象存活了下来&quot;</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;对象死了&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 再来一次</span></span><br><span class=\"line\">        test=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 这一次却死了，因为finalize()方法已经被执行过，虚拟机直接将对象扔到 F-Queue里面等待回收</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(test!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;对象存活了下来&quot;</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;对象死了&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>执行了一次 finalize()<br/><br>对象存活了下来<br/><br>对象死了</p>\n</blockquote>\n<h2 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h2><p>&emsp; &emsp;因为方法区的内存回收条件很苛刻，因此方法区被人称作永久代，在这个区域回收的内存主要为废弃的常量和无用的类；那么如何判定一个常量是否废弃呢？比如当一个字符串进入了常量池，但没有任何地方引用它，如果此时发生了内存回收，那么这个常量就会被清除出常量池——发生场景：一个类有一个成员 pubulic static String test=”aaa”;当这个类被加载的时候”aaa”进入常量池，当其他地方没有字符串等于”aaa”的时候并且此时这个类由于某种原因被卸载掉，此时这个”aaa”将会被回收。如何判定一个类是无用的类呢？需要满足三个条件：</p>\n<blockquote>\n<p>该类所有的实例都被回收<br/><br>   加载该类的ClassLoader已经被回收<br>   <br/>该类的Class对象没在任何地方被引用，无法通过反射访问该类</p>\n</blockquote>\n<h2 id=\"写在末尾\"><a href=\"#写在末尾\" class=\"headerlink\" title=\"写在末尾\"></a>写在末尾</h2><p>   &emsp; &emsp;本来还想写垃圾回收的算法的，结果时间不太够，那就留在下一次写吧。微信留言功能不能开通，有没有大佬指点一下是怎么回事？开通留言和大佬们沟通一波岂不是美滋滋。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"垃圾收集器介绍\"><a href=\"#垃圾收集器介绍\" class=\"headerlink\" title=\"垃圾收集器介绍\"></a>垃圾收集器介绍</h2><p>&emsp; &emsp;java内存在运行时被分为多个区域，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程生成和销毁；每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，在这几个区域内就不需要过多考虑回收问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而堆区就不一样了，我们只有在程序运行的时候才能知道哪些对象会被创建，这部分内存是动态分配的，垃圾收集器主要关注的也就是这部分内存。</p>","more":"<h2 id=\"垃圾收集器算法\"><a href=\"#垃圾收集器算法\" class=\"headerlink\" title=\"垃圾收集器算法\"></a>垃圾收集器算法</h2><p>&emsp; &emsp;jdk11刚发布不久，这个版本发布了一款新的垃圾收集器——G1垃圾收集器,这款垃圾收集器有很多优异的特性，我会在后文做介绍，这里先从简单的慢慢说起。</p>\n<p>&emsp; &emsp;引用计数算法是最初垃圾收集器采用的算法，也是相对简单的一种算法，其原理是：给对象中添加一个引用计数器，每当有一个地方引用它的时候这个计数器就加一；当引用失效，计数器就减一；任何时刻计数器为0则该对象就会被垃圾收集器回收。这种算法的缺点是当对象之间相互循环引用的时候，对象将永远不会被回收。举个例子——有类TestOne,类TestTwo;它们互相是对方的成员，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    TestOne testOne=<span class=\"keyword\">new</span> TestOne();</span><br><span class=\"line\">    TestTwo testTwo=<span class=\"keyword\">new</span> TestTwo();</span><br><span class=\"line\">    testOne.obj=testTwo;</span><br><span class=\"line\">    testTwo.obj=testOne;</span><br><span class=\"line\">    testOne=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    testTwo=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>理论上当代码执行到testTwo=null的时候 new TestOne() new TestTwo() 两块内存应该要被回收的，但是因为它们相互引用对方导致引用计数器不为0，所以这两块内存没有引用指向它们却无法被回收——这便是这种算法所存在的问题。</p>\n<p>&emsp; &emsp;可达性分析算法是使用比较广泛的算法。这个算法的基本思路是通过一系列的称为“GC Roots”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称作引用链；当一个对象和GC Roots之间不存在引用链的时候，这个对象将被回收；也就是说一个存活的对象向上追溯它的引用链，其头部必然是GC Roots,如果不是将被回收。在虚拟机中可以作为GC Roots的可以是：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象，本地方法栈中Native方法引用的对象；在堆区一个存活的对象被这些对象所直接引用或间接引用(引用又分为强引用、软引用、弱引用、、虚引用，引用强调依次降低，感兴趣的可以详细了解一下)。<br>&emsp; &emsp;当一个对象的引用链中没有GC Roots的时候并不会被马上回收，第一次他会被标记并筛选，当对象没有覆盖finalize()方法或该方法已经被虚拟机调用过，那么它会被放入一个叫做F-Queue的队列中等待被虚拟机自动回收；否则虚拟机会执行finalize()方法——当我们没有重写finalize()方法时，对象内存自然被回收掉，如果重写了这个方法，那么结果就会变得很有趣，下面做一个示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  Main test=<span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;执行了一次 finalize()&quot;</span>);</span><br><span class=\"line\">        Main.test=<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        test=<span class=\"keyword\">new</span> Main();</span><br><span class=\"line\">        <span class=\"comment\">// 让test失去 GC RootS</span></span><br><span class=\"line\">        test=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 finalize()方法</span></span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"comment\">// sleep一会确保finalize()方法执行</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 因为在finalize()方法中重新将this(也就是 new Main())赋值给了test 所以没被回收</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(test!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;对象存活了下来&quot;</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;对象死了&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 再来一次</span></span><br><span class=\"line\">        test=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.gc();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 这一次却死了，因为finalize()方法已经被执行过，虚拟机直接将对象扔到 F-Queue里面等待回收</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(test!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;对象存活了下来&quot;</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;对象死了&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>执行了一次 finalize()<br/><br>对象存活了下来<br/><br>对象死了</p>\n</blockquote>\n<h2 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h2><p>&emsp; &emsp;因为方法区的内存回收条件很苛刻，因此方法区被人称作永久代，在这个区域回收的内存主要为废弃的常量和无用的类；那么如何判定一个常量是否废弃呢？比如当一个字符串进入了常量池，但没有任何地方引用它，如果此时发生了内存回收，那么这个常量就会被清除出常量池——发生场景：一个类有一个成员 pubulic static String test=”aaa”;当这个类被加载的时候”aaa”进入常量池，当其他地方没有字符串等于”aaa”的时候并且此时这个类由于某种原因被卸载掉，此时这个”aaa”将会被回收。如何判定一个类是无用的类呢？需要满足三个条件：</p>\n<blockquote>\n<p>该类所有的实例都被回收<br/><br>   加载该类的ClassLoader已经被回收<br>   <br/>该类的Class对象没在任何地方被引用，无法通过反射访问该类</p>\n</blockquote>\n<h2 id=\"写在末尾\"><a href=\"#写在末尾\" class=\"headerlink\" title=\"写在末尾\"></a>写在末尾</h2><p>   &emsp; &emsp;本来还想写垃圾回收的算法的，结果时间不太够，那就留在下一次写吧。微信留言功能不能开通，有没有大佬指点一下是怎么回事？开通留言和大佬们沟通一波岂不是美滋滋。</p>"},{"title":"jvm基础篇四之垃圾收集算法","date":"2019-04-24T02:54:35.000Z","_content":"\n### 1 标记-清除算法\n标记-清除算法是最基础的算法，算法分为标记和清除两个阶段，首先标记出要清除的对象，在标记完后统一回收所有被标记的对象，标记方式为j《jvm系列之垃圾收集器》里面所提到的。这种算法标记和清除两个过程效率都不高；并且在标记清除后，内存空间变得很零散，产生大量内存碎片。当需要分配一个比较大的对象时有可能会导致找不到足够大的内存。<!--more-->\n\n标记清除算法图解（图片来源于百度图片）：![timg.jpg](https://upload-images.jianshu.io/upload_images/13612520-e59da44ca1b963c6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n### 3 清除-复制算法\n\n&emsp;为了解决标记清除效率低的问题，出现了复制算法；这种算法将内存划分为大小相等的两块内存，只使用其中一块。当这一块内存使用完了就将存活的对象复制到另一块上面去，然后把已使用的内存空间一次性清理掉，这种方法不必考虑内存碎片的情况，运行高效，实现简单。缺点是浪费了一半的内存。复制算法图解（图片来源百度图片）：![timg (1).jpg](https://upload-images.jianshu.io/upload_images/13612520-2f12466c88adfd82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 3 标记-整理算法\n&emsp; &emsp;复制收集算法在对象存活率较高的时候就要进行较多的复制操作，导致效率变低。而且老年代很少会有内存回收，对老年代而言，复制算法做了大量的无用功。针对复制算法存在的的问题，有人提出了标记-整理算法。标记过程和标记-清除算法过程一样，但后续不是直接对可回收对象进行清理，而是让所有存活对象都向一方移动，整理内存，然后再进行清理。标记-整理算法图解（图片来源百度图片）：![timg (2).jpg](https://upload-images.jianshu.io/upload_images/13612520-4fd6dd6461485a3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 4 分代收集算法\n&emsp; &emsp;分代收集算法思路是根据对象存活周期不同将内存划分为几块。一般是分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中每次收集时都会回收很多内存，选用高效率的复制算法，并且只需要预留少量的复制空间，用于复制存活对象。老年代中因为对象存活率高，采用标记-整理或标记清理算法节省内存空间提高清理效率。\n### 5 各版本jdk垃圾收集器一览\n| 收集器名称        | 区 &emsp; 域  | 说明  &emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp; |\n| ----------------- | :-----------: | -----------------------------------------------------------: |\n| Serial            |    新生代     | 单线程，GC时必须停止其它线程直到收集结束；JVM运行在client模式下新生代的默认收集器，简单有效；采用复制算法 |\n| ParNew            |    新生代     | Serial收集的多线程版，保留Serial的参数控制，算法等，暂停所有用户线程，采用复制算法；JVM运行在server的首先的新生代收集器；只有它能和CMS配合工作 |\n| Parallel Scavenge |    新生代     | 采用复制算法，并行的多线程收集器，与ParNew不同的是，关注点不是停顿时间，而是可控制的吞吐量，即运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间）。可设置最大GC时间和吞吐量大小等参数，也可以让JVM自适应调整策略 |\n| CMS               |    新生代     | concurrent Mark Sweep，已获取最短回收停顿为目标，大部分的互联网站及服务端采用的方式，标记-清除算法 |\n| G1                | 新生代/老年代 |                   收集器最前沿版本，JDK 1.7，代替CMS的新产品 |\n| Serial Old（MSC） |    老年代     | Serial的老年版，单线程收集器，采用标记-整理算法，主要是client模式的JVM使用 |\n| Parallel Old      |    老年代     |              Parallel Scavenge的老年版，多线程，标记整理算法 |\n### jdk11 垃圾收集器——ZGC\n&emsp; &emsp;（网上搜的）ZGC是一个处于实验阶段的，可扩展的低延迟垃圾回收器，旨在实现以下几个目标：\n- 停顿时间不超过10ms\n- 停顿时间不随heap大小或存活对象大小增大而增大\n- 可以处理从几百兆到几T的内存大小\n\n限制：\n* 当前版本不支持类卸载\n* 当前版本不支持JVMCI\n\nZGC包含10个阶段，但是主要是两个阶段标记和relocating。GC循环从标记阶段开始，递归标记所有可达对象，标记阶段结束时，ZGC可以知道哪些对象仍然存在哪些是垃圾。ZGC将结果存储在每一页的位图（称为live map）中。在标记阶段，应用线程中的load barrier将未标记的引用压入线程本地的标记缓冲区。一旦缓冲区满，GC线程会拿到缓冲区的所有权，并且递归遍历此缓冲区所有可达对象。注意：应用线程负责压入缓冲区，GC线程负责递归遍历。\n\n&emsp; &emsp;标记阶段后，ZGC需要迁移relocate集中的所有对象。relocate集是一组页面集合，包含了根据某些标准（例如那些包含最多垃圾对象的页面）确定的需要迁移的页面。对象由GC线程或者应用线程迁移（通过load barrier）。ZGC为每个relocate集中的页面分配了转发表。转发表是一个哈希映射，它存储一个对象已被迁移到的地址（如果该对象已经被迁移）。GC线程遍历relocate集的活动对象，并迁移尚未迁移的所有对象。有时候会发生应用线程和GC线程同时试图迁移同一个对象，在这种情况下，ZGC使用CAS操作来确定胜利者。一旦GC线程完成了relocate集的处理，迁移阶段就完成了。虽然这时所有对象都已迁移，但是旧地引用址仍然有可能被使用，仍然需要通过转发表重新映射（remapping）。然后通过load barrier或者等到下一个标记循环修复这些引用。","source":"_posts/jvm-4.md","raw":"---\ntitle: jvm基础篇四之垃圾收集算法\ndate: 2019-04-24 10:54:35\ntags: jvm\n---\n\n### 1 标记-清除算法\n标记-清除算法是最基础的算法，算法分为标记和清除两个阶段，首先标记出要清除的对象，在标记完后统一回收所有被标记的对象，标记方式为j《jvm系列之垃圾收集器》里面所提到的。这种算法标记和清除两个过程效率都不高；并且在标记清除后，内存空间变得很零散，产生大量内存碎片。当需要分配一个比较大的对象时有可能会导致找不到足够大的内存。<!--more-->\n\n标记清除算法图解（图片来源于百度图片）：![timg.jpg](https://upload-images.jianshu.io/upload_images/13612520-e59da44ca1b963c6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n### 3 清除-复制算法\n\n&emsp;为了解决标记清除效率低的问题，出现了复制算法；这种算法将内存划分为大小相等的两块内存，只使用其中一块。当这一块内存使用完了就将存活的对象复制到另一块上面去，然后把已使用的内存空间一次性清理掉，这种方法不必考虑内存碎片的情况，运行高效，实现简单。缺点是浪费了一半的内存。复制算法图解（图片来源百度图片）：![timg (1).jpg](https://upload-images.jianshu.io/upload_images/13612520-2f12466c88adfd82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 3 标记-整理算法\n&emsp; &emsp;复制收集算法在对象存活率较高的时候就要进行较多的复制操作，导致效率变低。而且老年代很少会有内存回收，对老年代而言，复制算法做了大量的无用功。针对复制算法存在的的问题，有人提出了标记-整理算法。标记过程和标记-清除算法过程一样，但后续不是直接对可回收对象进行清理，而是让所有存活对象都向一方移动，整理内存，然后再进行清理。标记-整理算法图解（图片来源百度图片）：![timg (2).jpg](https://upload-images.jianshu.io/upload_images/13612520-4fd6dd6461485a3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 4 分代收集算法\n&emsp; &emsp;分代收集算法思路是根据对象存活周期不同将内存划分为几块。一般是分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中每次收集时都会回收很多内存，选用高效率的复制算法，并且只需要预留少量的复制空间，用于复制存活对象。老年代中因为对象存活率高，采用标记-整理或标记清理算法节省内存空间提高清理效率。\n### 5 各版本jdk垃圾收集器一览\n| 收集器名称        | 区 &emsp; 域  | 说明  &emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp; |\n| ----------------- | :-----------: | -----------------------------------------------------------: |\n| Serial            |    新生代     | 单线程，GC时必须停止其它线程直到收集结束；JVM运行在client模式下新生代的默认收集器，简单有效；采用复制算法 |\n| ParNew            |    新生代     | Serial收集的多线程版，保留Serial的参数控制，算法等，暂停所有用户线程，采用复制算法；JVM运行在server的首先的新生代收集器；只有它能和CMS配合工作 |\n| Parallel Scavenge |    新生代     | 采用复制算法，并行的多线程收集器，与ParNew不同的是，关注点不是停顿时间，而是可控制的吞吐量，即运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间）。可设置最大GC时间和吞吐量大小等参数，也可以让JVM自适应调整策略 |\n| CMS               |    新生代     | concurrent Mark Sweep，已获取最短回收停顿为目标，大部分的互联网站及服务端采用的方式，标记-清除算法 |\n| G1                | 新生代/老年代 |                   收集器最前沿版本，JDK 1.7，代替CMS的新产品 |\n| Serial Old（MSC） |    老年代     | Serial的老年版，单线程收集器，采用标记-整理算法，主要是client模式的JVM使用 |\n| Parallel Old      |    老年代     |              Parallel Scavenge的老年版，多线程，标记整理算法 |\n### jdk11 垃圾收集器——ZGC\n&emsp; &emsp;（网上搜的）ZGC是一个处于实验阶段的，可扩展的低延迟垃圾回收器，旨在实现以下几个目标：\n- 停顿时间不超过10ms\n- 停顿时间不随heap大小或存活对象大小增大而增大\n- 可以处理从几百兆到几T的内存大小\n\n限制：\n* 当前版本不支持类卸载\n* 当前版本不支持JVMCI\n\nZGC包含10个阶段，但是主要是两个阶段标记和relocating。GC循环从标记阶段开始，递归标记所有可达对象，标记阶段结束时，ZGC可以知道哪些对象仍然存在哪些是垃圾。ZGC将结果存储在每一页的位图（称为live map）中。在标记阶段，应用线程中的load barrier将未标记的引用压入线程本地的标记缓冲区。一旦缓冲区满，GC线程会拿到缓冲区的所有权，并且递归遍历此缓冲区所有可达对象。注意：应用线程负责压入缓冲区，GC线程负责递归遍历。\n\n&emsp; &emsp;标记阶段后，ZGC需要迁移relocate集中的所有对象。relocate集是一组页面集合，包含了根据某些标准（例如那些包含最多垃圾对象的页面）确定的需要迁移的页面。对象由GC线程或者应用线程迁移（通过load barrier）。ZGC为每个relocate集中的页面分配了转发表。转发表是一个哈希映射，它存储一个对象已被迁移到的地址（如果该对象已经被迁移）。GC线程遍历relocate集的活动对象，并迁移尚未迁移的所有对象。有时候会发生应用线程和GC线程同时试图迁移同一个对象，在这种情况下，ZGC使用CAS操作来确定胜利者。一旦GC线程完成了relocate集的处理，迁移阶段就完成了。虽然这时所有对象都已迁移，但是旧地引用址仍然有可能被使用，仍然需要通过转发表重新映射（remapping）。然后通过load barrier或者等到下一个标记循环修复这些引用。","slug":"jvm-4","published":1,"updated":"2021-01-11T07:31:23.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6a002000wihgo52ozn","content":"<h3 id=\"1-标记-清除算法\"><a href=\"#1-标记-清除算法\" class=\"headerlink\" title=\"1 标记-清除算法\"></a>1 标记-清除算法</h3><p>标记-清除算法是最基础的算法，算法分为标记和清除两个阶段，首先标记出要清除的对象，在标记完后统一回收所有被标记的对象，标记方式为j《jvm系列之垃圾收集器》里面所提到的。这种算法标记和清除两个过程效率都不高；并且在标记清除后，内存空间变得很零散，产生大量内存碎片。当需要分配一个比较大的对象时有可能会导致找不到足够大的内存。<a id=\"more\"></a></p>\n<p>标记清除算法图解（图片来源于百度图片）：<img src=\"https://upload-images.jianshu.io/upload_images/13612520-e59da44ca1b963c6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timg.jpg\"> </p>\n<h3 id=\"3-清除-复制算法\"><a href=\"#3-清除-复制算法\" class=\"headerlink\" title=\"3 清除-复制算法\"></a>3 清除-复制算法</h3><p>&emsp;为了解决标记清除效率低的问题，出现了复制算法；这种算法将内存划分为大小相等的两块内存，只使用其中一块。当这一块内存使用完了就将存活的对象复制到另一块上面去，然后把已使用的内存空间一次性清理掉，这种方法不必考虑内存碎片的情况，运行高效，实现简单。缺点是浪费了一半的内存。复制算法图解（图片来源百度图片）：<img src=\"https://upload-images.jianshu.io/upload_images/13612520-2f12466c88adfd82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timg (1).jpg\"></p>\n<h3 id=\"3-标记-整理算法\"><a href=\"#3-标记-整理算法\" class=\"headerlink\" title=\"3 标记-整理算法\"></a>3 标记-整理算法</h3><p>&emsp; &emsp;复制收集算法在对象存活率较高的时候就要进行较多的复制操作，导致效率变低。而且老年代很少会有内存回收，对老年代而言，复制算法做了大量的无用功。针对复制算法存在的的问题，有人提出了标记-整理算法。标记过程和标记-清除算法过程一样，但后续不是直接对可回收对象进行清理，而是让所有存活对象都向一方移动，整理内存，然后再进行清理。标记-整理算法图解（图片来源百度图片）：<img src=\"https://upload-images.jianshu.io/upload_images/13612520-4fd6dd6461485a3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timg (2).jpg\"></p>\n<h3 id=\"4-分代收集算法\"><a href=\"#4-分代收集算法\" class=\"headerlink\" title=\"4 分代收集算法\"></a>4 分代收集算法</h3><p>&emsp; &emsp;分代收集算法思路是根据对象存活周期不同将内存划分为几块。一般是分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中每次收集时都会回收很多内存，选用高效率的复制算法，并且只需要预留少量的复制空间，用于复制存活对象。老年代中因为对象存活率高，采用标记-整理或标记清理算法节省内存空间提高清理效率。</p>\n<h3 id=\"5-各版本jdk垃圾收集器一览\"><a href=\"#5-各版本jdk垃圾收集器一览\" class=\"headerlink\" title=\"5 各版本jdk垃圾收集器一览\"></a>5 各版本jdk垃圾收集器一览</h3><table>\n<thead>\n<tr>\n<th>收集器名称</th>\n<th align=\"center\">区 &emsp; 域</th>\n<th align=\"right\">说明  &emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Serial</td>\n<td align=\"center\">新生代</td>\n<td align=\"right\">单线程，GC时必须停止其它线程直到收集结束；JVM运行在client模式下新生代的默认收集器，简单有效；采用复制算法</td>\n</tr>\n<tr>\n<td>ParNew</td>\n<td align=\"center\">新生代</td>\n<td align=\"right\">Serial收集的多线程版，保留Serial的参数控制，算法等，暂停所有用户线程，采用复制算法；JVM运行在server的首先的新生代收集器；只有它能和CMS配合工作</td>\n</tr>\n<tr>\n<td>Parallel Scavenge</td>\n<td align=\"center\">新生代</td>\n<td align=\"right\">采用复制算法，并行的多线程收集器，与ParNew不同的是，关注点不是停顿时间，而是可控制的吞吐量，即运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间）。可设置最大GC时间和吞吐量大小等参数，也可以让JVM自适应调整策略</td>\n</tr>\n<tr>\n<td>CMS</td>\n<td align=\"center\">新生代</td>\n<td align=\"right\">concurrent Mark Sweep，已获取最短回收停顿为目标，大部分的互联网站及服务端采用的方式，标记-清除算法</td>\n</tr>\n<tr>\n<td>G1</td>\n<td align=\"center\">新生代/老年代</td>\n<td align=\"right\">收集器最前沿版本，JDK 1.7，代替CMS的新产品</td>\n</tr>\n<tr>\n<td>Serial Old（MSC）</td>\n<td align=\"center\">老年代</td>\n<td align=\"right\">Serial的老年版，单线程收集器，采用标记-整理算法，主要是client模式的JVM使用</td>\n</tr>\n<tr>\n<td>Parallel Old</td>\n<td align=\"center\">老年代</td>\n<td align=\"right\">Parallel Scavenge的老年版，多线程，标记整理算法</td>\n</tr>\n<tr>\n<td>### jdk11 垃圾收集器——ZGC</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td>&emsp; &emsp;（网上搜的）ZGC是一个处于实验阶段的，可扩展的低延迟垃圾回收器，旨在实现以下几个目标：</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td>- 停顿时间不超过10ms</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td>- 停顿时间不随heap大小或存活对象大小增大而增大</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td>- 可以处理从几百兆到几T的内存大小</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n</tbody></table>\n<p>限制：</p>\n<ul>\n<li>当前版本不支持类卸载</li>\n<li>当前版本不支持JVMCI</li>\n</ul>\n<p>ZGC包含10个阶段，但是主要是两个阶段标记和relocating。GC循环从标记阶段开始，递归标记所有可达对象，标记阶段结束时，ZGC可以知道哪些对象仍然存在哪些是垃圾。ZGC将结果存储在每一页的位图（称为live map）中。在标记阶段，应用线程中的load barrier将未标记的引用压入线程本地的标记缓冲区。一旦缓冲区满，GC线程会拿到缓冲区的所有权，并且递归遍历此缓冲区所有可达对象。注意：应用线程负责压入缓冲区，GC线程负责递归遍历。</p>\n<p>&emsp; &emsp;标记阶段后，ZGC需要迁移relocate集中的所有对象。relocate集是一组页面集合，包含了根据某些标准（例如那些包含最多垃圾对象的页面）确定的需要迁移的页面。对象由GC线程或者应用线程迁移（通过load barrier）。ZGC为每个relocate集中的页面分配了转发表。转发表是一个哈希映射，它存储一个对象已被迁移到的地址（如果该对象已经被迁移）。GC线程遍历relocate集的活动对象，并迁移尚未迁移的所有对象。有时候会发生应用线程和GC线程同时试图迁移同一个对象，在这种情况下，ZGC使用CAS操作来确定胜利者。一旦GC线程完成了relocate集的处理，迁移阶段就完成了。虽然这时所有对象都已迁移，但是旧地引用址仍然有可能被使用，仍然需要通过转发表重新映射（remapping）。然后通过load barrier或者等到下一个标记循环修复这些引用。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-标记-清除算法\"><a href=\"#1-标记-清除算法\" class=\"headerlink\" title=\"1 标记-清除算法\"></a>1 标记-清除算法</h3><p>标记-清除算法是最基础的算法，算法分为标记和清除两个阶段，首先标记出要清除的对象，在标记完后统一回收所有被标记的对象，标记方式为j《jvm系列之垃圾收集器》里面所提到的。这种算法标记和清除两个过程效率都不高；并且在标记清除后，内存空间变得很零散，产生大量内存碎片。当需要分配一个比较大的对象时有可能会导致找不到足够大的内存。","more":"</p>\n<p>标记清除算法图解（图片来源于百度图片）：<img src=\"https://upload-images.jianshu.io/upload_images/13612520-e59da44ca1b963c6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timg.jpg\"> </p>\n<h3 id=\"3-清除-复制算法\"><a href=\"#3-清除-复制算法\" class=\"headerlink\" title=\"3 清除-复制算法\"></a>3 清除-复制算法</h3><p>&emsp;为了解决标记清除效率低的问题，出现了复制算法；这种算法将内存划分为大小相等的两块内存，只使用其中一块。当这一块内存使用完了就将存活的对象复制到另一块上面去，然后把已使用的内存空间一次性清理掉，这种方法不必考虑内存碎片的情况，运行高效，实现简单。缺点是浪费了一半的内存。复制算法图解（图片来源百度图片）：<img src=\"https://upload-images.jianshu.io/upload_images/13612520-2f12466c88adfd82.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timg (1).jpg\"></p>\n<h3 id=\"3-标记-整理算法\"><a href=\"#3-标记-整理算法\" class=\"headerlink\" title=\"3 标记-整理算法\"></a>3 标记-整理算法</h3><p>&emsp; &emsp;复制收集算法在对象存活率较高的时候就要进行较多的复制操作，导致效率变低。而且老年代很少会有内存回收，对老年代而言，复制算法做了大量的无用功。针对复制算法存在的的问题，有人提出了标记-整理算法。标记过程和标记-清除算法过程一样，但后续不是直接对可回收对象进行清理，而是让所有存活对象都向一方移动，整理内存，然后再进行清理。标记-整理算法图解（图片来源百度图片）：<img src=\"https://upload-images.jianshu.io/upload_images/13612520-4fd6dd6461485a3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timg (2).jpg\"></p>\n<h3 id=\"4-分代收集算法\"><a href=\"#4-分代收集算法\" class=\"headerlink\" title=\"4 分代收集算法\"></a>4 分代收集算法</h3><p>&emsp; &emsp;分代收集算法思路是根据对象存活周期不同将内存划分为几块。一般是分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中每次收集时都会回收很多内存，选用高效率的复制算法，并且只需要预留少量的复制空间，用于复制存活对象。老年代中因为对象存活率高，采用标记-整理或标记清理算法节省内存空间提高清理效率。</p>\n<h3 id=\"5-各版本jdk垃圾收集器一览\"><a href=\"#5-各版本jdk垃圾收集器一览\" class=\"headerlink\" title=\"5 各版本jdk垃圾收集器一览\"></a>5 各版本jdk垃圾收集器一览</h3><table>\n<thead>\n<tr>\n<th>收集器名称</th>\n<th align=\"center\">区 &emsp; 域</th>\n<th align=\"right\">说明  &emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Serial</td>\n<td align=\"center\">新生代</td>\n<td align=\"right\">单线程，GC时必须停止其它线程直到收集结束；JVM运行在client模式下新生代的默认收集器，简单有效；采用复制算法</td>\n</tr>\n<tr>\n<td>ParNew</td>\n<td align=\"center\">新生代</td>\n<td align=\"right\">Serial收集的多线程版，保留Serial的参数控制，算法等，暂停所有用户线程，采用复制算法；JVM运行在server的首先的新生代收集器；只有它能和CMS配合工作</td>\n</tr>\n<tr>\n<td>Parallel Scavenge</td>\n<td align=\"center\">新生代</td>\n<td align=\"right\">采用复制算法，并行的多线程收集器，与ParNew不同的是，关注点不是停顿时间，而是可控制的吞吐量，即运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间）。可设置最大GC时间和吞吐量大小等参数，也可以让JVM自适应调整策略</td>\n</tr>\n<tr>\n<td>CMS</td>\n<td align=\"center\">新生代</td>\n<td align=\"right\">concurrent Mark Sweep，已获取最短回收停顿为目标，大部分的互联网站及服务端采用的方式，标记-清除算法</td>\n</tr>\n<tr>\n<td>G1</td>\n<td align=\"center\">新生代/老年代</td>\n<td align=\"right\">收集器最前沿版本，JDK 1.7，代替CMS的新产品</td>\n</tr>\n<tr>\n<td>Serial Old（MSC）</td>\n<td align=\"center\">老年代</td>\n<td align=\"right\">Serial的老年版，单线程收集器，采用标记-整理算法，主要是client模式的JVM使用</td>\n</tr>\n<tr>\n<td>Parallel Old</td>\n<td align=\"center\">老年代</td>\n<td align=\"right\">Parallel Scavenge的老年版，多线程，标记整理算法</td>\n</tr>\n<tr>\n<td>### jdk11 垃圾收集器——ZGC</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td>&emsp; &emsp;（网上搜的）ZGC是一个处于实验阶段的，可扩展的低延迟垃圾回收器，旨在实现以下几个目标：</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td>- 停顿时间不超过10ms</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td>- 停顿时间不随heap大小或存活对象大小增大而增大</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td>- 可以处理从几百兆到几T的内存大小</td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n</tbody></table>\n<p>限制：</p>\n<ul>\n<li>当前版本不支持类卸载</li>\n<li>当前版本不支持JVMCI</li>\n</ul>\n<p>ZGC包含10个阶段，但是主要是两个阶段标记和relocating。GC循环从标记阶段开始，递归标记所有可达对象，标记阶段结束时，ZGC可以知道哪些对象仍然存在哪些是垃圾。ZGC将结果存储在每一页的位图（称为live map）中。在标记阶段，应用线程中的load barrier将未标记的引用压入线程本地的标记缓冲区。一旦缓冲区满，GC线程会拿到缓冲区的所有权，并且递归遍历此缓冲区所有可达对象。注意：应用线程负责压入缓冲区，GC线程负责递归遍历。</p>\n<p>&emsp; &emsp;标记阶段后，ZGC需要迁移relocate集中的所有对象。relocate集是一组页面集合，包含了根据某些标准（例如那些包含最多垃圾对象的页面）确定的需要迁移的页面。对象由GC线程或者应用线程迁移（通过load barrier）。ZGC为每个relocate集中的页面分配了转发表。转发表是一个哈希映射，它存储一个对象已被迁移到的地址（如果该对象已经被迁移）。GC线程遍历relocate集的活动对象，并迁移尚未迁移的所有对象。有时候会发生应用线程和GC线程同时试图迁移同一个对象，在这种情况下，ZGC使用CAS操作来确定胜利者。一旦GC线程完成了relocate集的处理，迁移阶段就完成了。虽然这时所有对象都已迁移，但是旧地引用址仍然有可能被使用，仍然需要通过转发表重新映射（remapping）。然后通过load barrier或者等到下一个标记循环修复这些引用。</p>"},{"title":"jvm基础篇五之类加载机制","date":"2019-04-24T02:56:54.000Z","_content":"\nmuggle\n### 1.类的生命周期\n&emsp; &emsp;类从被加载到虚拟机内存中内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（loading）、验证（verification）、准备（preparation）、解析（resolution）、初始化（initialization）、使用（using）卸载（unloading）七个阶段。其中验证、准备、解析三个阶段统称为连接（linking）。\n\n<!--more-->\n\n### 2.加载\n&emsp; &emsp;加载是类加载机制的第一个阶段，在这个阶段，虚拟机做了三件事情：\n> - 通过类的全限定名来获取定义此类的二进制字节流；\n- 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构\n- 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口\n\n&emsp; &emsp;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义；然后在内存中实例化一个Class类的对象，加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始了。\n### 3.验证\n&emsp; &emsp;验证是连接阶段的第一步，这一阶段目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上来看，验证阶段包括以下四个动作：文件格式验证、元数据验证、字节码验证、符号引用验证。\n### 4.准备\n&emsp; &emsp;准备阶段是正式为类变量分配内存并设置类变量初始值得阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念——1.这个时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，2.这里初始值是数据类型的零值，假设一个类变量定义为 ：\n```java\npublic static int value=2;\n```\n那变量value在准备阶段的值为0而不是2.\n### 5.解析\n&emsp; &emsp;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。\n\n### 6.初始化\n&emsp; &emsp;类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段可以通过自定义类加载器参与之外，其余动作都是虚拟机控制的。到了初始化阶段，才真正的执行java代码。初始化阶段是执行类构造器<clinit>()方法的过程。\n\n&emsp; &emsp;想要使用一个类，必须对其进行初始化，但初始化过程不是必然执行的；jvm规范中规定有且只有以下五种情况必须对类进行初始化：\n> - 遇到new、getstatic、putstatic、invokestatic这四个字节码指令的时候，如果类没有进行初始化，则需要先触发其初始化。生成这四条指令最常见的java代码场景是：使用new创建对象、读取或者设置一个类的静态字段（不包括值已在常量池中的情况）、调用一个类的静态方法的时候；\n- 使用java反射机制的时候，如果类没初始化需要先初始化；\n- 当初始化一个类的时候，如果发现其父类还未初始化，则需要先初始化父类。\n- 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化那个类。\n\n以上五种情况称为对一个类进行主动引用；其他引用类的方式都不会触发初始化，称为被动引用。下面举一个被动引用的例子：\n```java\npublic class TestClassloading {\n    static {\n        System.out.println(\"父类被初始化\");\n    }\n    public static int number=111;\n}\n\npublic class SubClass extends TestClassloading {\n    static {\n        System.out.println(\"子类被初始化\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(SubClass.number);\n    }\n}\n```\n输出结果：\n```java\n父类被初始化\n111\n```\n显然，子类没有被初始化，这里SubClass.number为被动引用，不会对子类初始化。\n### 7.类加载器\n&emsp; &emsp;通过一个类的全限定名来获取描述此类的二进制字节流这个动作被放到虚拟机外部区实现，以便让应用程序自己决定如何去获取所需的类，实现这个动作的代码模块称为类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。也就是说比较两个类是否相等必须要类加载器和类都相等。\n&emsp; &emsp;从java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器是虚拟机的一部分；另一种就是java代码实现的独立于虚拟机外部的类加载器，这种类加载器继承类抽象类java.lang.TestClassloader。\n\n&emsp; &emsp;类加载器还有一个很重要的概念就是双亲委派模型——在类加载器工作的时候是多个类加载器一起工作的它们包括：扩展类加载器，应用程序类加载器，启动类加载器，自定义类加载器。类加载器的层次图如图：\n\n![](https://upload-images.jianshu.io/upload_images/13612520-dd9a6a8324f136f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n类加载器层次结构\n\n&emsp; &emsp;双亲委派模型的工作流程是如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求交给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会被交给启动类加载器，当父类反馈无法加载这个类的时候，子类才会进行加载。","source":"_posts/jvm-5.md","raw":"---\ntitle: jvm基础篇五之类加载机制\ndate: 2019-04-24 10:56:54\ntags: jvm\n---\n\nmuggle\n### 1.类的生命周期\n&emsp; &emsp;类从被加载到虚拟机内存中内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（loading）、验证（verification）、准备（preparation）、解析（resolution）、初始化（initialization）、使用（using）卸载（unloading）七个阶段。其中验证、准备、解析三个阶段统称为连接（linking）。\n\n<!--more-->\n\n### 2.加载\n&emsp; &emsp;加载是类加载机制的第一个阶段，在这个阶段，虚拟机做了三件事情：\n> - 通过类的全限定名来获取定义此类的二进制字节流；\n- 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构\n- 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口\n\n&emsp; &emsp;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义；然后在内存中实例化一个Class类的对象，加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始了。\n### 3.验证\n&emsp; &emsp;验证是连接阶段的第一步，这一阶段目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上来看，验证阶段包括以下四个动作：文件格式验证、元数据验证、字节码验证、符号引用验证。\n### 4.准备\n&emsp; &emsp;准备阶段是正式为类变量分配内存并设置类变量初始值得阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念——1.这个时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，2.这里初始值是数据类型的零值，假设一个类变量定义为 ：\n```java\npublic static int value=2;\n```\n那变量value在准备阶段的值为0而不是2.\n### 5.解析\n&emsp; &emsp;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。\n\n### 6.初始化\n&emsp; &emsp;类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段可以通过自定义类加载器参与之外，其余动作都是虚拟机控制的。到了初始化阶段，才真正的执行java代码。初始化阶段是执行类构造器<clinit>()方法的过程。\n\n&emsp; &emsp;想要使用一个类，必须对其进行初始化，但初始化过程不是必然执行的；jvm规范中规定有且只有以下五种情况必须对类进行初始化：\n> - 遇到new、getstatic、putstatic、invokestatic这四个字节码指令的时候，如果类没有进行初始化，则需要先触发其初始化。生成这四条指令最常见的java代码场景是：使用new创建对象、读取或者设置一个类的静态字段（不包括值已在常量池中的情况）、调用一个类的静态方法的时候；\n- 使用java反射机制的时候，如果类没初始化需要先初始化；\n- 当初始化一个类的时候，如果发现其父类还未初始化，则需要先初始化父类。\n- 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化那个类。\n\n以上五种情况称为对一个类进行主动引用；其他引用类的方式都不会触发初始化，称为被动引用。下面举一个被动引用的例子：\n```java\npublic class TestClassloading {\n    static {\n        System.out.println(\"父类被初始化\");\n    }\n    public static int number=111;\n}\n\npublic class SubClass extends TestClassloading {\n    static {\n        System.out.println(\"子类被初始化\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(SubClass.number);\n    }\n}\n```\n输出结果：\n```java\n父类被初始化\n111\n```\n显然，子类没有被初始化，这里SubClass.number为被动引用，不会对子类初始化。\n### 7.类加载器\n&emsp; &emsp;通过一个类的全限定名来获取描述此类的二进制字节流这个动作被放到虚拟机外部区实现，以便让应用程序自己决定如何去获取所需的类，实现这个动作的代码模块称为类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。也就是说比较两个类是否相等必须要类加载器和类都相等。\n&emsp; &emsp;从java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器是虚拟机的一部分；另一种就是java代码实现的独立于虚拟机外部的类加载器，这种类加载器继承类抽象类java.lang.TestClassloader。\n\n&emsp; &emsp;类加载器还有一个很重要的概念就是双亲委派模型——在类加载器工作的时候是多个类加载器一起工作的它们包括：扩展类加载器，应用程序类加载器，启动类加载器，自定义类加载器。类加载器的层次图如图：\n\n![](https://upload-images.jianshu.io/upload_images/13612520-dd9a6a8324f136f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n类加载器层次结构\n\n&emsp; &emsp;双亲委派模型的工作流程是如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求交给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会被交给启动类加载器，当父类反馈无法加载这个类的时候，子类才会进行加载。","slug":"jvm-5","published":1,"updated":"2021-01-11T07:31:23.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6b002300wi1obtdxqd","content":"<p>muggle</p>\n<h3 id=\"1-类的生命周期\"><a href=\"#1-类的生命周期\" class=\"headerlink\" title=\"1.类的生命周期\"></a>1.类的生命周期</h3><p>&emsp; &emsp;类从被加载到虚拟机内存中内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（loading）、验证（verification）、准备（preparation）、解析（resolution）、初始化（initialization）、使用（using）卸载（unloading）七个阶段。其中验证、准备、解析三个阶段统称为连接（linking）。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"2-加载\"><a href=\"#2-加载\" class=\"headerlink\" title=\"2.加载\"></a>2.加载</h3><p>&emsp; &emsp;加载是类加载机制的第一个阶段，在这个阶段，虚拟机做了三件事情：</p>\n<blockquote>\n<ul>\n<li>通过类的全限定名来获取定义此类的二进制字节流；</li>\n</ul>\n</blockquote>\n<ul>\n<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口</li>\n</ul>\n<p>&emsp; &emsp;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义；然后在内存中实例化一个Class类的对象，加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始了。</p>\n<h3 id=\"3-验证\"><a href=\"#3-验证\" class=\"headerlink\" title=\"3.验证\"></a>3.验证</h3><p>&emsp; &emsp;验证是连接阶段的第一步，这一阶段目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上来看，验证阶段包括以下四个动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>\n<h3 id=\"4-准备\"><a href=\"#4-准备\" class=\"headerlink\" title=\"4.准备\"></a>4.准备</h3><p>&emsp; &emsp;准备阶段是正式为类变量分配内存并设置类变量初始值得阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念——1.这个时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，2.这里初始值是数据类型的零值，假设一个类变量定义为 ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> value=<span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>那变量value在准备阶段的值为0而不是2.</p>\n<h3 id=\"5-解析\"><a href=\"#5-解析\" class=\"headerlink\" title=\"5.解析\"></a>5.解析</h3><p>&emsp; &emsp;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>\n<h3 id=\"6-初始化\"><a href=\"#6-初始化\" class=\"headerlink\" title=\"6.初始化\"></a>6.初始化</h3><p>&emsp; &emsp;类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段可以通过自定义类加载器参与之外，其余动作都是虚拟机控制的。到了初始化阶段，才真正的执行java代码。初始化阶段是执行类构造器<clinit>()方法的过程。</p>\n<p>&emsp; &emsp;想要使用一个类，必须对其进行初始化，但初始化过程不是必然执行的；jvm规范中规定有且只有以下五种情况必须对类进行初始化：</p>\n<blockquote>\n<ul>\n<li>遇到new、getstatic、putstatic、invokestatic这四个字节码指令的时候，如果类没有进行初始化，则需要先触发其初始化。生成这四条指令最常见的java代码场景是：使用new创建对象、读取或者设置一个类的静态字段（不包括值已在常量池中的情况）、调用一个类的静态方法的时候；</li>\n</ul>\n</blockquote>\n<ul>\n<li>使用java反射机制的时候，如果类没初始化需要先初始化；</li>\n<li>当初始化一个类的时候，如果发现其父类还未初始化，则需要先初始化父类。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化那个类。</li>\n</ul>\n<p>以上五种情况称为对一个类进行主动引用；其他引用类的方式都不会触发初始化，称为被动引用。下面举一个被动引用的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestClassloading</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;父类被初始化&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> number=<span class=\"number\">111</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">TestClassloading</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类被初始化&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(SubClass.number);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类被初始化</span><br><span class=\"line\"><span class=\"number\">111</span></span><br></pre></td></tr></table></figure>\n<p>显然，子类没有被初始化，这里SubClass.number为被动引用，不会对子类初始化。</p>\n<h3 id=\"7-类加载器\"><a href=\"#7-类加载器\" class=\"headerlink\" title=\"7.类加载器\"></a>7.类加载器</h3><p>&emsp; &emsp;通过一个类的全限定名来获取描述此类的二进制字节流这个动作被放到虚拟机外部区实现，以便让应用程序自己决定如何去获取所需的类，实现这个动作的代码模块称为类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。也就是说比较两个类是否相等必须要类加载器和类都相等。<br>&emsp; &emsp;从java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器是虚拟机的一部分；另一种就是java代码实现的独立于虚拟机外部的类加载器，这种类加载器继承类抽象类java.lang.TestClassloader。</p>\n<p>&emsp; &emsp;类加载器还有一个很重要的概念就是双亲委派模型——在类加载器工作的时候是多个类加载器一起工作的它们包括：扩展类加载器，应用程序类加载器，启动类加载器，自定义类加载器。类加载器的层次图如图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-dd9a6a8324f136f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>类加载器层次结构</p>\n<p>&emsp; &emsp;双亲委派模型的工作流程是如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求交给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会被交给启动类加载器，当父类反馈无法加载这个类的时候，子类才会进行加载。</p>\n","site":{"data":{}},"excerpt":"<p>muggle</p>\n<h3 id=\"1-类的生命周期\"><a href=\"#1-类的生命周期\" class=\"headerlink\" title=\"1.类的生命周期\"></a>1.类的生命周期</h3><p>&emsp; &emsp;类从被加载到虚拟机内存中内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（loading）、验证（verification）、准备（preparation）、解析（resolution）、初始化（initialization）、使用（using）卸载（unloading）七个阶段。其中验证、准备、解析三个阶段统称为连接（linking）。</p>","more":"<h3 id=\"2-加载\"><a href=\"#2-加载\" class=\"headerlink\" title=\"2.加载\"></a>2.加载</h3><p>&emsp; &emsp;加载是类加载机制的第一个阶段，在这个阶段，虚拟机做了三件事情：</p>\n<blockquote>\n<ul>\n<li>通过类的全限定名来获取定义此类的二进制字节流；</li>\n</ul>\n</blockquote>\n<ul>\n<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口</li>\n</ul>\n<p>&emsp; &emsp;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义；然后在内存中实例化一个Class类的对象，加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始了。</p>\n<h3 id=\"3-验证\"><a href=\"#3-验证\" class=\"headerlink\" title=\"3.验证\"></a>3.验证</h3><p>&emsp; &emsp;验证是连接阶段的第一步，这一阶段目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上来看，验证阶段包括以下四个动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>\n<h3 id=\"4-准备\"><a href=\"#4-准备\" class=\"headerlink\" title=\"4.准备\"></a>4.准备</h3><p>&emsp; &emsp;准备阶段是正式为类变量分配内存并设置类变量初始值得阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念——1.这个时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，2.这里初始值是数据类型的零值，假设一个类变量定义为 ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> value=<span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>那变量value在准备阶段的值为0而不是2.</p>\n<h3 id=\"5-解析\"><a href=\"#5-解析\" class=\"headerlink\" title=\"5.解析\"></a>5.解析</h3><p>&emsp; &emsp;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>\n<h3 id=\"6-初始化\"><a href=\"#6-初始化\" class=\"headerlink\" title=\"6.初始化\"></a>6.初始化</h3><p>&emsp; &emsp;类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段可以通过自定义类加载器参与之外，其余动作都是虚拟机控制的。到了初始化阶段，才真正的执行java代码。初始化阶段是执行类构造器<clinit>()方法的过程。</p>\n<p>&emsp; &emsp;想要使用一个类，必须对其进行初始化，但初始化过程不是必然执行的；jvm规范中规定有且只有以下五种情况必须对类进行初始化：</p>\n<blockquote>\n<ul>\n<li>遇到new、getstatic、putstatic、invokestatic这四个字节码指令的时候，如果类没有进行初始化，则需要先触发其初始化。生成这四条指令最常见的java代码场景是：使用new创建对象、读取或者设置一个类的静态字段（不包括值已在常量池中的情况）、调用一个类的静态方法的时候；</li>\n</ul>\n</blockquote>\n<ul>\n<li>使用java反射机制的时候，如果类没初始化需要先初始化；</li>\n<li>当初始化一个类的时候，如果发现其父类还未初始化，则需要先初始化父类。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化那个类。</li>\n</ul>\n<p>以上五种情况称为对一个类进行主动引用；其他引用类的方式都不会触发初始化，称为被动引用。下面举一个被动引用的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestClassloading</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;父类被初始化&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> number=<span class=\"number\">111</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">TestClassloading</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;子类被初始化&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(SubClass.number);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类被初始化</span><br><span class=\"line\"><span class=\"number\">111</span></span><br></pre></td></tr></table></figure>\n<p>显然，子类没有被初始化，这里SubClass.number为被动引用，不会对子类初始化。</p>\n<h3 id=\"7-类加载器\"><a href=\"#7-类加载器\" class=\"headerlink\" title=\"7.类加载器\"></a>7.类加载器</h3><p>&emsp; &emsp;通过一个类的全限定名来获取描述此类的二进制字节流这个动作被放到虚拟机外部区实现，以便让应用程序自己决定如何去获取所需的类，实现这个动作的代码模块称为类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。也就是说比较两个类是否相等必须要类加载器和类都相等。<br>&emsp; &emsp;从java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器是虚拟机的一部分；另一种就是java代码实现的独立于虚拟机外部的类加载器，这种类加载器继承类抽象类java.lang.TestClassloader。</p>\n<p>&emsp; &emsp;类加载器还有一个很重要的概念就是双亲委派模型——在类加载器工作的时候是多个类加载器一起工作的它们包括：扩展类加载器，应用程序类加载器，启动类加载器，自定义类加载器。类加载器的层次图如图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-dd9a6a8324f136f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>类加载器层次结构</p>\n<p>&emsp; &emsp;双亲委派模型的工作流程是如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求交给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会被交给启动类加载器，当父类反馈无法加载这个类的时候，子类才会进行加载。</p>"},{"title":"jvm系列之对象引用分析","date":"2019-05-09T04:02:50.000Z","_content":"\n# java 引用介绍\n\n在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。对象引用被划分成简单的两种状态：可用和不可用。从JDK 1.2版本以后，对象的引用被划分为`4`种级别，从而使程序能更加灵活地控制对象的生命周期，引用的强度由高到低为：强、软、弱、虚引用。\n\n对象生命周期：在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）。上面的这7个阶段，构成了 JVM中对象的完整的生命周期。\n\n<!--more-->\n\n## 强引用(StrongReference)\n\n强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它，我们使用new关键字就是创建了一个强引用。被强引用引用的内存是无法被GC回收的，想要回收这一块的内存得等这个引用从栈内存中出来，对应的内存无引用了才能被回收。\n\n## 软引用(SoftReference)\n\n如果一个对象只具有软引用，则内存空间充足时，GC不会回收这块内存；单如果内存不足的时候它就会被回收，只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n\n创建一个软引用的办法\n\n```java\n    String str = new String(\"xxx\");\n    SoftReference<String> softReference = new SoftReference<String>(str);\n```\n\n`softReference`就是一个软引用。\n\n当内存不足时，`JVM`首先将软引用中的对象引用置为`null`，然后通知垃圾回收器进行回收。也就是说当软引用指向null的时候，对应的内存可能还是未被GC回收的。虚拟机会尽可能的优先回收长时间闲置不用的软引用对象。\n\n## 弱引用(WeakReference)\n\n弱引用比软引用有更短暂的生命周期。在GC扫描内存区域的时候，一旦发现弱引用就会马上回收它。\n\n创建一个弱引用的方法：\n\n```java\nString str = new String(\"xxx\");\nWeakReference<String> weakReference = new WeakReference<>(str);\n// 弱引用转强引用\nString strongReference = weakReference.get();\n```\n\n如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。如上面代码所示，弱引用也也可以转换成强引用\n\n## 虚引用(PhantomReference)\n\n虚引用可以理解为形同虚设的引用，不管你这个引用指向的内存有没有在用，它都随时可能被回收掉。虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n创建虚引用的办法：\n\n```java\n String str = new String(\"xxx\");\nReferenceQueue queue = new ReferenceQueue();\n// 创建虚引用，要求必须与一个引用队列关联\nPhantomReference pr = new PhantomReference(str, queue);\n```\n\n虚引用基本上好像没啥卵用。\n\n# 总结\n\nGC线程在虚拟机中的优先级别很低的，因此占用cpu资源的机会很少，所以当一个内存变成非强引用的时候，不一定马上会被回收，而是看这个时候GC线程有没有在执行。如果GC在执行，它会先检查这个内存有没有有引用指向它，如果没有就回收，如果有那么根据引用的级别来采用垃圾回收策略。\n\n","source":"_posts/jvm-6.md","raw":"---\ntitle: jvm系列之对象引用分析\ndate: 2019-05-09 12:02:50\ntags: jvm\n---\n\n# java 引用介绍\n\n在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。对象引用被划分成简单的两种状态：可用和不可用。从JDK 1.2版本以后，对象的引用被划分为`4`种级别，从而使程序能更加灵活地控制对象的生命周期，引用的强度由高到低为：强、软、弱、虚引用。\n\n对象生命周期：在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）。上面的这7个阶段，构成了 JVM中对象的完整的生命周期。\n\n<!--more-->\n\n## 强引用(StrongReference)\n\n强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它，我们使用new关键字就是创建了一个强引用。被强引用引用的内存是无法被GC回收的，想要回收这一块的内存得等这个引用从栈内存中出来，对应的内存无引用了才能被回收。\n\n## 软引用(SoftReference)\n\n如果一个对象只具有软引用，则内存空间充足时，GC不会回收这块内存；单如果内存不足的时候它就会被回收，只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n\n创建一个软引用的办法\n\n```java\n    String str = new String(\"xxx\");\n    SoftReference<String> softReference = new SoftReference<String>(str);\n```\n\n`softReference`就是一个软引用。\n\n当内存不足时，`JVM`首先将软引用中的对象引用置为`null`，然后通知垃圾回收器进行回收。也就是说当软引用指向null的时候，对应的内存可能还是未被GC回收的。虚拟机会尽可能的优先回收长时间闲置不用的软引用对象。\n\n## 弱引用(WeakReference)\n\n弱引用比软引用有更短暂的生命周期。在GC扫描内存区域的时候，一旦发现弱引用就会马上回收它。\n\n创建一个弱引用的方法：\n\n```java\nString str = new String(\"xxx\");\nWeakReference<String> weakReference = new WeakReference<>(str);\n// 弱引用转强引用\nString strongReference = weakReference.get();\n```\n\n如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。如上面代码所示，弱引用也也可以转换成强引用\n\n## 虚引用(PhantomReference)\n\n虚引用可以理解为形同虚设的引用，不管你这个引用指向的内存有没有在用，它都随时可能被回收掉。虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n创建虚引用的办法：\n\n```java\n String str = new String(\"xxx\");\nReferenceQueue queue = new ReferenceQueue();\n// 创建虚引用，要求必须与一个引用队列关联\nPhantomReference pr = new PhantomReference(str, queue);\n```\n\n虚引用基本上好像没啥卵用。\n\n# 总结\n\nGC线程在虚拟机中的优先级别很低的，因此占用cpu资源的机会很少，所以当一个内存变成非强引用的时候，不一定马上会被回收，而是看这个时候GC线程有没有在执行。如果GC在执行，它会先检查这个内存有没有有引用指向它，如果没有就回收，如果有那么根据引用的级别来采用垃圾回收策略。\n\n","slug":"jvm-6","published":1,"updated":"2021-01-11T07:31:23.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6c002500wi21caegsn","content":"<h1 id=\"java-引用介绍\"><a href=\"#java-引用介绍\" class=\"headerlink\" title=\"java 引用介绍\"></a>java 引用介绍</h1><p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。对象引用被划分成简单的两种状态：可用和不可用。从JDK 1.2版本以后，对象的引用被划分为<code>4</code>种级别，从而使程序能更加灵活地控制对象的生命周期，引用的强度由高到低为：强、软、弱、虚引用。</p>\n<p>对象生命周期：在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）。上面的这7个阶段，构成了 JVM中对象的完整的生命周期。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"强引用-StrongReference\"><a href=\"#强引用-StrongReference\" class=\"headerlink\" title=\"强引用(StrongReference)\"></a>强引用(StrongReference)</h2><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它，我们使用new关键字就是创建了一个强引用。被强引用引用的内存是无法被GC回收的，想要回收这一块的内存得等这个引用从栈内存中出来，对应的内存无引用了才能被回收。</p>\n<h2 id=\"软引用-SoftReference\"><a href=\"#软引用-SoftReference\" class=\"headerlink\" title=\"软引用(SoftReference)\"></a>软引用(SoftReference)</h2><p>如果一个对象只具有软引用，则内存空间充足时，GC不会回收这块内存；单如果内存不足的时候它就会被回收，只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>\n<p>创建一个软引用的办法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>\n<p><code>softReference</code>就是一个软引用。</p>\n<p>当内存不足时，<code>JVM</code>首先将软引用中的对象引用置为<code>null</code>，然后通知垃圾回收器进行回收。也就是说当软引用指向null的时候，对应的内存可能还是未被GC回收的。虚拟机会尽可能的优先回收长时间闲置不用的软引用对象。</p>\n<h2 id=\"弱引用-WeakReference\"><a href=\"#弱引用-WeakReference\" class=\"headerlink\" title=\"弱引用(WeakReference)\"></a>弱引用(WeakReference)</h2><p>弱引用比软引用有更短暂的生命周期。在GC扫描内存区域的时候，一旦发现弱引用就会马上回收它。</p>\n<p>创建一个弱引用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(str);</span><br><span class=\"line\"><span class=\"comment\">// 弱引用转强引用</span></span><br><span class=\"line\">String strongReference = weakReference.get();</span><br></pre></td></tr></table></figure>\n<p>如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。如上面代码所示，弱引用也也可以转换成强引用</p>\n<h2 id=\"虚引用-PhantomReference\"><a href=\"#虚引用-PhantomReference\" class=\"headerlink\" title=\"虚引用(PhantomReference)\"></a>虚引用(PhantomReference)</h2><p>虚引用可以理解为形同虚设的引用，不管你这个引用指向的内存有没有在用，它都随时可能被回收掉。虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<p>创建虚引用的办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">ReferenceQueue queue = <span class=\"keyword\">new</span> ReferenceQueue();</span><br><span class=\"line\"><span class=\"comment\">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class=\"line\">PhantomReference pr = <span class=\"keyword\">new</span> PhantomReference(str, queue);</span><br></pre></td></tr></table></figure>\n<p>虚引用基本上好像没啥卵用。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>GC线程在虚拟机中的优先级别很低的，因此占用cpu资源的机会很少，所以当一个内存变成非强引用的时候，不一定马上会被回收，而是看这个时候GC线程有没有在执行。如果GC在执行，它会先检查这个内存有没有有引用指向它，如果没有就回收，如果有那么根据引用的级别来采用垃圾回收策略。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"java-引用介绍\"><a href=\"#java-引用介绍\" class=\"headerlink\" title=\"java 引用介绍\"></a>java 引用介绍</h1><p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。对象引用被划分成简单的两种状态：可用和不可用。从JDK 1.2版本以后，对象的引用被划分为<code>4</code>种级别，从而使程序能更加灵活地控制对象的生命周期，引用的强度由高到低为：强、软、弱、虚引用。</p>\n<p>对象生命周期：在JVM运行空间中，对象的整个生命周期大致可以分为7个阶段：创建阶段（Creation）、应用阶段（Using）、不可视阶段（Invisible）、不可到达阶段（Unreachable）、可收集阶段（Collected）、终结阶段（Finalized）与释放阶段（Free）。上面的这7个阶段，构成了 JVM中对象的完整的生命周期。</p>","more":"<h2 id=\"强引用-StrongReference\"><a href=\"#强引用-StrongReference\" class=\"headerlink\" title=\"强引用(StrongReference)\"></a>强引用(StrongReference)</h2><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它，我们使用new关键字就是创建了一个强引用。被强引用引用的内存是无法被GC回收的，想要回收这一块的内存得等这个引用从栈内存中出来，对应的内存无引用了才能被回收。</p>\n<h2 id=\"软引用-SoftReference\"><a href=\"#软引用-SoftReference\" class=\"headerlink\" title=\"软引用(SoftReference)\"></a>软引用(SoftReference)</h2><p>如果一个对象只具有软引用，则内存空间充足时，GC不会回收这块内存；单如果内存不足的时候它就会被回收，只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>\n<p>创建一个软引用的办法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> SoftReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>\n<p><code>softReference</code>就是一个软引用。</p>\n<p>当内存不足时，<code>JVM</code>首先将软引用中的对象引用置为<code>null</code>，然后通知垃圾回收器进行回收。也就是说当软引用指向null的时候，对应的内存可能还是未被GC回收的。虚拟机会尽可能的优先回收长时间闲置不用的软引用对象。</p>\n<h2 id=\"弱引用-WeakReference\"><a href=\"#弱引用-WeakReference\" class=\"headerlink\" title=\"弱引用(WeakReference)\"></a>弱引用(WeakReference)</h2><p>弱引用比软引用有更短暂的生命周期。在GC扫描内存区域的时候，一旦发现弱引用就会马上回收它。</p>\n<p>创建一个弱引用的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">WeakReference&lt;String&gt; weakReference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(str);</span><br><span class=\"line\"><span class=\"comment\">// 弱引用转强引用</span></span><br><span class=\"line\">String strongReference = weakReference.get();</span><br></pre></td></tr></table></figure>\n<p>如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象。如上面代码所示，弱引用也也可以转换成强引用</p>\n<h2 id=\"虚引用-PhantomReference\"><a href=\"#虚引用-PhantomReference\" class=\"headerlink\" title=\"虚引用(PhantomReference)\"></a>虚引用(PhantomReference)</h2><p>虚引用可以理解为形同虚设的引用，不管你这个引用指向的内存有没有在用，它都随时可能被回收掉。虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<p>创建虚引用的办法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> String str = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">ReferenceQueue queue = <span class=\"keyword\">new</span> ReferenceQueue();</span><br><span class=\"line\"><span class=\"comment\">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class=\"line\">PhantomReference pr = <span class=\"keyword\">new</span> PhantomReference(str, queue);</span><br></pre></td></tr></table></figure>\n<p>虚引用基本上好像没啥卵用。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>GC线程在虚拟机中的优先级别很低的，因此占用cpu资源的机会很少，所以当一个内存变成非强引用的时候，不一定马上会被回收，而是看这个时候GC线程有没有在执行。如果GC在执行，它会先检查这个内存有没有有引用指向它，如果没有就回收，如果有那么根据引用的级别来采用垃圾回收策略。</p>"},{"title":"kafka 系列——kafka原理浅解","date":"2020-12-20T16:00:00.000Z","_content":"\n# kafka 原理\n\n消息队列一般包含两种模式，一种是点对点的模式，一种是发布订阅的模式。前文提到过 kafka 是一款基于发布订阅的消息队列。\n那么kafka是怎么去发布消息，怎么去保存消息，订阅消息的呢？首先我们从kafka的发布订阅模型开始分析。\n<!--more-->\n下图为kafka的发布订阅模型：\n![kafka发布订阅模型](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png)\n\n## kafka 运行流程\n\nkafka 总体流程可以粗略的归纳为：\nProducer 生产一个消息并指定消息的主题 Topic -> producer 将生产的消息投递给 kafka cluster -> kafka cluster \n将消息根据 Topic 拆分成多个partition 存储到各个 broker 中 -> 消费者组订阅主题，负载均衡的消费消息。\n接下来我们分析 kafka 的数据分区保存和记录消息消费与生产的方式。\n\n## partition(分区)\n\nkafka 对于 topic 有一个分区的默认值，通过config/server.properties中通过配置项num.partitions来指定新建Topic的默认Partition数量，\n同时也可在创建Topic时通过参数指定或者在Topic创建之后通过Kafka提供的工具修改。生产者将数据写入到kafka主题后，\nkafka通过不同的策略将数据分配到不同分区中，常见的有三种策略，轮询策略，随机策略，和按键保存策略。\n\n在消费者这一端，一个consumer可以消费一个或多个partition，1个partition只能被同组的一个consumer消费，\n但是可以被不同组的多个 consumer 消费。如果一个consumer group中的consumer个数多于topic中的partition的个数，\n多出来的consumer会闲置。\n\n分区本身会有多个副本，这多个副本中只有一个是leader，而其他的都是follower。仅有leader副本可以对外提供服务。\n通常follower不和leader在同一个broker中，这样当leader 挂掉 follower 不会跟着挂，\n而是从众多follower中选一个出来作为leader继续提供服务。\n\n## offset\n\n每个分区中还会维护一个 offset (偏移量)，这是一个很重要的数据，消息的存取都依赖它。\n现在我们可以先简单的理解为往每个分区中写一条数据就会加一个偏移量，而消费一条数据就会减一个偏移量，就好像队列的游标一样。\n后文会具体分析它的工作原理。下图为 offset 示意图：\n\n![offset](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka-partition-offset.png)\n\n\n通常由如下几种 Kafka Offset 的管理方式：\n\n- Spark Checkpoint：在 Spark Streaming 执行Checkpoint 操作时，将 Kafka Offset 一并保存到 HDFS 中。\n\n- HBASE、Redis 等外部 NOSQL 数据库：这一方式可以支持大吞吐量的 Offset 更新。\n\n- ZOOKEEPER：老版本的位移offset是提交到zookeeper中的，目录结构是 ：/consumers/<group.id>/offsets/ <topic>/<partitionId> ，当存在频繁的 Offset 更新时，ZOOKEEPER 集群本身可能成为瓶颈。\n\n- KAFKA：存入自身的一个特殊 Topic中，这种方式支持大吞吐量的Offset 更新，又不需要手动编写 Offset 管理程序或者维护一套额外的集群。\n\n\n后文我们会介绍关于 kafka 的 partition 与 offset 的一些机制，如数据存储与同步，分区原则，分区策略，可靠性保证，高效读写原理等。\n\n","source":"_posts/kafka-1.md","raw":"---\ntitle: kafka 系列——kafka原理浅解\ndate: 2020-12-21\ntags: 中间件\n---\n\n# kafka 原理\n\n消息队列一般包含两种模式，一种是点对点的模式，一种是发布订阅的模式。前文提到过 kafka 是一款基于发布订阅的消息队列。\n那么kafka是怎么去发布消息，怎么去保存消息，订阅消息的呢？首先我们从kafka的发布订阅模型开始分析。\n<!--more-->\n下图为kafka的发布订阅模型：\n![kafka发布订阅模型](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png)\n\n## kafka 运行流程\n\nkafka 总体流程可以粗略的归纳为：\nProducer 生产一个消息并指定消息的主题 Topic -> producer 将生产的消息投递给 kafka cluster -> kafka cluster \n将消息根据 Topic 拆分成多个partition 存储到各个 broker 中 -> 消费者组订阅主题，负载均衡的消费消息。\n接下来我们分析 kafka 的数据分区保存和记录消息消费与生产的方式。\n\n## partition(分区)\n\nkafka 对于 topic 有一个分区的默认值，通过config/server.properties中通过配置项num.partitions来指定新建Topic的默认Partition数量，\n同时也可在创建Topic时通过参数指定或者在Topic创建之后通过Kafka提供的工具修改。生产者将数据写入到kafka主题后，\nkafka通过不同的策略将数据分配到不同分区中，常见的有三种策略，轮询策略，随机策略，和按键保存策略。\n\n在消费者这一端，一个consumer可以消费一个或多个partition，1个partition只能被同组的一个consumer消费，\n但是可以被不同组的多个 consumer 消费。如果一个consumer group中的consumer个数多于topic中的partition的个数，\n多出来的consumer会闲置。\n\n分区本身会有多个副本，这多个副本中只有一个是leader，而其他的都是follower。仅有leader副本可以对外提供服务。\n通常follower不和leader在同一个broker中，这样当leader 挂掉 follower 不会跟着挂，\n而是从众多follower中选一个出来作为leader继续提供服务。\n\n## offset\n\n每个分区中还会维护一个 offset (偏移量)，这是一个很重要的数据，消息的存取都依赖它。\n现在我们可以先简单的理解为往每个分区中写一条数据就会加一个偏移量，而消费一条数据就会减一个偏移量，就好像队列的游标一样。\n后文会具体分析它的工作原理。下图为 offset 示意图：\n\n![offset](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka-partition-offset.png)\n\n\n通常由如下几种 Kafka Offset 的管理方式：\n\n- Spark Checkpoint：在 Spark Streaming 执行Checkpoint 操作时，将 Kafka Offset 一并保存到 HDFS 中。\n\n- HBASE、Redis 等外部 NOSQL 数据库：这一方式可以支持大吞吐量的 Offset 更新。\n\n- ZOOKEEPER：老版本的位移offset是提交到zookeeper中的，目录结构是 ：/consumers/<group.id>/offsets/ <topic>/<partitionId> ，当存在频繁的 Offset 更新时，ZOOKEEPER 集群本身可能成为瓶颈。\n\n- KAFKA：存入自身的一个特殊 Topic中，这种方式支持大吞吐量的Offset 更新，又不需要手动编写 Offset 管理程序或者维护一套额外的集群。\n\n\n后文我们会介绍关于 kafka 的 partition 与 offset 的一些机制，如数据存储与同步，分区原则，分区策略，可靠性保证，高效读写原理等。\n\n","slug":"kafka-1","published":1,"updated":"2021-01-12T03:43:04.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6d002700wieery2kd9","content":"<h1 id=\"kafka-原理\"><a href=\"#kafka-原理\" class=\"headerlink\" title=\"kafka 原理\"></a>kafka 原理</h1><p>消息队列一般包含两种模式，一种是点对点的模式，一种是发布订阅的模式。前文提到过 kafka 是一款基于发布订阅的消息队列。<br>那么kafka是怎么去发布消息，怎么去保存消息，订阅消息的呢？首先我们从kafka的发布订阅模型开始分析。</p>\n<a id=\"more\"></a>\n<p>下图为kafka的发布订阅模型：<br><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png\" alt=\"kafka发布订阅模型\"></p>\n<h2 id=\"kafka-运行流程\"><a href=\"#kafka-运行流程\" class=\"headerlink\" title=\"kafka 运行流程\"></a>kafka 运行流程</h2><p>kafka 总体流程可以粗略的归纳为：<br>Producer 生产一个消息并指定消息的主题 Topic -&gt; producer 将生产的消息投递给 kafka cluster -&gt; kafka cluster<br>将消息根据 Topic 拆分成多个partition 存储到各个 broker 中 -&gt; 消费者组订阅主题，负载均衡的消费消息。<br>接下来我们分析 kafka 的数据分区保存和记录消息消费与生产的方式。</p>\n<h2 id=\"partition-分区\"><a href=\"#partition-分区\" class=\"headerlink\" title=\"partition(分区)\"></a>partition(分区)</h2><p>kafka 对于 topic 有一个分区的默认值，通过config/server.properties中通过配置项num.partitions来指定新建Topic的默认Partition数量，<br>同时也可在创建Topic时通过参数指定或者在Topic创建之后通过Kafka提供的工具修改。生产者将数据写入到kafka主题后，<br>kafka通过不同的策略将数据分配到不同分区中，常见的有三种策略，轮询策略，随机策略，和按键保存策略。</p>\n<p>在消费者这一端，一个consumer可以消费一个或多个partition，1个partition只能被同组的一个consumer消费，<br>但是可以被不同组的多个 consumer 消费。如果一个consumer group中的consumer个数多于topic中的partition的个数，<br>多出来的consumer会闲置。</p>\n<p>分区本身会有多个副本，这多个副本中只有一个是leader，而其他的都是follower。仅有leader副本可以对外提供服务。<br>通常follower不和leader在同一个broker中，这样当leader 挂掉 follower 不会跟着挂，<br>而是从众多follower中选一个出来作为leader继续提供服务。</p>\n<h2 id=\"offset\"><a href=\"#offset\" class=\"headerlink\" title=\"offset\"></a>offset</h2><p>每个分区中还会维护一个 offset (偏移量)，这是一个很重要的数据，消息的存取都依赖它。<br>现在我们可以先简单的理解为往每个分区中写一条数据就会加一个偏移量，而消费一条数据就会减一个偏移量，就好像队列的游标一样。<br>后文会具体分析它的工作原理。下图为 offset 示意图：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka-partition-offset.png\" alt=\"offset\"></p>\n<p>通常由如下几种 Kafka Offset 的管理方式：</p>\n<ul>\n<li><p>Spark Checkpoint：在 Spark Streaming 执行Checkpoint 操作时，将 Kafka Offset 一并保存到 HDFS 中。</p>\n</li>\n<li><p>HBASE、Redis 等外部 NOSQL 数据库：这一方式可以支持大吞吐量的 Offset 更新。</p>\n</li>\n<li><p>ZOOKEEPER：老版本的位移offset是提交到zookeeper中的，目录结构是 ：/consumers/&lt;group.id&gt;/offsets/ <topic>/<partitionId> ，当存在频繁的 Offset 更新时，ZOOKEEPER 集群本身可能成为瓶颈。</p>\n</li>\n<li><p>KAFKA：存入自身的一个特殊 Topic中，这种方式支持大吞吐量的Offset 更新，又不需要手动编写 Offset 管理程序或者维护一套额外的集群。</p>\n</li>\n</ul>\n<p>后文我们会介绍关于 kafka 的 partition 与 offset 的一些机制，如数据存储与同步，分区原则，分区策略，可靠性保证，高效读写原理等。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"kafka-原理\"><a href=\"#kafka-原理\" class=\"headerlink\" title=\"kafka 原理\"></a>kafka 原理</h1><p>消息队列一般包含两种模式，一种是点对点的模式，一种是发布订阅的模式。前文提到过 kafka 是一款基于发布订阅的消息队列。<br>那么kafka是怎么去发布消息，怎么去保存消息，订阅消息的呢？首先我们从kafka的发布订阅模型开始分析。</p>","more":"<p>下图为kafka的发布订阅模型：<br><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png\" alt=\"kafka发布订阅模型\"></p>\n<h2 id=\"kafka-运行流程\"><a href=\"#kafka-运行流程\" class=\"headerlink\" title=\"kafka 运行流程\"></a>kafka 运行流程</h2><p>kafka 总体流程可以粗略的归纳为：<br>Producer 生产一个消息并指定消息的主题 Topic -&gt; producer 将生产的消息投递给 kafka cluster -&gt; kafka cluster<br>将消息根据 Topic 拆分成多个partition 存储到各个 broker 中 -&gt; 消费者组订阅主题，负载均衡的消费消息。<br>接下来我们分析 kafka 的数据分区保存和记录消息消费与生产的方式。</p>\n<h2 id=\"partition-分区\"><a href=\"#partition-分区\" class=\"headerlink\" title=\"partition(分区)\"></a>partition(分区)</h2><p>kafka 对于 topic 有一个分区的默认值，通过config/server.properties中通过配置项num.partitions来指定新建Topic的默认Partition数量，<br>同时也可在创建Topic时通过参数指定或者在Topic创建之后通过Kafka提供的工具修改。生产者将数据写入到kafka主题后，<br>kafka通过不同的策略将数据分配到不同分区中，常见的有三种策略，轮询策略，随机策略，和按键保存策略。</p>\n<p>在消费者这一端，一个consumer可以消费一个或多个partition，1个partition只能被同组的一个consumer消费，<br>但是可以被不同组的多个 consumer 消费。如果一个consumer group中的consumer个数多于topic中的partition的个数，<br>多出来的consumer会闲置。</p>\n<p>分区本身会有多个副本，这多个副本中只有一个是leader，而其他的都是follower。仅有leader副本可以对外提供服务。<br>通常follower不和leader在同一个broker中，这样当leader 挂掉 follower 不会跟着挂，<br>而是从众多follower中选一个出来作为leader继续提供服务。</p>\n<h2 id=\"offset\"><a href=\"#offset\" class=\"headerlink\" title=\"offset\"></a>offset</h2><p>每个分区中还会维护一个 offset (偏移量)，这是一个很重要的数据，消息的存取都依赖它。<br>现在我们可以先简单的理解为往每个分区中写一条数据就会加一个偏移量，而消费一条数据就会减一个偏移量，就好像队列的游标一样。<br>后文会具体分析它的工作原理。下图为 offset 示意图：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka-partition-offset.png\" alt=\"offset\"></p>\n<p>通常由如下几种 Kafka Offset 的管理方式：</p>\n<ul>\n<li><p>Spark Checkpoint：在 Spark Streaming 执行Checkpoint 操作时，将 Kafka Offset 一并保存到 HDFS 中。</p>\n</li>\n<li><p>HBASE、Redis 等外部 NOSQL 数据库：这一方式可以支持大吞吐量的 Offset 更新。</p>\n</li>\n<li><p>ZOOKEEPER：老版本的位移offset是提交到zookeeper中的，目录结构是 ：/consumers/&lt;group.id&gt;/offsets/ <topic>/<partitionId> ，当存在频繁的 Offset 更新时，ZOOKEEPER 集群本身可能成为瓶颈。</p>\n</li>\n<li><p>KAFKA：存入自身的一个特殊 Topic中，这种方式支持大吞吐量的Offset 更新，又不需要手动编写 Offset 管理程序或者维护一套额外的集群。</p>\n</li>\n</ul>\n<p>后文我们会介绍关于 kafka 的 partition 与 offset 的一些机制，如数据存储与同步，分区原则，分区策略，可靠性保证，高效读写原理等。</p>"},{"title":"kafka系列——kafka高级特性解析","date":"2020-12-21T16:00:00.000Z","_content":"\n\n# kafka 原理深度解读\n\n前文介绍了kafka的一些基本原理，接下来我们深入了解下关于kafka的一些机制和优化\n\n<!--more-->\n\n## partition 文件存储机制\n\n前文提到过，一个topic是分成多个partition 存储的；topic是逻辑上的概念，partition是物理上的概念，如图所示：\n![partition](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka_partition.png)\n通过图片我们可以看出，虽然每个partition内部是有序的，但对于整个topic而言它是无法保证有序性的。\npartition 的数据会以 日志文件的形式存储到磁盘中，在配置文件 `server.properties` 中通过属性 `log.dirs` 指定。\n在该文件夹下会根据topic和序号来创建文件夹，在该 partition 文件夹中以 `.log` 结尾的文件是实际存储数据的文件，当生产者生产数据，。\n以 `.index` 结尾的文件是索引文件，index 和log 组成一个 `segment`。 .log 文件默认只会保持7天内的数据，通过 `log.retention.hours` 配置项指定数据保持时长。\n当.log 文件超出最大值时会创建新的 .log文件和.index文件，也就是一个新的segment；其中文件的名称以消息起始偏移量命名。 \n`log.segment.bytes` 指定log文件的最大值。当我们去寻找一条消息的时候，会先根据偏移量来定位到属于哪一个 `segment`，\n再通过二分查找从index文件中寻找该偏移量对应的索引，再通过索引去log文件中找到真正的消息。\n\n## 数据可靠性保证\n为保证producer 发送的数据不丢失，broker 接收到数据后都需要对producer发送ack(确认接收) ，如果producer 未收到ack则会重新发送该条消息。producer 的 ack 策略又分为三种：\n\n- ack=0 producer不等待broker同步完成的确认，继续发送下一条(批)信息\n- ack=1 producer要等待leader成功收到数据并得到确认，才发送下一条message。\n- ack=-1 producer得到follwer确认(全副本同步完成)，才发送下一条数据\n\n## isr（同步副本表） \n\n采用全副本同步完成再ack会有一个问题：\n当leader 接收完数据，所有的follower开始同步数据，但一旦有一个follower不能与leader进行同步，那leader会一直等下去，这样会非常的浪费时间。\n为此kafka引入了 isr 机制——leader会维护一个动态的 isr（in-sync replica set）列表，这个列表维护了和leader保持同步的集合。当ISR中的follower完成数据的同步之后，leader就会发送ack。如果follower 长时间未向leader同步数据，则该follower将会被踢出 isr，当其他满足条件的follower也会被加入到isr。这个同步最大时间配置项为`replica.lag.time.max.ms` 参数设置。如果leader故障了，也会从isr的follower中选举新的leader。\n\n## 数据一致性问题\n因为副本的消息数是存在差异的，可能leader10条，而follower只同步了8条；当leader挂掉，数据就有可能会发生丢失，通过一种机制来保证消费者消费数据的一致性就很有必要了。kafka的数据一致性通过  LEO（每个副本的最后一条o'f'fset）和HW（所有的LEO中最小的那个）来保证。示意图：\n![hw](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/leader.png)\n\n消费者只能看到offset<=HW 的消息。\n\n## 消费策略\n\nkafka 对消息消费的处理有两种：\n- （at least once）至少一次\n- (at most once)至多一次\n- (exactly once) 有且只有一次\n\n因为ack机制的存在，producer 向kafka发送消息时如果 ack=0，由于producer不等确认消息是否投递成功就不管了 ，可能丢失数据，此时消费者最多消费一次消息；如果ack=1，当producer未收到消息确认投递成功时会再次投递，这个时候可能消息被投递了多次，可能会存在重复消费的情况。当kafka开启数据幂等性且ack=1的时候，此时重复的消息会被去重，因此不会产生重复消费的情况。\n启用幂等性的方式是将producer中的参数 `enable.idompotence` 设置为true。\n\n## 消费者相关特性\n\n和rabbitMQ一样，可以指定消费者消费消息是推模式还是拉模式，逻辑是和 rabbit 一样的，这里就不多做解释了。在消费者组中，有多个消费者，一个topic中有多个partition。那么消息的分配是怎么样的呢，首先前文提到过一个消费者组中的消费者不能同时消费同一个partition，这是基本原则。\n然后partiotion的分配机制有两种，一种是range（范围） 一种是 RoundRobin（轮询），range示 意图：\n\n![range](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/range.jpg)\n\nRoundRobin 示意图：\n\n![range](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/roundbin.png)\n\n\n由于consumer也可能会宕机挂掉，当consumer恢复的时候必须要能够从上一次消费的地方重新开始消费。所以consumer需要实时记录自己消费到了哪一个offset，以便能够恢复到宕机前状态。\n\n## kafka高效读写保证\n\nkafka的producer生产数据，要以追加的形式写入到log文件中，这个写磁盘的过程是顺序写，相对于磁盘的随机写来说，这个效率要高出很多，这个是kafka高效读写的保证之一。而另外的一个保证高效读写的技术是零拷贝，用过netty的小伙伴应该知道这个技术，中间少了两次用户态的切换。\n\n## kafka 集群特性\n\nkafka的集群中会有一个broker会被选举为 controller，负责管理集群broker的上下线，所有topic的副本leader的选举工作，\n而controller的这些管理工作都是需要依赖于kafka的。下图为leader的选举示意图：\n\n![range](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/leader1.png)\n\nkafka特性介绍完毕，接下来介绍kafka 事务相关的知识","source":"_posts/kafka-2.md","raw":"---\ntitle: kafka系列——kafka高级特性解析\ndate: 2020-12-22\ntags: 中间件\n---\n\n\n# kafka 原理深度解读\n\n前文介绍了kafka的一些基本原理，接下来我们深入了解下关于kafka的一些机制和优化\n\n<!--more-->\n\n## partition 文件存储机制\n\n前文提到过，一个topic是分成多个partition 存储的；topic是逻辑上的概念，partition是物理上的概念，如图所示：\n![partition](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka_partition.png)\n通过图片我们可以看出，虽然每个partition内部是有序的，但对于整个topic而言它是无法保证有序性的。\npartition 的数据会以 日志文件的形式存储到磁盘中，在配置文件 `server.properties` 中通过属性 `log.dirs` 指定。\n在该文件夹下会根据topic和序号来创建文件夹，在该 partition 文件夹中以 `.log` 结尾的文件是实际存储数据的文件，当生产者生产数据，。\n以 `.index` 结尾的文件是索引文件，index 和log 组成一个 `segment`。 .log 文件默认只会保持7天内的数据，通过 `log.retention.hours` 配置项指定数据保持时长。\n当.log 文件超出最大值时会创建新的 .log文件和.index文件，也就是一个新的segment；其中文件的名称以消息起始偏移量命名。 \n`log.segment.bytes` 指定log文件的最大值。当我们去寻找一条消息的时候，会先根据偏移量来定位到属于哪一个 `segment`，\n再通过二分查找从index文件中寻找该偏移量对应的索引，再通过索引去log文件中找到真正的消息。\n\n## 数据可靠性保证\n为保证producer 发送的数据不丢失，broker 接收到数据后都需要对producer发送ack(确认接收) ，如果producer 未收到ack则会重新发送该条消息。producer 的 ack 策略又分为三种：\n\n- ack=0 producer不等待broker同步完成的确认，继续发送下一条(批)信息\n- ack=1 producer要等待leader成功收到数据并得到确认，才发送下一条message。\n- ack=-1 producer得到follwer确认(全副本同步完成)，才发送下一条数据\n\n## isr（同步副本表） \n\n采用全副本同步完成再ack会有一个问题：\n当leader 接收完数据，所有的follower开始同步数据，但一旦有一个follower不能与leader进行同步，那leader会一直等下去，这样会非常的浪费时间。\n为此kafka引入了 isr 机制——leader会维护一个动态的 isr（in-sync replica set）列表，这个列表维护了和leader保持同步的集合。当ISR中的follower完成数据的同步之后，leader就会发送ack。如果follower 长时间未向leader同步数据，则该follower将会被踢出 isr，当其他满足条件的follower也会被加入到isr。这个同步最大时间配置项为`replica.lag.time.max.ms` 参数设置。如果leader故障了，也会从isr的follower中选举新的leader。\n\n## 数据一致性问题\n因为副本的消息数是存在差异的，可能leader10条，而follower只同步了8条；当leader挂掉，数据就有可能会发生丢失，通过一种机制来保证消费者消费数据的一致性就很有必要了。kafka的数据一致性通过  LEO（每个副本的最后一条o'f'fset）和HW（所有的LEO中最小的那个）来保证。示意图：\n![hw](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/leader.png)\n\n消费者只能看到offset<=HW 的消息。\n\n## 消费策略\n\nkafka 对消息消费的处理有两种：\n- （at least once）至少一次\n- (at most once)至多一次\n- (exactly once) 有且只有一次\n\n因为ack机制的存在，producer 向kafka发送消息时如果 ack=0，由于producer不等确认消息是否投递成功就不管了 ，可能丢失数据，此时消费者最多消费一次消息；如果ack=1，当producer未收到消息确认投递成功时会再次投递，这个时候可能消息被投递了多次，可能会存在重复消费的情况。当kafka开启数据幂等性且ack=1的时候，此时重复的消息会被去重，因此不会产生重复消费的情况。\n启用幂等性的方式是将producer中的参数 `enable.idompotence` 设置为true。\n\n## 消费者相关特性\n\n和rabbitMQ一样，可以指定消费者消费消息是推模式还是拉模式，逻辑是和 rabbit 一样的，这里就不多做解释了。在消费者组中，有多个消费者，一个topic中有多个partition。那么消息的分配是怎么样的呢，首先前文提到过一个消费者组中的消费者不能同时消费同一个partition，这是基本原则。\n然后partiotion的分配机制有两种，一种是range（范围） 一种是 RoundRobin（轮询），range示 意图：\n\n![range](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/range.jpg)\n\nRoundRobin 示意图：\n\n![range](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/roundbin.png)\n\n\n由于consumer也可能会宕机挂掉，当consumer恢复的时候必须要能够从上一次消费的地方重新开始消费。所以consumer需要实时记录自己消费到了哪一个offset，以便能够恢复到宕机前状态。\n\n## kafka高效读写保证\n\nkafka的producer生产数据，要以追加的形式写入到log文件中，这个写磁盘的过程是顺序写，相对于磁盘的随机写来说，这个效率要高出很多，这个是kafka高效读写的保证之一。而另外的一个保证高效读写的技术是零拷贝，用过netty的小伙伴应该知道这个技术，中间少了两次用户态的切换。\n\n## kafka 集群特性\n\nkafka的集群中会有一个broker会被选举为 controller，负责管理集群broker的上下线，所有topic的副本leader的选举工作，\n而controller的这些管理工作都是需要依赖于kafka的。下图为leader的选举示意图：\n\n![range](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/leader1.png)\n\nkafka特性介绍完毕，接下来介绍kafka 事务相关的知识","slug":"kafka-2","published":1,"updated":"2021-01-31T03:32:08.182Z","_id":"ckjtgsh6e002900wi8x3k7vgn","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"kafka-原理深度解读\"><a href=\"#kafka-原理深度解读\" class=\"headerlink\" title=\"kafka 原理深度解读\"></a>kafka 原理深度解读</h1><p>前文介绍了kafka的一些基本原理，接下来我们深入了解下关于kafka的一些机制和优化</p>\n<a id=\"more\"></a>\n\n<h2 id=\"partition-文件存储机制\"><a href=\"#partition-文件存储机制\" class=\"headerlink\" title=\"partition 文件存储机制\"></a>partition 文件存储机制</h2><p>前文提到过，一个topic是分成多个partition 存储的；topic是逻辑上的概念，partition是物理上的概念，如图所示：<br><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka_partition.png\" alt=\"partition\"><br>通过图片我们可以看出，虽然每个partition内部是有序的，但对于整个topic而言它是无法保证有序性的。<br>partition 的数据会以 日志文件的形式存储到磁盘中，在配置文件 <code>server.properties</code> 中通过属性 <code>log.dirs</code> 指定。<br>在该文件夹下会根据topic和序号来创建文件夹，在该 partition 文件夹中以 <code>.log</code> 结尾的文件是实际存储数据的文件，当生产者生产数据，。<br>以 <code>.index</code> 结尾的文件是索引文件，index 和log 组成一个 <code>segment</code>。 .log 文件默认只会保持7天内的数据，通过 <code>log.retention.hours</code> 配置项指定数据保持时长。<br>当.log 文件超出最大值时会创建新的 .log文件和.index文件，也就是一个新的segment；其中文件的名称以消息起始偏移量命名。<br><code>log.segment.bytes</code> 指定log文件的最大值。当我们去寻找一条消息的时候，会先根据偏移量来定位到属于哪一个 <code>segment</code>，<br>再通过二分查找从index文件中寻找该偏移量对应的索引，再通过索引去log文件中找到真正的消息。</p>\n<h2 id=\"数据可靠性保证\"><a href=\"#数据可靠性保证\" class=\"headerlink\" title=\"数据可靠性保证\"></a>数据可靠性保证</h2><p>为保证producer 发送的数据不丢失，broker 接收到数据后都需要对producer发送ack(确认接收) ，如果producer 未收到ack则会重新发送该条消息。producer 的 ack 策略又分为三种：</p>\n<ul>\n<li>ack=0 producer不等待broker同步完成的确认，继续发送下一条(批)信息</li>\n<li>ack=1 producer要等待leader成功收到数据并得到确认，才发送下一条message。</li>\n<li>ack=-1 producer得到follwer确认(全副本同步完成)，才发送下一条数据</li>\n</ul>\n<h2 id=\"isr（同步副本表）\"><a href=\"#isr（同步副本表）\" class=\"headerlink\" title=\"isr（同步副本表）\"></a>isr（同步副本表）</h2><p>采用全副本同步完成再ack会有一个问题：<br>当leader 接收完数据，所有的follower开始同步数据，但一旦有一个follower不能与leader进行同步，那leader会一直等下去，这样会非常的浪费时间。<br>为此kafka引入了 isr 机制——leader会维护一个动态的 isr（in-sync replica set）列表，这个列表维护了和leader保持同步的集合。当ISR中的follower完成数据的同步之后，leader就会发送ack。如果follower 长时间未向leader同步数据，则该follower将会被踢出 isr，当其他满足条件的follower也会被加入到isr。这个同步最大时间配置项为<code>replica.lag.time.max.ms</code> 参数设置。如果leader故障了，也会从isr的follower中选举新的leader。</p>\n<h2 id=\"数据一致性问题\"><a href=\"#数据一致性问题\" class=\"headerlink\" title=\"数据一致性问题\"></a>数据一致性问题</h2><p>因为副本的消息数是存在差异的，可能leader10条，而follower只同步了8条；当leader挂掉，数据就有可能会发生丢失，通过一种机制来保证消费者消费数据的一致性就很有必要了。kafka的数据一致性通过  LEO（每个副本的最后一条o’f’fset）和HW（所有的LEO中最小的那个）来保证。示意图：<br><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/leader.png\" alt=\"hw\"></p>\n<p>消费者只能看到offset&lt;=HW 的消息。</p>\n<h2 id=\"消费策略\"><a href=\"#消费策略\" class=\"headerlink\" title=\"消费策略\"></a>消费策略</h2><p>kafka 对消息消费的处理有两种：</p>\n<ul>\n<li>（at least once）至少一次</li>\n<li>(at most once)至多一次</li>\n<li>(exactly once) 有且只有一次</li>\n</ul>\n<p>因为ack机制的存在，producer 向kafka发送消息时如果 ack=0，由于producer不等确认消息是否投递成功就不管了 ，可能丢失数据，此时消费者最多消费一次消息；如果ack=1，当producer未收到消息确认投递成功时会再次投递，这个时候可能消息被投递了多次，可能会存在重复消费的情况。当kafka开启数据幂等性且ack=1的时候，此时重复的消息会被去重，因此不会产生重复消费的情况。<br>启用幂等性的方式是将producer中的参数 <code>enable.idompotence</code> 设置为true。</p>\n<h2 id=\"消费者相关特性\"><a href=\"#消费者相关特性\" class=\"headerlink\" title=\"消费者相关特性\"></a>消费者相关特性</h2><p>和rabbitMQ一样，可以指定消费者消费消息是推模式还是拉模式，逻辑是和 rabbit 一样的，这里就不多做解释了。在消费者组中，有多个消费者，一个topic中有多个partition。那么消息的分配是怎么样的呢，首先前文提到过一个消费者组中的消费者不能同时消费同一个partition，这是基本原则。<br>然后partiotion的分配机制有两种，一种是range（范围） 一种是 RoundRobin（轮询），range示 意图：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/range.jpg\" alt=\"range\"></p>\n<p>RoundRobin 示意图：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/roundbin.png\" alt=\"range\"></p>\n<p>由于consumer也可能会宕机挂掉，当consumer恢复的时候必须要能够从上一次消费的地方重新开始消费。所以consumer需要实时记录自己消费到了哪一个offset，以便能够恢复到宕机前状态。</p>\n<h2 id=\"kafka高效读写保证\"><a href=\"#kafka高效读写保证\" class=\"headerlink\" title=\"kafka高效读写保证\"></a>kafka高效读写保证</h2><p>kafka的producer生产数据，要以追加的形式写入到log文件中，这个写磁盘的过程是顺序写，相对于磁盘的随机写来说，这个效率要高出很多，这个是kafka高效读写的保证之一。而另外的一个保证高效读写的技术是零拷贝，用过netty的小伙伴应该知道这个技术，中间少了两次用户态的切换。</p>\n<h2 id=\"kafka-集群特性\"><a href=\"#kafka-集群特性\" class=\"headerlink\" title=\"kafka 集群特性\"></a>kafka 集群特性</h2><p>kafka的集群中会有一个broker会被选举为 controller，负责管理集群broker的上下线，所有topic的副本leader的选举工作，<br>而controller的这些管理工作都是需要依赖于kafka的。下图为leader的选举示意图：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/leader1.png\" alt=\"range\"></p>\n<p>kafka特性介绍完毕，接下来介绍kafka 事务相关的知识</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"kafka-原理深度解读\"><a href=\"#kafka-原理深度解读\" class=\"headerlink\" title=\"kafka 原理深度解读\"></a>kafka 原理深度解读</h1><p>前文介绍了kafka的一些基本原理，接下来我们深入了解下关于kafka的一些机制和优化</p>","more":"<h2 id=\"partition-文件存储机制\"><a href=\"#partition-文件存储机制\" class=\"headerlink\" title=\"partition 文件存储机制\"></a>partition 文件存储机制</h2><p>前文提到过，一个topic是分成多个partition 存储的；topic是逻辑上的概念，partition是物理上的概念，如图所示：<br><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/kafka_partition.png\" alt=\"partition\"><br>通过图片我们可以看出，虽然每个partition内部是有序的，但对于整个topic而言它是无法保证有序性的。<br>partition 的数据会以 日志文件的形式存储到磁盘中，在配置文件 <code>server.properties</code> 中通过属性 <code>log.dirs</code> 指定。<br>在该文件夹下会根据topic和序号来创建文件夹，在该 partition 文件夹中以 <code>.log</code> 结尾的文件是实际存储数据的文件，当生产者生产数据，。<br>以 <code>.index</code> 结尾的文件是索引文件，index 和log 组成一个 <code>segment</code>。 .log 文件默认只会保持7天内的数据，通过 <code>log.retention.hours</code> 配置项指定数据保持时长。<br>当.log 文件超出最大值时会创建新的 .log文件和.index文件，也就是一个新的segment；其中文件的名称以消息起始偏移量命名。<br><code>log.segment.bytes</code> 指定log文件的最大值。当我们去寻找一条消息的时候，会先根据偏移量来定位到属于哪一个 <code>segment</code>，<br>再通过二分查找从index文件中寻找该偏移量对应的索引，再通过索引去log文件中找到真正的消息。</p>\n<h2 id=\"数据可靠性保证\"><a href=\"#数据可靠性保证\" class=\"headerlink\" title=\"数据可靠性保证\"></a>数据可靠性保证</h2><p>为保证producer 发送的数据不丢失，broker 接收到数据后都需要对producer发送ack(确认接收) ，如果producer 未收到ack则会重新发送该条消息。producer 的 ack 策略又分为三种：</p>\n<ul>\n<li>ack=0 producer不等待broker同步完成的确认，继续发送下一条(批)信息</li>\n<li>ack=1 producer要等待leader成功收到数据并得到确认，才发送下一条message。</li>\n<li>ack=-1 producer得到follwer确认(全副本同步完成)，才发送下一条数据</li>\n</ul>\n<h2 id=\"isr（同步副本表）\"><a href=\"#isr（同步副本表）\" class=\"headerlink\" title=\"isr（同步副本表）\"></a>isr（同步副本表）</h2><p>采用全副本同步完成再ack会有一个问题：<br>当leader 接收完数据，所有的follower开始同步数据，但一旦有一个follower不能与leader进行同步，那leader会一直等下去，这样会非常的浪费时间。<br>为此kafka引入了 isr 机制——leader会维护一个动态的 isr（in-sync replica set）列表，这个列表维护了和leader保持同步的集合。当ISR中的follower完成数据的同步之后，leader就会发送ack。如果follower 长时间未向leader同步数据，则该follower将会被踢出 isr，当其他满足条件的follower也会被加入到isr。这个同步最大时间配置项为<code>replica.lag.time.max.ms</code> 参数设置。如果leader故障了，也会从isr的follower中选举新的leader。</p>\n<h2 id=\"数据一致性问题\"><a href=\"#数据一致性问题\" class=\"headerlink\" title=\"数据一致性问题\"></a>数据一致性问题</h2><p>因为副本的消息数是存在差异的，可能leader10条，而follower只同步了8条；当leader挂掉，数据就有可能会发生丢失，通过一种机制来保证消费者消费数据的一致性就很有必要了。kafka的数据一致性通过  LEO（每个副本的最后一条o’f’fset）和HW（所有的LEO中最小的那个）来保证。示意图：<br><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/leader.png\" alt=\"hw\"></p>\n<p>消费者只能看到offset&lt;=HW 的消息。</p>\n<h2 id=\"消费策略\"><a href=\"#消费策略\" class=\"headerlink\" title=\"消费策略\"></a>消费策略</h2><p>kafka 对消息消费的处理有两种：</p>\n<ul>\n<li>（at least once）至少一次</li>\n<li>(at most once)至多一次</li>\n<li>(exactly once) 有且只有一次</li>\n</ul>\n<p>因为ack机制的存在，producer 向kafka发送消息时如果 ack=0，由于producer不等确认消息是否投递成功就不管了 ，可能丢失数据，此时消费者最多消费一次消息；如果ack=1，当producer未收到消息确认投递成功时会再次投递，这个时候可能消息被投递了多次，可能会存在重复消费的情况。当kafka开启数据幂等性且ack=1的时候，此时重复的消息会被去重，因此不会产生重复消费的情况。<br>启用幂等性的方式是将producer中的参数 <code>enable.idompotence</code> 设置为true。</p>\n<h2 id=\"消费者相关特性\"><a href=\"#消费者相关特性\" class=\"headerlink\" title=\"消费者相关特性\"></a>消费者相关特性</h2><p>和rabbitMQ一样，可以指定消费者消费消息是推模式还是拉模式，逻辑是和 rabbit 一样的，这里就不多做解释了。在消费者组中，有多个消费者，一个topic中有多个partition。那么消息的分配是怎么样的呢，首先前文提到过一个消费者组中的消费者不能同时消费同一个partition，这是基本原则。<br>然后partiotion的分配机制有两种，一种是range（范围） 一种是 RoundRobin（轮询），range示 意图：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/range.jpg\" alt=\"range\"></p>\n<p>RoundRobin 示意图：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/roundbin.png\" alt=\"range\"></p>\n<p>由于consumer也可能会宕机挂掉，当consumer恢复的时候必须要能够从上一次消费的地方重新开始消费。所以consumer需要实时记录自己消费到了哪一个offset，以便能够恢复到宕机前状态。</p>\n<h2 id=\"kafka高效读写保证\"><a href=\"#kafka高效读写保证\" class=\"headerlink\" title=\"kafka高效读写保证\"></a>kafka高效读写保证</h2><p>kafka的producer生产数据，要以追加的形式写入到log文件中，这个写磁盘的过程是顺序写，相对于磁盘的随机写来说，这个效率要高出很多，这个是kafka高效读写的保证之一。而另外的一个保证高效读写的技术是零拷贝，用过netty的小伙伴应该知道这个技术，中间少了两次用户态的切换。</p>\n<h2 id=\"kafka-集群特性\"><a href=\"#kafka-集群特性\" class=\"headerlink\" title=\"kafka 集群特性\"></a>kafka 集群特性</h2><p>kafka的集群中会有一个broker会被选举为 controller，负责管理集群broker的上下线，所有topic的副本leader的选举工作，<br>而controller的这些管理工作都是需要依赖于kafka的。下图为leader的选举示意图：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/leader1.png\" alt=\"range\"></p>\n<p>kafka特性介绍完毕，接下来介绍kafka 事务相关的知识</p>"},{"title":"kafka系列-安装和使用kafka","date":"2020-12-19T16:00:00.000Z","_content":"\n# kafka 介绍\n\nkafka 是一款基于发布订阅的消息系统，Kafka的最大的特点就是高吞吐量以及可水平扩展，\nKafka擅长处理数据量庞大的业务，例如使用Kafka做日志分析、数据计算等。\n<!--more-->\n## kafka 概念角色介绍\n\n- Broker：kafka 中 broker概念和rabbitMQ的broker概念类似，一个独立的 Kafka 服务器被称为broker，接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存；\n- Topic：Topic为主题，也就是相当于消息系统中的队列(queue)，一个Topic中存在多个Partition；注意，这里区别于 rabbitMQ 的 Topic；\n- Partition：Partition为分区，是构成Kafka存储结构的最小单位；\n- Group：消费者组，一组消费者构成消费者组\n- Message：消息\n\n# kafka 安装及使用\nkafka 的运行依赖于 zookeeper，它的安装相对于 rabbitMQ来说比较简单。下面介绍Windows下 kafka的安装及其使用。\n\nkafka是依赖于zookeeper的，所以我们先要安装zookeeper ，当然kafka的二进制包里面，包含了zookeeper 的安装包，我们不需要单独的再去下载ZK的安装包；\n\n 在 kafka 官网下载 二进制的 tgz 压缩包： http://kafka.apache.org/downloads.html，解压后它的 bin/windows下有 zk的启动脚本和kafka的启动脚本，\n zk的配置文件和kafka的配置文件在 config文件夹下，分别对应 zookeeper.properties和server.properties。\n 由于本人对zk使用的频率也比较高，因此我是单独安装的zk。\n\n 下面我们对kafka进行配置及启动，配置文件说明：\n ```\n # 对外暴露的服务端口\nadvertised.listeners=PLAINTEXT://ip:9092\n# 机器的标识\nbroker.id=1\n# kafka日志存储的位置\nlog.dirs=c:xxx\n# zk的地址\nzookeeper.connect=localhost:2181\n ```\n\n启动脚本： \n ```bat\n.\\bin\\windows\\kafka-server-start.bat .\\config\\server.properties\n ```\n\n接下来我们做一下简单的测试。\n\n执行脚本\n```bat\n.\\bin\\windows\\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n```\n\n该操作创建了一个 名为 test 的 kafka 主题，接下来我们可以在主题中写入消息并消费消息了。\n\n执行脚本\n```bat\n.\\bin\\windows\\kafka-console-producer.bat --broker-list 127.0.0.1:9092 --topic test \nxxx\nxxx\n```\n该操作创建了一个消息生产者，并发送消息 \"xxx\"\n\n执行脚本,消费消息：\n```bat\nkafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning\n\n```\n","source":"_posts/kafka.md","raw":"---\ntitle: kafka系列-安装和使用kafka\ndate: 2020-12-20\ntags: 中间件\n---\n\n# kafka 介绍\n\nkafka 是一款基于发布订阅的消息系统，Kafka的最大的特点就是高吞吐量以及可水平扩展，\nKafka擅长处理数据量庞大的业务，例如使用Kafka做日志分析、数据计算等。\n<!--more-->\n## kafka 概念角色介绍\n\n- Broker：kafka 中 broker概念和rabbitMQ的broker概念类似，一个独立的 Kafka 服务器被称为broker，接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存；\n- Topic：Topic为主题，也就是相当于消息系统中的队列(queue)，一个Topic中存在多个Partition；注意，这里区别于 rabbitMQ 的 Topic；\n- Partition：Partition为分区，是构成Kafka存储结构的最小单位；\n- Group：消费者组，一组消费者构成消费者组\n- Message：消息\n\n# kafka 安装及使用\nkafka 的运行依赖于 zookeeper，它的安装相对于 rabbitMQ来说比较简单。下面介绍Windows下 kafka的安装及其使用。\n\nkafka是依赖于zookeeper的，所以我们先要安装zookeeper ，当然kafka的二进制包里面，包含了zookeeper 的安装包，我们不需要单独的再去下载ZK的安装包；\n\n 在 kafka 官网下载 二进制的 tgz 压缩包： http://kafka.apache.org/downloads.html，解压后它的 bin/windows下有 zk的启动脚本和kafka的启动脚本，\n zk的配置文件和kafka的配置文件在 config文件夹下，分别对应 zookeeper.properties和server.properties。\n 由于本人对zk使用的频率也比较高，因此我是单独安装的zk。\n\n 下面我们对kafka进行配置及启动，配置文件说明：\n ```\n # 对外暴露的服务端口\nadvertised.listeners=PLAINTEXT://ip:9092\n# 机器的标识\nbroker.id=1\n# kafka日志存储的位置\nlog.dirs=c:xxx\n# zk的地址\nzookeeper.connect=localhost:2181\n ```\n\n启动脚本： \n ```bat\n.\\bin\\windows\\kafka-server-start.bat .\\config\\server.properties\n ```\n\n接下来我们做一下简单的测试。\n\n执行脚本\n```bat\n.\\bin\\windows\\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n```\n\n该操作创建了一个 名为 test 的 kafka 主题，接下来我们可以在主题中写入消息并消费消息了。\n\n执行脚本\n```bat\n.\\bin\\windows\\kafka-console-producer.bat --broker-list 127.0.0.1:9092 --topic test \nxxx\nxxx\n```\n该操作创建了一个消息生产者，并发送消息 \"xxx\"\n\n执行脚本,消费消息：\n```bat\nkafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning\n\n```\n","slug":"kafka","published":1,"updated":"2021-03-28T03:57:24.877Z","_id":"ckjtgsh6e002b00wieaw4406z","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"kafka-介绍\"><a href=\"#kafka-介绍\" class=\"headerlink\" title=\"kafka 介绍\"></a>kafka 介绍</h1><p>kafka 是一款基于发布订阅的消息系统，Kafka的最大的特点就是高吞吐量以及可水平扩展，<br>Kafka擅长处理数据量庞大的业务，例如使用Kafka做日志分析、数据计算等。</p>\n<span id=\"more\"></span>\n<h2 id=\"kafka-概念角色介绍\"><a href=\"#kafka-概念角色介绍\" class=\"headerlink\" title=\"kafka 概念角色介绍\"></a>kafka 概念角色介绍</h2><ul>\n<li>Broker：kafka 中 broker概念和rabbitMQ的broker概念类似，一个独立的 Kafka 服务器被称为broker，接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存；</li>\n<li>Topic：Topic为主题，也就是相当于消息系统中的队列(queue)，一个Topic中存在多个Partition；注意，这里区别于 rabbitMQ 的 Topic；</li>\n<li>Partition：Partition为分区，是构成Kafka存储结构的最小单位；</li>\n<li>Group：消费者组，一组消费者构成消费者组</li>\n<li>Message：消息</li>\n</ul>\n<h1 id=\"kafka-安装及使用\"><a href=\"#kafka-安装及使用\" class=\"headerlink\" title=\"kafka 安装及使用\"></a>kafka 安装及使用</h1><p>kafka 的运行依赖于 zookeeper，它的安装相对于 rabbitMQ来说比较简单。下面介绍Windows下 kafka的安装及其使用。</p>\n<p>kafka是依赖于zookeeper的，所以我们先要安装zookeeper ，当然kafka的二进制包里面，包含了zookeeper 的安装包，我们不需要单独的再去下载ZK的安装包；</p>\n<p> 在 kafka 官网下载 二进制的 tgz 压缩包： <a href=\"http://kafka.apache.org/downloads.html，解压后它的\">http://kafka.apache.org/downloads.html，解压后它的</a> bin/windows下有 zk的启动脚本和kafka的启动脚本，<br> zk的配置文件和kafka的配置文件在 config文件夹下，分别对应 zookeeper.properties和server.properties。<br> 由于本人对zk使用的频率也比较高，因此我是单独安装的zk。</p>\n<p> 下面我们对kafka进行配置及启动，配置文件说明：<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> # 对外暴露的服务端口</span><br><span class=\"line\">advertised.listeners=PLAINTEXT://ip:9092</span><br><span class=\"line\"># 机器的标识</span><br><span class=\"line\">broker.id=1</span><br><span class=\"line\"># kafka日志存储的位置</span><br><span class=\"line\">log.dirs=c:xxx</span><br><span class=\"line\"># zk的地址</span><br><span class=\"line\">zookeeper.connect=localhost:2181</span><br></pre></td></tr></table></figure></p>\n<p>启动脚本：<br> <figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.\\bin\\windows\\kafka-server-<span class=\"built_in\">start</span>.bat .\\config\\server.properties</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们做一下简单的测试。</p>\n<p>执行脚本</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.\\bin\\windows\\kafka-topics.bat --create --zookeeper localhost:<span class=\"number\">2181</span> --replication-factor <span class=\"number\">1</span> --partitions <span class=\"number\">1</span> --topic test</span><br></pre></td></tr></table></figure>\n\n<p>该操作创建了一个 名为 test 的 kafka 主题，接下来我们可以在主题中写入消息并消费消息了。</p>\n<p>执行脚本</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.\\bin\\windows\\kafka-console-producer.bat --broker-list <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9092</span> --topic test </span><br><span class=\"line\">xxx</span><br><span class=\"line\">xxx</span><br></pre></td></tr></table></figure>\n<p>该操作创建了一个消息生产者，并发送消息 “xxx”</p>\n<p>执行脚本,消费消息：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kafka-console-consumer.bat --bootstrap-server localhost:<span class=\"number\">9092</span> --topic test --from-beginning</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"kafka-介绍\"><a href=\"#kafka-介绍\" class=\"headerlink\" title=\"kafka 介绍\"></a>kafka 介绍</h1><p>kafka 是一款基于发布订阅的消息系统，Kafka的最大的特点就是高吞吐量以及可水平扩展，<br>Kafka擅长处理数据量庞大的业务，例如使用Kafka做日志分析、数据计算等。</p>","more":"<h2 id=\"kafka-概念角色介绍\"><a href=\"#kafka-概念角色介绍\" class=\"headerlink\" title=\"kafka 概念角色介绍\"></a>kafka 概念角色介绍</h2><ul>\n<li>Broker：kafka 中 broker概念和rabbitMQ的broker概念类似，一个独立的 Kafka 服务器被称为broker，接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存；</li>\n<li>Topic：Topic为主题，也就是相当于消息系统中的队列(queue)，一个Topic中存在多个Partition；注意，这里区别于 rabbitMQ 的 Topic；</li>\n<li>Partition：Partition为分区，是构成Kafka存储结构的最小单位；</li>\n<li>Group：消费者组，一组消费者构成消费者组</li>\n<li>Message：消息</li>\n</ul>\n<h1 id=\"kafka-安装及使用\"><a href=\"#kafka-安装及使用\" class=\"headerlink\" title=\"kafka 安装及使用\"></a>kafka 安装及使用</h1><p>kafka 的运行依赖于 zookeeper，它的安装相对于 rabbitMQ来说比较简单。下面介绍Windows下 kafka的安装及其使用。</p>\n<p>kafka是依赖于zookeeper的，所以我们先要安装zookeeper ，当然kafka的二进制包里面，包含了zookeeper 的安装包，我们不需要单独的再去下载ZK的安装包；</p>\n<p> 在 kafka 官网下载 二进制的 tgz 压缩包： <a href=\"http://kafka.apache.org/downloads.html，解压后它的\">http://kafka.apache.org/downloads.html，解压后它的</a> bin/windows下有 zk的启动脚本和kafka的启动脚本，<br> zk的配置文件和kafka的配置文件在 config文件夹下，分别对应 zookeeper.properties和server.properties。<br> 由于本人对zk使用的频率也比较高，因此我是单独安装的zk。</p>\n<p> 下面我们对kafka进行配置及启动，配置文件说明：<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> # 对外暴露的服务端口</span><br><span class=\"line\">advertised.listeners=PLAINTEXT://ip:9092</span><br><span class=\"line\"># 机器的标识</span><br><span class=\"line\">broker.id=1</span><br><span class=\"line\"># kafka日志存储的位置</span><br><span class=\"line\">log.dirs=c:xxx</span><br><span class=\"line\"># zk的地址</span><br><span class=\"line\">zookeeper.connect=localhost:2181</span><br></pre></td></tr></table></figure></p>\n<p>启动脚本：<br> <figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.\\bin\\windows\\kafka-server-<span class=\"built_in\">start</span>.bat .\\config\\server.properties</span><br></pre></td></tr></table></figure></p>\n<p>接下来我们做一下简单的测试。</p>\n<p>执行脚本</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.\\bin\\windows\\kafka-topics.bat --create --zookeeper localhost:<span class=\"number\">2181</span> --replication-factor <span class=\"number\">1</span> --partitions <span class=\"number\">1</span> --topic test</span><br></pre></td></tr></table></figure>\n\n<p>该操作创建了一个 名为 test 的 kafka 主题，接下来我们可以在主题中写入消息并消费消息了。</p>\n<p>执行脚本</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.\\bin\\windows\\kafka-console-producer.bat --broker-list <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9092</span> --topic test </span><br><span class=\"line\">xxx</span><br><span class=\"line\">xxx</span><br></pre></td></tr></table></figure>\n<p>该操作创建了一个消息生产者，并发送消息 “xxx”</p>\n<p>执行脚本,消费消息：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kafka-console-consumer.bat --bootstrap-server localhost:<span class=\"number\">9092</span> --topic test --from-beginning</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"leetcode刷题记录","date":"2019-04-27T06:00:37.000Z","_content":"\n这篇博客会记录我的一些刷题心得\n\n## 参考：[leetcode答案](<https://www.cnblogs.com/grandyang/p/4606334.html>)\n\n**两数之和**\n\n给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n<!--more-->\n\n**示例:**\n\n```\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n\n**解析**\n\n此题纯考数据结构\n\n利用HashMap提高查询速度 \n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n         HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\n        int[] res = new int[2];\n        for (int i = 0; i < nums.length; ++i) {\n            m.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; ++i) {\n            int t = target - nums[i];\n            // 这里\n            if (m.containsKey(t) && m.get(t) != i) {\n                res[0] = i;\n                res[1] = m.get(t);\n                break;\n            }\n        }\n        return res;\n    }\n}\n```\n\n**两数相加**\n\n给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n**示例：**\n\n```java\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n```","source":"_posts/leetcode.md","raw":"---\ntitle: leetcode刷题记录\ndate: 2019-04-27 14:00:37\ntags: 算法\n---\n\n这篇博客会记录我的一些刷题心得\n\n## 参考：[leetcode答案](<https://www.cnblogs.com/grandyang/p/4606334.html>)\n\n**两数之和**\n\n给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n<!--more-->\n\n**示例:**\n\n```\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n```\n\n**解析**\n\n此题纯考数据结构\n\n利用HashMap提高查询速度 \n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n         HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();\n        int[] res = new int[2];\n        for (int i = 0; i < nums.length; ++i) {\n            m.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; ++i) {\n            int t = target - nums[i];\n            // 这里\n            if (m.containsKey(t) && m.get(t) != i) {\n                res[0] = i;\n                res[1] = m.get(t);\n                break;\n            }\n        }\n        return res;\n    }\n}\n```\n\n**两数相加**\n\n给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n**示例：**\n\n```java\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n```","slug":"leetcode","published":1,"updated":"2021-01-11T07:31:23.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6f002e00wi89qt2yhe","content":"<p>这篇博客会记录我的一些刷题心得</p>\n<h2 id=\"参考：leetcode答案\"><a href=\"#参考：leetcode答案\" class=\"headerlink\" title=\"参考：leetcode答案\"></a>参考：<a href=\"https://www.cnblogs.com/grandyang/p/4606334.html\">leetcode答案</a></h2><p><strong>两数之和</strong></p>\n<p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\n<a id=\"more\"></a>\n\n<p><strong>示例:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class=\"line\"></span><br><span class=\"line\">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class=\"line\">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>\n<p><strong>解析</strong></p>\n<p>此题纯考数据结构</p>\n<p>利用HashMap提高查询速度 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">         HashMap&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            m.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = target - nums[i];</span><br><span class=\"line\">            <span class=\"comment\">// 这里</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.containsKey(t) &amp;&amp; m.get(t) != i) &#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">                res[<span class=\"number\">1</span>] = m.get(t);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>两数相加</strong></p>\n<p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>\n<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>\n<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：(<span class=\"number\">2</span> -&gt; <span class=\"number\">4</span> -&gt; <span class=\"number\">3</span>) + (<span class=\"number\">5</span> -&gt; <span class=\"number\">6</span> -&gt; <span class=\"number\">4</span>)</span><br><span class=\"line\">输出：<span class=\"number\">7</span> -&gt; <span class=\"number\">0</span> -&gt; <span class=\"number\">8</span></span><br><span class=\"line\">原因：<span class=\"number\">342</span> + <span class=\"number\">465</span> = <span class=\"number\">807</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>这篇博客会记录我的一些刷题心得</p>\n<h2 id=\"参考：leetcode答案\"><a href=\"#参考：leetcode答案\" class=\"headerlink\" title=\"参考：leetcode答案\"></a>参考：<a href=\"https://www.cnblogs.com/grandyang/p/4606334.html\">leetcode答案</a></h2><p><strong>两数之和</strong></p>\n<p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>","more":"<p><strong>示例:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class=\"line\"></span><br><span class=\"line\">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class=\"line\">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>\n<p><strong>解析</strong></p>\n<p>此题纯考数据结构</p>\n<p>利用HashMap提高查询速度 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">         HashMap&lt;Integer, Integer&gt; m = <span class=\"keyword\">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            m.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = target - nums[i];</span><br><span class=\"line\">            <span class=\"comment\">// 这里</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m.containsKey(t) &amp;&amp; m.get(t) != i) &#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">                res[<span class=\"number\">1</span>] = m.get(t);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>两数相加</strong></p>\n<p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>\n<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>\n<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：(<span class=\"number\">2</span> -&gt; <span class=\"number\">4</span> -&gt; <span class=\"number\">3</span>) + (<span class=\"number\">5</span> -&gt; <span class=\"number\">6</span> -&gt; <span class=\"number\">4</span>)</span><br><span class=\"line\">输出：<span class=\"number\">7</span> -&gt; <span class=\"number\">0</span> -&gt; <span class=\"number\">8</span></span><br><span class=\"line\">原因：<span class=\"number\">342</span> + <span class=\"number\">465</span> = <span class=\"number\">807</span></span><br></pre></td></tr></table></figure>"},{"title":"logback自定义Appender","date":"2019-04-22T03:25:45.000Z","_content":"\n作者：muggle\n\n<!--more-->","source":"_posts/logback-2.md","raw":"---\ntitle: logback自定义Appender\ndate: 2019-04-22 11:25:45\ntags: log\n---\n\n作者：muggle\n\n<!--more-->","slug":"logback-2","published":1,"updated":"2021-01-11T07:31:23.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6g002g00wi3vnqhecw","content":"<p>作者：muggle</p>\n<a id=\"more\"></a>","site":{"data":{}},"excerpt":"<p>作者：muggle</p>","more":""},{"title":"服务注册发现与配置中心新选择——nacos","date":"2019-04-27T02:17:48.000Z","_content":"\n### 编辑中\n\n\n\n# nacos简介\n\n​\t在nacos-0.3的时候我就开始关注，期间还写过一篇作为springcloud配置中心的使用记录的博客。在前不久，nacos终于出了正式版，赶个时髦出篇博客吹一波，[nacos官方文档](https://nacos.io/zh-cn/index.html)\n\n<!--more-->\n\n## nacos特性\n\n###  服务发现和服务健康监测\n\n支持基于 DNS 和基于 RPC 的服务发现（**可替代eureka**）。Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。\n\n### 动态配置服务\n\n动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置（**可以作为配置中心**）。动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。Nacos 提供了一个简洁易用的UI ([控制台样例 Demo](http://console.nacos.io/nacos/index.html)) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。\n\n### 动态 DNS 服务\n\n动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务（**可做负载均衡**）。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。\n\n### 服务及其元数据管理\n\nNacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据（**不知道啥意思，以后研究**）。\n\n## nacos的相关概念\n\n- 地域 （Region）：物理的数据中心，资源创建成功后不能更换。\n- 可用区（Available Zone）：同一地域内，电力和网络互相独立的物理区域。同一可用区内，实例的网络延迟较低。\n- 接入点（Endpoint）：地域的某个服务的入口域名。\n- 命名空间（Namespace）：用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。\n- 元信息(Metadata)：Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。\n- 实例（Instance）：提供一个或多个服务的具有可访问网络地址（IP:Port）的进程。\n- 权重（Weight）：实例级别的配置。权重为浮点数。权重越大，分配给该实例的流量越大。\n- 健康检测（Health Check）：以指定方式检查服务下挂载的实例 (Instance) 的健康度，从而确认该实例 (Instance) 是否能提供服务。根据检查结果，实例 (Instance) 会被判断为健康或不健康。对服务发起解析请求时，不健康的实例 (Instance) 不会返回给客户端。\n- 健康保护阈值（Protect Threshold）：为了防止因过多实例 (Instance) 不健康导致流量全部流向健康实例 (Instance) ，继而造成流量压力把健康 健康实例 (Instance) 压垮并形成雪崩效应，应将健康保护阈值定义为一个 0 到 1 之间的浮点数。当域名健康实例 (Instance) 占总服务实例 (Instance) 的比例小于该值时，无论实例 (Instance) 是否健康，都会将这个实例 (Instance) 返回给客户端。这样做虽然损失了一部分流量，但是保证了集群的剩余健康实例 (Instance) 能正常工作。\n- 服务分组（Service Group）：不同的服务可以归类到同一分组。\n- 虚拟集群（Virtual Cluster）：同一个服务下的所有服务实例组成一个默认集群, 集群可以被进一步按需求划分，划分的单位可以是虚拟集群。\n\n# nacos 使用\n\n## 安装\n\n可在github上下载安装包安装，或者采用docker安装；\n\nwindows上运行：[nacos github地址](<https://github.com/alibaba/nacos>) 在github查看该项目的releases并下载最新版，解压后进入bin目录 运行`startup.cmd`。\n\ndocker上运行：docker run --name nacos-standalone -e MODE=standalone -p 8848:8848 nacos/nacos-server:latest 可运行一个单机版nacos\n\n浏览器上访问 ip:8848/nacos 进入登陆界面，用户名和密码都是nacos；登陆成功就能看到控制台UI界面了。在安装包的./conf目录下有一个application.properties文件，这是nacos的配置文件，相关配置后期会说。\n\n## 作为配置中心\n\n### 示例\n\n这里为方便讲解，我们现在Windows环境下运行一个单机版nacos，启动后登陆；创建一个springboot应用，导入依赖\n\n```xml\n <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-alibaba-nacos-config</artifactId>\n    <version>0.9.0.RELEASE</version>\n </dependency>\n```\n\n然后删除application.properties 新建一个bootstrap.properties。这里可能还有同学不知道application和bootstrap的区别；在这里科普一下：在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application, bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。bootstrap比application要先加载，bootstrap只在cloud项目中使用。\n\n添加配置：\n\n```properties\n#服务名\nspring.application.name=nacos-config-example\n# 配置中心url\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848\n# 配置中心的配置语法\nspring.cloud.nacos.config.file-extension=properties\n```\n\n现在在nacos配置中心新建配置：\n\ndataId:nacos-config-example.properties\n\n![1556523308515](C:\\Users\\isock\\AppData\\Roaming\\Typora\\typora-user-images\\1556523308515.png)\n\n启动项目，发现项目端口号是8082，我们的配置成功了。\n\n### 说明\n\n注意 图中几个选项 TEXT\\JSON\\ XML \\YAML\\ HTML\\Propertiest这些并不是指定nacos以何种语法去解析配置文件，仅仅是提供语法提示，代码高亮辅助样式；第一次使用的人很容易被误导。我们要指定配置文件语法要在bootstrap做如下配置：\n\n```properties\nspring.cloud.nacos.config.file-extension=properties\nspring.cloud.nacos.config.file-extension=yaml\n```\n\n配置中心配置依靠dataId将配置信息和客户端绑定，我们来看看dataId组成规则：\n\n```java\n${prefix}-${spring.profile.active}.${file-extension}\n```\n\n- `prefix` 默认为 `spring.application.name` 的值，也可以通过配置项 `spring.cloud.nacos.config.prefix`来配置。\n\n- `spring.profile.active` 即为当前环境对应的 profile， **注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}**\n- `file-exetension` 为配置内容的数据格式，可以通过配置项 `spring.cloud.nacos.config.file-extension` 来配置。目前只支持 `properties` 和 `yaml` 类型。\n\n也就是说我们这个配置中心的dataId和我们平时用springboot命名配置文件只有一个prefix的区别\n\n现在我们来修改一下配置文件，bootstrap加一项：\n\n```properties\nspring.cloud.nacos.config.prefix=config-test\nspring.profiles.active=dev\n```\n\n配置中心弄两个配置方便比较，一个dataId是`config-test-dev.properties`，一个dataId是`config-test-prod.properties`配置端口号分别为8081和8082测试。启动项目后发现项目端口号为8081，然后修改配置重启：\n\n```properties\nspring.profiles.active=prod\n```\n\n此时端口变成了8082。用法和springboot的配置文件区别不大。\n\n### 命名空间和分组\n\n命名空间和分组相当于一个配置文件的\"年级和班次\"，在同一个group下，配置文件名不能重复，所以当需要创建文件名称相同的两个配置文件时，将两个配置文件创建在不同的group下即可。而namespace范围比group大，目的是一样的。\n\n定义命名空间方式如图\n\n![1556525537769](C:\\Users\\isock\\AppData\\Roaming\\Typora\\typora-user-images\\1556525537769.png)\n\n在bootstrap中对应配置\n\n```properties\nspring.cloud.nacos.config.namespace=命名空间ID\n```\n\n分组则在配置中心新建配置的时候可指定，在bootstrap中对应配置\n\n```properties\nspring.cloud.nacos.config.group=group\n```\n\n### 配置自动更新\n\n通过 Spring Cloud 原生注解 `@RefreshScope` 实现配置自动更新，示例：\n\n```java\n@Service\n@RefreshScope\npublic class ConfigController {\n\n    @Value(\"${config.test}\")\n    private String test;\n\tpublic void testStr(){\n        System.out.print(test)\n    }\n    \n}\n```\n\n当你在配置中心更新`config.test`的 客户端的test的值也会刷新，并且你还能在客户端看到值变更的相关日志。\n\n### 小结\n\n别的不说，这比spring cloud config好用太多了有木有，和apollo比起来配置太容易了有木有；这么好用的东西，出正式版了，等坑都排完了妥妥的神器有木有。我选nacos，你呢。\n\n## 作为注册中心\n\n### 介绍\n\n服务治理是微服务架构中最为核心和基础的模块。它主要用来实现各个微服务实例的自动化注册与发现。随着服务的越来越多，越来越杂，服务之间的调用会越来越复杂，越来越难以管理。而当某个服务发生了变化，或者由于压力性能问题，多部署了几台服务，怎么让服务的消费者知晓变化，就显得很重要了。不然就会存在调用的服务其实已经下线了，但调用者不知道等异常情况。这个时候有个服务组件去统一治理就相当重要了。注册中心便是做这个事情的，我们的服务上下线和发现服务都要依赖于注册中心。\n\nnacos注册中心有哪些特性呢？首先nacos从cap的角度来说，它能针对不同模式采用cp还是ap原则。然后它对服务发现的支持种类也有很多，比如：gRpc、Dubbo RpcService、Spring Cloud RESTful Service。并且ncos本身提供了很直观的注册中心管理界面。方便我们查看管理服务，其api也很丰富，我们完全可以在做二次开发去写一个我们自己满意的管理页面。Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。\n\n### 示例\n\n新建一个springboot项目，添加如下依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n            <version>0.9.0.RELEASE</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter</artifactId>\n            <version>2.1.1.RELEASE</version>\n        </dependency>\n```\n\n在启动类上加上`@EnableDiscoveryClient`注解\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class MytestApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MytestApplication.class, args);\n    }\n\n}\n```\n\napplication添加配置\n\n```properties\n\nserver.port=8081\nspring.application.name=service-mytest\nspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848\n```\n\n\n\n启动服务后，我们能看到nacos管理页面注册上了一个服务。点击查看详情：\n\n![1557666285270](C:\\Users\\isock\\AppData\\Roaming\\Typora\\typora-user-images\\1557666285270.png)\n\n列表上有一列是临时实例，临时实例通常使用AP一致性，因此如果发生网络分区，注册临时实例仍然有效。持久化实例使用CP一致性，这保证了数据的一致性。而持久化配置则是配置集群和数据库，本文不做介绍。后期搭建集群的时候我们在做测试。权重则是指调用服务时路由到该实例的优先系数，数字越大优先级越高，为0则不会使用该实例。\n\n# 总结\n\n我们能用nacos作为配置中心或者注册中心，其本身提供管理界面也很方便。nacos的使用企业也很多，下面放出一张github上nacos的使用企业截图：![1557667876620](C:\\Users\\isock\\AppData\\Roaming\\Typora\\typora-user-images\\1557667876620.png)\t\t\n\n官方文档还有提到nacos支持动态DNS，也就是说支持DNS的负载均衡，但本人没找到很好的资料，后续再做研究。关于nacos集群和持久化配置后续更新，感谢阅读。\n\n","source":"_posts/nacos.md","raw":"---\ntitle: 服务注册发现与配置中心新选择——nacos\ndate: 2019-04-27 10:17:48\ntags: cloud\n---\n\n### 编辑中\n\n\n\n# nacos简介\n\n​\t在nacos-0.3的时候我就开始关注，期间还写过一篇作为springcloud配置中心的使用记录的博客。在前不久，nacos终于出了正式版，赶个时髦出篇博客吹一波，[nacos官方文档](https://nacos.io/zh-cn/index.html)\n\n<!--more-->\n\n## nacos特性\n\n###  服务发现和服务健康监测\n\n支持基于 DNS 和基于 RPC 的服务发现（**可替代eureka**）。Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。\n\n### 动态配置服务\n\n动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置（**可以作为配置中心**）。动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。Nacos 提供了一个简洁易用的UI ([控制台样例 Demo](http://console.nacos.io/nacos/index.html)) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。\n\n### 动态 DNS 服务\n\n动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务（**可做负载均衡**）。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。\n\n### 服务及其元数据管理\n\nNacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据（**不知道啥意思，以后研究**）。\n\n## nacos的相关概念\n\n- 地域 （Region）：物理的数据中心，资源创建成功后不能更换。\n- 可用区（Available Zone）：同一地域内，电力和网络互相独立的物理区域。同一可用区内，实例的网络延迟较低。\n- 接入点（Endpoint）：地域的某个服务的入口域名。\n- 命名空间（Namespace）：用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。\n- 元信息(Metadata)：Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。\n- 实例（Instance）：提供一个或多个服务的具有可访问网络地址（IP:Port）的进程。\n- 权重（Weight）：实例级别的配置。权重为浮点数。权重越大，分配给该实例的流量越大。\n- 健康检测（Health Check）：以指定方式检查服务下挂载的实例 (Instance) 的健康度，从而确认该实例 (Instance) 是否能提供服务。根据检查结果，实例 (Instance) 会被判断为健康或不健康。对服务发起解析请求时，不健康的实例 (Instance) 不会返回给客户端。\n- 健康保护阈值（Protect Threshold）：为了防止因过多实例 (Instance) 不健康导致流量全部流向健康实例 (Instance) ，继而造成流量压力把健康 健康实例 (Instance) 压垮并形成雪崩效应，应将健康保护阈值定义为一个 0 到 1 之间的浮点数。当域名健康实例 (Instance) 占总服务实例 (Instance) 的比例小于该值时，无论实例 (Instance) 是否健康，都会将这个实例 (Instance) 返回给客户端。这样做虽然损失了一部分流量，但是保证了集群的剩余健康实例 (Instance) 能正常工作。\n- 服务分组（Service Group）：不同的服务可以归类到同一分组。\n- 虚拟集群（Virtual Cluster）：同一个服务下的所有服务实例组成一个默认集群, 集群可以被进一步按需求划分，划分的单位可以是虚拟集群。\n\n# nacos 使用\n\n## 安装\n\n可在github上下载安装包安装，或者采用docker安装；\n\nwindows上运行：[nacos github地址](<https://github.com/alibaba/nacos>) 在github查看该项目的releases并下载最新版，解压后进入bin目录 运行`startup.cmd`。\n\ndocker上运行：docker run --name nacos-standalone -e MODE=standalone -p 8848:8848 nacos/nacos-server:latest 可运行一个单机版nacos\n\n浏览器上访问 ip:8848/nacos 进入登陆界面，用户名和密码都是nacos；登陆成功就能看到控制台UI界面了。在安装包的./conf目录下有一个application.properties文件，这是nacos的配置文件，相关配置后期会说。\n\n## 作为配置中心\n\n### 示例\n\n这里为方便讲解，我们现在Windows环境下运行一个单机版nacos，启动后登陆；创建一个springboot应用，导入依赖\n\n```xml\n <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-alibaba-nacos-config</artifactId>\n    <version>0.9.0.RELEASE</version>\n </dependency>\n```\n\n然后删除application.properties 新建一个bootstrap.properties。这里可能还有同学不知道application和bootstrap的区别；在这里科普一下：在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application, bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。bootstrap比application要先加载，bootstrap只在cloud项目中使用。\n\n添加配置：\n\n```properties\n#服务名\nspring.application.name=nacos-config-example\n# 配置中心url\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848\n# 配置中心的配置语法\nspring.cloud.nacos.config.file-extension=properties\n```\n\n现在在nacos配置中心新建配置：\n\ndataId:nacos-config-example.properties\n\n![1556523308515](C:\\Users\\isock\\AppData\\Roaming\\Typora\\typora-user-images\\1556523308515.png)\n\n启动项目，发现项目端口号是8082，我们的配置成功了。\n\n### 说明\n\n注意 图中几个选项 TEXT\\JSON\\ XML \\YAML\\ HTML\\Propertiest这些并不是指定nacos以何种语法去解析配置文件，仅仅是提供语法提示，代码高亮辅助样式；第一次使用的人很容易被误导。我们要指定配置文件语法要在bootstrap做如下配置：\n\n```properties\nspring.cloud.nacos.config.file-extension=properties\nspring.cloud.nacos.config.file-extension=yaml\n```\n\n配置中心配置依靠dataId将配置信息和客户端绑定，我们来看看dataId组成规则：\n\n```java\n${prefix}-${spring.profile.active}.${file-extension}\n```\n\n- `prefix` 默认为 `spring.application.name` 的值，也可以通过配置项 `spring.cloud.nacos.config.prefix`来配置。\n\n- `spring.profile.active` 即为当前环境对应的 profile， **注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}**\n- `file-exetension` 为配置内容的数据格式，可以通过配置项 `spring.cloud.nacos.config.file-extension` 来配置。目前只支持 `properties` 和 `yaml` 类型。\n\n也就是说我们这个配置中心的dataId和我们平时用springboot命名配置文件只有一个prefix的区别\n\n现在我们来修改一下配置文件，bootstrap加一项：\n\n```properties\nspring.cloud.nacos.config.prefix=config-test\nspring.profiles.active=dev\n```\n\n配置中心弄两个配置方便比较，一个dataId是`config-test-dev.properties`，一个dataId是`config-test-prod.properties`配置端口号分别为8081和8082测试。启动项目后发现项目端口号为8081，然后修改配置重启：\n\n```properties\nspring.profiles.active=prod\n```\n\n此时端口变成了8082。用法和springboot的配置文件区别不大。\n\n### 命名空间和分组\n\n命名空间和分组相当于一个配置文件的\"年级和班次\"，在同一个group下，配置文件名不能重复，所以当需要创建文件名称相同的两个配置文件时，将两个配置文件创建在不同的group下即可。而namespace范围比group大，目的是一样的。\n\n定义命名空间方式如图\n\n![1556525537769](C:\\Users\\isock\\AppData\\Roaming\\Typora\\typora-user-images\\1556525537769.png)\n\n在bootstrap中对应配置\n\n```properties\nspring.cloud.nacos.config.namespace=命名空间ID\n```\n\n分组则在配置中心新建配置的时候可指定，在bootstrap中对应配置\n\n```properties\nspring.cloud.nacos.config.group=group\n```\n\n### 配置自动更新\n\n通过 Spring Cloud 原生注解 `@RefreshScope` 实现配置自动更新，示例：\n\n```java\n@Service\n@RefreshScope\npublic class ConfigController {\n\n    @Value(\"${config.test}\")\n    private String test;\n\tpublic void testStr(){\n        System.out.print(test)\n    }\n    \n}\n```\n\n当你在配置中心更新`config.test`的 客户端的test的值也会刷新，并且你还能在客户端看到值变更的相关日志。\n\n### 小结\n\n别的不说，这比spring cloud config好用太多了有木有，和apollo比起来配置太容易了有木有；这么好用的东西，出正式版了，等坑都排完了妥妥的神器有木有。我选nacos，你呢。\n\n## 作为注册中心\n\n### 介绍\n\n服务治理是微服务架构中最为核心和基础的模块。它主要用来实现各个微服务实例的自动化注册与发现。随着服务的越来越多，越来越杂，服务之间的调用会越来越复杂，越来越难以管理。而当某个服务发生了变化，或者由于压力性能问题，多部署了几台服务，怎么让服务的消费者知晓变化，就显得很重要了。不然就会存在调用的服务其实已经下线了，但调用者不知道等异常情况。这个时候有个服务组件去统一治理就相当重要了。注册中心便是做这个事情的，我们的服务上下线和发现服务都要依赖于注册中心。\n\nnacos注册中心有哪些特性呢？首先nacos从cap的角度来说，它能针对不同模式采用cp还是ap原则。然后它对服务发现的支持种类也有很多，比如：gRpc、Dubbo RpcService、Spring Cloud RESTful Service。并且ncos本身提供了很直观的注册中心管理界面。方便我们查看管理服务，其api也很丰富，我们完全可以在做二次开发去写一个我们自己满意的管理页面。Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。\n\n### 示例\n\n新建一个springboot项目，添加如下依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n            <version>0.9.0.RELEASE</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter</artifactId>\n            <version>2.1.1.RELEASE</version>\n        </dependency>\n```\n\n在启动类上加上`@EnableDiscoveryClient`注解\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class MytestApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MytestApplication.class, args);\n    }\n\n}\n```\n\napplication添加配置\n\n```properties\n\nserver.port=8081\nspring.application.name=service-mytest\nspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848\n```\n\n\n\n启动服务后，我们能看到nacos管理页面注册上了一个服务。点击查看详情：\n\n![1557666285270](C:\\Users\\isock\\AppData\\Roaming\\Typora\\typora-user-images\\1557666285270.png)\n\n列表上有一列是临时实例，临时实例通常使用AP一致性，因此如果发生网络分区，注册临时实例仍然有效。持久化实例使用CP一致性，这保证了数据的一致性。而持久化配置则是配置集群和数据库，本文不做介绍。后期搭建集群的时候我们在做测试。权重则是指调用服务时路由到该实例的优先系数，数字越大优先级越高，为0则不会使用该实例。\n\n# 总结\n\n我们能用nacos作为配置中心或者注册中心，其本身提供管理界面也很方便。nacos的使用企业也很多，下面放出一张github上nacos的使用企业截图：![1557667876620](C:\\Users\\isock\\AppData\\Roaming\\Typora\\typora-user-images\\1557667876620.png)\t\t\n\n官方文档还有提到nacos支持动态DNS，也就是说支持DNS的负载均衡，但本人没找到很好的资料，后续再做研究。关于nacos集群和持久化配置后续更新，感谢阅读。\n\n","slug":"nacos","published":1,"updated":"2021-01-11T07:31:23.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6h002j00wiacpm5luw","content":"<h3 id=\"编辑中\"><a href=\"#编辑中\" class=\"headerlink\" title=\"编辑中\"></a>编辑中</h3><h1 id=\"nacos简介\"><a href=\"#nacos简介\" class=\"headerlink\" title=\"nacos简介\"></a>nacos简介</h1><p>​    在nacos-0.3的时候我就开始关注，期间还写过一篇作为springcloud配置中心的使用记录的博客。在前不久，nacos终于出了正式版，赶个时髦出篇博客吹一波，<a href=\"https://nacos.io/zh-cn/index.html\">nacos官方文档</a></p>\n<a id=\"more\"></a>\n\n<h2 id=\"nacos特性\"><a href=\"#nacos特性\" class=\"headerlink\" title=\"nacos特性\"></a>nacos特性</h2><h3 id=\"服务发现和服务健康监测\"><a href=\"#服务发现和服务健康监测\" class=\"headerlink\" title=\"服务发现和服务健康监测\"></a>服务发现和服务健康监测</h3><p>支持基于 DNS 和基于 RPC 的服务发现（<strong>可替代eureka</strong>）。Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</p>\n<h3 id=\"动态配置服务\"><a href=\"#动态配置服务\" class=\"headerlink\" title=\"动态配置服务\"></a>动态配置服务</h3><p>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置（<strong>可以作为配置中心</strong>）。动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。Nacos 提供了一个简洁易用的UI (<a href=\"http://console.nacos.io/nacos/index.html\">控制台样例 Demo</a>) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。</p>\n<h3 id=\"动态-DNS-服务\"><a href=\"#动态-DNS-服务\" class=\"headerlink\" title=\"动态 DNS 服务\"></a>动态 DNS 服务</h3><p>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务（<strong>可做负载均衡</strong>）。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。</p>\n<h3 id=\"服务及其元数据管理\"><a href=\"#服务及其元数据管理\" class=\"headerlink\" title=\"服务及其元数据管理\"></a>服务及其元数据管理</h3><p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据（<strong>不知道啥意思，以后研究</strong>）。</p>\n<h2 id=\"nacos的相关概念\"><a href=\"#nacos的相关概念\" class=\"headerlink\" title=\"nacos的相关概念\"></a>nacos的相关概念</h2><ul>\n<li>地域 （Region）：物理的数据中心，资源创建成功后不能更换。</li>\n<li>可用区（Available Zone）：同一地域内，电力和网络互相独立的物理区域。同一可用区内，实例的网络延迟较低。</li>\n<li>接入点（Endpoint）：地域的某个服务的入口域名。</li>\n<li>命名空间（Namespace）：用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</li>\n<li>元信息(Metadata)：Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。</li>\n<li>实例（Instance）：提供一个或多个服务的具有可访问网络地址（IP:Port）的进程。</li>\n<li>权重（Weight）：实例级别的配置。权重为浮点数。权重越大，分配给该实例的流量越大。</li>\n<li>健康检测（Health Check）：以指定方式检查服务下挂载的实例 (Instance) 的健康度，从而确认该实例 (Instance) 是否能提供服务。根据检查结果，实例 (Instance) 会被判断为健康或不健康。对服务发起解析请求时，不健康的实例 (Instance) 不会返回给客户端。</li>\n<li>健康保护阈值（Protect Threshold）：为了防止因过多实例 (Instance) 不健康导致流量全部流向健康实例 (Instance) ，继而造成流量压力把健康 健康实例 (Instance) 压垮并形成雪崩效应，应将健康保护阈值定义为一个 0 到 1 之间的浮点数。当域名健康实例 (Instance) 占总服务实例 (Instance) 的比例小于该值时，无论实例 (Instance) 是否健康，都会将这个实例 (Instance) 返回给客户端。这样做虽然损失了一部分流量，但是保证了集群的剩余健康实例 (Instance) 能正常工作。</li>\n<li>服务分组（Service Group）：不同的服务可以归类到同一分组。</li>\n<li>虚拟集群（Virtual Cluster）：同一个服务下的所有服务实例组成一个默认集群, 集群可以被进一步按需求划分，划分的单位可以是虚拟集群。</li>\n</ul>\n<h1 id=\"nacos-使用\"><a href=\"#nacos-使用\" class=\"headerlink\" title=\"nacos 使用\"></a>nacos 使用</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>可在github上下载安装包安装，或者采用docker安装；</p>\n<p>windows上运行：<a href=\"https://github.com/alibaba/nacos\">nacos github地址</a> 在github查看该项目的releases并下载最新版，解压后进入bin目录 运行<code>startup.cmd</code>。</p>\n<p>docker上运行：docker run –name nacos-standalone -e MODE=standalone -p 8848:8848 nacos/nacos-server:latest 可运行一个单机版nacos</p>\n<p>浏览器上访问 ip:8848/nacos 进入登陆界面，用户名和密码都是nacos；登陆成功就能看到控制台UI界面了。在安装包的./conf目录下有一个application.properties文件，这是nacos的配置文件，相关配置后期会说。</p>\n<h2 id=\"作为配置中心\"><a href=\"#作为配置中心\" class=\"headerlink\" title=\"作为配置中心\"></a>作为配置中心</h2><h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>这里为方便讲解，我们现在Windows环境下运行一个单机版nacos，启动后登陆；创建一个springboot应用，导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-alibaba-nacos-config<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.9.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后删除application.properties 新建一个bootstrap.properties。这里可能还有同学不知道application和bootstrap的区别；在这里科普一下：在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application, bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。bootstrap比application要先加载，bootstrap只在cloud项目中使用。</p>\n<p>添加配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#服务名</span></span><br><span class=\"line\"><span class=\"meta\">spring.application.name</span>=<span class=\"string\">nacos-config-example</span></span><br><span class=\"line\"><span class=\"comment\"># 配置中心url</span></span><br><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.server-addr</span>=<span class=\"string\">127.0.0.1:8848</span></span><br><span class=\"line\"><span class=\"comment\"># 配置中心的配置语法</span></span><br><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.file-extension</span>=<span class=\"string\">properties</span></span><br></pre></td></tr></table></figure>\n<p>现在在nacos配置中心新建配置：</p>\n<p>dataId:nacos-config-example.properties</p>\n<p><img src=\"C:%5CUsers%5Cisock%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1556523308515.png\" alt=\"1556523308515\"></p>\n<p>启动项目，发现项目端口号是8082，我们的配置成功了。</p>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>注意 图中几个选项 TEXT\\JSON\\ XML \\YAML\\ HTML\\Propertiest这些并不是指定nacos以何种语法去解析配置文件，仅仅是提供语法提示，代码高亮辅助样式；第一次使用的人很容易被误导。我们要指定配置文件语法要在bootstrap做如下配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.file-extension</span>=<span class=\"string\">properties</span></span><br><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.file-extension</span>=<span class=\"string\">yaml</span></span><br></pre></td></tr></table></figure>\n<p>配置中心配置依靠dataId将配置信息和客户端绑定，我们来看看dataId组成规则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</p>\n</li>\n<li><p><code>spring.profile.active</code> 即为当前环境对应的 profile， <strong>注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}</strong></p>\n</li>\n<li><p><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</p>\n</li>\n</ul>\n<p>也就是说我们这个配置中心的dataId和我们平时用springboot命名配置文件只有一个prefix的区别</p>\n<p>现在我们来修改一下配置文件，bootstrap加一项：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.prefix</span>=<span class=\"string\">config-test</span></span><br><span class=\"line\"><span class=\"meta\">spring.profiles.active</span>=<span class=\"string\">dev</span></span><br></pre></td></tr></table></figure>\n<p>配置中心弄两个配置方便比较，一个dataId是<code>config-test-dev.properties</code>，一个dataId是<code>config-test-prod.properties</code>配置端口号分别为8081和8082测试。启动项目后发现项目端口号为8081，然后修改配置重启：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.profiles.active</span>=<span class=\"string\">prod</span></span><br></pre></td></tr></table></figure>\n<p>此时端口变成了8082。用法和springboot的配置文件区别不大。</p>\n<h3 id=\"命名空间和分组\"><a href=\"#命名空间和分组\" class=\"headerlink\" title=\"命名空间和分组\"></a>命名空间和分组</h3><p>命名空间和分组相当于一个配置文件的”年级和班次”，在同一个group下，配置文件名不能重复，所以当需要创建文件名称相同的两个配置文件时，将两个配置文件创建在不同的group下即可。而namespace范围比group大，目的是一样的。</p>\n<p>定义命名空间方式如图</p>\n<p><img src=\"C:%5CUsers%5Cisock%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1556525537769.png\" alt=\"1556525537769\"></p>\n<p>在bootstrap中对应配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.namespace</span>=<span class=\"string\">命名空间ID</span></span><br></pre></td></tr></table></figure>\n<p>分组则在配置中心新建配置的时候可指定，在bootstrap中对应配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.group</span>=<span class=\"string\">group</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"配置自动更新\"><a href=\"#配置自动更新\" class=\"headerlink\" title=\"配置自动更新\"></a>配置自动更新</h3><p>通过 Spring Cloud 原生注解 <code>@RefreshScope</code> 实现配置自动更新，示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@RefreshScope</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConfigController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;config.test&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String test;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testStr</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.print(test)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你在配置中心更新<code>config.test</code>的 客户端的test的值也会刷新，并且你还能在客户端看到值变更的相关日志。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>别的不说，这比spring cloud config好用太多了有木有，和apollo比起来配置太容易了有木有；这么好用的东西，出正式版了，等坑都排完了妥妥的神器有木有。我选nacos，你呢。</p>\n<h2 id=\"作为注册中心\"><a href=\"#作为注册中心\" class=\"headerlink\" title=\"作为注册中心\"></a>作为注册中心</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>服务治理是微服务架构中最为核心和基础的模块。它主要用来实现各个微服务实例的自动化注册与发现。随着服务的越来越多，越来越杂，服务之间的调用会越来越复杂，越来越难以管理。而当某个服务发生了变化，或者由于压力性能问题，多部署了几台服务，怎么让服务的消费者知晓变化，就显得很重要了。不然就会存在调用的服务其实已经下线了，但调用者不知道等异常情况。这个时候有个服务组件去统一治理就相当重要了。注册中心便是做这个事情的，我们的服务上下线和发现服务都要依赖于注册中心。</p>\n<p>nacos注册中心有哪些特性呢？首先nacos从cap的角度来说，它能针对不同模式采用cp还是ap原则。然后它对服务发现的支持种类也有很多，比如：gRpc、Dubbo RpcService、Spring Cloud RESTful Service。并且ncos本身提供了很直观的注册中心管理界面。方便我们查看管理服务，其api也很丰富，我们完全可以在做二次开发去写一个我们自己满意的管理页面。Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>新建一个springboot项目，添加如下依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.9.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.1.1.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在启动类上加上<code>@EnableDiscoveryClient</code>注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MytestApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(MytestApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>application添加配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">server.port</span>=<span class=\"string\">8081</span></span><br><span class=\"line\"><span class=\"meta\">spring.application.name</span>=<span class=\"string\">service-mytest</span></span><br><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.discovery.server-addr</span>=<span class=\"string\">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure>\n\n\n<p>启动服务后，我们能看到nacos管理页面注册上了一个服务。点击查看详情：</p>\n<p><img src=\"C:%5CUsers%5Cisock%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557666285270.png\" alt=\"1557666285270\"></p>\n<p>列表上有一列是临时实例，临时实例通常使用AP一致性，因此如果发生网络分区，注册临时实例仍然有效。持久化实例使用CP一致性，这保证了数据的一致性。而持久化配置则是配置集群和数据库，本文不做介绍。后期搭建集群的时候我们在做测试。权重则是指调用服务时路由到该实例的优先系数，数字越大优先级越高，为0则不会使用该实例。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>我们能用nacos作为配置中心或者注册中心，其本身提供管理界面也很方便。nacos的使用企业也很多，下面放出一张github上nacos的使用企业截图：<img src=\"C:%5CUsers%5Cisock%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557667876620.png\" alt=\"1557667876620\">        </p>\n<p>官方文档还有提到nacos支持动态DNS，也就是说支持DNS的负载均衡，但本人没找到很好的资料，后续再做研究。关于nacos集群和持久化配置后续更新，感谢阅读。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"编辑中\"><a href=\"#编辑中\" class=\"headerlink\" title=\"编辑中\"></a>编辑中</h3><h1 id=\"nacos简介\"><a href=\"#nacos简介\" class=\"headerlink\" title=\"nacos简介\"></a>nacos简介</h1><p>​    在nacos-0.3的时候我就开始关注，期间还写过一篇作为springcloud配置中心的使用记录的博客。在前不久，nacos终于出了正式版，赶个时髦出篇博客吹一波，<a href=\"https://nacos.io/zh-cn/index.html\">nacos官方文档</a></p>","more":"<h2 id=\"nacos特性\"><a href=\"#nacos特性\" class=\"headerlink\" title=\"nacos特性\"></a>nacos特性</h2><h3 id=\"服务发现和服务健康监测\"><a href=\"#服务发现和服务健康监测\" class=\"headerlink\" title=\"服务发现和服务健康监测\"></a>服务发现和服务健康监测</h3><p>支持基于 DNS 和基于 RPC 的服务发现（<strong>可替代eureka</strong>）。Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</p>\n<h3 id=\"动态配置服务\"><a href=\"#动态配置服务\" class=\"headerlink\" title=\"动态配置服务\"></a>动态配置服务</h3><p>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置（<strong>可以作为配置中心</strong>）。动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。Nacos 提供了一个简洁易用的UI (<a href=\"http://console.nacos.io/nacos/index.html\">控制台样例 Demo</a>) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。</p>\n<h3 id=\"动态-DNS-服务\"><a href=\"#动态-DNS-服务\" class=\"headerlink\" title=\"动态 DNS 服务\"></a>动态 DNS 服务</h3><p>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务（<strong>可做负载均衡</strong>）。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。</p>\n<h3 id=\"服务及其元数据管理\"><a href=\"#服务及其元数据管理\" class=\"headerlink\" title=\"服务及其元数据管理\"></a>服务及其元数据管理</h3><p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据（<strong>不知道啥意思，以后研究</strong>）。</p>\n<h2 id=\"nacos的相关概念\"><a href=\"#nacos的相关概念\" class=\"headerlink\" title=\"nacos的相关概念\"></a>nacos的相关概念</h2><ul>\n<li>地域 （Region）：物理的数据中心，资源创建成功后不能更换。</li>\n<li>可用区（Available Zone）：同一地域内，电力和网络互相独立的物理区域。同一可用区内，实例的网络延迟较低。</li>\n<li>接入点（Endpoint）：地域的某个服务的入口域名。</li>\n<li>命名空间（Namespace）：用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</li>\n<li>元信息(Metadata)：Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。</li>\n<li>实例（Instance）：提供一个或多个服务的具有可访问网络地址（IP:Port）的进程。</li>\n<li>权重（Weight）：实例级别的配置。权重为浮点数。权重越大，分配给该实例的流量越大。</li>\n<li>健康检测（Health Check）：以指定方式检查服务下挂载的实例 (Instance) 的健康度，从而确认该实例 (Instance) 是否能提供服务。根据检查结果，实例 (Instance) 会被判断为健康或不健康。对服务发起解析请求时，不健康的实例 (Instance) 不会返回给客户端。</li>\n<li>健康保护阈值（Protect Threshold）：为了防止因过多实例 (Instance) 不健康导致流量全部流向健康实例 (Instance) ，继而造成流量压力把健康 健康实例 (Instance) 压垮并形成雪崩效应，应将健康保护阈值定义为一个 0 到 1 之间的浮点数。当域名健康实例 (Instance) 占总服务实例 (Instance) 的比例小于该值时，无论实例 (Instance) 是否健康，都会将这个实例 (Instance) 返回给客户端。这样做虽然损失了一部分流量，但是保证了集群的剩余健康实例 (Instance) 能正常工作。</li>\n<li>服务分组（Service Group）：不同的服务可以归类到同一分组。</li>\n<li>虚拟集群（Virtual Cluster）：同一个服务下的所有服务实例组成一个默认集群, 集群可以被进一步按需求划分，划分的单位可以是虚拟集群。</li>\n</ul>\n<h1 id=\"nacos-使用\"><a href=\"#nacos-使用\" class=\"headerlink\" title=\"nacos 使用\"></a>nacos 使用</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>可在github上下载安装包安装，或者采用docker安装；</p>\n<p>windows上运行：<a href=\"https://github.com/alibaba/nacos\">nacos github地址</a> 在github查看该项目的releases并下载最新版，解压后进入bin目录 运行<code>startup.cmd</code>。</p>\n<p>docker上运行：docker run –name nacos-standalone -e MODE=standalone -p 8848:8848 nacos/nacos-server:latest 可运行一个单机版nacos</p>\n<p>浏览器上访问 ip:8848/nacos 进入登陆界面，用户名和密码都是nacos；登陆成功就能看到控制台UI界面了。在安装包的./conf目录下有一个application.properties文件，这是nacos的配置文件，相关配置后期会说。</p>\n<h2 id=\"作为配置中心\"><a href=\"#作为配置中心\" class=\"headerlink\" title=\"作为配置中心\"></a>作为配置中心</h2><h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>这里为方便讲解，我们现在Windows环境下运行一个单机版nacos，启动后登陆；创建一个springboot应用，导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-alibaba-nacos-config<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.9.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后删除application.properties 新建一个bootstrap.properties。这里可能还有同学不知道application和bootstrap的区别；在这里科普一下：在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application, bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。bootstrap比application要先加载，bootstrap只在cloud项目中使用。</p>\n<p>添加配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#服务名</span></span><br><span class=\"line\"><span class=\"meta\">spring.application.name</span>=<span class=\"string\">nacos-config-example</span></span><br><span class=\"line\"><span class=\"comment\"># 配置中心url</span></span><br><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.server-addr</span>=<span class=\"string\">127.0.0.1:8848</span></span><br><span class=\"line\"><span class=\"comment\"># 配置中心的配置语法</span></span><br><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.file-extension</span>=<span class=\"string\">properties</span></span><br></pre></td></tr></table></figure>\n<p>现在在nacos配置中心新建配置：</p>\n<p>dataId:nacos-config-example.properties</p>\n<p><img src=\"C:%5CUsers%5Cisock%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1556523308515.png\" alt=\"1556523308515\"></p>\n<p>启动项目，发现项目端口号是8082，我们的配置成功了。</p>\n<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><p>注意 图中几个选项 TEXT\\JSON\\ XML \\YAML\\ HTML\\Propertiest这些并不是指定nacos以何种语法去解析配置文件，仅仅是提供语法提示，代码高亮辅助样式；第一次使用的人很容易被误导。我们要指定配置文件语法要在bootstrap做如下配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.file-extension</span>=<span class=\"string\">properties</span></span><br><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.file-extension</span>=<span class=\"string\">yaml</span></span><br></pre></td></tr></table></figure>\n<p>配置中心配置依靠dataId将配置信息和客户端绑定，我们来看看dataId组成规则：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</p>\n</li>\n<li><p><code>spring.profile.active</code> 即为当前环境对应的 profile， <strong>注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}</strong></p>\n</li>\n<li><p><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</p>\n</li>\n</ul>\n<p>也就是说我们这个配置中心的dataId和我们平时用springboot命名配置文件只有一个prefix的区别</p>\n<p>现在我们来修改一下配置文件，bootstrap加一项：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.prefix</span>=<span class=\"string\">config-test</span></span><br><span class=\"line\"><span class=\"meta\">spring.profiles.active</span>=<span class=\"string\">dev</span></span><br></pre></td></tr></table></figure>\n<p>配置中心弄两个配置方便比较，一个dataId是<code>config-test-dev.properties</code>，一个dataId是<code>config-test-prod.properties</code>配置端口号分别为8081和8082测试。启动项目后发现项目端口号为8081，然后修改配置重启：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.profiles.active</span>=<span class=\"string\">prod</span></span><br></pre></td></tr></table></figure>\n<p>此时端口变成了8082。用法和springboot的配置文件区别不大。</p>\n<h3 id=\"命名空间和分组\"><a href=\"#命名空间和分组\" class=\"headerlink\" title=\"命名空间和分组\"></a>命名空间和分组</h3><p>命名空间和分组相当于一个配置文件的”年级和班次”，在同一个group下，配置文件名不能重复，所以当需要创建文件名称相同的两个配置文件时，将两个配置文件创建在不同的group下即可。而namespace范围比group大，目的是一样的。</p>\n<p>定义命名空间方式如图</p>\n<p><img src=\"C:%5CUsers%5Cisock%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1556525537769.png\" alt=\"1556525537769\"></p>\n<p>在bootstrap中对应配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.namespace</span>=<span class=\"string\">命名空间ID</span></span><br></pre></td></tr></table></figure>\n<p>分组则在配置中心新建配置的时候可指定，在bootstrap中对应配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.config.group</span>=<span class=\"string\">group</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"配置自动更新\"><a href=\"#配置自动更新\" class=\"headerlink\" title=\"配置自动更新\"></a>配置自动更新</h3><p>通过 Spring Cloud 原生注解 <code>@RefreshScope</code> 实现配置自动更新，示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@RefreshScope</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConfigController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;config.test&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String test;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testStr</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.print(test)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你在配置中心更新<code>config.test</code>的 客户端的test的值也会刷新，并且你还能在客户端看到值变更的相关日志。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>别的不说，这比spring cloud config好用太多了有木有，和apollo比起来配置太容易了有木有；这么好用的东西，出正式版了，等坑都排完了妥妥的神器有木有。我选nacos，你呢。</p>\n<h2 id=\"作为注册中心\"><a href=\"#作为注册中心\" class=\"headerlink\" title=\"作为注册中心\"></a>作为注册中心</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>服务治理是微服务架构中最为核心和基础的模块。它主要用来实现各个微服务实例的自动化注册与发现。随着服务的越来越多，越来越杂，服务之间的调用会越来越复杂，越来越难以管理。而当某个服务发生了变化，或者由于压力性能问题，多部署了几台服务，怎么让服务的消费者知晓变化，就显得很重要了。不然就会存在调用的服务其实已经下线了，但调用者不知道等异常情况。这个时候有个服务组件去统一治理就相当重要了。注册中心便是做这个事情的，我们的服务上下线和发现服务都要依赖于注册中心。</p>\n<p>nacos注册中心有哪些特性呢？首先nacos从cap的角度来说，它能针对不同模式采用cp还是ap原则。然后它对服务发现的支持种类也有很多，比如：gRpc、Dubbo RpcService、Spring Cloud RESTful Service。并且ncos本身提供了很直观的注册中心管理界面。方便我们查看管理服务，其api也很丰富，我们完全可以在做二次开发去写一个我们自己满意的管理页面。Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>新建一个springboot项目，添加如下依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.9.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.1.1.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在启动类上加上<code>@EnableDiscoveryClient</code>注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MytestApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(MytestApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>application添加配置</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">server.port</span>=<span class=\"string\">8081</span></span><br><span class=\"line\"><span class=\"meta\">spring.application.name</span>=<span class=\"string\">service-mytest</span></span><br><span class=\"line\"><span class=\"meta\">spring.cloud.nacos.discovery.server-addr</span>=<span class=\"string\">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure>\n\n\n<p>启动服务后，我们能看到nacos管理页面注册上了一个服务。点击查看详情：</p>\n<p><img src=\"C:%5CUsers%5Cisock%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557666285270.png\" alt=\"1557666285270\"></p>\n<p>列表上有一列是临时实例，临时实例通常使用AP一致性，因此如果发生网络分区，注册临时实例仍然有效。持久化实例使用CP一致性，这保证了数据的一致性。而持久化配置则是配置集群和数据库，本文不做介绍。后期搭建集群的时候我们在做测试。权重则是指调用服务时路由到该实例的优先系数，数字越大优先级越高，为0则不会使用该实例。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>我们能用nacos作为配置中心或者注册中心，其本身提供管理界面也很方便。nacos的使用企业也很多，下面放出一张github上nacos的使用企业截图：<img src=\"C:%5CUsers%5Cisock%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557667876620.png\" alt=\"1557667876620\">        </p>\n<p>官方文档还有提到nacos支持动态DNS，也就是说支持DNS的负载均衡，但本人没找到很好的资料，后续再做研究。关于nacos集群和持久化配置后续更新，感谢阅读。</p>"},{"title":" netty学习笔记第一篇","date":"2019-04-01T10:02:04.000Z","_content":"\n作者：muggle\n\nnetty框架代码很猛（读源码有益身心健康），学习起来也比较难；在阅读这篇文章我假设你有了一定nio基础，tcp网络协议基础，否则不建议阅读。\n\n关于netty的学习视频我推荐B站张龙的教学视频，讲的很不错。学netty之前先学会用，然后在去看他的原理这样学起来会轻松不少。\n\n<!--more-->\n\n### http demo\n\n用netty实现一个http服务端\n\n编写main函数\n\n```java\npublic class TestNetty {\n    public static void main(String[] args) throws InterruptedException {\n//        事件循环组 接收连接，将连接发送给work\n        NioEventLoopGroup bossGroup = new NioEventLoopGroup();\n//        work 干活\n        NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n//      简化服务端启动\n        ServerBootstrap serverBootstrap=new ServerBootstrap();\n//                     打开通道                                               子处理器 服务端初始化器\n  serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new TestServerInitlizer());、\n      // 绑定接口\n        final ChannelFuture sync = serverBootstrap.bind(8081).sync();\n        sync.channel().closeFuture().sync();\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n}\n\n```\n\n编写初始化器\n\n```java\n// 初始化器 channel注册好之后 自动创建 执行代码\npublic class TestServerInitlizer extends ChannelInitializer<SocketChannel> {\n    @Override\n    protected void initChannel(SocketChannel socketChannel) throws Exception {\n        final ChannelPipeline pipeline = socketChannel.pipeline();\n//        对web响应编解码\n        pipeline.addLast(\"httpserverCodec\",new HttpServerCodec());\n//        起名加入管道  自己的处理器\n        pipeline.addLast(\"testHttpResponse\",new TestHttpServerHandler());\n    }\n}\n```\n\n编写数据处理器\n\n```java\npublic class TestHttpServerHandler extends SimpleChannelInboundHandler<HttpObject> {\n//    构造一个Http响应\n    @Override\n    protected void channelRead0(ChannelHandlerContext channelHandlerContext, HttpObject httpObject) throws Exception {\n        System.out.println(\"请求读取处理4\");\n        ByteBuf buffer=Unpooled.copiedBuffer(\"<!DOCTYPE html>\\n\" +\n                \"<html lang=\\\"en\\\">\\n\" +\n                \"<head>\\n\" +\n                \"    <meta charset=\\\"UTF-8\\\">\\n\" +\n                \"    <title>Title</title>\\n\" +\n                \"</head>\\n\" +\n                \"<body>\\n\" +\n                \"<h1>这是一个Netty构造的http响应</h1>\\n\" +\n                \"</body>\\n\" +\n                \"</html>\", CharsetUtil.UTF_8);\n        FullHttpResponse response=new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK,buffer);\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE,\"text/html\");\n        response.headers().set(HttpHeaderNames.CONTENT_LENGTH,buffer.readableBytes());\n        channelHandlerContext.writeAndFlush(response);\n       channelHandlerContext.close();\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(\"通道处于活动状态 3\");\n        super.channelActive(ctx);\n    }\n\n    @Override\n    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(\"通道注册 2\");\n        super.channelRegistered(ctx);\n    }\n\n    @Override\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(\"处理器添加 1\");\n        super.handlerAdded(ctx);\n    }\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(\"通道数据进入5\");\n        super.channelInactive(ctx);\n    }\n\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(\"通道取消注册6\");\n        super.channelUnregistered(ctx);\n    }\n}\n```\n\n说明：\n\n我们来看一下构造一个http服务端，都需要干些啥。\n\n在main函数中，我们创建了两个线程组`NioEventLoopGroup`，boss线程组负责接收请求，work线程组负责处理请求。`ServerBootstrap`服务端配置辅助器进行服务端配置，绑定端口号。\n\n初始化器`ChannelInitializer<SocketChannel>`对管道设置各种处理器，数据处理器`SimpleChannelInboundHandler<HttpObject>` 的`channelRead0`方法处理数据，调用`channelHandlerContext.writeAndFlush` 将数据写入通道，其他重写的方法看代码便能知道是干嘛的\n\n### socket demo\n\nsocket连接步骤大同小异\n\n编写server的main函数\n\n```java\npublic static void main(String[] args) {\n        EventLoopGroup boss=new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.group(boss,worker).channel(NioServerSocketChannel.class).childHandler(new MyServerInitializer());\n            ChannelFuture sync = serverBootstrap.bind(8081).sync();\n            sync.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n```\n\n编写初始化器\n\n```java\npublic class MyServerInitializer extends ChannelInitializer<SocketChannel> {\n    @Override\n    protected void initChannel(SocketChannel socketChannel) throws Exception {\n        ChannelPipeline pipeline = socketChannel.pipeline();\n//        jia 一堆处理器 策略模式\n        pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));\n        pipeline.addLast(new LengthFieldPrepender(4));\n        pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));\n        pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));\n        pipeline.addLast(new MyserverHandler());\n    }\n}\n```\n\n编写数据处理器\n\n```jav\n\npublic class MyserverHandler extends SimpleChannelInboundHandler<String> {\n    private static ChannelGroup group=new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n//    处理方法\n    protected void channelRead0(ChannelHandlerContext ctx, String s) throws Exception {\n        Channel channel = ctx.channel();\n        group.writeAndFlush(ctx.channel().remoteAddress()+\">>>>\"+s);\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        cause.printStackTrace();\n\n        ctx.close();\n    }\n\n    @Override\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        Channel channel = ctx.channel();\n        group.writeAndFlush(channel.remoteAddress()+\"连接地址》》》》》》》\");\n        group.add(channel);\n    }\n\n    @Override\n    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n        Channel channel = ctx.channel();\n        group.writeAndFlush(channel.remoteAddress()+\"断开连接》》》》》》》\");\n    }\n}\n```\n\n编写client 的main\n\n```java\n public static void main(String[] args) {\n        EventLoopGroup boss = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(boss).channel(NioSocketChannel.class).handler(new MyClientInitializer());\n            ChannelFuture sync = bootstrap.connect(\"127.0.0.1\",8081).sync();\n            Channel channel = sync.channel();\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n            while (true){\n                channel.writeAndFlush(bufferedReader.readLine());\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            boss.shutdownGracefully();\n        }\n    }\n```\n\n其他和服务端一样，所以略；\n\n服务端启动类`serverBootstrap.bind(8081).sync()` 而客户端启动类配置是` ChannelFuture sync = bootstrap.connect(\"127.0.0.1\",8081).sync();`区别就在这里\n\n### websocket demo\n\n[github](<https://github.com/muggle0/learn/tree/all>) netty模块 下有所有代码\n\n","source":"_posts/netty学习笔记.md","raw":"---\ntitle: ' netty学习笔记第一篇'\ndate: 2019-04-01 18:02:04\ntags: netty\n---\n\n作者：muggle\n\nnetty框架代码很猛（读源码有益身心健康），学习起来也比较难；在阅读这篇文章我假设你有了一定nio基础，tcp网络协议基础，否则不建议阅读。\n\n关于netty的学习视频我推荐B站张龙的教学视频，讲的很不错。学netty之前先学会用，然后在去看他的原理这样学起来会轻松不少。\n\n<!--more-->\n\n### http demo\n\n用netty实现一个http服务端\n\n编写main函数\n\n```java\npublic class TestNetty {\n    public static void main(String[] args) throws InterruptedException {\n//        事件循环组 接收连接，将连接发送给work\n        NioEventLoopGroup bossGroup = new NioEventLoopGroup();\n//        work 干活\n        NioEventLoopGroup workerGroup = new NioEventLoopGroup();\n//      简化服务端启动\n        ServerBootstrap serverBootstrap=new ServerBootstrap();\n//                     打开通道                                               子处理器 服务端初始化器\n  serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new TestServerInitlizer());、\n      // 绑定接口\n        final ChannelFuture sync = serverBootstrap.bind(8081).sync();\n        sync.channel().closeFuture().sync();\n        bossGroup.shutdownGracefully();\n        workerGroup.shutdownGracefully();\n    }\n}\n\n```\n\n编写初始化器\n\n```java\n// 初始化器 channel注册好之后 自动创建 执行代码\npublic class TestServerInitlizer extends ChannelInitializer<SocketChannel> {\n    @Override\n    protected void initChannel(SocketChannel socketChannel) throws Exception {\n        final ChannelPipeline pipeline = socketChannel.pipeline();\n//        对web响应编解码\n        pipeline.addLast(\"httpserverCodec\",new HttpServerCodec());\n//        起名加入管道  自己的处理器\n        pipeline.addLast(\"testHttpResponse\",new TestHttpServerHandler());\n    }\n}\n```\n\n编写数据处理器\n\n```java\npublic class TestHttpServerHandler extends SimpleChannelInboundHandler<HttpObject> {\n//    构造一个Http响应\n    @Override\n    protected void channelRead0(ChannelHandlerContext channelHandlerContext, HttpObject httpObject) throws Exception {\n        System.out.println(\"请求读取处理4\");\n        ByteBuf buffer=Unpooled.copiedBuffer(\"<!DOCTYPE html>\\n\" +\n                \"<html lang=\\\"en\\\">\\n\" +\n                \"<head>\\n\" +\n                \"    <meta charset=\\\"UTF-8\\\">\\n\" +\n                \"    <title>Title</title>\\n\" +\n                \"</head>\\n\" +\n                \"<body>\\n\" +\n                \"<h1>这是一个Netty构造的http响应</h1>\\n\" +\n                \"</body>\\n\" +\n                \"</html>\", CharsetUtil.UTF_8);\n        FullHttpResponse response=new DefaultFullHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK,buffer);\n        response.headers().set(HttpHeaderNames.CONTENT_TYPE,\"text/html\");\n        response.headers().set(HttpHeaderNames.CONTENT_LENGTH,buffer.readableBytes());\n        channelHandlerContext.writeAndFlush(response);\n       channelHandlerContext.close();\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(\"通道处于活动状态 3\");\n        super.channelActive(ctx);\n    }\n\n    @Override\n    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(\"通道注册 2\");\n        super.channelRegistered(ctx);\n    }\n\n    @Override\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(\"处理器添加 1\");\n        super.handlerAdded(ctx);\n    }\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(\"通道数据进入5\");\n        super.channelInactive(ctx);\n    }\n\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n        System.out.println(\"通道取消注册6\");\n        super.channelUnregistered(ctx);\n    }\n}\n```\n\n说明：\n\n我们来看一下构造一个http服务端，都需要干些啥。\n\n在main函数中，我们创建了两个线程组`NioEventLoopGroup`，boss线程组负责接收请求，work线程组负责处理请求。`ServerBootstrap`服务端配置辅助器进行服务端配置，绑定端口号。\n\n初始化器`ChannelInitializer<SocketChannel>`对管道设置各种处理器，数据处理器`SimpleChannelInboundHandler<HttpObject>` 的`channelRead0`方法处理数据，调用`channelHandlerContext.writeAndFlush` 将数据写入通道，其他重写的方法看代码便能知道是干嘛的\n\n### socket demo\n\nsocket连接步骤大同小异\n\n编写server的main函数\n\n```java\npublic static void main(String[] args) {\n        EventLoopGroup boss=new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.group(boss,worker).channel(NioServerSocketChannel.class).childHandler(new MyServerInitializer());\n            ChannelFuture sync = serverBootstrap.bind(8081).sync();\n            sync.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n```\n\n编写初始化器\n\n```java\npublic class MyServerInitializer extends ChannelInitializer<SocketChannel> {\n    @Override\n    protected void initChannel(SocketChannel socketChannel) throws Exception {\n        ChannelPipeline pipeline = socketChannel.pipeline();\n//        jia 一堆处理器 策略模式\n        pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));\n        pipeline.addLast(new LengthFieldPrepender(4));\n        pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));\n        pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));\n        pipeline.addLast(new MyserverHandler());\n    }\n}\n```\n\n编写数据处理器\n\n```jav\n\npublic class MyserverHandler extends SimpleChannelInboundHandler<String> {\n    private static ChannelGroup group=new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);\n//    处理方法\n    protected void channelRead0(ChannelHandlerContext ctx, String s) throws Exception {\n        Channel channel = ctx.channel();\n        group.writeAndFlush(ctx.channel().remoteAddress()+\">>>>\"+s);\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        cause.printStackTrace();\n\n        ctx.close();\n    }\n\n    @Override\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        Channel channel = ctx.channel();\n        group.writeAndFlush(channel.remoteAddress()+\"连接地址》》》》》》》\");\n        group.add(channel);\n    }\n\n    @Override\n    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n        Channel channel = ctx.channel();\n        group.writeAndFlush(channel.remoteAddress()+\"断开连接》》》》》》》\");\n    }\n}\n```\n\n编写client 的main\n\n```java\n public static void main(String[] args) {\n        EventLoopGroup boss = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.group(boss).channel(NioSocketChannel.class).handler(new MyClientInitializer());\n            ChannelFuture sync = bootstrap.connect(\"127.0.0.1\",8081).sync();\n            Channel channel = sync.channel();\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n            while (true){\n                channel.writeAndFlush(bufferedReader.readLine());\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            boss.shutdownGracefully();\n        }\n    }\n```\n\n其他和服务端一样，所以略；\n\n服务端启动类`serverBootstrap.bind(8081).sync()` 而客户端启动类配置是` ChannelFuture sync = bootstrap.connect(\"127.0.0.1\",8081).sync();`区别就在这里\n\n### websocket demo\n\n[github](<https://github.com/muggle0/learn/tree/all>) netty模块 下有所有代码\n\n","slug":"netty学习笔记","published":1,"updated":"2021-01-11T07:31:23.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6k002l00wif40pb0sl","content":"<p>作者：muggle</p>\n<p>netty框架代码很猛（读源码有益身心健康），学习起来也比较难；在阅读这篇文章我假设你有了一定nio基础，tcp网络协议基础，否则不建议阅读。</p>\n<p>关于netty的学习视频我推荐B站张龙的教学视频，讲的很不错。学netty之前先学会用，然后在去看他的原理这样学起来会轻松不少。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"http-demo\"><a href=\"#http-demo\" class=\"headerlink\" title=\"http demo\"></a>http demo</h3><p>用netty实现一个http服务端</p>\n<p>编写main函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestNetty</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        事件循环组 接收连接，将连接发送给work</span></span><br><span class=\"line\">        NioEventLoopGroup bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\"><span class=\"comment\">//        work 干活</span></span><br><span class=\"line\">        NioEventLoopGroup workerGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\"><span class=\"comment\">//      简化服务端启动</span></span><br><span class=\"line\">        ServerBootstrap serverBootstrap=<span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\"><span class=\"comment\">//                     打开通道                                               子处理器 服务端初始化器</span></span><br><span class=\"line\">  serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class=\"keyword\">new</span> TestServerInitlizer());、</span><br><span class=\"line\">      <span class=\"comment\">// 绑定接口</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ChannelFuture sync = serverBootstrap.bind(<span class=\"number\">8081</span>).sync();</span><br><span class=\"line\">        sync.channel().closeFuture().sync();</span><br><span class=\"line\">        bossGroup.shutdownGracefully();</span><br><span class=\"line\">        workerGroup.shutdownGracefully();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>编写初始化器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化器 channel注册好之后 自动创建 执行代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestServerInitlizer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInitializer</span>&lt;<span class=\"title\">SocketChannel</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel socketChannel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class=\"line\"><span class=\"comment\">//        对web响应编解码</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"string\">&quot;httpserverCodec&quot;</span>,<span class=\"keyword\">new</span> HttpServerCodec());</span><br><span class=\"line\"><span class=\"comment\">//        起名加入管道  自己的处理器</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"string\">&quot;testHttpResponse&quot;</span>,<span class=\"keyword\">new</span> TestHttpServerHandler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写数据处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestHttpServerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleChannelInboundHandler</span>&lt;<span class=\"title\">HttpObject</span>&gt; </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//    构造一个Http响应</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext channelHandlerContext, HttpObject httpObject)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请求读取处理4&quot;</span>);</span><br><span class=\"line\">        ByteBuf buffer=Unpooled.copiedBuffer(<span class=\"string\">&quot;&lt;!DOCTYPE html&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;html lang=\\&quot;en\\&quot;&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;    &lt;meta charset=\\&quot;UTF-8\\&quot;&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;    &lt;title&gt;Title&lt;/title&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;h1&gt;这是一个Netty构造的http响应&lt;/h1&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;/html&gt;&quot;</span>, CharsetUtil.UTF_8);</span><br><span class=\"line\">        FullHttpResponse response=<span class=\"keyword\">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK,buffer);</span><br><span class=\"line\">        response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        response.headers().set(HttpHeaderNames.CONTENT_LENGTH,buffer.readableBytes());</span><br><span class=\"line\">        channelHandlerContext.writeAndFlush(response);</span><br><span class=\"line\">       channelHandlerContext.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;通道处于活动状态 3&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.channelActive(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRegistered</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;通道注册 2&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.channelRegistered(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handlerAdded</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;处理器添加 1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.handlerAdded(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelInactive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;通道数据进入5&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.channelInactive(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelUnregistered</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;通道取消注册6&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.channelUnregistered(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<p>我们来看一下构造一个http服务端，都需要干些啥。</p>\n<p>在main函数中，我们创建了两个线程组<code>NioEventLoopGroup</code>，boss线程组负责接收请求，work线程组负责处理请求。<code>ServerBootstrap</code>服务端配置辅助器进行服务端配置，绑定端口号。</p>\n<p>初始化器<code>ChannelInitializer&lt;SocketChannel&gt;</code>对管道设置各种处理器，数据处理器<code>SimpleChannelInboundHandler&lt;HttpObject&gt;</code> 的<code>channelRead0</code>方法处理数据，调用<code>channelHandlerContext.writeAndFlush</code> 将数据写入通道，其他重写的方法看代码便能知道是干嘛的</p>\n<h3 id=\"socket-demo\"><a href=\"#socket-demo\" class=\"headerlink\" title=\"socket demo\"></a>socket demo</h3><p>socket连接步骤大同小异</p>\n<p>编写server的main函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        EventLoopGroup boss=<span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        NioEventLoopGroup worker = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ServerBootstrap serverBootstrap = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">            serverBootstrap.group(boss,worker).channel(NioServerSocketChannel.class).childHandler(<span class=\"keyword\">new</span> MyServerInitializer());</span><br><span class=\"line\">            ChannelFuture sync = serverBootstrap.bind(<span class=\"number\">8081</span>).sync();</span><br><span class=\"line\">            sync.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            boss.shutdownGracefully();</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>编写初始化器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServerInitializer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInitializer</span>&lt;<span class=\"title\">SocketChannel</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel socketChannel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class=\"line\"><span class=\"comment\">//        jia 一堆处理器 策略模式</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>));</span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> LengthFieldPrepender(<span class=\"number\">4</span>));</span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> MyserverHandler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写数据处理器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class MyserverHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;</span><br><span class=\"line\">    private static ChannelGroup group&#x3D;new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class=\"line\">&#x2F;&#x2F;    处理方法</span><br><span class=\"line\">    protected void channelRead0(ChannelHandlerContext ctx, String s) throws Exception &#123;</span><br><span class=\"line\">        Channel channel &#x3D; ctx.channel();</span><br><span class=\"line\">        group.writeAndFlush(ctx.channel().remoteAddress()+&quot;&gt;&gt;&gt;&gt;&quot;+s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class=\"line\">        Channel channel &#x3D; ctx.channel();</span><br><span class=\"line\">        group.writeAndFlush(channel.remoteAddress()+&quot;连接地址》》》》》》》&quot;);</span><br><span class=\"line\">        group.add(channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class=\"line\">        Channel channel &#x3D; ctx.channel();</span><br><span class=\"line\">        group.writeAndFlush(channel.remoteAddress()+&quot;断开连接》》》》》》》&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写client 的main</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">       EventLoopGroup boss = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">           bootstrap.group(boss).channel(NioSocketChannel.class).handler(<span class=\"keyword\">new</span> MyClientInitializer());</span><br><span class=\"line\">           ChannelFuture sync = bootstrap.connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>,<span class=\"number\">8081</span>).sync();</span><br><span class=\"line\">           Channel channel = sync.channel();</span><br><span class=\"line\">           BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">           <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">               channel.writeAndFlush(bufferedReader.readLine());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           boss.shutdownGracefully();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>其他和服务端一样，所以略；</p>\n<p>服务端启动类<code>serverBootstrap.bind(8081).sync()</code> 而客户端启动类配置是<code>ChannelFuture sync = bootstrap.connect(&quot;127.0.0.1&quot;,8081).sync();</code>区别就在这里</p>\n<h3 id=\"websocket-demo\"><a href=\"#websocket-demo\" class=\"headerlink\" title=\"websocket demo\"></a>websocket demo</h3><p><a href=\"https://github.com/muggle0/learn/tree/all\">github</a> netty模块 下有所有代码</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<p>netty框架代码很猛（读源码有益身心健康），学习起来也比较难；在阅读这篇文章我假设你有了一定nio基础，tcp网络协议基础，否则不建议阅读。</p>\n<p>关于netty的学习视频我推荐B站张龙的教学视频，讲的很不错。学netty之前先学会用，然后在去看他的原理这样学起来会轻松不少。</p>","more":"<h3 id=\"http-demo\"><a href=\"#http-demo\" class=\"headerlink\" title=\"http demo\"></a>http demo</h3><p>用netty实现一个http服务端</p>\n<p>编写main函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestNetty</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        事件循环组 接收连接，将连接发送给work</span></span><br><span class=\"line\">        NioEventLoopGroup bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\"><span class=\"comment\">//        work 干活</span></span><br><span class=\"line\">        NioEventLoopGroup workerGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\"><span class=\"comment\">//      简化服务端启动</span></span><br><span class=\"line\">        ServerBootstrap serverBootstrap=<span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\"><span class=\"comment\">//                     打开通道                                               子处理器 服务端初始化器</span></span><br><span class=\"line\">  serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(<span class=\"keyword\">new</span> TestServerInitlizer());、</span><br><span class=\"line\">      <span class=\"comment\">// 绑定接口</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ChannelFuture sync = serverBootstrap.bind(<span class=\"number\">8081</span>).sync();</span><br><span class=\"line\">        sync.channel().closeFuture().sync();</span><br><span class=\"line\">        bossGroup.shutdownGracefully();</span><br><span class=\"line\">        workerGroup.shutdownGracefully();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>编写初始化器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化器 channel注册好之后 自动创建 执行代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestServerInitlizer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInitializer</span>&lt;<span class=\"title\">SocketChannel</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel socketChannel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class=\"line\"><span class=\"comment\">//        对web响应编解码</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"string\">&quot;httpserverCodec&quot;</span>,<span class=\"keyword\">new</span> HttpServerCodec());</span><br><span class=\"line\"><span class=\"comment\">//        起名加入管道  自己的处理器</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"string\">&quot;testHttpResponse&quot;</span>,<span class=\"keyword\">new</span> TestHttpServerHandler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写数据处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestHttpServerHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleChannelInboundHandler</span>&lt;<span class=\"title\">HttpObject</span>&gt; </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//    构造一个Http响应</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext channelHandlerContext, HttpObject httpObject)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请求读取处理4&quot;</span>);</span><br><span class=\"line\">        ByteBuf buffer=Unpooled.copiedBuffer(<span class=\"string\">&quot;&lt;!DOCTYPE html&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;html lang=\\&quot;en\\&quot;&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;    &lt;meta charset=\\&quot;UTF-8\\&quot;&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;    &lt;title&gt;Title&lt;/title&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;h1&gt;这是一个Netty构造的http响应&lt;/h1&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;/body&gt;\\n&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;&lt;/html&gt;&quot;</span>, CharsetUtil.UTF_8);</span><br><span class=\"line\">        FullHttpResponse response=<span class=\"keyword\">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK,buffer);</span><br><span class=\"line\">        response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        response.headers().set(HttpHeaderNames.CONTENT_LENGTH,buffer.readableBytes());</span><br><span class=\"line\">        channelHandlerContext.writeAndFlush(response);</span><br><span class=\"line\">       channelHandlerContext.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;通道处于活动状态 3&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.channelActive(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRegistered</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;通道注册 2&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.channelRegistered(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handlerAdded</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;处理器添加 1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.handlerAdded(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelInactive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;通道数据进入5&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.channelInactive(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelUnregistered</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;通道取消注册6&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.channelUnregistered(ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>说明：</p>\n<p>我们来看一下构造一个http服务端，都需要干些啥。</p>\n<p>在main函数中，我们创建了两个线程组<code>NioEventLoopGroup</code>，boss线程组负责接收请求，work线程组负责处理请求。<code>ServerBootstrap</code>服务端配置辅助器进行服务端配置，绑定端口号。</p>\n<p>初始化器<code>ChannelInitializer&lt;SocketChannel&gt;</code>对管道设置各种处理器，数据处理器<code>SimpleChannelInboundHandler&lt;HttpObject&gt;</code> 的<code>channelRead0</code>方法处理数据，调用<code>channelHandlerContext.writeAndFlush</code> 将数据写入通道，其他重写的方法看代码便能知道是干嘛的</p>\n<h3 id=\"socket-demo\"><a href=\"#socket-demo\" class=\"headerlink\" title=\"socket demo\"></a>socket demo</h3><p>socket连接步骤大同小异</p>\n<p>编写server的main函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        EventLoopGroup boss=<span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        NioEventLoopGroup worker = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ServerBootstrap serverBootstrap = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">            serverBootstrap.group(boss,worker).channel(NioServerSocketChannel.class).childHandler(<span class=\"keyword\">new</span> MyServerInitializer());</span><br><span class=\"line\">            ChannelFuture sync = serverBootstrap.bind(<span class=\"number\">8081</span>).sync();</span><br><span class=\"line\">            sync.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            boss.shutdownGracefully();</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>编写初始化器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServerInitializer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ChannelInitializer</span>&lt;<span class=\"title\">SocketChannel</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel socketChannel)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class=\"line\"><span class=\"comment\">//        jia 一堆处理器 策略模式</span></span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>));</span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> LengthFieldPrepender(<span class=\"number\">4</span>));</span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class=\"line\">        pipeline.addLast(<span class=\"keyword\">new</span> MyserverHandler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写数据处理器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class MyserverHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;</span><br><span class=\"line\">    private static ChannelGroup group&#x3D;new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class=\"line\">&#x2F;&#x2F;    处理方法</span><br><span class=\"line\">    protected void channelRead0(ChannelHandlerContext ctx, String s) throws Exception &#123;</span><br><span class=\"line\">        Channel channel &#x3D; ctx.channel();</span><br><span class=\"line\">        group.writeAndFlush(ctx.channel().remoteAddress()+&quot;&gt;&gt;&gt;&gt;&quot;+s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class=\"line\">        cause.printStackTrace();</span><br><span class=\"line\"></span><br><span class=\"line\">        ctx.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class=\"line\">        Channel channel &#x3D; ctx.channel();</span><br><span class=\"line\">        group.writeAndFlush(channel.remoteAddress()+&quot;连接地址》》》》》》》&quot;);</span><br><span class=\"line\">        group.add(channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class=\"line\">        Channel channel &#x3D; ctx.channel();</span><br><span class=\"line\">        group.writeAndFlush(channel.remoteAddress()+&quot;断开连接》》》》》》》&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写client 的main</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">       EventLoopGroup boss = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">           bootstrap.group(boss).channel(NioSocketChannel.class).handler(<span class=\"keyword\">new</span> MyClientInitializer());</span><br><span class=\"line\">           ChannelFuture sync = bootstrap.connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>,<span class=\"number\">8081</span>).sync();</span><br><span class=\"line\">           Channel channel = sync.channel();</span><br><span class=\"line\">           BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">           <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">               channel.writeAndFlush(bufferedReader.readLine());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           boss.shutdownGracefully();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>其他和服务端一样，所以略；</p>\n<p>服务端启动类<code>serverBootstrap.bind(8081).sync()</code> 而客户端启动类配置是<code>ChannelFuture sync = bootstrap.connect(&quot;127.0.0.1&quot;,8081).sync();</code>区别就在这里</p>\n<h3 id=\"websocket-demo\"><a href=\"#websocket-demo\" class=\"headerlink\" title=\"websocket demo\"></a>websocket demo</h3><p><a href=\"https://github.com/muggle0/learn/tree/all\">github</a> netty模块 下有所有代码</p>"},{"title":"nio学习笔记","date":"2019-04-26T03:49:48.000Z","_content":"作者：muggle\n\n# nio介绍\n\n传统的IO又称BIO，即阻塞式IO，NIO就是非阻塞IO了，而NIO在jdk1.7后又进行了升级成为nio.2也就是aio；\nJava IO的各种流是阻塞的。这意味着，当一个线程调用`read() `或 `write()`时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。\n\n<!--more-->\n\n# nio相关的类\n\nnio有四个很重要的类：`Selector`，`Channel`，`Buffer`，`Charset`\n## Channel\n\n Channel通过节点流的getChannel()方法来获得，成员map()用来将其部分或全部数据映射为Buffer，成员read()、write()方法来读写数据，而且只能通过Buffer作为缓冲来读写Channel关联的数据。\n\nChannel接口下有用于文件IO的`FileChannel`，用于UDP通信的`DatagramChannel`，用于TCP通信的`ocketChannel`、`ServerSocketChannel`，用于线程间通信的`Pipe.SinkChannel`、`Pipe.SourceChannel`等实现类。Channel也不是通过构造器来创建对象，而是通过节点流的getChannel()方法来获得，如通过`FileInputStream`、`FileOutputStream`、`andomAccessFile`的`getChannel()`获得对应的`FileChannel`。\n\n  `Channel`中常用的方法有`map()`、`read()`、`write()`，`map()`用来将`Channel`对应的部分或全部数据映射成`MappedByteBuffer`（`ByteBuffer`的子类），`read()/write()`用于对Buffer读写数据。\n\n## Buffer\n\nBuffer是一个缓冲区，它是一个抽象类，常用的子类:`ByteBuffer`,`MappedByteBuffer`,`CharBuffer`,`DoubleBuffer`,`FloatBuffer`,`IntBuffer`,`LongBuffer`,`ShortBuffer`等，通过它可以用来装入数据和输出数据。Buffer没有构造器，使用类方法`allocate()`来创建对应的Buffer对象，当向Buffer写入数据后，在读取Buffer中数据之前应该调用flip()方法来设置Buffer中的数据位置信息，读取Buffer中数据之后应该调用`clear()`方法来清空原来的数据位置信息。`compact()`方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。\n\n## charset\n\n Charset可以将Unicode字符串（CharBuffer）和字节序列（ByteBuffer）相互转化。\n\nJava中默认使用Unicode字符集，可以通过Charset来处理字节序列和字符序列（字符串）之间的转换，其`availableCharsets()`静态方法可以获得当前JDK支持的所有字符集。调用Charset的静态方法`forName()`可以获得指定字符集对应的Charset对象，调用该对象的`newEncoder()`、`newDecoder()`可以获得对应的编码器、解码器，调用编码器的encode()可以将CharBuffer或String转换为ByteBuffer，调用解码器的`decode()`可以将ByteBuffer转换为CharBuffer。\n\n ## Selector\n\nSelector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel。通过调用`Selector.open()`方法创建一个Selector，将Channel注册到Selector上。通过`SelectableChannel.register()`方法来实现。与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。\n\n# nio使用须知\n\n缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。它的三个属性capacity,position和limit就是描述这块内存的了。capacity可以简单理解为这块内存的大小；写数据到Buffer中时，position表示当前的位置。初始的position值为0。当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.\n当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。limit表示你最多能读（写）多少数据。\n\nbuffer的方法：\n\n- flip()：将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。\n- get()：从Buffer中读取数据\n- rewind()：将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。\n- clear()：position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。\n- compact()：将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。\n-  put()：向Buffer存入数据，带索引参数的版本不会移动位置position。\n-  capacity()：获得Buffer的大小capacity。\n-  hasRemaining()：判断当前位置position和界限limit之间是否还有元素可供处理。\n-  remaining()：获得当前位置position和界限limit之间元素的个数。\n-  limit()：获得或者设置Buffer的界限limit的位置。\n-  position()：获得或者设置Buffer的位置position。\n-  mark()：设置Buffer的mark位置。\n-  reset()：将位置positon转到mark所在的位置。\n\n# nio使用示例\n\nNIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel传输到另外一个channel。\n\nFileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中。\n\nransferTo()方法将数据从FileChannel传输到其他的channel中。\n\nInputStream get出来的通道只能用于输入，outputStream同理\n\n文件读操作\n\n```java\nFile file = new File(\"test.txt\");\nFileInputStream fin = new FileInputStream(file);\n\nFileChannel channel = fin.getChannel();\nByteBuffer buf = ByteBuffer.allocate(10);\nint read = channel.read(buf);\nwhile (read>0){\n     buf.flip();\n    byte[] array = new byte[10];\n    int limit = buf.limit();\n    if (limit>=10){\n         buf.get(array);\n    }else {\n        array=new byte[limit];\n        buf.get(array);\n    }\n    String s = new String(array);\n    System.out.print(s);\n    buf.clear();\n     read = channel.read(buf);\n    }\n```\n\n文件写操作\n\n```java\nRandomAccessFile rw = new RandomAccessFile(\"test.txt\", \"rw\");\nFileChannel channel = rw.getChannel();\nByteBuffer allocate = ByteBuffer.allocate(1000);\nallocate.put(\"wwwww\".getBytes());\nallocate.flip();\nchannel.write(allocate);\nchannel.write(wrap);\n//      wrap 不需要 flip()\nByteBuffer wrap = ByteBuffer.wrap(\"sssssssssssss\".getBytes());\nchannel1.write(wrap);\nrw.close()\n```\n\n通道间数据传输\n\n```java\n  RandomAccessFile rw = new RandomAccessFile(\"test.txt\", \"rw\");\n  RandomAccessFile rw2 = new RandomAccessFile(\"test2.txt\", \"rw\");\n  FileChannel channel = rw.getChannel();\n  FileChannel channel2 = rw2.getChannel();\n  channel2.transferFrom(channel,0,channel.size());\n```\n\n","source":"_posts/nio.md","raw":"---\ntitle: nio学习笔记\ndate: 2019-04-26 11:49:48\ntags: javase\n---\n作者：muggle\n\n# nio介绍\n\n传统的IO又称BIO，即阻塞式IO，NIO就是非阻塞IO了，而NIO在jdk1.7后又进行了升级成为nio.2也就是aio；\nJava IO的各种流是阻塞的。这意味着，当一个线程调用`read() `或 `write()`时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。\n\n<!--more-->\n\n# nio相关的类\n\nnio有四个很重要的类：`Selector`，`Channel`，`Buffer`，`Charset`\n## Channel\n\n Channel通过节点流的getChannel()方法来获得，成员map()用来将其部分或全部数据映射为Buffer，成员read()、write()方法来读写数据，而且只能通过Buffer作为缓冲来读写Channel关联的数据。\n\nChannel接口下有用于文件IO的`FileChannel`，用于UDP通信的`DatagramChannel`，用于TCP通信的`ocketChannel`、`ServerSocketChannel`，用于线程间通信的`Pipe.SinkChannel`、`Pipe.SourceChannel`等实现类。Channel也不是通过构造器来创建对象，而是通过节点流的getChannel()方法来获得，如通过`FileInputStream`、`FileOutputStream`、`andomAccessFile`的`getChannel()`获得对应的`FileChannel`。\n\n  `Channel`中常用的方法有`map()`、`read()`、`write()`，`map()`用来将`Channel`对应的部分或全部数据映射成`MappedByteBuffer`（`ByteBuffer`的子类），`read()/write()`用于对Buffer读写数据。\n\n## Buffer\n\nBuffer是一个缓冲区，它是一个抽象类，常用的子类:`ByteBuffer`,`MappedByteBuffer`,`CharBuffer`,`DoubleBuffer`,`FloatBuffer`,`IntBuffer`,`LongBuffer`,`ShortBuffer`等，通过它可以用来装入数据和输出数据。Buffer没有构造器，使用类方法`allocate()`来创建对应的Buffer对象，当向Buffer写入数据后，在读取Buffer中数据之前应该调用flip()方法来设置Buffer中的数据位置信息，读取Buffer中数据之后应该调用`clear()`方法来清空原来的数据位置信息。`compact()`方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。\n\n## charset\n\n Charset可以将Unicode字符串（CharBuffer）和字节序列（ByteBuffer）相互转化。\n\nJava中默认使用Unicode字符集，可以通过Charset来处理字节序列和字符序列（字符串）之间的转换，其`availableCharsets()`静态方法可以获得当前JDK支持的所有字符集。调用Charset的静态方法`forName()`可以获得指定字符集对应的Charset对象，调用该对象的`newEncoder()`、`newDecoder()`可以获得对应的编码器、解码器，调用编码器的encode()可以将CharBuffer或String转换为ByteBuffer，调用解码器的`decode()`可以将ByteBuffer转换为CharBuffer。\n\n ## Selector\n\nSelector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel。通过调用`Selector.open()`方法创建一个Selector，将Channel注册到Selector上。通过`SelectableChannel.register()`方法来实现。与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。\n\n# nio使用须知\n\n缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。它的三个属性capacity,position和limit就是描述这块内存的了。capacity可以简单理解为这块内存的大小；写数据到Buffer中时，position表示当前的位置。初始的position值为0。当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.\n当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。limit表示你最多能读（写）多少数据。\n\nbuffer的方法：\n\n- flip()：将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。\n- get()：从Buffer中读取数据\n- rewind()：将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。\n- clear()：position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。\n- compact()：将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。\n-  put()：向Buffer存入数据，带索引参数的版本不会移动位置position。\n-  capacity()：获得Buffer的大小capacity。\n-  hasRemaining()：判断当前位置position和界限limit之间是否还有元素可供处理。\n-  remaining()：获得当前位置position和界限limit之间元素的个数。\n-  limit()：获得或者设置Buffer的界限limit的位置。\n-  position()：获得或者设置Buffer的位置position。\n-  mark()：设置Buffer的mark位置。\n-  reset()：将位置positon转到mark所在的位置。\n\n# nio使用示例\n\nNIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel传输到另外一个channel。\n\nFileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中。\n\nransferTo()方法将数据从FileChannel传输到其他的channel中。\n\nInputStream get出来的通道只能用于输入，outputStream同理\n\n文件读操作\n\n```java\nFile file = new File(\"test.txt\");\nFileInputStream fin = new FileInputStream(file);\n\nFileChannel channel = fin.getChannel();\nByteBuffer buf = ByteBuffer.allocate(10);\nint read = channel.read(buf);\nwhile (read>0){\n     buf.flip();\n    byte[] array = new byte[10];\n    int limit = buf.limit();\n    if (limit>=10){\n         buf.get(array);\n    }else {\n        array=new byte[limit];\n        buf.get(array);\n    }\n    String s = new String(array);\n    System.out.print(s);\n    buf.clear();\n     read = channel.read(buf);\n    }\n```\n\n文件写操作\n\n```java\nRandomAccessFile rw = new RandomAccessFile(\"test.txt\", \"rw\");\nFileChannel channel = rw.getChannel();\nByteBuffer allocate = ByteBuffer.allocate(1000);\nallocate.put(\"wwwww\".getBytes());\nallocate.flip();\nchannel.write(allocate);\nchannel.write(wrap);\n//      wrap 不需要 flip()\nByteBuffer wrap = ByteBuffer.wrap(\"sssssssssssss\".getBytes());\nchannel1.write(wrap);\nrw.close()\n```\n\n通道间数据传输\n\n```java\n  RandomAccessFile rw = new RandomAccessFile(\"test.txt\", \"rw\");\n  RandomAccessFile rw2 = new RandomAccessFile(\"test2.txt\", \"rw\");\n  FileChannel channel = rw.getChannel();\n  FileChannel channel2 = rw2.getChannel();\n  channel2.transferFrom(channel,0,channel.size());\n```\n\n","slug":"nio","published":1,"updated":"2021-01-11T07:31:23.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6l002o00wi9wgyhyks","content":"<p>作者：muggle</p>\n<h1 id=\"nio介绍\"><a href=\"#nio介绍\" class=\"headerlink\" title=\"nio介绍\"></a>nio介绍</h1><p>传统的IO又称BIO，即阻塞式IO，NIO就是非阻塞IO了，而NIO在jdk1.7后又进行了升级成为nio.2也就是aio；<br>Java IO的各种流是阻塞的。这意味着，当一个线程调用<code>read()</code>或 <code>write()</code>时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"nio相关的类\"><a href=\"#nio相关的类\" class=\"headerlink\" title=\"nio相关的类\"></a>nio相关的类</h1><p>nio有四个很重要的类：<code>Selector</code>，<code>Channel</code>，<code>Buffer</code>，<code>Charset</code></p>\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p> Channel通过节点流的getChannel()方法来获得，成员map()用来将其部分或全部数据映射为Buffer，成员read()、write()方法来读写数据，而且只能通过Buffer作为缓冲来读写Channel关联的数据。</p>\n<p>Channel接口下有用于文件IO的<code>FileChannel</code>，用于UDP通信的<code>DatagramChannel</code>，用于TCP通信的<code>ocketChannel</code>、<code>ServerSocketChannel</code>，用于线程间通信的<code>Pipe.SinkChannel</code>、<code>Pipe.SourceChannel</code>等实现类。Channel也不是通过构造器来创建对象，而是通过节点流的getChannel()方法来获得，如通过<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>andomAccessFile</code>的<code>getChannel()</code>获得对应的<code>FileChannel</code>。</p>\n<p>  <code>Channel</code>中常用的方法有<code>map()</code>、<code>read()</code>、<code>write()</code>，<code>map()</code>用来将<code>Channel</code>对应的部分或全部数据映射成<code>MappedByteBuffer</code>（<code>ByteBuffer</code>的子类），<code>read()/write()</code>用于对Buffer读写数据。</p>\n<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>Buffer是一个缓冲区，它是一个抽象类，常用的子类:<code>ByteBuffer</code>,<code>MappedByteBuffer</code>,<code>CharBuffer</code>,<code>DoubleBuffer</code>,<code>FloatBuffer</code>,<code>IntBuffer</code>,<code>LongBuffer</code>,<code>ShortBuffer</code>等，通过它可以用来装入数据和输出数据。Buffer没有构造器，使用类方法<code>allocate()</code>来创建对应的Buffer对象，当向Buffer写入数据后，在读取Buffer中数据之前应该调用flip()方法来设置Buffer中的数据位置信息，读取Buffer中数据之后应该调用<code>clear()</code>方法来清空原来的数据位置信息。<code>compact()</code>方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>\n<h2 id=\"charset\"><a href=\"#charset\" class=\"headerlink\" title=\"charset\"></a>charset</h2><p> Charset可以将Unicode字符串（CharBuffer）和字节序列（ByteBuffer）相互转化。</p>\n<p>Java中默认使用Unicode字符集，可以通过Charset来处理字节序列和字符序列（字符串）之间的转换，其<code>availableCharsets()</code>静态方法可以获得当前JDK支持的所有字符集。调用Charset的静态方法<code>forName()</code>可以获得指定字符集对应的Charset对象，调用该对象的<code>newEncoder()</code>、<code>newDecoder()</code>可以获得对应的编码器、解码器，调用编码器的encode()可以将CharBuffer或String转换为ByteBuffer，调用解码器的<code>decode()</code>可以将ByteBuffer转换为CharBuffer。</p>\n<h2 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h2><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel。通过调用<code>Selector.open()</code>方法创建一个Selector，将Channel注册到Selector上。通过<code>SelectableChannel.register()</code>方法来实现。与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p>\n<h1 id=\"nio使用须知\"><a href=\"#nio使用须知\" class=\"headerlink\" title=\"nio使用须知\"></a>nio使用须知</h1><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。它的三个属性capacity,position和limit就是描述这块内存的了。capacity可以简单理解为这块内存的大小；写数据到Buffer中时，position表示当前的位置。初始的position值为0。当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.<br>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。limit表示你最多能读（写）多少数据。</p>\n<p>buffer的方法：</p>\n<ul>\n<li>flip()：将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</li>\n<li>get()：从Buffer中读取数据</li>\n<li>rewind()：将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</li>\n<li>clear()：position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</li>\n<li>compact()：将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。</li>\n<li>put()：向Buffer存入数据，带索引参数的版本不会移动位置position。</li>\n<li>capacity()：获得Buffer的大小capacity。</li>\n<li>hasRemaining()：判断当前位置position和界限limit之间是否还有元素可供处理。</li>\n<li>remaining()：获得当前位置position和界限limit之间元素的个数。</li>\n<li>limit()：获得或者设置Buffer的界限limit的位置。</li>\n<li>position()：获得或者设置Buffer的位置position。</li>\n<li>mark()：设置Buffer的mark位置。</li>\n<li>reset()：将位置positon转到mark所在的位置。</li>\n</ul>\n<h1 id=\"nio使用示例\"><a href=\"#nio使用示例\" class=\"headerlink\" title=\"nio使用示例\"></a>nio使用示例</h1><p>NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel传输到另外一个channel。</p>\n<p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中。</p>\n<p>ransferTo()方法将数据从FileChannel传输到其他的channel中。</p>\n<p>InputStream get出来的通道只能用于输入，outputStream同理</p>\n<p>文件读操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;test.txt&quot;</span>);</span><br><span class=\"line\">FileInputStream fin = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\"></span><br><span class=\"line\">FileChannel channel = fin.getChannel();</span><br><span class=\"line\">ByteBuffer buf = ByteBuffer.allocate(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> read = channel.read(buf);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (read&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">     buf.flip();</span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] array = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> limit = buf.limit();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (limit&gt;=<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">         buf.get(array);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        array=<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[limit];</span><br><span class=\"line\">        buf.get(array);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String s = <span class=\"keyword\">new</span> String(array);</span><br><span class=\"line\">    System.out.print(s);</span><br><span class=\"line\">    buf.clear();</span><br><span class=\"line\">     read = channel.read(buf);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>文件写操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RandomAccessFile rw = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">&quot;test.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\">FileChannel channel = rw.getChannel();</span><br><span class=\"line\">ByteBuffer allocate = ByteBuffer.allocate(<span class=\"number\">1000</span>);</span><br><span class=\"line\">allocate.put(<span class=\"string\">&quot;wwwww&quot;</span>.getBytes());</span><br><span class=\"line\">allocate.flip();</span><br><span class=\"line\">channel.write(allocate);</span><br><span class=\"line\">channel.write(wrap);</span><br><span class=\"line\"><span class=\"comment\">//      wrap 不需要 flip()</span></span><br><span class=\"line\">ByteBuffer wrap = ByteBuffer.wrap(<span class=\"string\">&quot;sssssssssssss&quot;</span>.getBytes());</span><br><span class=\"line\">channel1.write(wrap);</span><br><span class=\"line\">rw.close()</span><br></pre></td></tr></table></figure>\n<p>通道间数据传输</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RandomAccessFile rw = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">&quot;test.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\">RandomAccessFile rw2 = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">&quot;test2.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\">FileChannel channel = rw.getChannel();</span><br><span class=\"line\">FileChannel channel2 = rw2.getChannel();</span><br><span class=\"line\">channel2.transferFrom(channel,<span class=\"number\">0</span>,channel.size());</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h1 id=\"nio介绍\"><a href=\"#nio介绍\" class=\"headerlink\" title=\"nio介绍\"></a>nio介绍</h1><p>传统的IO又称BIO，即阻塞式IO，NIO就是非阻塞IO了，而NIO在jdk1.7后又进行了升级成为nio.2也就是aio；<br>Java IO的各种流是阻塞的。这意味着，当一个线程调用<code>read()</code>或 <code>write()</code>时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>","more":"<h1 id=\"nio相关的类\"><a href=\"#nio相关的类\" class=\"headerlink\" title=\"nio相关的类\"></a>nio相关的类</h1><p>nio有四个很重要的类：<code>Selector</code>，<code>Channel</code>，<code>Buffer</code>，<code>Charset</code></p>\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p> Channel通过节点流的getChannel()方法来获得，成员map()用来将其部分或全部数据映射为Buffer，成员read()、write()方法来读写数据，而且只能通过Buffer作为缓冲来读写Channel关联的数据。</p>\n<p>Channel接口下有用于文件IO的<code>FileChannel</code>，用于UDP通信的<code>DatagramChannel</code>，用于TCP通信的<code>ocketChannel</code>、<code>ServerSocketChannel</code>，用于线程间通信的<code>Pipe.SinkChannel</code>、<code>Pipe.SourceChannel</code>等实现类。Channel也不是通过构造器来创建对象，而是通过节点流的getChannel()方法来获得，如通过<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>andomAccessFile</code>的<code>getChannel()</code>获得对应的<code>FileChannel</code>。</p>\n<p>  <code>Channel</code>中常用的方法有<code>map()</code>、<code>read()</code>、<code>write()</code>，<code>map()</code>用来将<code>Channel</code>对应的部分或全部数据映射成<code>MappedByteBuffer</code>（<code>ByteBuffer</code>的子类），<code>read()/write()</code>用于对Buffer读写数据。</p>\n<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>Buffer是一个缓冲区，它是一个抽象类，常用的子类:<code>ByteBuffer</code>,<code>MappedByteBuffer</code>,<code>CharBuffer</code>,<code>DoubleBuffer</code>,<code>FloatBuffer</code>,<code>IntBuffer</code>,<code>LongBuffer</code>,<code>ShortBuffer</code>等，通过它可以用来装入数据和输出数据。Buffer没有构造器，使用类方法<code>allocate()</code>来创建对应的Buffer对象，当向Buffer写入数据后，在读取Buffer中数据之前应该调用flip()方法来设置Buffer中的数据位置信息，读取Buffer中数据之后应该调用<code>clear()</code>方法来清空原来的数据位置信息。<code>compact()</code>方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>\n<h2 id=\"charset\"><a href=\"#charset\" class=\"headerlink\" title=\"charset\"></a>charset</h2><p> Charset可以将Unicode字符串（CharBuffer）和字节序列（ByteBuffer）相互转化。</p>\n<p>Java中默认使用Unicode字符集，可以通过Charset来处理字节序列和字符序列（字符串）之间的转换，其<code>availableCharsets()</code>静态方法可以获得当前JDK支持的所有字符集。调用Charset的静态方法<code>forName()</code>可以获得指定字符集对应的Charset对象，调用该对象的<code>newEncoder()</code>、<code>newDecoder()</code>可以获得对应的编码器、解码器，调用编码器的encode()可以将CharBuffer或String转换为ByteBuffer，调用解码器的<code>decode()</code>可以将ByteBuffer转换为CharBuffer。</p>\n<h2 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h2><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel。通过调用<code>Selector.open()</code>方法创建一个Selector，将Channel注册到Selector上。通过<code>SelectableChannel.register()</code>方法来实现。与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p>\n<h1 id=\"nio使用须知\"><a href=\"#nio使用须知\" class=\"headerlink\" title=\"nio使用须知\"></a>nio使用须知</h1><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。它的三个属性capacity,position和limit就是描述这块内存的了。capacity可以简单理解为这块内存的大小；写数据到Buffer中时，position表示当前的位置。初始的position值为0。当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.<br>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。limit表示你最多能读（写）多少数据。</p>\n<p>buffer的方法：</p>\n<ul>\n<li>flip()：将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</li>\n<li>get()：从Buffer中读取数据</li>\n<li>rewind()：将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</li>\n<li>clear()：position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</li>\n<li>compact()：将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。</li>\n<li>put()：向Buffer存入数据，带索引参数的版本不会移动位置position。</li>\n<li>capacity()：获得Buffer的大小capacity。</li>\n<li>hasRemaining()：判断当前位置position和界限limit之间是否还有元素可供处理。</li>\n<li>remaining()：获得当前位置position和界限limit之间元素的个数。</li>\n<li>limit()：获得或者设置Buffer的界限limit的位置。</li>\n<li>position()：获得或者设置Buffer的位置position。</li>\n<li>mark()：设置Buffer的mark位置。</li>\n<li>reset()：将位置positon转到mark所在的位置。</li>\n</ul>\n<h1 id=\"nio使用示例\"><a href=\"#nio使用示例\" class=\"headerlink\" title=\"nio使用示例\"></a>nio使用示例</h1><p>NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel传输到另外一个channel。</p>\n<p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中。</p>\n<p>ransferTo()方法将数据从FileChannel传输到其他的channel中。</p>\n<p>InputStream get出来的通道只能用于输入，outputStream同理</p>\n<p>文件读操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;test.txt&quot;</span>);</span><br><span class=\"line\">FileInputStream fin = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\"></span><br><span class=\"line\">FileChannel channel = fin.getChannel();</span><br><span class=\"line\">ByteBuffer buf = ByteBuffer.allocate(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> read = channel.read(buf);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (read&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">     buf.flip();</span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] array = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> limit = buf.limit();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (limit&gt;=<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">         buf.get(array);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        array=<span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[limit];</span><br><span class=\"line\">        buf.get(array);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String s = <span class=\"keyword\">new</span> String(array);</span><br><span class=\"line\">    System.out.print(s);</span><br><span class=\"line\">    buf.clear();</span><br><span class=\"line\">     read = channel.read(buf);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>文件写操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RandomAccessFile rw = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">&quot;test.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\">FileChannel channel = rw.getChannel();</span><br><span class=\"line\">ByteBuffer allocate = ByteBuffer.allocate(<span class=\"number\">1000</span>);</span><br><span class=\"line\">allocate.put(<span class=\"string\">&quot;wwwww&quot;</span>.getBytes());</span><br><span class=\"line\">allocate.flip();</span><br><span class=\"line\">channel.write(allocate);</span><br><span class=\"line\">channel.write(wrap);</span><br><span class=\"line\"><span class=\"comment\">//      wrap 不需要 flip()</span></span><br><span class=\"line\">ByteBuffer wrap = ByteBuffer.wrap(<span class=\"string\">&quot;sssssssssssss&quot;</span>.getBytes());</span><br><span class=\"line\">channel1.write(wrap);</span><br><span class=\"line\">rw.close()</span><br></pre></td></tr></table></figure>\n<p>通道间数据传输</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RandomAccessFile rw = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">&quot;test.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\">RandomAccessFile rw2 = <span class=\"keyword\">new</span> RandomAccessFile(<span class=\"string\">&quot;test2.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>);</span><br><span class=\"line\">FileChannel channel = rw.getChannel();</span><br><span class=\"line\">FileChannel channel2 = rw2.getChannel();</span><br><span class=\"line\">channel2.transferFrom(channel,<span class=\"number\">0</span>,channel.size());</span><br></pre></td></tr></table></figure>"},{"title":"相册","date":"2019-04-20T04:01:54.000Z","_content":"\n以前很少拍照，结果错失了很多珍贵的回忆，翻自己的相册都翻不出什么照片，最近买了个相机，准备摄影一波积累一些素材。\n\n<!-- more -->\n\n\n\n","source":"_posts/photo.md","raw":"---\ntitle: 相册\ndate: 2019-04-20 12:01:54\ntags: photo\n---\n\n以前很少拍照，结果错失了很多珍贵的回忆，翻自己的相册都翻不出什么照片，最近买了个相机，准备摄影一波积累一些素材。\n\n<!-- more -->\n\n\n\n","slug":"photo","published":1,"updated":"2021-01-11T07:31:23.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6m002q00widf79510r","content":"<p>以前很少拍照，结果错失了很多珍贵的回忆，翻自己的相册都翻不出什么照片，最近买了个相机，准备摄影一波积累一些素材。</p>\n<a id=\"more\"></a>\n\n\n\n","site":{"data":{}},"excerpt":"<p>以前很少拍照，结果错失了很多珍贵的回忆，翻自己的相册都翻不出什么照片，最近买了个相机，准备摄影一波积累一些素材。</p>","more":""},{"title":"rabbitMQ 结合 springboot 使用 二","date":"2020-12-14T16:00:00.000Z","_content":"\n这一章节我们会学习rabbitMQ在项目生产中一些重要的特性，如持久化，消息确认机制，消息过期等特性。只要能利用好这些特性，我们就能开发出可用性强的，功能强大的MQ系统。\n<!--more-->\n##  持久化\n\nRabbitMQ通过消息持久化来保证消息的可靠性——为了保证RabbitMQ在退出或者发生异常情况下数据不会丢失，需要将 queue ，exchange 和 Message 都持久化。下面分别介绍它们持久化配置的方式。\n\n对于 queue ，exchange 在创建的时候都会提供一个参数用以设置是否持久化，而如果使用它们对应的建造者而不是new，就能很清晰的看到是怎么指定持久化的：\n\n```java\n//  创建 queue 指定为非持久化\n    QueueBuilder.nonDurable(\"xxx\").build();\n//  指定持久化\n     return QueueBuilder.durable(\"second-direct-queue\").build();\n//  durable 为true则是持久化，false非持久化\n    ExchangeBuilder.topicExchange(\"topic\").durable(true).build();\n```\n\n这里需要注意一个地方，**直接在原队列的基础上添加属性是会报错的，它会告诉你队列已经存在。需要你手动打开管理界面把那个队列删除掉，然后重启项目**。\n\n你如果将 queue 的持久化标识 durable 设置为true ,则代表是一个持久的队列，那么在服务重启之后，也会存在，因为服务会把持久化的 queue 存放在硬盘上，当服务重启的时候，会重新什么之前被持久化的queue；但是里面的消息是否为持久化还需要看消息是否做了持久化设置。exchange 的持久化和 Queue 一样将交换机保存在磁盘，重启后这个交换机还会存在。\n\n那么消息如何持久化呢？在springboot中需要借助`MessagePostProcessor` 消息加工器对消息进行加工 rabbitMQ 才能知道这个消息是不是要持久化，`MessagePostProcessor`还有其他的很多作用，在后文会介绍。下面看如何进行消息的持久化。\n创建`MessagePostProcessor`类：\n\n```JAVA\npublic class MyMessagePostProcessor implements MessagePostProcessor {\n    \n    @Override\n    public Message postProcessMessage(Message message) throws AmqpException {\n        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);\n        return message;\n    }\n}\n```\n\n生产者通过`MessagePostProcessor`发送消息：\n\n```java\n @Scheduled(fixedRate = 1000)\n    private void sendMessageForDlx() {\n        rabbitTemplate.convertAndSend(\"exchange\",\"routing key\",\"mesage\",new MyMessagePostProcessor());\n    }\n```\n\n消息持久化过程：\n\n> 写入文件前会有一个Buffer,大小为1M,数据在写入文件时，首先会写入到这个Buffer，如果Buffer已满，则会将Buffer写入到文件（未必刷到磁盘）。\n> 有个固定的刷盘时间：25ms,也就是不管Buffer满不满，每个25ms，Buffer里的数据及未刷新到磁盘的文件内容必定会刷到磁盘。\n> 每次消息写入后，如果没有后续写入请求，则会直接将已写入的消息刷到磁盘：使用Erlang的receive x after 0实现，只要进程的信箱里没有消息，则产生一个timeout消息，而timeout会触发刷盘操作。\n> 原文链接：https://blog.csdn.net/u013256816/article/details/60875666\n\n## TTL\n\nRabbitMQ可以对消息和队列设置TTL(消息的过期时间)，消息在队列的生存时间一旦超过设置的TTL值，就称为dead message， 消费者将无法再收到该消息。\n\n- 在队列上设置消息过期时间\n\n设置队列过期加一个参数 `x-message-ttl` 就可以搞定，同样记得先把原队列在管理界面删除再启动项目，才会创建队列成功。创建持久化队列：\n\n```java\n    Queue build = QueueBuilder.durable(\"queue\")\n//      消息过期的时间\n                .withArgument(\"x-message-ttl\",5000L).build();\n```\n\n这种方式设置的过期属性特性是一旦消息过期，就会从队列中抹去（及时性）。\n\n- 通过`MessagePostProcessor`设置消息过期时间\n\n把原来的 `MyMessagePostProcessor` 代码拿过来加一个参数就行了：\n\n```java\npublic class MyMessagePostProcessor implements MessagePostProcessor {\n    private String expirTime;\n\n    public MyMessagePostProcessor(String expirTime){\n        this.expirTime=expirTime;\n    }\n    @Override\n    public Message postProcessMessage(Message message) throws AmqpException {\n//        设置过期时间\n        message.getMessageProperties().setExpiration(expirTime);\n//        设置消息持久化\n        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);\n        return message;\n    }\n}\n```\n\n这种方式设置的过期时间即使消息过期，也不一定会马上从队列中抹去，它会等轮到这个消息即将投递到消费者之前进行判定。如果过期就丢弃，不再投递给消费者\n\n## 优先级\n\n优先级分为消息优先级和队列优先级，队列优先级高的会先被处理，消息优先级高的会先被消费，队列优先级配置参数为`x-max-priority`,配置方式为：\n\n```java\nQueue build = QueueBuilder.durable(\"queue\").withArgument(\"x-max-priority\",10)\n```\n\n配置的数字越大，优先级越高默认优先级为0，消息优先级设置也一样。消息的优先级还是通过 `MessagePostProcessor` 来设置：\n\n```java\n    @Override\n    public Message postProcessMessage(Message message) throws AmqpException {\n        message.getMessageProperties().setPriority(5);\n        return message;\n    }\n```\n\n## 死信队列\n\n通过参数`x-dead-letter-exchange`将一个队列设置为死信队列。死信队列的机制是，如果一条消息成为死信 `dead message`，它不是直接丢弃掉，而是在转发到另外一个交换机，由这个交换机来处理这条死信。利用这一机制可达到消息延时的效果——先注册一个没有消费者且设置了过期时间的队列死信队列，投递给这个队列的消息因为没有消费者过一段时间后就会过期成为死信，过期的死信转发到对应的死信交换机里面去分配给其他队列去处理这些消息。上代码：\n\n```java\n//  注册死信队列\n    @Bean(\"dlxQueue\")\n    public Queue dlxQueue(){\n//        new Queue(\"text\",true, false, false,new HashMap<>())\n//        x-dead-letter-exchange声明了队列里的死信转发到的交换机名称\n        Queue build = QueueBuilder.durable(\"dlx-queue\").withArgument(\"x-dead-letter-exchange\", \"gc-exchange\")\n//                dead letter携带的routing-key\n                .withArgument(\"x-dead-letter-routing-key\", \"dlx-key\")\n//                消息在过期的时间\n                .withArgument(\"x-message-ttl\",5000L).build();\n        return build;\n    }\n//  队列的交换机    \n    @Bean(\"dlxExchange\")\n    public DirectExchange  dlxExchange(){\n//        ExchangeBuilder.topicExchange().durable()\n        return new DirectExchange(\"dlx-exchange\");\n    }\n//  真正处理消息的队列\n    @Bean(\"gcQueue\")\n    public Queue gcQueue(){\n        Queue build = QueueBuilder.durable(\"gc-queue\").build();\n        return build;\n    }\n//  略\n    @Bean(\"dlxExchange\")\n    public DirectExchange  dlxExchange(){\n//        ExchangeBuilder.topicExchange().durable()\n        return new DirectExchange(\"dlx-exchange\");\n    }\n\n    @Bean(\"gcExchange\")\n    public DirectExchange  gcExchange(){\n        return new DirectExchange(\"gc-exchange\");\n    }\n\n    @Bean\n    public Binding bindingGcQueue(@Qualifier(\"gcQueue\") Queue queue,@Qualifier(\"gcExchange\")DirectExchange exchange){\n        return BindingBuilder.bind(queue).to(exchange).with(\"dlx-key\");\n    }\n\n    @Bean\n    public Binding bindingDlxQueue(@Qualifier(\"dlxQueue\") Queue queue,@Qualifier(\"dlxExchange\")DirectExchange exchange){\n        return BindingBuilder.bind(queue).to(exchange).with(\"test-dlx\");\n    }\n```\n\n队列和交换机都注册好了，然后我们分别向 `dlx-queue` 分配一个生产者，向 `gc-queue` 分配一个消费者：\n\n```java\n @Scheduled(fixedRate = 1000)\n    private void sendMessageForDlx() {\n        rabbitTemplate.convertAndSend(\"dlx-exchange\",\"test-dlx\",\"test\");\n    }\n    \n    @RabbitListener(queues = { \"gc-queue\"})\n    public void gcMessage(String message){\n        System.out.println(message);\n    }\n```\n\n打开管理界面界面你能看到消息的流转过程`dlx-queue`被写入消息，而 `gc-queue` 却没有消息,然后 `dlx-queue` 消息减少而`gc-queue` 消息增多。最终消息在`gc-queue` 被消费。\n\n##  生产者确认机制\n\n假如我们将消息投递给交换机，而交换机路由不到队列该怎么处理呢？在 springboot 中 如果交换机找不到队列默认是直接丢弃，如果我们想保证消息百分百投递该怎么办呢？我们可以这样配置，将 `mandatory` 参数设为 true：\n\n```proper\nspring.rabbitmq.template.mandatory=true\n\n```\n\n这个参数的作用是：如果消息路由不到队列中去则退还给生产者。我们也可以通过另外两个参数来设置，效果一样：\n\n```properties\nspring.rabbitmq.publisher-returns=true\nspring.rabbitmq.publisher-confirms=true\n```\n\n开启 `publisher-confirms` 和 `publisher-returns` 这两个参数或者 `mandatory` 参数开启的是 生产者的两个监听器 的回调函数 `ConfirmCallback` 和 `ReturnCallback` 。`ConfirmCallback`是在消息发给交换机时被回调，通过这个回调函数我们能知道发送的消息内容，路由键，交换机名称，是否投递成功等内容；而 `ReturnCallback` 则是在交换机路由不到队列的时候被调用。它通过这个回调函数将你的消息退还给你，让你自行处理。上代码：\n\n```java\n@Component\npublic class MyConfirmCallback implements RabbitTemplate.ConfirmCallback {\n    @Override\n    public void confirm(CorrelationData correlationData, boolean b, String s) {\n        System.out.println(\"消息唯一标识：\"+correlationData);\n        System.out.println(\"确认结果：\"+b);\n        System.out.println(\"失败原因：\"+s);\n    }\n}\n\n@Component\npublic class MyReturnCallback implements RabbitTemplate.ReturnCallback {\n\n    @Override\n    public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {\n        System.out.println(\"消息主体 message : \"+message);\n        System.out.println(\"消息主体 message : \"+replyCode);\n        System.out.println(\"描述：\"+replyText);\n        System.out.println(\"消息使用的交换器 exchange : \"+exchange);\n        System.out.println(\"消息使用的路由键 routing : \"+routingKey);\n    }\n\n}\n\n@Component\n@Order(1)\npublic class RabbitConfig {\n    @Autowired\n    public RabbitConfig( RabbitTemplate rabbitTemplate,MyConfirmCallback \t\tconfirmCallback,MyReturnCallback returnCallback){\n        rabbitTemplate.setReturnCallback(returnCallback);\n        rabbitTemplate.setConfirmCallback(confirmCallback);\n    }\n}\n\n@Component\n@Order(5)\npublic class ScheduleHandler {\n    @Autowired\n    private AmqpTemplate rabbitTemplate;\n\n    @Scheduled(fixedRate = 6000)\n    private void simpleQueueSchedule() {\n        System.out.println(\"<<<<<<<<<<\");\n        rabbitTemplate.convertAndSend(\"null-queue\",\"ni----hao\");\n    }\n}\n```\n\n配置好之后我们把消息投递给一个不存在的队列 `null-queue` ，你就会看到两个回调函数依次被触发。通过这个机制，生产者就可以确认消息是否被成功投递。在 rabbit 3.0 版本以前还有一个 `immediate` 参数来保证消息所在队列中有消费者，后来被取消。\n\n## 消费者确认机制\n\n在拉模式下，消费者主动去一条消息，不存在确认问题；而推模式下消费者是被动接收消息的，那么如果消费者不想消费这条消息该怎么办呢，rabbit 提供了消费端确认机制，在 springboot 中消费端确认默认是 `NONE` 自动确认，我们需要设置成手动确认 `manual` 或者根据情况确认 `AUTO` 才能使用这一功能：\n\n```properties\n# 这里的配置是指向容器 SimpleMessageListenerContainer和DirectMessageListenerContainer 后文会介绍\n# spring.rabbitmq.listener.simple.acknowledge-mode=auto\nspring.rabbitmq.listener.direct.acknowledge-mode=auto\n```\n\n改造消费者：\n\n```java\n    @RabbitListener(queues = { \"obj-simple-queue\"})\n    public void testCallBack(Message msg,Channel channel,@Header(AmqpHeaders.DELIVERY_TAG) long tag){\n        try {\n            // 做些啥\n          if (xxx){\n                channel.basicAck(tag,false);\n            }else {\n                channel.basicNack(tag,false,true);\n            }\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.out.println(msg);\n    }\n```\n\n采用消息确认机制后，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直持有消息直到消费者显式调用 `basicAck`  为止。如果 `RabbitMQ` 没有收到回执并检测到消费者的 rabbit 连接断开，则  rabbit  会将该消息发送给其他消费者进行处理。一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的RabbitMQ连接断开。\n\n在代码中有一个参数 `DELIVERY_TAG` 这个参数是投递的标识；当一个消费者向 rabbit 注册后，会建立起一个 `channel` 当 rabbit 向这个 `channel` 投递消息的时候，会附带一个一个单调递增的正整数 `DELIVERY_TAG`，用于标识这是经过 `channel` 的第几条消息，它的范围仅限于该 `channle`。\n\n下面看一下消费者确认和拒绝消息的方法：\n\n```java\nvoid basicNack(long deliveryTag, boolean multiple, boolean requeue)throws IOException;\nvoid basicReject(long deliveryTag, boolean requeue) throws IOException;\nvoid basicAck(long deliveryTag, boolean multiple) throws IOException;\n```\n\n`multiple`：为了减少网络流量，手动确认可以被批处理，当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的channel中缓存的所有消息。`requeue`：消息被拒绝后是否重新进入队列重发。\n\n当 rabbit 队列拥有多个消费者的时候，**队列收到的消息将以轮训的的方式分发到各个消费者**，每条消息只会发送到订阅列表里的一个消费者。这样的会导致一个问题当前一个消费者迟迟不能确认消息的时候，那么下一个消费者只能等。为了解决这个问题，rabbit中 channel 可持有多个未确认消息。可通过配置来指定channel缓存的未确定消息的个数\n\n```java\nspring.rabbitmq.listener.simple.prefetch=3\n```\n\n\n\n消费者的其他相关配置：\n\n```properties\n# 消费者端的重试 这里重试不是重发，而是对channel中的消息无法交给监听方法，或者监听方法抛出异常则进行重试，是发生在消费者内部的\nspring.rabbitmq.listener.simple.retry.enabled=true\n# 初次尝试的时间间隔\nspring.rabbitmq.listener..simple.retry.initial-interval=1000 \n# 最大重试次数\nspring.rabbitmq.listener.simple.retry.max-attempts=3 \n#重试时间间隔。\nspring.rabbitmq.listener.simple.retry.max-interval=10000 \n# 下次重试时间比上次重试时间的倍数\nspring.rabbitmq.listener.simple.retry.multiplier=1.0 \n# 重试是无状态的还是有状态的。\nspring.rabbitmq.listener.simple.retry.stateless=true \n\n# 并发的消费者最小数量 这里指某一时刻所有消费者并发数量（但似乎最小值没有意义啊）\nspring.rabbitmq.listener.concurrency=10\n# 并发的消费者最大数量\nspring.rabbitmq.listener.max-concurrency=20\n```\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","source":"_posts/rabbitMQ-springboot-1.md","raw":"---\ntitle: rabbitMQ 结合 springboot 使用 二\ndate: 2020-12-15\ntags: 中间件\n---\n\n这一章节我们会学习rabbitMQ在项目生产中一些重要的特性，如持久化，消息确认机制，消息过期等特性。只要能利用好这些特性，我们就能开发出可用性强的，功能强大的MQ系统。\n<!--more-->\n##  持久化\n\nRabbitMQ通过消息持久化来保证消息的可靠性——为了保证RabbitMQ在退出或者发生异常情况下数据不会丢失，需要将 queue ，exchange 和 Message 都持久化。下面分别介绍它们持久化配置的方式。\n\n对于 queue ，exchange 在创建的时候都会提供一个参数用以设置是否持久化，而如果使用它们对应的建造者而不是new，就能很清晰的看到是怎么指定持久化的：\n\n```java\n//  创建 queue 指定为非持久化\n    QueueBuilder.nonDurable(\"xxx\").build();\n//  指定持久化\n     return QueueBuilder.durable(\"second-direct-queue\").build();\n//  durable 为true则是持久化，false非持久化\n    ExchangeBuilder.topicExchange(\"topic\").durable(true).build();\n```\n\n这里需要注意一个地方，**直接在原队列的基础上添加属性是会报错的，它会告诉你队列已经存在。需要你手动打开管理界面把那个队列删除掉，然后重启项目**。\n\n你如果将 queue 的持久化标识 durable 设置为true ,则代表是一个持久的队列，那么在服务重启之后，也会存在，因为服务会把持久化的 queue 存放在硬盘上，当服务重启的时候，会重新什么之前被持久化的queue；但是里面的消息是否为持久化还需要看消息是否做了持久化设置。exchange 的持久化和 Queue 一样将交换机保存在磁盘，重启后这个交换机还会存在。\n\n那么消息如何持久化呢？在springboot中需要借助`MessagePostProcessor` 消息加工器对消息进行加工 rabbitMQ 才能知道这个消息是不是要持久化，`MessagePostProcessor`还有其他的很多作用，在后文会介绍。下面看如何进行消息的持久化。\n创建`MessagePostProcessor`类：\n\n```JAVA\npublic class MyMessagePostProcessor implements MessagePostProcessor {\n    \n    @Override\n    public Message postProcessMessage(Message message) throws AmqpException {\n        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);\n        return message;\n    }\n}\n```\n\n生产者通过`MessagePostProcessor`发送消息：\n\n```java\n @Scheduled(fixedRate = 1000)\n    private void sendMessageForDlx() {\n        rabbitTemplate.convertAndSend(\"exchange\",\"routing key\",\"mesage\",new MyMessagePostProcessor());\n    }\n```\n\n消息持久化过程：\n\n> 写入文件前会有一个Buffer,大小为1M,数据在写入文件时，首先会写入到这个Buffer，如果Buffer已满，则会将Buffer写入到文件（未必刷到磁盘）。\n> 有个固定的刷盘时间：25ms,也就是不管Buffer满不满，每个25ms，Buffer里的数据及未刷新到磁盘的文件内容必定会刷到磁盘。\n> 每次消息写入后，如果没有后续写入请求，则会直接将已写入的消息刷到磁盘：使用Erlang的receive x after 0实现，只要进程的信箱里没有消息，则产生一个timeout消息，而timeout会触发刷盘操作。\n> 原文链接：https://blog.csdn.net/u013256816/article/details/60875666\n\n## TTL\n\nRabbitMQ可以对消息和队列设置TTL(消息的过期时间)，消息在队列的生存时间一旦超过设置的TTL值，就称为dead message， 消费者将无法再收到该消息。\n\n- 在队列上设置消息过期时间\n\n设置队列过期加一个参数 `x-message-ttl` 就可以搞定，同样记得先把原队列在管理界面删除再启动项目，才会创建队列成功。创建持久化队列：\n\n```java\n    Queue build = QueueBuilder.durable(\"queue\")\n//      消息过期的时间\n                .withArgument(\"x-message-ttl\",5000L).build();\n```\n\n这种方式设置的过期属性特性是一旦消息过期，就会从队列中抹去（及时性）。\n\n- 通过`MessagePostProcessor`设置消息过期时间\n\n把原来的 `MyMessagePostProcessor` 代码拿过来加一个参数就行了：\n\n```java\npublic class MyMessagePostProcessor implements MessagePostProcessor {\n    private String expirTime;\n\n    public MyMessagePostProcessor(String expirTime){\n        this.expirTime=expirTime;\n    }\n    @Override\n    public Message postProcessMessage(Message message) throws AmqpException {\n//        设置过期时间\n        message.getMessageProperties().setExpiration(expirTime);\n//        设置消息持久化\n        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);\n        return message;\n    }\n}\n```\n\n这种方式设置的过期时间即使消息过期，也不一定会马上从队列中抹去，它会等轮到这个消息即将投递到消费者之前进行判定。如果过期就丢弃，不再投递给消费者\n\n## 优先级\n\n优先级分为消息优先级和队列优先级，队列优先级高的会先被处理，消息优先级高的会先被消费，队列优先级配置参数为`x-max-priority`,配置方式为：\n\n```java\nQueue build = QueueBuilder.durable(\"queue\").withArgument(\"x-max-priority\",10)\n```\n\n配置的数字越大，优先级越高默认优先级为0，消息优先级设置也一样。消息的优先级还是通过 `MessagePostProcessor` 来设置：\n\n```java\n    @Override\n    public Message postProcessMessage(Message message) throws AmqpException {\n        message.getMessageProperties().setPriority(5);\n        return message;\n    }\n```\n\n## 死信队列\n\n通过参数`x-dead-letter-exchange`将一个队列设置为死信队列。死信队列的机制是，如果一条消息成为死信 `dead message`，它不是直接丢弃掉，而是在转发到另外一个交换机，由这个交换机来处理这条死信。利用这一机制可达到消息延时的效果——先注册一个没有消费者且设置了过期时间的队列死信队列，投递给这个队列的消息因为没有消费者过一段时间后就会过期成为死信，过期的死信转发到对应的死信交换机里面去分配给其他队列去处理这些消息。上代码：\n\n```java\n//  注册死信队列\n    @Bean(\"dlxQueue\")\n    public Queue dlxQueue(){\n//        new Queue(\"text\",true, false, false,new HashMap<>())\n//        x-dead-letter-exchange声明了队列里的死信转发到的交换机名称\n        Queue build = QueueBuilder.durable(\"dlx-queue\").withArgument(\"x-dead-letter-exchange\", \"gc-exchange\")\n//                dead letter携带的routing-key\n                .withArgument(\"x-dead-letter-routing-key\", \"dlx-key\")\n//                消息在过期的时间\n                .withArgument(\"x-message-ttl\",5000L).build();\n        return build;\n    }\n//  队列的交换机    \n    @Bean(\"dlxExchange\")\n    public DirectExchange  dlxExchange(){\n//        ExchangeBuilder.topicExchange().durable()\n        return new DirectExchange(\"dlx-exchange\");\n    }\n//  真正处理消息的队列\n    @Bean(\"gcQueue\")\n    public Queue gcQueue(){\n        Queue build = QueueBuilder.durable(\"gc-queue\").build();\n        return build;\n    }\n//  略\n    @Bean(\"dlxExchange\")\n    public DirectExchange  dlxExchange(){\n//        ExchangeBuilder.topicExchange().durable()\n        return new DirectExchange(\"dlx-exchange\");\n    }\n\n    @Bean(\"gcExchange\")\n    public DirectExchange  gcExchange(){\n        return new DirectExchange(\"gc-exchange\");\n    }\n\n    @Bean\n    public Binding bindingGcQueue(@Qualifier(\"gcQueue\") Queue queue,@Qualifier(\"gcExchange\")DirectExchange exchange){\n        return BindingBuilder.bind(queue).to(exchange).with(\"dlx-key\");\n    }\n\n    @Bean\n    public Binding bindingDlxQueue(@Qualifier(\"dlxQueue\") Queue queue,@Qualifier(\"dlxExchange\")DirectExchange exchange){\n        return BindingBuilder.bind(queue).to(exchange).with(\"test-dlx\");\n    }\n```\n\n队列和交换机都注册好了，然后我们分别向 `dlx-queue` 分配一个生产者，向 `gc-queue` 分配一个消费者：\n\n```java\n @Scheduled(fixedRate = 1000)\n    private void sendMessageForDlx() {\n        rabbitTemplate.convertAndSend(\"dlx-exchange\",\"test-dlx\",\"test\");\n    }\n    \n    @RabbitListener(queues = { \"gc-queue\"})\n    public void gcMessage(String message){\n        System.out.println(message);\n    }\n```\n\n打开管理界面界面你能看到消息的流转过程`dlx-queue`被写入消息，而 `gc-queue` 却没有消息,然后 `dlx-queue` 消息减少而`gc-queue` 消息增多。最终消息在`gc-queue` 被消费。\n\n##  生产者确认机制\n\n假如我们将消息投递给交换机，而交换机路由不到队列该怎么处理呢？在 springboot 中 如果交换机找不到队列默认是直接丢弃，如果我们想保证消息百分百投递该怎么办呢？我们可以这样配置，将 `mandatory` 参数设为 true：\n\n```proper\nspring.rabbitmq.template.mandatory=true\n\n```\n\n这个参数的作用是：如果消息路由不到队列中去则退还给生产者。我们也可以通过另外两个参数来设置，效果一样：\n\n```properties\nspring.rabbitmq.publisher-returns=true\nspring.rabbitmq.publisher-confirms=true\n```\n\n开启 `publisher-confirms` 和 `publisher-returns` 这两个参数或者 `mandatory` 参数开启的是 生产者的两个监听器 的回调函数 `ConfirmCallback` 和 `ReturnCallback` 。`ConfirmCallback`是在消息发给交换机时被回调，通过这个回调函数我们能知道发送的消息内容，路由键，交换机名称，是否投递成功等内容；而 `ReturnCallback` 则是在交换机路由不到队列的时候被调用。它通过这个回调函数将你的消息退还给你，让你自行处理。上代码：\n\n```java\n@Component\npublic class MyConfirmCallback implements RabbitTemplate.ConfirmCallback {\n    @Override\n    public void confirm(CorrelationData correlationData, boolean b, String s) {\n        System.out.println(\"消息唯一标识：\"+correlationData);\n        System.out.println(\"确认结果：\"+b);\n        System.out.println(\"失败原因：\"+s);\n    }\n}\n\n@Component\npublic class MyReturnCallback implements RabbitTemplate.ReturnCallback {\n\n    @Override\n    public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {\n        System.out.println(\"消息主体 message : \"+message);\n        System.out.println(\"消息主体 message : \"+replyCode);\n        System.out.println(\"描述：\"+replyText);\n        System.out.println(\"消息使用的交换器 exchange : \"+exchange);\n        System.out.println(\"消息使用的路由键 routing : \"+routingKey);\n    }\n\n}\n\n@Component\n@Order(1)\npublic class RabbitConfig {\n    @Autowired\n    public RabbitConfig( RabbitTemplate rabbitTemplate,MyConfirmCallback \t\tconfirmCallback,MyReturnCallback returnCallback){\n        rabbitTemplate.setReturnCallback(returnCallback);\n        rabbitTemplate.setConfirmCallback(confirmCallback);\n    }\n}\n\n@Component\n@Order(5)\npublic class ScheduleHandler {\n    @Autowired\n    private AmqpTemplate rabbitTemplate;\n\n    @Scheduled(fixedRate = 6000)\n    private void simpleQueueSchedule() {\n        System.out.println(\"<<<<<<<<<<\");\n        rabbitTemplate.convertAndSend(\"null-queue\",\"ni----hao\");\n    }\n}\n```\n\n配置好之后我们把消息投递给一个不存在的队列 `null-queue` ，你就会看到两个回调函数依次被触发。通过这个机制，生产者就可以确认消息是否被成功投递。在 rabbit 3.0 版本以前还有一个 `immediate` 参数来保证消息所在队列中有消费者，后来被取消。\n\n## 消费者确认机制\n\n在拉模式下，消费者主动去一条消息，不存在确认问题；而推模式下消费者是被动接收消息的，那么如果消费者不想消费这条消息该怎么办呢，rabbit 提供了消费端确认机制，在 springboot 中消费端确认默认是 `NONE` 自动确认，我们需要设置成手动确认 `manual` 或者根据情况确认 `AUTO` 才能使用这一功能：\n\n```properties\n# 这里的配置是指向容器 SimpleMessageListenerContainer和DirectMessageListenerContainer 后文会介绍\n# spring.rabbitmq.listener.simple.acknowledge-mode=auto\nspring.rabbitmq.listener.direct.acknowledge-mode=auto\n```\n\n改造消费者：\n\n```java\n    @RabbitListener(queues = { \"obj-simple-queue\"})\n    public void testCallBack(Message msg,Channel channel,@Header(AmqpHeaders.DELIVERY_TAG) long tag){\n        try {\n            // 做些啥\n          if (xxx){\n                channel.basicAck(tag,false);\n            }else {\n                channel.basicNack(tag,false,true);\n            }\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.out.println(msg);\n    }\n```\n\n采用消息确认机制后，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直持有消息直到消费者显式调用 `basicAck`  为止。如果 `RabbitMQ` 没有收到回执并检测到消费者的 rabbit 连接断开，则  rabbit  会将该消息发送给其他消费者进行处理。一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的RabbitMQ连接断开。\n\n在代码中有一个参数 `DELIVERY_TAG` 这个参数是投递的标识；当一个消费者向 rabbit 注册后，会建立起一个 `channel` 当 rabbit 向这个 `channel` 投递消息的时候，会附带一个一个单调递增的正整数 `DELIVERY_TAG`，用于标识这是经过 `channel` 的第几条消息，它的范围仅限于该 `channle`。\n\n下面看一下消费者确认和拒绝消息的方法：\n\n```java\nvoid basicNack(long deliveryTag, boolean multiple, boolean requeue)throws IOException;\nvoid basicReject(long deliveryTag, boolean requeue) throws IOException;\nvoid basicAck(long deliveryTag, boolean multiple) throws IOException;\n```\n\n`multiple`：为了减少网络流量，手动确认可以被批处理，当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的channel中缓存的所有消息。`requeue`：消息被拒绝后是否重新进入队列重发。\n\n当 rabbit 队列拥有多个消费者的时候，**队列收到的消息将以轮训的的方式分发到各个消费者**，每条消息只会发送到订阅列表里的一个消费者。这样的会导致一个问题当前一个消费者迟迟不能确认消息的时候，那么下一个消费者只能等。为了解决这个问题，rabbit中 channel 可持有多个未确认消息。可通过配置来指定channel缓存的未确定消息的个数\n\n```java\nspring.rabbitmq.listener.simple.prefetch=3\n```\n\n\n\n消费者的其他相关配置：\n\n```properties\n# 消费者端的重试 这里重试不是重发，而是对channel中的消息无法交给监听方法，或者监听方法抛出异常则进行重试，是发生在消费者内部的\nspring.rabbitmq.listener.simple.retry.enabled=true\n# 初次尝试的时间间隔\nspring.rabbitmq.listener..simple.retry.initial-interval=1000 \n# 最大重试次数\nspring.rabbitmq.listener.simple.retry.max-attempts=3 \n#重试时间间隔。\nspring.rabbitmq.listener.simple.retry.max-interval=10000 \n# 下次重试时间比上次重试时间的倍数\nspring.rabbitmq.listener.simple.retry.multiplier=1.0 \n# 重试是无状态的还是有状态的。\nspring.rabbitmq.listener.simple.retry.stateless=true \n\n# 并发的消费者最小数量 这里指某一时刻所有消费者并发数量（但似乎最小值没有意义啊）\nspring.rabbitmq.listener.concurrency=10\n# 并发的消费者最大数量\nspring.rabbitmq.listener.max-concurrency=20\n```\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","slug":"rabbitMQ-springboot-1","published":1,"updated":"2021-01-12T03:36:04.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6n002t00wi1x4v7w3v","content":"<p>这一章节我们会学习rabbitMQ在项目生产中一些重要的特性，如持久化，消息确认机制，消息过期等特性。只要能利用好这些特性，我们就能开发出可用性强的，功能强大的MQ系统。</p>\n<a id=\"more\"></a>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>RabbitMQ通过消息持久化来保证消息的可靠性——为了保证RabbitMQ在退出或者发生异常情况下数据不会丢失，需要将 queue ，exchange 和 Message 都持久化。下面分别介绍它们持久化配置的方式。</p>\n<p>对于 queue ，exchange 在创建的时候都会提供一个参数用以设置是否持久化，而如果使用它们对应的建造者而不是new，就能很清晰的看到是怎么指定持久化的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  创建 queue 指定为非持久化</span></span><br><span class=\"line\">    QueueBuilder.nonDurable(<span class=\"string\">&quot;xxx&quot;</span>).build();</span><br><span class=\"line\"><span class=\"comment\">//  指定持久化</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> QueueBuilder.durable(<span class=\"string\">&quot;second-direct-queue&quot;</span>).build();</span><br><span class=\"line\"><span class=\"comment\">//  durable 为true则是持久化，false非持久化</span></span><br><span class=\"line\">    ExchangeBuilder.topicExchange(<span class=\"string\">&quot;topic&quot;</span>).durable(<span class=\"keyword\">true</span>).build();</span><br></pre></td></tr></table></figure>\n<p>这里需要注意一个地方，<strong>直接在原队列的基础上添加属性是会报错的，它会告诉你队列已经存在。需要你手动打开管理界面把那个队列删除掉，然后重启项目</strong>。</p>\n<p>你如果将 queue 的持久化标识 durable 设置为true ,则代表是一个持久的队列，那么在服务重启之后，也会存在，因为服务会把持久化的 queue 存放在硬盘上，当服务重启的时候，会重新什么之前被持久化的queue；但是里面的消息是否为持久化还需要看消息是否做了持久化设置。exchange 的持久化和 Queue 一样将交换机保存在磁盘，重启后这个交换机还会存在。</p>\n<p>那么消息如何持久化呢？在springboot中需要借助<code>MessagePostProcessor</code> 消息加工器对消息进行加工 rabbitMQ 才能知道这个消息是不是要持久化，<code>MessagePostProcessor</code>还有其他的很多作用，在后文会介绍。下面看如何进行消息的持久化。<br>创建<code>MessagePostProcessor</code>类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMessagePostProcessor</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessagePostProcessor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Message <span class=\"title\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException </span>&#123;</span><br><span class=\"line\">        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生产者通过<code>MessagePostProcessor</code>发送消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scheduled(fixedRate = 1000)</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMessageForDlx</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       rabbitTemplate.convertAndSend(<span class=\"string\">&quot;exchange&quot;</span>,<span class=\"string\">&quot;routing key&quot;</span>,<span class=\"string\">&quot;mesage&quot;</span>,<span class=\"keyword\">new</span> MyMessagePostProcessor());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>消息持久化过程：</p>\n<blockquote>\n<p>写入文件前会有一个Buffer,大小为1M,数据在写入文件时，首先会写入到这个Buffer，如果Buffer已满，则会将Buffer写入到文件（未必刷到磁盘）。<br>有个固定的刷盘时间：25ms,也就是不管Buffer满不满，每个25ms，Buffer里的数据及未刷新到磁盘的文件内容必定会刷到磁盘。<br>每次消息写入后，如果没有后续写入请求，则会直接将已写入的消息刷到磁盘：使用Erlang的receive x after 0实现，只要进程的信箱里没有消息，则产生一个timeout消息，而timeout会触发刷盘操作。<br>原文链接：<a href=\"https://blog.csdn.net/u013256816/article/details/60875666\">https://blog.csdn.net/u013256816/article/details/60875666</a></p>\n</blockquote>\n<h2 id=\"TTL\"><a href=\"#TTL\" class=\"headerlink\" title=\"TTL\"></a>TTL</h2><p>RabbitMQ可以对消息和队列设置TTL(消息的过期时间)，消息在队列的生存时间一旦超过设置的TTL值，就称为dead message， 消费者将无法再收到该消息。</p>\n<ul>\n<li>在队列上设置消息过期时间</li>\n</ul>\n<p>设置队列过期加一个参数 <code>x-message-ttl</code> 就可以搞定，同样记得先把原队列在管理界面删除再启动项目，才会创建队列成功。创建持久化队列：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    Queue build = QueueBuilder.durable(<span class=\"string\">&quot;queue&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//      消息过期的时间</span></span><br><span class=\"line\">                .withArgument(<span class=\"string\">&quot;x-message-ttl&quot;</span>,<span class=\"number\">5000L</span>).build();</span><br></pre></td></tr></table></figure>\n<p>这种方式设置的过期属性特性是一旦消息过期，就会从队列中抹去（及时性）。</p>\n<ul>\n<li>通过<code>MessagePostProcessor</code>设置消息过期时间</li>\n</ul>\n<p>把原来的 <code>MyMessagePostProcessor</code> 代码拿过来加一个参数就行了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMessagePostProcessor</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessagePostProcessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String expirTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyMessagePostProcessor</span><span class=\"params\">(String expirTime)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.expirTime=expirTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Message <span class=\"title\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        设置过期时间</span></span><br><span class=\"line\">        message.getMessageProperties().setExpiration(expirTime);</span><br><span class=\"line\"><span class=\"comment\">//        设置消息持久化</span></span><br><span class=\"line\">        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式设置的过期时间即使消息过期，也不一定会马上从队列中抹去，它会等轮到这个消息即将投递到消费者之前进行判定。如果过期就丢弃，不再投递给消费者</p>\n<h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><p>优先级分为消息优先级和队列优先级，队列优先级高的会先被处理，消息优先级高的会先被消费，队列优先级配置参数为<code>x-max-priority</code>,配置方式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Queue build = QueueBuilder.durable(<span class=\"string\">&quot;queue&quot;</span>).withArgument(<span class=\"string\">&quot;x-max-priority&quot;</span>,<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>配置的数字越大，优先级越高默认优先级为0，消息优先级设置也一样。消息的优先级还是通过 <code>MessagePostProcessor</code> 来设置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Message <span class=\"title\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException </span>&#123;</span><br><span class=\"line\">    message.getMessageProperties().setPriority(<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"死信队列\"><a href=\"#死信队列\" class=\"headerlink\" title=\"死信队列\"></a>死信队列</h2><p>通过参数<code>x-dead-letter-exchange</code>将一个队列设置为死信队列。死信队列的机制是，如果一条消息成为死信 <code>dead message</code>，它不是直接丢弃掉，而是在转发到另外一个交换机，由这个交换机来处理这条死信。利用这一机制可达到消息延时的效果——先注册一个没有消费者且设置了过期时间的队列死信队列，投递给这个队列的消息因为没有消费者过一段时间后就会过期成为死信，过期的死信转发到对应的死信交换机里面去分配给其他队列去处理这些消息。上代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  注册死信队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;dlxQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">dlxQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        new Queue(&quot;text&quot;,true, false, false,new HashMap&lt;&gt;())</span></span><br><span class=\"line\"><span class=\"comment\">//        x-dead-letter-exchange声明了队列里的死信转发到的交换机名称</span></span><br><span class=\"line\">        Queue build = QueueBuilder.durable(<span class=\"string\">&quot;dlx-queue&quot;</span>).withArgument(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, <span class=\"string\">&quot;gc-exchange&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//                dead letter携带的routing-key</span></span><br><span class=\"line\">                .withArgument(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;dlx-key&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//                消息在过期的时间</span></span><br><span class=\"line\">                .withArgument(<span class=\"string\">&quot;x-message-ttl&quot;</span>,<span class=\"number\">5000L</span>).build();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> build;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//  队列的交换机    </span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;dlxExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange  <span class=\"title\">dlxExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        ExchangeBuilder.topicExchange().durable()</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;dlx-exchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//  真正处理消息的队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;gcQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">gcQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Queue build = QueueBuilder.durable(<span class=\"string\">&quot;gc-queue&quot;</span>).build();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> build;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//  略</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;dlxExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange  <span class=\"title\">dlxExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        ExchangeBuilder.topicExchange().durable()</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;dlx-exchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;gcExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange  <span class=\"title\">gcExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;gc-exchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bindingGcQueue</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;gcQueue&quot;)</span> Queue queue,<span class=\"meta\">@Qualifier(&quot;gcExchange&quot;)</span>DirectExchange exchange)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;dlx-key&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bindingDlxQueue</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;dlxQueue&quot;)</span> Queue queue,<span class=\"meta\">@Qualifier(&quot;dlxExchange&quot;)</span>DirectExchange exchange)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;test-dlx&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>队列和交换机都注册好了，然后我们分别向 <code>dlx-queue</code> 分配一个生产者，向 <code>gc-queue</code> 分配一个消费者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scheduled(fixedRate = 1000)</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMessageForDlx</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       rabbitTemplate.convertAndSend(<span class=\"string\">&quot;dlx-exchange&quot;</span>,<span class=\"string\">&quot;test-dlx&quot;</span>,<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"meta\">@RabbitListener(queues = &#123; &quot;gc-queue&quot;&#125;)</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">gcMessage</span><span class=\"params\">(String message)</span></span>&#123;</span><br><span class=\"line\">       System.out.println(message);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>打开管理界面界面你能看到消息的流转过程<code>dlx-queue</code>被写入消息，而 <code>gc-queue</code> 却没有消息,然后 <code>dlx-queue</code> 消息减少而<code>gc-queue</code> 消息增多。最终消息在<code>gc-queue</code> 被消费。</p>\n<h2 id=\"生产者确认机制\"><a href=\"#生产者确认机制\" class=\"headerlink\" title=\"生产者确认机制\"></a>生产者确认机制</h2><p>假如我们将消息投递给交换机，而交换机路由不到队列该怎么处理呢？在 springboot 中 如果交换机找不到队列默认是直接丢弃，如果我们想保证消息百分百投递该怎么办呢？我们可以这样配置，将 <code>mandatory</code> 参数设为 true：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.rabbitmq.template.mandatory&#x3D;true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这个参数的作用是：如果消息路由不到队列中去则退还给生产者。我们也可以通过另外两个参数来设置，效果一样：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.rabbitmq.publisher-returns</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.publisher-confirms</span>=<span class=\"string\">true</span></span><br></pre></td></tr></table></figure>\n<p>开启 <code>publisher-confirms</code> 和 <code>publisher-returns</code> 这两个参数或者 <code>mandatory</code> 参数开启的是 生产者的两个监听器 的回调函数 <code>ConfirmCallback</code> 和 <code>ReturnCallback</code> 。<code>ConfirmCallback</code>是在消息发给交换机时被回调，通过这个回调函数我们能知道发送的消息内容，路由键，交换机名称，是否投递成功等内容；而 <code>ReturnCallback</code> 则是在交换机路由不到队列的时候被调用。它通过这个回调函数将你的消息退还给你，让你自行处理。上代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfirmCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ConfirmCallback</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"keyword\">boolean</span> b, String s)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息唯一标识：&quot;</span>+correlationData);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;确认结果：&quot;</span>+b);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;失败原因：&quot;</span>+s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyReturnCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ReturnCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"keyword\">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息主体 message : &quot;</span>+message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息主体 message : &quot;</span>+replyCode);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;描述：&quot;</span>+replyText);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息使用的交换器 exchange : &quot;</span>+exchange);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息使用的路由键 routing : &quot;</span>+routingKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Order(1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RabbitConfig</span><span class=\"params\">( RabbitTemplate rabbitTemplate,MyConfirmCallback \t\tconfirmCallback,MyReturnCallback returnCallback)</span></span>&#123;</span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Order(5)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AmqpTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">simpleQueueSchedule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;null-queue&quot;</span>,<span class=\"string\">&quot;ni----hao&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置好之后我们把消息投递给一个不存在的队列 <code>null-queue</code> ，你就会看到两个回调函数依次被触发。通过这个机制，生产者就可以确认消息是否被成功投递。在 rabbit 3.0 版本以前还有一个 <code>immediate</code> 参数来保证消息所在队列中有消费者，后来被取消。</p>\n<h2 id=\"消费者确认机制\"><a href=\"#消费者确认机制\" class=\"headerlink\" title=\"消费者确认机制\"></a>消费者确认机制</h2><p>在拉模式下，消费者主动去一条消息，不存在确认问题；而推模式下消费者是被动接收消息的，那么如果消费者不想消费这条消息该怎么办呢，rabbit 提供了消费端确认机制，在 springboot 中消费端确认默认是 <code>NONE</code> 自动确认，我们需要设置成手动确认 <code>manual</code> 或者根据情况确认 <code>AUTO</code> 才能使用这一功能：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里的配置是指向容器 SimpleMessageListenerContainer和DirectMessageListenerContainer 后文会介绍</span></span><br><span class=\"line\"><span class=\"comment\"># spring.rabbitmq.listener.simple.acknowledge-mode=auto</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.direct.acknowledge-mode</span>=<span class=\"string\">auto</span></span><br></pre></td></tr></table></figure>\n<p>改造消费者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &#123; &quot;obj-simple-queue&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCallBack</span><span class=\"params\">(Message msg,Channel channel,<span class=\"meta\">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class=\"keyword\">long</span> tag)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 做些啥</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (xxx)&#123;</span><br><span class=\"line\">            channel.basicAck(tag,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            channel.basicNack(tag,<span class=\"keyword\">false</span>,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采用消息确认机制后，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直持有消息直到消费者显式调用 <code>basicAck</code>  为止。如果 <code>RabbitMQ</code> 没有收到回执并检测到消费者的 rabbit 连接断开，则  rabbit  会将该消息发送给其他消费者进行处理。一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的RabbitMQ连接断开。</p>\n<p>在代码中有一个参数 <code>DELIVERY_TAG</code> 这个参数是投递的标识；当一个消费者向 rabbit 注册后，会建立起一个 <code>channel</code> 当 rabbit 向这个 <code>channel</code> 投递消息的时候，会附带一个一个单调递增的正整数 <code>DELIVERY_TAG</code>，用于标识这是经过 <code>channel</code> 的第几条消息，它的范围仅限于该 <code>channle</code>。</p>\n<p>下面看一下消费者确认和拒绝消息的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicNack</span><span class=\"params\">(<span class=\"keyword\">long</span> deliveryTag, <span class=\"keyword\">boolean</span> multiple, <span class=\"keyword\">boolean</span> requeue)</span><span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicReject</span><span class=\"params\">(<span class=\"keyword\">long</span> deliveryTag, <span class=\"keyword\">boolean</span> requeue)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicAck</span><span class=\"params\">(<span class=\"keyword\">long</span> deliveryTag, <span class=\"keyword\">boolean</span> multiple)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>\n<p><code>multiple</code>：为了减少网络流量，手动确认可以被批处理，当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的channel中缓存的所有消息。<code>requeue</code>：消息被拒绝后是否重新进入队列重发。</p>\n<p>当 rabbit 队列拥有多个消费者的时候，<strong>队列收到的消息将以轮训的的方式分发到各个消费者</strong>，每条消息只会发送到订阅列表里的一个消费者。这样的会导致一个问题当前一个消费者迟迟不能确认消息的时候，那么下一个消费者只能等。为了解决这个问题，rabbit中 channel 可持有多个未确认消息。可通过配置来指定channel缓存的未确定消息的个数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.rabbitmq.listener.simple.prefetch=<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n\n<p>消费者的其他相关配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 消费者端的重试 这里重试不是重发，而是对channel中的消息无法交给监听方法，或者监听方法抛出异常则进行重试，是发生在消费者内部的</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.simple.retry.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 初次尝试的时间间隔</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener..simple.retry.initial-interval</span>=<span class=\"string\">1000 </span></span><br><span class=\"line\"><span class=\"comment\"># 最大重试次数</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.simple.retry.max-attempts</span>=<span class=\"string\">3 </span></span><br><span class=\"line\"><span class=\"comment\">#重试时间间隔。</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.simple.retry.max-interval</span>=<span class=\"string\">10000 </span></span><br><span class=\"line\"><span class=\"comment\"># 下次重试时间比上次重试时间的倍数</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.simple.retry.multiplier</span>=<span class=\"string\">1.0 </span></span><br><span class=\"line\"><span class=\"comment\"># 重试是无状态的还是有状态的。</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.simple.retry.stateless</span>=<span class=\"string\">true </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 并发的消费者最小数量 这里指某一时刻所有消费者并发数量（但似乎最小值没有意义啊）</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.concurrency</span>=<span class=\"string\">10</span></span><br><span class=\"line\"><span class=\"comment\"># 并发的消费者最大数量</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.max-concurrency</span>=<span class=\"string\">20</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>\n","site":{"data":{}},"excerpt":"<p>这一章节我们会学习rabbitMQ在项目生产中一些重要的特性，如持久化，消息确认机制，消息过期等特性。只要能利用好这些特性，我们就能开发出可用性强的，功能强大的MQ系统。</p>","more":"<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>RabbitMQ通过消息持久化来保证消息的可靠性——为了保证RabbitMQ在退出或者发生异常情况下数据不会丢失，需要将 queue ，exchange 和 Message 都持久化。下面分别介绍它们持久化配置的方式。</p>\n<p>对于 queue ，exchange 在创建的时候都会提供一个参数用以设置是否持久化，而如果使用它们对应的建造者而不是new，就能很清晰的看到是怎么指定持久化的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  创建 queue 指定为非持久化</span></span><br><span class=\"line\">    QueueBuilder.nonDurable(<span class=\"string\">&quot;xxx&quot;</span>).build();</span><br><span class=\"line\"><span class=\"comment\">//  指定持久化</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> QueueBuilder.durable(<span class=\"string\">&quot;second-direct-queue&quot;</span>).build();</span><br><span class=\"line\"><span class=\"comment\">//  durable 为true则是持久化，false非持久化</span></span><br><span class=\"line\">    ExchangeBuilder.topicExchange(<span class=\"string\">&quot;topic&quot;</span>).durable(<span class=\"keyword\">true</span>).build();</span><br></pre></td></tr></table></figure>\n<p>这里需要注意一个地方，<strong>直接在原队列的基础上添加属性是会报错的，它会告诉你队列已经存在。需要你手动打开管理界面把那个队列删除掉，然后重启项目</strong>。</p>\n<p>你如果将 queue 的持久化标识 durable 设置为true ,则代表是一个持久的队列，那么在服务重启之后，也会存在，因为服务会把持久化的 queue 存放在硬盘上，当服务重启的时候，会重新什么之前被持久化的queue；但是里面的消息是否为持久化还需要看消息是否做了持久化设置。exchange 的持久化和 Queue 一样将交换机保存在磁盘，重启后这个交换机还会存在。</p>\n<p>那么消息如何持久化呢？在springboot中需要借助<code>MessagePostProcessor</code> 消息加工器对消息进行加工 rabbitMQ 才能知道这个消息是不是要持久化，<code>MessagePostProcessor</code>还有其他的很多作用，在后文会介绍。下面看如何进行消息的持久化。<br>创建<code>MessagePostProcessor</code>类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMessagePostProcessor</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessagePostProcessor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Message <span class=\"title\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException </span>&#123;</span><br><span class=\"line\">        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生产者通过<code>MessagePostProcessor</code>发送消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scheduled(fixedRate = 1000)</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMessageForDlx</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       rabbitTemplate.convertAndSend(<span class=\"string\">&quot;exchange&quot;</span>,<span class=\"string\">&quot;routing key&quot;</span>,<span class=\"string\">&quot;mesage&quot;</span>,<span class=\"keyword\">new</span> MyMessagePostProcessor());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>消息持久化过程：</p>\n<blockquote>\n<p>写入文件前会有一个Buffer,大小为1M,数据在写入文件时，首先会写入到这个Buffer，如果Buffer已满，则会将Buffer写入到文件（未必刷到磁盘）。<br>有个固定的刷盘时间：25ms,也就是不管Buffer满不满，每个25ms，Buffer里的数据及未刷新到磁盘的文件内容必定会刷到磁盘。<br>每次消息写入后，如果没有后续写入请求，则会直接将已写入的消息刷到磁盘：使用Erlang的receive x after 0实现，只要进程的信箱里没有消息，则产生一个timeout消息，而timeout会触发刷盘操作。<br>原文链接：<a href=\"https://blog.csdn.net/u013256816/article/details/60875666\">https://blog.csdn.net/u013256816/article/details/60875666</a></p>\n</blockquote>\n<h2 id=\"TTL\"><a href=\"#TTL\" class=\"headerlink\" title=\"TTL\"></a>TTL</h2><p>RabbitMQ可以对消息和队列设置TTL(消息的过期时间)，消息在队列的生存时间一旦超过设置的TTL值，就称为dead message， 消费者将无法再收到该消息。</p>\n<ul>\n<li>在队列上设置消息过期时间</li>\n</ul>\n<p>设置队列过期加一个参数 <code>x-message-ttl</code> 就可以搞定，同样记得先把原队列在管理界面删除再启动项目，才会创建队列成功。创建持久化队列：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    Queue build = QueueBuilder.durable(<span class=\"string\">&quot;queue&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//      消息过期的时间</span></span><br><span class=\"line\">                .withArgument(<span class=\"string\">&quot;x-message-ttl&quot;</span>,<span class=\"number\">5000L</span>).build();</span><br></pre></td></tr></table></figure>\n<p>这种方式设置的过期属性特性是一旦消息过期，就会从队列中抹去（及时性）。</p>\n<ul>\n<li>通过<code>MessagePostProcessor</code>设置消息过期时间</li>\n</ul>\n<p>把原来的 <code>MyMessagePostProcessor</code> 代码拿过来加一个参数就行了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMessagePostProcessor</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessagePostProcessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String expirTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyMessagePostProcessor</span><span class=\"params\">(String expirTime)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.expirTime=expirTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Message <span class=\"title\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        设置过期时间</span></span><br><span class=\"line\">        message.getMessageProperties().setExpiration(expirTime);</span><br><span class=\"line\"><span class=\"comment\">//        设置消息持久化</span></span><br><span class=\"line\">        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式设置的过期时间即使消息过期，也不一定会马上从队列中抹去，它会等轮到这个消息即将投递到消费者之前进行判定。如果过期就丢弃，不再投递给消费者</p>\n<h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><p>优先级分为消息优先级和队列优先级，队列优先级高的会先被处理，消息优先级高的会先被消费，队列优先级配置参数为<code>x-max-priority</code>,配置方式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Queue build = QueueBuilder.durable(<span class=\"string\">&quot;queue&quot;</span>).withArgument(<span class=\"string\">&quot;x-max-priority&quot;</span>,<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>配置的数字越大，优先级越高默认优先级为0，消息优先级设置也一样。消息的优先级还是通过 <code>MessagePostProcessor</code> 来设置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Message <span class=\"title\">postProcessMessage</span><span class=\"params\">(Message message)</span> <span class=\"keyword\">throws</span> AmqpException </span>&#123;</span><br><span class=\"line\">    message.getMessageProperties().setPriority(<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"死信队列\"><a href=\"#死信队列\" class=\"headerlink\" title=\"死信队列\"></a>死信队列</h2><p>通过参数<code>x-dead-letter-exchange</code>将一个队列设置为死信队列。死信队列的机制是，如果一条消息成为死信 <code>dead message</code>，它不是直接丢弃掉，而是在转发到另外一个交换机，由这个交换机来处理这条死信。利用这一机制可达到消息延时的效果——先注册一个没有消费者且设置了过期时间的队列死信队列，投递给这个队列的消息因为没有消费者过一段时间后就会过期成为死信，过期的死信转发到对应的死信交换机里面去分配给其他队列去处理这些消息。上代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  注册死信队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;dlxQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">dlxQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        new Queue(&quot;text&quot;,true, false, false,new HashMap&lt;&gt;())</span></span><br><span class=\"line\"><span class=\"comment\">//        x-dead-letter-exchange声明了队列里的死信转发到的交换机名称</span></span><br><span class=\"line\">        Queue build = QueueBuilder.durable(<span class=\"string\">&quot;dlx-queue&quot;</span>).withArgument(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, <span class=\"string\">&quot;gc-exchange&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//                dead letter携带的routing-key</span></span><br><span class=\"line\">                .withArgument(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;dlx-key&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//                消息在过期的时间</span></span><br><span class=\"line\">                .withArgument(<span class=\"string\">&quot;x-message-ttl&quot;</span>,<span class=\"number\">5000L</span>).build();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> build;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//  队列的交换机    </span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;dlxExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange  <span class=\"title\">dlxExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        ExchangeBuilder.topicExchange().durable()</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;dlx-exchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//  真正处理消息的队列</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;gcQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">gcQueue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Queue build = QueueBuilder.durable(<span class=\"string\">&quot;gc-queue&quot;</span>).build();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> build;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//  略</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;dlxExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange  <span class=\"title\">dlxExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        ExchangeBuilder.topicExchange().durable()</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;dlx-exchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;gcExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange  <span class=\"title\">gcExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;gc-exchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bindingGcQueue</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;gcQueue&quot;)</span> Queue queue,<span class=\"meta\">@Qualifier(&quot;gcExchange&quot;)</span>DirectExchange exchange)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;dlx-key&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bindingDlxQueue</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;dlxQueue&quot;)</span> Queue queue,<span class=\"meta\">@Qualifier(&quot;dlxExchange&quot;)</span>DirectExchange exchange)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;test-dlx&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>队列和交换机都注册好了，然后我们分别向 <code>dlx-queue</code> 分配一个生产者，向 <code>gc-queue</code> 分配一个消费者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scheduled(fixedRate = 1000)</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMessageForDlx</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       rabbitTemplate.convertAndSend(<span class=\"string\">&quot;dlx-exchange&quot;</span>,<span class=\"string\">&quot;test-dlx&quot;</span>,<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"meta\">@RabbitListener(queues = &#123; &quot;gc-queue&quot;&#125;)</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">gcMessage</span><span class=\"params\">(String message)</span></span>&#123;</span><br><span class=\"line\">       System.out.println(message);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>打开管理界面界面你能看到消息的流转过程<code>dlx-queue</code>被写入消息，而 <code>gc-queue</code> 却没有消息,然后 <code>dlx-queue</code> 消息减少而<code>gc-queue</code> 消息增多。最终消息在<code>gc-queue</code> 被消费。</p>\n<h2 id=\"生产者确认机制\"><a href=\"#生产者确认机制\" class=\"headerlink\" title=\"生产者确认机制\"></a>生产者确认机制</h2><p>假如我们将消息投递给交换机，而交换机路由不到队列该怎么处理呢？在 springboot 中 如果交换机找不到队列默认是直接丢弃，如果我们想保证消息百分百投递该怎么办呢？我们可以这样配置，将 <code>mandatory</code> 参数设为 true：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.rabbitmq.template.mandatory&#x3D;true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这个参数的作用是：如果消息路由不到队列中去则退还给生产者。我们也可以通过另外两个参数来设置，效果一样：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.rabbitmq.publisher-returns</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.publisher-confirms</span>=<span class=\"string\">true</span></span><br></pre></td></tr></table></figure>\n<p>开启 <code>publisher-confirms</code> 和 <code>publisher-returns</code> 这两个参数或者 <code>mandatory</code> 参数开启的是 生产者的两个监听器 的回调函数 <code>ConfirmCallback</code> 和 <code>ReturnCallback</code> 。<code>ConfirmCallback</code>是在消息发给交换机时被回调，通过这个回调函数我们能知道发送的消息内容，路由键，交换机名称，是否投递成功等内容；而 <code>ReturnCallback</code> 则是在交换机路由不到队列的时候被调用。它通过这个回调函数将你的消息退还给你，让你自行处理。上代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfirmCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ConfirmCallback</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"keyword\">boolean</span> b, String s)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息唯一标识：&quot;</span>+correlationData);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;确认结果：&quot;</span>+b);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;失败原因：&quot;</span>+s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyReturnCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">RabbitTemplate</span>.<span class=\"title\">ReturnCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"keyword\">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息主体 message : &quot;</span>+message);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息主体 message : &quot;</span>+replyCode);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;描述：&quot;</span>+replyText);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息使用的交换器 exchange : &quot;</span>+exchange);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;消息使用的路由键 routing : &quot;</span>+routingKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Order(1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RabbitConfig</span><span class=\"params\">( RabbitTemplate rabbitTemplate,MyConfirmCallback \t\tconfirmCallback,MyReturnCallback returnCallback)</span></span>&#123;</span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Order(5)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AmqpTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">simpleQueueSchedule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;null-queue&quot;</span>,<span class=\"string\">&quot;ni----hao&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>配置好之后我们把消息投递给一个不存在的队列 <code>null-queue</code> ，你就会看到两个回调函数依次被触发。通过这个机制，生产者就可以确认消息是否被成功投递。在 rabbit 3.0 版本以前还有一个 <code>immediate</code> 参数来保证消息所在队列中有消费者，后来被取消。</p>\n<h2 id=\"消费者确认机制\"><a href=\"#消费者确认机制\" class=\"headerlink\" title=\"消费者确认机制\"></a>消费者确认机制</h2><p>在拉模式下，消费者主动去一条消息，不存在确认问题；而推模式下消费者是被动接收消息的，那么如果消费者不想消费这条消息该怎么办呢，rabbit 提供了消费端确认机制，在 springboot 中消费端确认默认是 <code>NONE</code> 自动确认，我们需要设置成手动确认 <code>manual</code> 或者根据情况确认 <code>AUTO</code> 才能使用这一功能：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 这里的配置是指向容器 SimpleMessageListenerContainer和DirectMessageListenerContainer 后文会介绍</span></span><br><span class=\"line\"><span class=\"comment\"># spring.rabbitmq.listener.simple.acknowledge-mode=auto</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.direct.acknowledge-mode</span>=<span class=\"string\">auto</span></span><br></pre></td></tr></table></figure>\n<p>改造消费者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &#123; &quot;obj-simple-queue&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCallBack</span><span class=\"params\">(Message msg,Channel channel,<span class=\"meta\">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class=\"keyword\">long</span> tag)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 做些啥</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (xxx)&#123;</span><br><span class=\"line\">            channel.basicAck(tag,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            channel.basicNack(tag,<span class=\"keyword\">false</span>,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采用消息确认机制后，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为RabbitMQ会一直持有消息直到消费者显式调用 <code>basicAck</code>  为止。如果 <code>RabbitMQ</code> 没有收到回执并检测到消费者的 rabbit 连接断开，则  rabbit  会将该消息发送给其他消费者进行处理。一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的RabbitMQ连接断开。</p>\n<p>在代码中有一个参数 <code>DELIVERY_TAG</code> 这个参数是投递的标识；当一个消费者向 rabbit 注册后，会建立起一个 <code>channel</code> 当 rabbit 向这个 <code>channel</code> 投递消息的时候，会附带一个一个单调递增的正整数 <code>DELIVERY_TAG</code>，用于标识这是经过 <code>channel</code> 的第几条消息，它的范围仅限于该 <code>channle</code>。</p>\n<p>下面看一下消费者确认和拒绝消息的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicNack</span><span class=\"params\">(<span class=\"keyword\">long</span> deliveryTag, <span class=\"keyword\">boolean</span> multiple, <span class=\"keyword\">boolean</span> requeue)</span><span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicReject</span><span class=\"params\">(<span class=\"keyword\">long</span> deliveryTag, <span class=\"keyword\">boolean</span> requeue)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">basicAck</span><span class=\"params\">(<span class=\"keyword\">long</span> deliveryTag, <span class=\"keyword\">boolean</span> multiple)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>\n<p><code>multiple</code>：为了减少网络流量，手动确认可以被批处理，当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的channel中缓存的所有消息。<code>requeue</code>：消息被拒绝后是否重新进入队列重发。</p>\n<p>当 rabbit 队列拥有多个消费者的时候，<strong>队列收到的消息将以轮训的的方式分发到各个消费者</strong>，每条消息只会发送到订阅列表里的一个消费者。这样的会导致一个问题当前一个消费者迟迟不能确认消息的时候，那么下一个消费者只能等。为了解决这个问题，rabbit中 channel 可持有多个未确认消息。可通过配置来指定channel缓存的未确定消息的个数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.rabbitmq.listener.simple.prefetch=<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n\n<p>消费者的其他相关配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 消费者端的重试 这里重试不是重发，而是对channel中的消息无法交给监听方法，或者监听方法抛出异常则进行重试，是发生在消费者内部的</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.simple.retry.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 初次尝试的时间间隔</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener..simple.retry.initial-interval</span>=<span class=\"string\">1000 </span></span><br><span class=\"line\"><span class=\"comment\"># 最大重试次数</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.simple.retry.max-attempts</span>=<span class=\"string\">3 </span></span><br><span class=\"line\"><span class=\"comment\">#重试时间间隔。</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.simple.retry.max-interval</span>=<span class=\"string\">10000 </span></span><br><span class=\"line\"><span class=\"comment\"># 下次重试时间比上次重试时间的倍数</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.simple.retry.multiplier</span>=<span class=\"string\">1.0 </span></span><br><span class=\"line\"><span class=\"comment\"># 重试是无状态的还是有状态的。</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.simple.retry.stateless</span>=<span class=\"string\">true </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 并发的消费者最小数量 这里指某一时刻所有消费者并发数量（但似乎最小值没有意义啊）</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.concurrency</span>=<span class=\"string\">10</span></span><br><span class=\"line\"><span class=\"comment\"># 并发的消费者最大数量</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.listener.max-concurrency</span>=<span class=\"string\">20</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>"},{"title":"rabbitMQ 结合 springboot 使用 一","date":"2020-12-13T16:00:00.000Z","_content":"\n从这一节开始我们进入rabbitMQ的实战环节，项目环境是spring-boot 加maven。首先让我们创建一个spring-boot项目，然后引入web依赖和 rabbitMQ的依赖\n<!--more-->\n```xml\n <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n </dependency>\n <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n```\n\napplication.properties\n\n```properties\nspring.rabbitmq.host=localhost\nspring.rabbitmq.username=guest\nspring.activemq.password=guest\n```\n\n环境搭建好之后我们就可以开始进行实战操作了。\n\n## 简单消息队列\n\nspringboot会默认为你创建一个`direct exchange`类型交换机，其名称为`\"\"`空字符串，其路由键和绑定键都是队列名称，未指定交换机的队列都会绑定到这个交换机上去。我们就以这个最简单的消息队列开始来学习如何在项目中使用`rabbitMQ`。\n\n我们先注册两个队列，一个用于传递String类型消息，一个传递Object类型的数据。项目启动后springboot会为你在 rabbitMQ 中创建两个队列，启动项目后打开 rabbitMQ 的 web 管理界面（以下简称管理界面）会在 Queues 中看到这两个队列的相关信息。\n\n```java\n@Component\npublic class QueueConfig {\n    @Bean\n    public Queue getSimpleQueue() {\n        return new Queue(\"simple-queue\");\n    }\n\n    @Bean\n    public Queue getObjSimpleQueue() {\n        return new Queue(\"obj-simple-queue\");\n    }\n}\n```\n\n创建两个定时任务，向 rabbitMQ 投递消息，注意这里需要在启动类上加 `@EnableScheduling` 注解以启动定时任务，而 `Message` 是我创建的实体类：\n\n```java\n@Component\npublic class ScheduleHandler {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @Scheduled(fixedRate = 6000)\n    private void simpleQueueSchedule() {\n        System.out.println(\"<<<<<<<<<<\");\n\n        rabbitTemplate.convertAndSend(\"simple-queue\",\"ni----hao\");\n    }\n\n    @Scheduled(fixedRate = 6000)\n    private void objSimpleQueueSchedule() {\n        System.out.println(\"<<<<<<<<<<\");\n        Message message = new Message();\n        message.setTitle(\"hello\");\n        message.setContent(\"how are you \");\n        rabbitTemplate.convertAndSend(\"obj-simple-queue\",message);\n    }\n\n}\n```\n\n消费者消费消息：\n\n```java\n@Component\npublic class QueueMessageHandler {\n\n    @RabbitListener(queues = { \"simple-queue\"})\n    public void getSimpleQueueMessage(String msg){\n        System.out.println(msg);\n    }\n\n    @RabbitListener(queues = { \"obj-simple-queue\"})\n    public void getObjSimpleQueueMessage(Message msg){\n        System.out.println(msg);\n    }\n\n}\n```\n\n`rabbitTemplate.convertAndSend()`方法是将数据序列化并写入队列中，而其使用的序列化协议自然是java序列化协议（使用 `ObjectInputStream` 和 `ObjectOutputStream` 读写），因此你如果调用这个方法则其实体类需要实现`Serializable`接口，而如果跨虚拟机还需要注意 `serialVersionUID`。如果跨平台了，那么最好使用其他序列化的方式,序列化反序列化配置在后文关于**监听器容器**的章节介绍。\n\n## 推模式和拉模式\n\n对消费端而言使用`@RabbitListener`监听器获取MQ消息的方式称为`推模式`，我们还可以使用拉模式，当我们需要一条消息的时候才从队列中拉一条消息出来，使用的方法为 `rabbitTemplate.receiveAndConvert()`，如：\n\n```\n  Message o = ((Message) rabbitTemplate.receiveAndConvert(\"obj-simple-queue\"));\n```\n\n##  direct exchange 直连交换机\n\n直连交换机，需要注册一个 `DirectExchange` , `Queue` , `Binding` 。`Bingding` 负责将 `DirectExchange` 和 `Queue` 绑定并指定 `routingKey` 生产者生产消息的时候也需要指定 `routingKey`。下面看示例：\n\n```java\n//  生产端配置\n    @Bean(\"directQueueFirst\")\n    public Queue directQueueFirst() {\n        return new Queue(\"first-direct-queue\");\n    }\n\n    @Bean(\"directQueueSecond\")\n    public Queue directQueueSecond() {\n        return QueueBuilder.durable(\"second-direct-queue\").build();\n    }\n    @Bean(\"directExchange\")\n    public DirectExchange directExchange() {\n        return new DirectExchange(\"direct-exchange\");\n    }\n    \n    @Bean\n    public Binding bingQueueFirstToDirect(@Qualifier(\"directQueueFirst\") Queue queue, \t\t@Qualifier(\"directExchange\") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(\"first-key\");\n    }\n\n    @Bean\n    public Binding bingQueueSecondToDirect(@Qualifier(\"directQueueSecond\") Queue queue, @Qualifier(\"directExchange\") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(\"second-key\");\n    }\n    \n//  生产者发送消息\n@Component\npublic class ScheduleHandler {\n\n    @Scheduled(fixedRate = 6000)\n    private void directMessageScheduleFirst() {\n        Message message = new Message();\n        message.setTitle(\"hello\");\n        message.setContent(\"how are you for direct first\");\n        rabbitTemplate.convertAndSend(\"direct-exchange\",\"first-key\",message);\n    }\n\n    @Scheduled(fixedRate = 6000)\n    private void directMessageScheduleSecond() {\n        Message message = new Message();\n        message.setTitle(\"hello\");\n        message.setContent(\"how are you for direct second\");\n        rabbitTemplate.convertAndSend(\"topic-exchange\",\"second-key\",message);\n    }\n}\n@Component\npublic class QueueMessageHandler {\n//  消费端\n    @RabbitListener(queues = { \"first-direct-queue\"})\n    public void firstDirectMessageQueue(Message msg){\n        System.out.println(msg);\n    }\n\n    @RabbitListener(queues = { \"second-direct-queue\"})\n    public void secondDirectMessageQueue(Message msg){\n        System.out.println(msg);\n    }\n}\n```\n\n值得注意的是，springboot为了使我们的代码可读性更好，还非常贴心的提供 `Exchange`,`Binding`,`Queue`的`Builder`（建造者），因此你可以使用它们对应建造者，也可以使用直接 new 的方式进行创建。另外创建的这些 exchange queue 都能在管理界面上看到，如图 2 ，图 3 ：\n\n![图 2：队列信息](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/b.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t图 2：队列信息\n\n![图 3：交换机信息](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/c.png)\n\n​\t\t\t\t\t\t\t\t\t\t图 3：交换机信息\n\n##  fanout exchange  扇型交换机\n\n使用上和 direct exchange 大同小异，只不过不需要指定路由键，而且所有和它绑定的队列都会收到消息，直接上代码：\n\n```java\n// 生产者配置\n    @Bean(\"fanoutQueueFirst\")\n    public Queue fanoutQueueFirst() {\n        return new Queue(\"first-fanout-queue\");\n    }\n\n    @Bean(\"fanoutQueueSecond\")\n    public Queue fanoutQueueSecond() {\n        return new Queue(\"second-fanout-queue\");\n    }\n\n    @Bean(\"fanoutExchange\")\n    public FanoutExchange fanoutExchange() {\n        return new FanoutExchange(\"fanout-exchange\");\n    }\n\n    @Bean\n    public Binding bingQueueFirstToExchange(@Qualifier(\"fanoutQueueFirst\") Queue queue, @Qualifier(\"fanoutExchange\") FanoutExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange);\n    }\n\n    @Bean\n    public Binding bingQueueSecondToExchange(@Qualifier(\"fanoutQueueSecond\") Queue queue, @Qualifier(\"fanoutExchange\") FanoutExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange);\n    }\n@Component\npublic class ScheduleHandler {\n//  生产者发消息，注意这里虽然填了routingKey 但是是无效的\n    @Scheduled(fixedRate = 6000)\n    private void directMessageScheduleFirst() {\n        Message message = new Message();\n        message.setTitle(\"hello\");\n        message.setContent(\"how are you for direct first\");\n        rabbitTemplate.convertAndSend(\"direct-exchange\",\"first-key\",message);\n    }\n}\n//  消费者，两个队列都能收到同一份消息\n@Component\npublic class QueueMessageHandler {\n    @RabbitListener(queues = { \"first-fanout-queue\"})\n    public void firstFanoutQueue(Message msg){\n        System.out.println(msg);\n    }\n\n    @RabbitListener(queues = { \"second-fanout-queue\"})\n    public void secondFanoutQueue(Message msg){\n        System.out.println(msg);\n    }\n}\n```\n\n##  主题交换机  Topic\n\n前文介绍了主题交换机的路由方式，注意我代码中的路由键设置，这里我设置两个`bingding-key` 分别是 `com.muggle.first` 和 `com.#` 我用 `routing-key` 为 `com.muggle.test` 发消息这两个队列都能接收到\n\n```java\n    @Bean(\"topicQueueFirst\")\n    public Queue topicQueueFirst() {\n        return new Queue(\"first-topic-queue\");\n    }\n\n    @Bean(\"topicQueueSecond\")\n    public Queue topicQueueSecond() {\n        return new Queue(\"second-topic-queue\");\n    }\n\n    @Bean\n    public Binding bindTopicFirst(@Qualifier(\"topicQueueFirst\") Queue queue, @Qualifier(\"topicExchange\") TopicExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(\"com.muggle.first\");\n    }\n\n    @Bean\n    public Binding bindTopicSecond(@Qualifier(\"topicQueueFirst\") Queue queue, @Qualifier(\"topicExchange\") TopicExchange exchange) {\n        return BindingBuilder.bind(topicQueueFirst()).to(topicExchange()).with(\"com.#\");\n    }\n    \n@Component\npublic class ScheduleHandler {\n    @Scheduled(fixedRate = 6000)\n    private void topicMessage() {\n        Message message = new Message();\n        message.setTitle(\"hello\");\n        message.setContent(\"how are you for topic test\");\n        rabbitTemplate. convertAndSend(\"topic-exchange\",\"com.muggle.test\",message);\n    }\n    \n}\n\n@Component\npublic class QueueMessageHandler {\n    @RabbitListener(queues = { \"first-topic-queue\"})\n    public void firstTopicMessageQueue(Message msg){\n        System.out.println(msg);\n    }\n\n    @RabbitListener(queues = { \"second-topic-queue\"})\n    public void secondTopicMessageQueue(Message msg){\n        System.out.println(msg);\n    }\n}\n\n\n```\n现在我们学习了 rabbitMQ 的各类交换机的用法，这些只是 rabbitMQ 的基础特性，下文我们将介绍一些 rabbitMQ 的更复杂的使用方法。\n\n项目源码：https://github.com/muggle0/learn-simple.git\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","source":"_posts/rabbitMQ-springboot-0.md","raw":"---\ntitle: rabbitMQ 结合 springboot 使用 一\ndate: 2020-12-14 \ntags: 中间件\n---\n\n从这一节开始我们进入rabbitMQ的实战环节，项目环境是spring-boot 加maven。首先让我们创建一个spring-boot项目，然后引入web依赖和 rabbitMQ的依赖\n<!--more-->\n```xml\n <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n </dependency>\n <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n```\n\napplication.properties\n\n```properties\nspring.rabbitmq.host=localhost\nspring.rabbitmq.username=guest\nspring.activemq.password=guest\n```\n\n环境搭建好之后我们就可以开始进行实战操作了。\n\n## 简单消息队列\n\nspringboot会默认为你创建一个`direct exchange`类型交换机，其名称为`\"\"`空字符串，其路由键和绑定键都是队列名称，未指定交换机的队列都会绑定到这个交换机上去。我们就以这个最简单的消息队列开始来学习如何在项目中使用`rabbitMQ`。\n\n我们先注册两个队列，一个用于传递String类型消息，一个传递Object类型的数据。项目启动后springboot会为你在 rabbitMQ 中创建两个队列，启动项目后打开 rabbitMQ 的 web 管理界面（以下简称管理界面）会在 Queues 中看到这两个队列的相关信息。\n\n```java\n@Component\npublic class QueueConfig {\n    @Bean\n    public Queue getSimpleQueue() {\n        return new Queue(\"simple-queue\");\n    }\n\n    @Bean\n    public Queue getObjSimpleQueue() {\n        return new Queue(\"obj-simple-queue\");\n    }\n}\n```\n\n创建两个定时任务，向 rabbitMQ 投递消息，注意这里需要在启动类上加 `@EnableScheduling` 注解以启动定时任务，而 `Message` 是我创建的实体类：\n\n```java\n@Component\npublic class ScheduleHandler {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @Scheduled(fixedRate = 6000)\n    private void simpleQueueSchedule() {\n        System.out.println(\"<<<<<<<<<<\");\n\n        rabbitTemplate.convertAndSend(\"simple-queue\",\"ni----hao\");\n    }\n\n    @Scheduled(fixedRate = 6000)\n    private void objSimpleQueueSchedule() {\n        System.out.println(\"<<<<<<<<<<\");\n        Message message = new Message();\n        message.setTitle(\"hello\");\n        message.setContent(\"how are you \");\n        rabbitTemplate.convertAndSend(\"obj-simple-queue\",message);\n    }\n\n}\n```\n\n消费者消费消息：\n\n```java\n@Component\npublic class QueueMessageHandler {\n\n    @RabbitListener(queues = { \"simple-queue\"})\n    public void getSimpleQueueMessage(String msg){\n        System.out.println(msg);\n    }\n\n    @RabbitListener(queues = { \"obj-simple-queue\"})\n    public void getObjSimpleQueueMessage(Message msg){\n        System.out.println(msg);\n    }\n\n}\n```\n\n`rabbitTemplate.convertAndSend()`方法是将数据序列化并写入队列中，而其使用的序列化协议自然是java序列化协议（使用 `ObjectInputStream` 和 `ObjectOutputStream` 读写），因此你如果调用这个方法则其实体类需要实现`Serializable`接口，而如果跨虚拟机还需要注意 `serialVersionUID`。如果跨平台了，那么最好使用其他序列化的方式,序列化反序列化配置在后文关于**监听器容器**的章节介绍。\n\n## 推模式和拉模式\n\n对消费端而言使用`@RabbitListener`监听器获取MQ消息的方式称为`推模式`，我们还可以使用拉模式，当我们需要一条消息的时候才从队列中拉一条消息出来，使用的方法为 `rabbitTemplate.receiveAndConvert()`，如：\n\n```\n  Message o = ((Message) rabbitTemplate.receiveAndConvert(\"obj-simple-queue\"));\n```\n\n##  direct exchange 直连交换机\n\n直连交换机，需要注册一个 `DirectExchange` , `Queue` , `Binding` 。`Bingding` 负责将 `DirectExchange` 和 `Queue` 绑定并指定 `routingKey` 生产者生产消息的时候也需要指定 `routingKey`。下面看示例：\n\n```java\n//  生产端配置\n    @Bean(\"directQueueFirst\")\n    public Queue directQueueFirst() {\n        return new Queue(\"first-direct-queue\");\n    }\n\n    @Bean(\"directQueueSecond\")\n    public Queue directQueueSecond() {\n        return QueueBuilder.durable(\"second-direct-queue\").build();\n    }\n    @Bean(\"directExchange\")\n    public DirectExchange directExchange() {\n        return new DirectExchange(\"direct-exchange\");\n    }\n    \n    @Bean\n    public Binding bingQueueFirstToDirect(@Qualifier(\"directQueueFirst\") Queue queue, \t\t@Qualifier(\"directExchange\") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(\"first-key\");\n    }\n\n    @Bean\n    public Binding bingQueueSecondToDirect(@Qualifier(\"directQueueSecond\") Queue queue, @Qualifier(\"directExchange\") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(\"second-key\");\n    }\n    \n//  生产者发送消息\n@Component\npublic class ScheduleHandler {\n\n    @Scheduled(fixedRate = 6000)\n    private void directMessageScheduleFirst() {\n        Message message = new Message();\n        message.setTitle(\"hello\");\n        message.setContent(\"how are you for direct first\");\n        rabbitTemplate.convertAndSend(\"direct-exchange\",\"first-key\",message);\n    }\n\n    @Scheduled(fixedRate = 6000)\n    private void directMessageScheduleSecond() {\n        Message message = new Message();\n        message.setTitle(\"hello\");\n        message.setContent(\"how are you for direct second\");\n        rabbitTemplate.convertAndSend(\"topic-exchange\",\"second-key\",message);\n    }\n}\n@Component\npublic class QueueMessageHandler {\n//  消费端\n    @RabbitListener(queues = { \"first-direct-queue\"})\n    public void firstDirectMessageQueue(Message msg){\n        System.out.println(msg);\n    }\n\n    @RabbitListener(queues = { \"second-direct-queue\"})\n    public void secondDirectMessageQueue(Message msg){\n        System.out.println(msg);\n    }\n}\n```\n\n值得注意的是，springboot为了使我们的代码可读性更好，还非常贴心的提供 `Exchange`,`Binding`,`Queue`的`Builder`（建造者），因此你可以使用它们对应建造者，也可以使用直接 new 的方式进行创建。另外创建的这些 exchange queue 都能在管理界面上看到，如图 2 ，图 3 ：\n\n![图 2：队列信息](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/b.png)\n\n​\t\t\t\t\t\t\t\t\t\t\t图 2：队列信息\n\n![图 3：交换机信息](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/c.png)\n\n​\t\t\t\t\t\t\t\t\t\t图 3：交换机信息\n\n##  fanout exchange  扇型交换机\n\n使用上和 direct exchange 大同小异，只不过不需要指定路由键，而且所有和它绑定的队列都会收到消息，直接上代码：\n\n```java\n// 生产者配置\n    @Bean(\"fanoutQueueFirst\")\n    public Queue fanoutQueueFirst() {\n        return new Queue(\"first-fanout-queue\");\n    }\n\n    @Bean(\"fanoutQueueSecond\")\n    public Queue fanoutQueueSecond() {\n        return new Queue(\"second-fanout-queue\");\n    }\n\n    @Bean(\"fanoutExchange\")\n    public FanoutExchange fanoutExchange() {\n        return new FanoutExchange(\"fanout-exchange\");\n    }\n\n    @Bean\n    public Binding bingQueueFirstToExchange(@Qualifier(\"fanoutQueueFirst\") Queue queue, @Qualifier(\"fanoutExchange\") FanoutExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange);\n    }\n\n    @Bean\n    public Binding bingQueueSecondToExchange(@Qualifier(\"fanoutQueueSecond\") Queue queue, @Qualifier(\"fanoutExchange\") FanoutExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange);\n    }\n@Component\npublic class ScheduleHandler {\n//  生产者发消息，注意这里虽然填了routingKey 但是是无效的\n    @Scheduled(fixedRate = 6000)\n    private void directMessageScheduleFirst() {\n        Message message = new Message();\n        message.setTitle(\"hello\");\n        message.setContent(\"how are you for direct first\");\n        rabbitTemplate.convertAndSend(\"direct-exchange\",\"first-key\",message);\n    }\n}\n//  消费者，两个队列都能收到同一份消息\n@Component\npublic class QueueMessageHandler {\n    @RabbitListener(queues = { \"first-fanout-queue\"})\n    public void firstFanoutQueue(Message msg){\n        System.out.println(msg);\n    }\n\n    @RabbitListener(queues = { \"second-fanout-queue\"})\n    public void secondFanoutQueue(Message msg){\n        System.out.println(msg);\n    }\n}\n```\n\n##  主题交换机  Topic\n\n前文介绍了主题交换机的路由方式，注意我代码中的路由键设置，这里我设置两个`bingding-key` 分别是 `com.muggle.first` 和 `com.#` 我用 `routing-key` 为 `com.muggle.test` 发消息这两个队列都能接收到\n\n```java\n    @Bean(\"topicQueueFirst\")\n    public Queue topicQueueFirst() {\n        return new Queue(\"first-topic-queue\");\n    }\n\n    @Bean(\"topicQueueSecond\")\n    public Queue topicQueueSecond() {\n        return new Queue(\"second-topic-queue\");\n    }\n\n    @Bean\n    public Binding bindTopicFirst(@Qualifier(\"topicQueueFirst\") Queue queue, @Qualifier(\"topicExchange\") TopicExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with(\"com.muggle.first\");\n    }\n\n    @Bean\n    public Binding bindTopicSecond(@Qualifier(\"topicQueueFirst\") Queue queue, @Qualifier(\"topicExchange\") TopicExchange exchange) {\n        return BindingBuilder.bind(topicQueueFirst()).to(topicExchange()).with(\"com.#\");\n    }\n    \n@Component\npublic class ScheduleHandler {\n    @Scheduled(fixedRate = 6000)\n    private void topicMessage() {\n        Message message = new Message();\n        message.setTitle(\"hello\");\n        message.setContent(\"how are you for topic test\");\n        rabbitTemplate. convertAndSend(\"topic-exchange\",\"com.muggle.test\",message);\n    }\n    \n}\n\n@Component\npublic class QueueMessageHandler {\n    @RabbitListener(queues = { \"first-topic-queue\"})\n    public void firstTopicMessageQueue(Message msg){\n        System.out.println(msg);\n    }\n\n    @RabbitListener(queues = { \"second-topic-queue\"})\n    public void secondTopicMessageQueue(Message msg){\n        System.out.println(msg);\n    }\n}\n\n\n```\n现在我们学习了 rabbitMQ 的各类交换机的用法，这些只是 rabbitMQ 的基础特性，下文我们将介绍一些 rabbitMQ 的更复杂的使用方法。\n\n项目源码：https://github.com/muggle0/learn-simple.git\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","slug":"rabbitMQ-springboot-0","published":1,"updated":"2021-01-12T03:47:13.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6n002v00wiff0i198y","content":"<p>从这一节开始我们进入rabbitMQ的实战环节，项目环境是spring-boot 加maven。首先让我们创建一个spring-boot项目，然后引入web依赖和 rabbitMQ的依赖</p>\n<a id=\"more\"></a>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>application.properties</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.rabbitmq.host</span>=<span class=\"string\">localhost</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.username</span>=<span class=\"string\">guest</span></span><br><span class=\"line\"><span class=\"meta\">spring.activemq.password</span>=<span class=\"string\">guest</span></span><br></pre></td></tr></table></figure>\n<p>环境搭建好之后我们就可以开始进行实战操作了。</p>\n<h2 id=\"简单消息队列\"><a href=\"#简单消息队列\" class=\"headerlink\" title=\"简单消息队列\"></a>简单消息队列</h2><p>springboot会默认为你创建一个<code>direct exchange</code>类型交换机，其名称为<code>&quot;&quot;</code>空字符串，其路由键和绑定键都是队列名称，未指定交换机的队列都会绑定到这个交换机上去。我们就以这个最简单的消息队列开始来学习如何在项目中使用<code>rabbitMQ</code>。</p>\n<p>我们先注册两个队列，一个用于传递String类型消息，一个传递Object类型的数据。项目启动后springboot会为你在 rabbitMQ 中创建两个队列，启动项目后打开 rabbitMQ 的 web 管理界面（以下简称管理界面）会在 Queues 中看到这两个队列的相关信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">getSimpleQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;simple-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">getObjSimpleQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;obj-simple-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建两个定时任务，向 rabbitMQ 投递消息，注意这里需要在启动类上加 <code>@EnableScheduling</code> 注解以启动定时任务，而 <code>Message</code> 是我创建的实体类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">simpleQueueSchedule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;simple-queue&quot;</span>,<span class=\"string\">&quot;ni----hao&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">objSimpleQueueSchedule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class=\"line\">        Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">        message.setTitle(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        message.setContent(<span class=\"string\">&quot;how are you &quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;obj-simple-queue&quot;</span>,message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>消费者消费消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueMessageHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;simple-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getSimpleQueueMessage</span><span class=\"params\">(String msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;obj-simple-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getObjSimpleQueueMessage</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>rabbitTemplate.convertAndSend()</code>方法是将数据序列化并写入队列中，而其使用的序列化协议自然是java序列化协议（使用 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 读写），因此你如果调用这个方法则其实体类需要实现<code>Serializable</code>接口，而如果跨虚拟机还需要注意 <code>serialVersionUID</code>。如果跨平台了，那么最好使用其他序列化的方式,序列化反序列化配置在后文关于<strong>监听器容器</strong>的章节介绍。</p>\n<h2 id=\"推模式和拉模式\"><a href=\"#推模式和拉模式\" class=\"headerlink\" title=\"推模式和拉模式\"></a>推模式和拉模式</h2><p>对消费端而言使用<code>@RabbitListener</code>监听器获取MQ消息的方式称为<code>推模式</code>，我们还可以使用拉模式，当我们需要一条消息的时候才从队列中拉一条消息出来，使用的方法为 <code>rabbitTemplate.receiveAndConvert()</code>，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Message o &#x3D; ((Message) rabbitTemplate.receiveAndConvert(&quot;obj-simple-queue&quot;));</span><br></pre></td></tr></table></figure>\n<h2 id=\"direct-exchange-直连交换机\"><a href=\"#direct-exchange-直连交换机\" class=\"headerlink\" title=\"direct exchange 直连交换机\"></a>direct exchange 直连交换机</h2><p>直连交换机，需要注册一个 <code>DirectExchange</code> , <code>Queue</code> , <code>Binding</code> 。<code>Bingding</code> 负责将 <code>DirectExchange</code> 和 <code>Queue</code> 绑定并指定 <code>routingKey</code> 生产者生产消息的时候也需要指定 <code>routingKey</code>。下面看示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  生产端配置</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;directQueueFirst&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueueFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;first-direct-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;directQueueSecond&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueueSecond</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(<span class=\"string\">&quot;second-direct-queue&quot;</span>).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;directExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">directExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;direct-exchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bingQueueFirstToDirect</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;directQueueFirst&quot;)</span> Queue queue, \t\t<span class=\"meta\">@Qualifier(&quot;directExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;first-key&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bingQueueSecondToDirect</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;directQueueSecond&quot;)</span> Queue queue, <span class=\"meta\">@Qualifier(&quot;directExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;second-key&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//  生产者发送消息</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">directMessageScheduleFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">        message.setTitle(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        message.setContent(<span class=\"string\">&quot;how are you for direct first&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;direct-exchange&quot;</span>,<span class=\"string\">&quot;first-key&quot;</span>,message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">directMessageScheduleSecond</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">        message.setTitle(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        message.setContent(<span class=\"string\">&quot;how are you for direct second&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;topic-exchange&quot;</span>,<span class=\"string\">&quot;second-key&quot;</span>,message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueMessageHandler</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//  消费端</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;first-direct-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">firstDirectMessageQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;second-direct-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">secondDirectMessageQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，springboot为了使我们的代码可读性更好，还非常贴心的提供 <code>Exchange</code>,<code>Binding</code>,<code>Queue</code>的<code>Builder</code>（建造者），因此你可以使用它们对应建造者，也可以使用直接 new 的方式进行创建。另外创建的这些 exchange queue 都能在管理界面上看到，如图 2 ，图 3 ：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/b.png\" alt=\"图 2：队列信息\"></p>\n<p>​                                            图 2：队列信息</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/c.png\" alt=\"图 3：交换机信息\"></p>\n<p>​                                        图 3：交换机信息</p>\n<h2 id=\"fanout-exchange-扇型交换机\"><a href=\"#fanout-exchange-扇型交换机\" class=\"headerlink\" title=\"fanout exchange  扇型交换机\"></a>fanout exchange  扇型交换机</h2><p>使用上和 direct exchange 大同小异，只不过不需要指定路由键，而且所有和它绑定的队列都会收到消息，直接上代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生产者配置</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;fanoutQueueFirst&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutQueueFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;first-fanout-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;fanoutQueueSecond&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutQueueSecond</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;second-fanout-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;fanoutExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">fanoutExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">&quot;fanout-exchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bingQueueFirstToExchange</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;fanoutQueueFirst&quot;)</span> Queue queue, <span class=\"meta\">@Qualifier(&quot;fanoutExchange&quot;)</span> FanoutExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bingQueueSecondToExchange</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;fanoutQueueSecond&quot;)</span> Queue queue, <span class=\"meta\">@Qualifier(&quot;fanoutExchange&quot;)</span> FanoutExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleHandler</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//  生产者发消息，注意这里虽然填了routingKey 但是是无效的</span></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">directMessageScheduleFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">        message.setTitle(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        message.setContent(<span class=\"string\">&quot;how are you for direct first&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;direct-exchange&quot;</span>,<span class=\"string\">&quot;first-key&quot;</span>,message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//  消费者，两个队列都能收到同一份消息</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueMessageHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;first-fanout-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">firstFanoutQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;second-fanout-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">secondFanoutQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"主题交换机-Topic\"><a href=\"#主题交换机-Topic\" class=\"headerlink\" title=\"主题交换机  Topic\"></a>主题交换机  Topic</h2><p>前文介绍了主题交换机的路由方式，注意我代码中的路由键设置，这里我设置两个<code>bingding-key</code> 分别是 <code>com.muggle.first</code> 和 <code>com.#</code> 我用 <code>routing-key</code> 为 <code>com.muggle.test</code> 发消息这两个队列都能接收到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Bean(&quot;topicQueueFirst&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueueFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;first-topic-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;topicQueueSecond&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueueSecond</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;second-topic-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bindTopicFirst</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;topicQueueFirst&quot;)</span> Queue queue, <span class=\"meta\">@Qualifier(&quot;topicExchange&quot;)</span> TopicExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;com.muggle.first&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bindTopicSecond</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;topicQueueFirst&quot;)</span> Queue queue, <span class=\"meta\">@Qualifier(&quot;topicExchange&quot;)</span> TopicExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(topicQueueFirst()).to(topicExchange()).with(<span class=\"string\">&quot;com.#&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">topicMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">        message.setTitle(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        message.setContent(<span class=\"string\">&quot;how are you for topic test&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate. convertAndSend(<span class=\"string\">&quot;topic-exchange&quot;</span>,<span class=\"string\">&quot;com.muggle.test&quot;</span>,message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueMessageHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;first-topic-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">firstTopicMessageQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;second-topic-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">secondTopicMessageQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>现在我们学习了 rabbitMQ 的各类交换机的用法，这些只是 rabbitMQ 的基础特性，下文我们将介绍一些 rabbitMQ 的更复杂的使用方法。</p>\n<p>项目源码：<a href=\"https://github.com/muggle0/learn-simple.git\">https://github.com/muggle0/learn-simple.git</a></p>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>\n","site":{"data":{}},"excerpt":"<p>从这一节开始我们进入rabbitMQ的实战环节，项目环境是spring-boot 加maven。首先让我们创建一个spring-boot项目，然后引入web依赖和 rabbitMQ的依赖</p>","more":"<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>application.properties</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.rabbitmq.host</span>=<span class=\"string\">localhost</span></span><br><span class=\"line\"><span class=\"meta\">spring.rabbitmq.username</span>=<span class=\"string\">guest</span></span><br><span class=\"line\"><span class=\"meta\">spring.activemq.password</span>=<span class=\"string\">guest</span></span><br></pre></td></tr></table></figure>\n<p>环境搭建好之后我们就可以开始进行实战操作了。</p>\n<h2 id=\"简单消息队列\"><a href=\"#简单消息队列\" class=\"headerlink\" title=\"简单消息队列\"></a>简单消息队列</h2><p>springboot会默认为你创建一个<code>direct exchange</code>类型交换机，其名称为<code>&quot;&quot;</code>空字符串，其路由键和绑定键都是队列名称，未指定交换机的队列都会绑定到这个交换机上去。我们就以这个最简单的消息队列开始来学习如何在项目中使用<code>rabbitMQ</code>。</p>\n<p>我们先注册两个队列，一个用于传递String类型消息，一个传递Object类型的数据。项目启动后springboot会为你在 rabbitMQ 中创建两个队列，启动项目后打开 rabbitMQ 的 web 管理界面（以下简称管理界面）会在 Queues 中看到这两个队列的相关信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">getSimpleQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;simple-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">getObjSimpleQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;obj-simple-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建两个定时任务，向 rabbitMQ 投递消息，注意这里需要在启动类上加 <code>@EnableScheduling</code> 注解以启动定时任务，而 <code>Message</code> 是我创建的实体类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">simpleQueueSchedule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;simple-queue&quot;</span>,<span class=\"string\">&quot;ni----hao&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">objSimpleQueueSchedule</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class=\"line\">        Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">        message.setTitle(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        message.setContent(<span class=\"string\">&quot;how are you &quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;obj-simple-queue&quot;</span>,message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>消费者消费消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueMessageHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;simple-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getSimpleQueueMessage</span><span class=\"params\">(String msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;obj-simple-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getObjSimpleQueueMessage</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>rabbitTemplate.convertAndSend()</code>方法是将数据序列化并写入队列中，而其使用的序列化协议自然是java序列化协议（使用 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 读写），因此你如果调用这个方法则其实体类需要实现<code>Serializable</code>接口，而如果跨虚拟机还需要注意 <code>serialVersionUID</code>。如果跨平台了，那么最好使用其他序列化的方式,序列化反序列化配置在后文关于<strong>监听器容器</strong>的章节介绍。</p>\n<h2 id=\"推模式和拉模式\"><a href=\"#推模式和拉模式\" class=\"headerlink\" title=\"推模式和拉模式\"></a>推模式和拉模式</h2><p>对消费端而言使用<code>@RabbitListener</code>监听器获取MQ消息的方式称为<code>推模式</code>，我们还可以使用拉模式，当我们需要一条消息的时候才从队列中拉一条消息出来，使用的方法为 <code>rabbitTemplate.receiveAndConvert()</code>，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Message o &#x3D; ((Message) rabbitTemplate.receiveAndConvert(&quot;obj-simple-queue&quot;));</span><br></pre></td></tr></table></figure>\n<h2 id=\"direct-exchange-直连交换机\"><a href=\"#direct-exchange-直连交换机\" class=\"headerlink\" title=\"direct exchange 直连交换机\"></a>direct exchange 直连交换机</h2><p>直连交换机，需要注册一个 <code>DirectExchange</code> , <code>Queue</code> , <code>Binding</code> 。<code>Bingding</code> 负责将 <code>DirectExchange</code> 和 <code>Queue</code> 绑定并指定 <code>routingKey</code> 生产者生产消息的时候也需要指定 <code>routingKey</code>。下面看示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  生产端配置</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;directQueueFirst&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueueFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;first-direct-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;directQueueSecond&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueueSecond</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(<span class=\"string\">&quot;second-direct-queue&quot;</span>).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;directExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">directExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;direct-exchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bingQueueFirstToDirect</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;directQueueFirst&quot;)</span> Queue queue, \t\t<span class=\"meta\">@Qualifier(&quot;directExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;first-key&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bingQueueSecondToDirect</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;directQueueSecond&quot;)</span> Queue queue, <span class=\"meta\">@Qualifier(&quot;directExchange&quot;)</span> DirectExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;second-key&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//  生产者发送消息</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">directMessageScheduleFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">        message.setTitle(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        message.setContent(<span class=\"string\">&quot;how are you for direct first&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;direct-exchange&quot;</span>,<span class=\"string\">&quot;first-key&quot;</span>,message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">directMessageScheduleSecond</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">        message.setTitle(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        message.setContent(<span class=\"string\">&quot;how are you for direct second&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;topic-exchange&quot;</span>,<span class=\"string\">&quot;second-key&quot;</span>,message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueMessageHandler</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//  消费端</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;first-direct-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">firstDirectMessageQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;second-direct-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">secondDirectMessageQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，springboot为了使我们的代码可读性更好，还非常贴心的提供 <code>Exchange</code>,<code>Binding</code>,<code>Queue</code>的<code>Builder</code>（建造者），因此你可以使用它们对应建造者，也可以使用直接 new 的方式进行创建。另外创建的这些 exchange queue 都能在管理界面上看到，如图 2 ，图 3 ：</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/b.png\" alt=\"图 2：队列信息\"></p>\n<p>​                                            图 2：队列信息</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/c.png\" alt=\"图 3：交换机信息\"></p>\n<p>​                                        图 3：交换机信息</p>\n<h2 id=\"fanout-exchange-扇型交换机\"><a href=\"#fanout-exchange-扇型交换机\" class=\"headerlink\" title=\"fanout exchange  扇型交换机\"></a>fanout exchange  扇型交换机</h2><p>使用上和 direct exchange 大同小异，只不过不需要指定路由键，而且所有和它绑定的队列都会收到消息，直接上代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生产者配置</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;fanoutQueueFirst&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutQueueFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;first-fanout-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;fanoutQueueSecond&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutQueueSecond</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;second-fanout-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;fanoutExchange&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">fanoutExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">&quot;fanout-exchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bingQueueFirstToExchange</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;fanoutQueueFirst&quot;)</span> Queue queue, <span class=\"meta\">@Qualifier(&quot;fanoutExchange&quot;)</span> FanoutExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bingQueueSecondToExchange</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;fanoutQueueSecond&quot;)</span> Queue queue, <span class=\"meta\">@Qualifier(&quot;fanoutExchange&quot;)</span> FanoutExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleHandler</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//  生产者发消息，注意这里虽然填了routingKey 但是是无效的</span></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">directMessageScheduleFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">        message.setTitle(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        message.setContent(<span class=\"string\">&quot;how are you for direct first&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;direct-exchange&quot;</span>,<span class=\"string\">&quot;first-key&quot;</span>,message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//  消费者，两个队列都能收到同一份消息</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueMessageHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;first-fanout-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">firstFanoutQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;second-fanout-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">secondFanoutQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"主题交换机-Topic\"><a href=\"#主题交换机-Topic\" class=\"headerlink\" title=\"主题交换机  Topic\"></a>主题交换机  Topic</h2><p>前文介绍了主题交换机的路由方式，注意我代码中的路由键设置，这里我设置两个<code>bingding-key</code> 分别是 <code>com.muggle.first</code> 和 <code>com.#</code> 我用 <code>routing-key</code> 为 <code>com.muggle.test</code> 发消息这两个队列都能接收到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Bean(&quot;topicQueueFirst&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueueFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;first-topic-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;topicQueueSecond&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueueSecond</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">&quot;second-topic-queue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bindTopicFirst</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;topicQueueFirst&quot;)</span> Queue queue, <span class=\"meta\">@Qualifier(&quot;topicExchange&quot;)</span> TopicExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class=\"string\">&quot;com.muggle.first&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">bindTopicSecond</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;topicQueueFirst&quot;)</span> Queue queue, <span class=\"meta\">@Qualifier(&quot;topicExchange&quot;)</span> TopicExchange exchange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(topicQueueFirst()).to(topicExchange()).with(<span class=\"string\">&quot;com.#&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(fixedRate = 6000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">topicMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Message message = <span class=\"keyword\">new</span> Message();</span><br><span class=\"line\">        message.setTitle(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        message.setContent(<span class=\"string\">&quot;how are you for topic test&quot;</span>);</span><br><span class=\"line\">        rabbitTemplate. convertAndSend(<span class=\"string\">&quot;topic-exchange&quot;</span>,<span class=\"string\">&quot;com.muggle.test&quot;</span>,message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueMessageHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;first-topic-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">firstTopicMessageQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &#123; &quot;second-topic-queue&quot;&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">secondTopicMessageQueue</span><span class=\"params\">(Message msg)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>现在我们学习了 rabbitMQ 的各类交换机的用法，这些只是 rabbitMQ 的基础特性，下文我们将介绍一些 rabbitMQ 的更复杂的使用方法。</p>\n<p>项目源码：<a href=\"https://github.com/muggle0/learn-simple.git\">https://github.com/muggle0/learn-simple.git</a></p>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>"},{"title":"rabbitMQ 结合 springboot 使用 三","date":"2020-12-15T16:00:00.000Z","_content":"## `ListenerContainer ` 的使用\n\n在消费端，我们的消费监听器是运行在 监听器容器之中的（ `ListenerContainer` ），springboot 给我们提供了两个监听器容器 `SimpleMessageListenerContainer` 和 `DirectMessageListenerContainer ` 在配置文件中凡是以 `spring.rabbitmq.listener.simple` 开头的就是对第一个容器的配置，以 `spring.rabbitmq.listener.direct` 开头的是对第二个容器的配置。其实这两个容器类让我很费劲；首先官方文档并没有说哪个是默认的容器，似乎两个都能用；其次，它说这个容器默认是单例模式的，但它又提供了工厂方法，而且我们看 `@RabbitListener` 注解源码：\n<!--more-->\n```java\nTarget({ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@MessageMapping\n@Documented\n@Repeatable(RabbitListeners.class)\npublic @interface RabbitListener {\n    String id() default \"\";\n    String containerFactory() default \"\";\n    ......\n}\n```\n\n它是指定一个 `containerFactory` 那我通过 `@Bean` 注解注册一个 `ListenerContainer ` ` 到底有没有用。\n\n保险起见这里教程中建议注册一个`containerFactory`  而不是一个单例的`ListenerContainer `  那我可以对这个容器工厂做哪些设置呢。它的官方文档`<https://docs.spring.io/spring-amqp/docs/2.1.8.RELEASE/api/>` 其中前往提到的序列化问题就可以配置这个工厂bean来解决：\n\n```java\n@Bean\n    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) {\n        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        // 传入一个序列化器 也可以通过 rabbitTemplate.setMessageConverter(）来配置\n        factory.setMessageConverter(new MessagingMessageConverter());\n        return factory;\n    }\n```\n\n除此之外 它还能设置事务的长度，消费者并发数，消息重试的相关参数等。小伙伴自己按需查阅资料去进行尝试，这里由于篇幅问题就不做说明了。\n\n## 8. 惰性队列\n\n在 rabbit3.6 版本引入了惰性队列的的概念；默认情况下队列的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者，就算持久化的消息也会在内存中做备份。当 rabbit 需要释放内存的时候，会将内存中的消息写入磁盘。这个操作不仅耗时还阻塞队列，让队列无法写入消息。于是 rabbit 将队列分为了两中模式——`default` 模式和 `lazy` 模式来解决这一问题。`lazy` 模式即为惰性队列的模式。惰性队列 通过参数 `x-queue-mode`来配置，代码可参考死信队列，通过  `QueueBuilder` 的 `withArgument` 来指定参数。\n\n惰性队列和普通队列相比，只有很小的内存开销。惰性队列会将消息直接写入到磁盘，需要消费的时候再取出来。当消息量级很大，内存完全不够用的时候，普通队列要经历这样的过程——将消息读到内存 —> 内存满了需要给后面的消息腾地方，将消息写入磁盘—>消费到这条消息，将消息又读入内存。所以当消息量级很大的时候，惰性队列性能要好过普通队列，当内存完全够用的时候则不然。\n\n##  事务\n\n  事务特性是针对生产者投递消息而言的，对我们的项目来说 rabbit 的事务是很重要的；假如没有事务特性，在一个方法中，数据库插入数据失败回滚了，而对应的消息却无法回滚，就会产生一条错误的消息。\n\nrabbit 中的事务机制和 callable 机制是互斥的，也就是说只有 `spring.rabbitmq.template.mandatory=false` 的时候才能使用。rabbit 事务的声明，提交，回滚的方法是channel的 `txSelect()`，`txCoomit()` ，`txRollback()`。但是在 springboot 我们大可不必去手动提交和回滚，可以使用 spring 的声明式事务，上代码：\n\n```java\n@Component\n@Order(1)\npublic class RabbitConfig {\n    @Autowired\n    public RabbitConfig( RabbitTemplate rabbitTemplate,MyConfirmCallback confirmCallback,MyReturnCallback returnCallback){\n//        rabbitTemplate.setReturnCallback(returnCallback);\n//        rabbitTemplate.setConfirmCallback(confirmCallback);\n        // 设置事务环境，使得可以使用RabbitMQ事务\n        rabbitTemplate.setChannelTransacted(true);\n    }\n}\n```\n\n生产者：\n\n```java\n@Service\npublic class RabbitTestService {\n    @Autowired\n    RabbitTemplate template;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void test() throws InterruptedException {\n        for (int i = 0; i < 30; i++) {\n\n            template.convertAndSend(\"test for \" + i);\n            System.out.println(\">>>>>\" +i);\n        }\n        Thread.sleep(1000);\n        throw new RuntimeException();\n        \n\n    }\n}\n```\n\n通过管理界面和，消费者打印窗口，可确定声明式事务是否配置成功。\n\n## 备胎机\n\n备胎机顾名思义就是替代现任的备胎，“正主” 没了后可以及时上位。在rabbitMQ中，如果生产者发送消息，由于路由错误等原因不能到达指定队列，就会路由到备胎队列消费。这样做可以保证未被路由的消息不会丢失。\n\n备胎交换机的参数为 `alternate-exchange`来指定做谁的备胎：\n\n```java\n   @Bean\n    public DirectExchange alternateExchange() {\n        Map<String, Object> arguments = new HashMap<>();\n        //指定做哪个交换机的备胎\n        arguments.put(\"alternate-exchange\", \"exchange-boss\");\n        return new DirectExchange(\"xxxqueue\", true, false, arguments);\n    }\n    @Bean\n    public FanoutExchange bossExchange() {\n        // 执行业务的交换机\n        return new FanoutExchange(\"exchange-boss\");\n    }\n\n```\n\n到这里，你已经学习完了rabbitMQ在springboot中的实战相关技术，下一章节我们将学习rabbitMQ运维相关知识\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","source":"_posts/rabbitMQ-springboot-3.md","raw":"---\ntitle: rabbitMQ 结合 springboot 使用 三\ndate: 2020-12-16\ntags: 中间件\n---\n## `ListenerContainer ` 的使用\n\n在消费端，我们的消费监听器是运行在 监听器容器之中的（ `ListenerContainer` ），springboot 给我们提供了两个监听器容器 `SimpleMessageListenerContainer` 和 `DirectMessageListenerContainer ` 在配置文件中凡是以 `spring.rabbitmq.listener.simple` 开头的就是对第一个容器的配置，以 `spring.rabbitmq.listener.direct` 开头的是对第二个容器的配置。其实这两个容器类让我很费劲；首先官方文档并没有说哪个是默认的容器，似乎两个都能用；其次，它说这个容器默认是单例模式的，但它又提供了工厂方法，而且我们看 `@RabbitListener` 注解源码：\n<!--more-->\n```java\nTarget({ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@MessageMapping\n@Documented\n@Repeatable(RabbitListeners.class)\npublic @interface RabbitListener {\n    String id() default \"\";\n    String containerFactory() default \"\";\n    ......\n}\n```\n\n它是指定一个 `containerFactory` 那我通过 `@Bean` 注解注册一个 `ListenerContainer ` ` 到底有没有用。\n\n保险起见这里教程中建议注册一个`containerFactory`  而不是一个单例的`ListenerContainer `  那我可以对这个容器工厂做哪些设置呢。它的官方文档`<https://docs.spring.io/spring-amqp/docs/2.1.8.RELEASE/api/>` 其中前往提到的序列化问题就可以配置这个工厂bean来解决：\n\n```java\n@Bean\n    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) {\n        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n        factory.setConnectionFactory(connectionFactory);\n        // 传入一个序列化器 也可以通过 rabbitTemplate.setMessageConverter(）来配置\n        factory.setMessageConverter(new MessagingMessageConverter());\n        return factory;\n    }\n```\n\n除此之外 它还能设置事务的长度，消费者并发数，消息重试的相关参数等。小伙伴自己按需查阅资料去进行尝试，这里由于篇幅问题就不做说明了。\n\n## 8. 惰性队列\n\n在 rabbit3.6 版本引入了惰性队列的的概念；默认情况下队列的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者，就算持久化的消息也会在内存中做备份。当 rabbit 需要释放内存的时候，会将内存中的消息写入磁盘。这个操作不仅耗时还阻塞队列，让队列无法写入消息。于是 rabbit 将队列分为了两中模式——`default` 模式和 `lazy` 模式来解决这一问题。`lazy` 模式即为惰性队列的模式。惰性队列 通过参数 `x-queue-mode`来配置，代码可参考死信队列，通过  `QueueBuilder` 的 `withArgument` 来指定参数。\n\n惰性队列和普通队列相比，只有很小的内存开销。惰性队列会将消息直接写入到磁盘，需要消费的时候再取出来。当消息量级很大，内存完全不够用的时候，普通队列要经历这样的过程——将消息读到内存 —> 内存满了需要给后面的消息腾地方，将消息写入磁盘—>消费到这条消息，将消息又读入内存。所以当消息量级很大的时候，惰性队列性能要好过普通队列，当内存完全够用的时候则不然。\n\n##  事务\n\n  事务特性是针对生产者投递消息而言的，对我们的项目来说 rabbit 的事务是很重要的；假如没有事务特性，在一个方法中，数据库插入数据失败回滚了，而对应的消息却无法回滚，就会产生一条错误的消息。\n\nrabbit 中的事务机制和 callable 机制是互斥的，也就是说只有 `spring.rabbitmq.template.mandatory=false` 的时候才能使用。rabbit 事务的声明，提交，回滚的方法是channel的 `txSelect()`，`txCoomit()` ，`txRollback()`。但是在 springboot 我们大可不必去手动提交和回滚，可以使用 spring 的声明式事务，上代码：\n\n```java\n@Component\n@Order(1)\npublic class RabbitConfig {\n    @Autowired\n    public RabbitConfig( RabbitTemplate rabbitTemplate,MyConfirmCallback confirmCallback,MyReturnCallback returnCallback){\n//        rabbitTemplate.setReturnCallback(returnCallback);\n//        rabbitTemplate.setConfirmCallback(confirmCallback);\n        // 设置事务环境，使得可以使用RabbitMQ事务\n        rabbitTemplate.setChannelTransacted(true);\n    }\n}\n```\n\n生产者：\n\n```java\n@Service\npublic class RabbitTestService {\n    @Autowired\n    RabbitTemplate template;\n\n    @Transactional(rollbackFor = Exception.class)\n    public void test() throws InterruptedException {\n        for (int i = 0; i < 30; i++) {\n\n            template.convertAndSend(\"test for \" + i);\n            System.out.println(\">>>>>\" +i);\n        }\n        Thread.sleep(1000);\n        throw new RuntimeException();\n        \n\n    }\n}\n```\n\n通过管理界面和，消费者打印窗口，可确定声明式事务是否配置成功。\n\n## 备胎机\n\n备胎机顾名思义就是替代现任的备胎，“正主” 没了后可以及时上位。在rabbitMQ中，如果生产者发送消息，由于路由错误等原因不能到达指定队列，就会路由到备胎队列消费。这样做可以保证未被路由的消息不会丢失。\n\n备胎交换机的参数为 `alternate-exchange`来指定做谁的备胎：\n\n```java\n   @Bean\n    public DirectExchange alternateExchange() {\n        Map<String, Object> arguments = new HashMap<>();\n        //指定做哪个交换机的备胎\n        arguments.put(\"alternate-exchange\", \"exchange-boss\");\n        return new DirectExchange(\"xxxqueue\", true, false, arguments);\n    }\n    @Bean\n    public FanoutExchange bossExchange() {\n        // 执行业务的交换机\n        return new FanoutExchange(\"exchange-boss\");\n    }\n\n```\n\n到这里，你已经学习完了rabbitMQ在springboot中的实战相关技术，下一章节我们将学习rabbitMQ运维相关知识\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","slug":"rabbitMQ-springboot-3","published":1,"updated":"2021-01-12T03:36:18.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6o002y00wi7h7jaktg","content":"<h2 id=\"ListenerContainer-的使用\"><a href=\"#ListenerContainer-的使用\" class=\"headerlink\" title=\"ListenerContainer 的使用\"></a><code>ListenerContainer</code> 的使用</h2><p>在消费端，我们的消费监听器是运行在 监听器容器之中的（ <code>ListenerContainer</code> ），springboot 给我们提供了两个监听器容器 <code>SimpleMessageListenerContainer</code> 和 <code>DirectMessageListenerContainer</code> 在配置文件中凡是以 <code>spring.rabbitmq.listener.simple</code> 开头的就是对第一个容器的配置，以 <code>spring.rabbitmq.listener.direct</code> 开头的是对第二个容器的配置。其实这两个容器类让我很费劲；首先官方文档并没有说哪个是默认的容器，似乎两个都能用；其次，它说这个容器默认是单例模式的，但它又提供了工厂方法，而且我们看 <code>@RabbitListener</code> 注解源码：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@MessageMapping</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Repeatable(RabbitListeners.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RabbitListener &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">id</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">containerFactory</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它是指定一个 <code>containerFactory</code> 那我通过 <code>@Bean</code> 注解注册一个 <code>ListenerContainer</code> ` 到底有没有用。</p>\n<p>保险起见这里教程中建议注册一个<code>containerFactory</code>  而不是一个单例的<code>ListenerContainer</code>  那我可以对这个容器工厂做哪些设置呢。它的官方文档<code>&lt;https://docs.spring.io/spring-amqp/docs/2.1.8.RELEASE/api/&gt;</code> 其中前往提到的序列化问题就可以配置这个工厂bean来解决：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SimpleRabbitListenerContainerFactory <span class=\"title\">rabbitListenerContainerFactory</span><span class=\"params\">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class=\"line\">        SimpleRabbitListenerContainerFactory factory = <span class=\"keyword\">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class=\"line\">        factory.setConnectionFactory(connectionFactory);</span><br><span class=\"line\">        <span class=\"comment\">// 传入一个序列化器 也可以通过 rabbitTemplate.setMessageConverter(）来配置</span></span><br><span class=\"line\">        factory.setMessageConverter(<span class=\"keyword\">new</span> MessagingMessageConverter());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> factory;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外 它还能设置事务的长度，消费者并发数，消息重试的相关参数等。小伙伴自己按需查阅资料去进行尝试，这里由于篇幅问题就不做说明了。</p>\n<h2 id=\"8-惰性队列\"><a href=\"#8-惰性队列\" class=\"headerlink\" title=\"8. 惰性队列\"></a>8. 惰性队列</h2><p>在 rabbit3.6 版本引入了惰性队列的的概念；默认情况下队列的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者，就算持久化的消息也会在内存中做备份。当 rabbit 需要释放内存的时候，会将内存中的消息写入磁盘。这个操作不仅耗时还阻塞队列，让队列无法写入消息。于是 rabbit 将队列分为了两中模式——<code>default</code> 模式和 <code>lazy</code> 模式来解决这一问题。<code>lazy</code> 模式即为惰性队列的模式。惰性队列 通过参数 <code>x-queue-mode</code>来配置，代码可参考死信队列，通过  <code>QueueBuilder</code> 的 <code>withArgument</code> 来指定参数。</p>\n<p>惰性队列和普通队列相比，只有很小的内存开销。惰性队列会将消息直接写入到磁盘，需要消费的时候再取出来。当消息量级很大，内存完全不够用的时候，普通队列要经历这样的过程——将消息读到内存 —&gt; 内存满了需要给后面的消息腾地方，将消息写入磁盘—&gt;消费到这条消息，将消息又读入内存。所以当消息量级很大的时候，惰性队列性能要好过普通队列，当内存完全够用的时候则不然。</p>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>  事务特性是针对生产者投递消息而言的，对我们的项目来说 rabbit 的事务是很重要的；假如没有事务特性，在一个方法中，数据库插入数据失败回滚了，而对应的消息却无法回滚，就会产生一条错误的消息。</p>\n<p>rabbit 中的事务机制和 callable 机制是互斥的，也就是说只有 <code>spring.rabbitmq.template.mandatory=false</code> 的时候才能使用。rabbit 事务的声明，提交，回滚的方法是channel的 <code>txSelect()</code>，<code>txCoomit()</code> ，<code>txRollback()</code>。但是在 springboot 我们大可不必去手动提交和回滚，可以使用 spring 的声明式事务，上代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Order(1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RabbitConfig</span><span class=\"params\">( RabbitTemplate rabbitTemplate,MyConfirmCallback confirmCallback,MyReturnCallback returnCallback)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        rabbitTemplate.setReturnCallback(returnCallback);</span></span><br><span class=\"line\"><span class=\"comment\">//        rabbitTemplate.setConfirmCallback(confirmCallback);</span></span><br><span class=\"line\">        <span class=\"comment\">// 设置事务环境，使得可以使用RabbitMQ事务</span></span><br><span class=\"line\">        rabbitTemplate.setChannelTransacted(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生产者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitTestService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RabbitTemplate template;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">30</span>; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            template.convertAndSend(<span class=\"string\">&quot;test for &quot;</span> + i);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&quot;</span> +i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过管理界面和，消费者打印窗口，可确定声明式事务是否配置成功。</p>\n<h2 id=\"备胎机\"><a href=\"#备胎机\" class=\"headerlink\" title=\"备胎机\"></a>备胎机</h2><p>备胎机顾名思义就是替代现任的备胎，“正主” 没了后可以及时上位。在rabbitMQ中，如果生产者发送消息，由于路由错误等原因不能到达指定队列，就会路由到备胎队列消费。这样做可以保证未被路由的消息不会丢失。</p>\n<p>备胎交换机的参数为 <code>alternate-exchange</code>来指定做谁的备胎：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">alternateExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">     <span class=\"comment\">//指定做哪个交换机的备胎</span></span><br><span class=\"line\">     arguments.put(<span class=\"string\">&quot;alternate-exchange&quot;</span>, <span class=\"string\">&quot;exchange-boss&quot;</span>);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;xxxqueue&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, arguments);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"meta\">@Bean</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">bossExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// 执行业务的交换机</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">&quot;exchange-boss&quot;</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>到这里，你已经学习完了rabbitMQ在springboot中的实战相关技术，下一章节我们将学习rabbitMQ运维相关知识</p>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"ListenerContainer-的使用\"><a href=\"#ListenerContainer-的使用\" class=\"headerlink\" title=\"ListenerContainer 的使用\"></a><code>ListenerContainer</code> 的使用</h2><p>在消费端，我们的消费监听器是运行在 监听器容器之中的（ <code>ListenerContainer</code> ），springboot 给我们提供了两个监听器容器 <code>SimpleMessageListenerContainer</code> 和 <code>DirectMessageListenerContainer</code> 在配置文件中凡是以 <code>spring.rabbitmq.listener.simple</code> 开头的就是对第一个容器的配置，以 <code>spring.rabbitmq.listener.direct</code> 开头的是对第二个容器的配置。其实这两个容器类让我很费劲；首先官方文档并没有说哪个是默认的容器，似乎两个都能用；其次，它说这个容器默认是单例模式的，但它又提供了工厂方法，而且我们看 <code>@RabbitListener</code> 注解源码：</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@MessageMapping</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Repeatable(RabbitListeners.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> RabbitListener &#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">id</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">containerFactory</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它是指定一个 <code>containerFactory</code> 那我通过 <code>@Bean</code> 注解注册一个 <code>ListenerContainer</code> ` 到底有没有用。</p>\n<p>保险起见这里教程中建议注册一个<code>containerFactory</code>  而不是一个单例的<code>ListenerContainer</code>  那我可以对这个容器工厂做哪些设置呢。它的官方文档<code>&lt;https://docs.spring.io/spring-amqp/docs/2.1.8.RELEASE/api/&gt;</code> 其中前往提到的序列化问题就可以配置这个工厂bean来解决：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SimpleRabbitListenerContainerFactory <span class=\"title\">rabbitListenerContainerFactory</span><span class=\"params\">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class=\"line\">        SimpleRabbitListenerContainerFactory factory = <span class=\"keyword\">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class=\"line\">        factory.setConnectionFactory(connectionFactory);</span><br><span class=\"line\">        <span class=\"comment\">// 传入一个序列化器 也可以通过 rabbitTemplate.setMessageConverter(）来配置</span></span><br><span class=\"line\">        factory.setMessageConverter(<span class=\"keyword\">new</span> MessagingMessageConverter());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> factory;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外 它还能设置事务的长度，消费者并发数，消息重试的相关参数等。小伙伴自己按需查阅资料去进行尝试，这里由于篇幅问题就不做说明了。</p>\n<h2 id=\"8-惰性队列\"><a href=\"#8-惰性队列\" class=\"headerlink\" title=\"8. 惰性队列\"></a>8. 惰性队列</h2><p>在 rabbit3.6 版本引入了惰性队列的的概念；默认情况下队列的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者，就算持久化的消息也会在内存中做备份。当 rabbit 需要释放内存的时候，会将内存中的消息写入磁盘。这个操作不仅耗时还阻塞队列，让队列无法写入消息。于是 rabbit 将队列分为了两中模式——<code>default</code> 模式和 <code>lazy</code> 模式来解决这一问题。<code>lazy</code> 模式即为惰性队列的模式。惰性队列 通过参数 <code>x-queue-mode</code>来配置，代码可参考死信队列，通过  <code>QueueBuilder</code> 的 <code>withArgument</code> 来指定参数。</p>\n<p>惰性队列和普通队列相比，只有很小的内存开销。惰性队列会将消息直接写入到磁盘，需要消费的时候再取出来。当消息量级很大，内存完全不够用的时候，普通队列要经历这样的过程——将消息读到内存 —&gt; 内存满了需要给后面的消息腾地方，将消息写入磁盘—&gt;消费到这条消息，将消息又读入内存。所以当消息量级很大的时候，惰性队列性能要好过普通队列，当内存完全够用的时候则不然。</p>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>  事务特性是针对生产者投递消息而言的，对我们的项目来说 rabbit 的事务是很重要的；假如没有事务特性，在一个方法中，数据库插入数据失败回滚了，而对应的消息却无法回滚，就会产生一条错误的消息。</p>\n<p>rabbit 中的事务机制和 callable 机制是互斥的，也就是说只有 <code>spring.rabbitmq.template.mandatory=false</code> 的时候才能使用。rabbit 事务的声明，提交，回滚的方法是channel的 <code>txSelect()</code>，<code>txCoomit()</code> ，<code>txRollback()</code>。但是在 springboot 我们大可不必去手动提交和回滚，可以使用 spring 的声明式事务，上代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Order(1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RabbitConfig</span><span class=\"params\">( RabbitTemplate rabbitTemplate,MyConfirmCallback confirmCallback,MyReturnCallback returnCallback)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        rabbitTemplate.setReturnCallback(returnCallback);</span></span><br><span class=\"line\"><span class=\"comment\">//        rabbitTemplate.setConfirmCallback(confirmCallback);</span></span><br><span class=\"line\">        <span class=\"comment\">// 设置事务环境，使得可以使用RabbitMQ事务</span></span><br><span class=\"line\">        rabbitTemplate.setChannelTransacted(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生产者：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitTestService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RabbitTemplate template;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">30</span>; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            template.convertAndSend(<span class=\"string\">&quot;test for &quot;</span> + i);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&quot;</span> +i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过管理界面和，消费者打印窗口，可确定声明式事务是否配置成功。</p>\n<h2 id=\"备胎机\"><a href=\"#备胎机\" class=\"headerlink\" title=\"备胎机\"></a>备胎机</h2><p>备胎机顾名思义就是替代现任的备胎，“正主” 没了后可以及时上位。在rabbitMQ中，如果生产者发送消息，由于路由错误等原因不能到达指定队列，就会路由到备胎队列消费。这样做可以保证未被路由的消息不会丢失。</p>\n<p>备胎交换机的参数为 <code>alternate-exchange</code>来指定做谁的备胎：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">alternateExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">     <span class=\"comment\">//指定做哪个交换机的备胎</span></span><br><span class=\"line\">     arguments.put(<span class=\"string\">&quot;alternate-exchange&quot;</span>, <span class=\"string\">&quot;exchange-boss&quot;</span>);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">&quot;xxxqueue&quot;</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, arguments);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"meta\">@Bean</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">bossExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// 执行业务的交换机</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">&quot;exchange-boss&quot;</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>到这里，你已经学习完了rabbitMQ在springboot中的实战相关技术，下一章节我们将学习rabbitMQ运维相关知识</p>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>"},{"title":"rabbitMQ 运维相关","date":"2020-12-16T16:00:00.000Z","_content":"相对前面几个章节来说，这个章节知识点不是着重点。大家对这一章节知识的掌握程度为了解。好了，废话不多说，开始正文\n<!--more-->\n## rabbitMQ集群\n\n单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，如果对吞吐量要求更高就需要构建rabbitMQ集群了。RabbitMQ 集群允许消费者和生产者在 RabbitMQ 单个节点崩惯的情况下继续运行，它可以 通过添加更多的节点来线性地扩展消息通信的吞吐量。当失去一个 RabbitMQ 节点时，客户端 能够重新连接到集群中的任何其他节点并继续生产或者消费。\n\nRabbitMQ 集群不能保证消息的万无一失。即使将消息、队列、交换器等都设置为可持久化，生产端和消费端都正确地使用了确认方式，当集群中一个 RabbitMQ 节点崩溃时，该节 点上的所有队列中的消息也会丢失。 RabbitMQ 集群中的所有节点都会备份所有的元数据信息， 包括队列的名称及属性，交换器的名称及属性，交换器与队列或者交换器与交换器之间的绑定关系， 但是不会备份消息（可以通过镜像队列来解决这个问题）。\n\nrabbitmq可以通过三种方式来部署分布式集群系统，分别是：cluster、federation、shovel。\n\ncluster的特点为:\n\n- 不支持夸网段，用于同一个网段内的局域网\n- 可以随意动态的增加和减少\n- 节点之间需要运行相同版本的rabbitmq和erlang\n\nfederation特点为:\n\n- 需要配置联邦交换机和联邦队列\n- 应用于广域网，允许单台服务器上的交换机或队列接收发布到另一台服务器交换机或队列的消息\n- 消息会在联盟队列之间转发任意次，直到被消费者接受。\n\nshovel:连接方式与federation的连接方式类似，相当于建立一个消费者，来将消息从一个队列转移到另一个队列。\n\n## 常用命令\n\n```\n#开启WEB后台监控\n./rabbitmq-plugins enable rabbitmq_management\n#启停服务\nservice rabbitmq-server start\nservice rabbitmq-server stop\nservice rabbitmq-server restart\n#查看状态\nservice rabbitmq-server status\n#运行节点\nrabbitmq-server -detached\n# rabbitmqctl（命令行工具）\nrabbitmqctl stop_app\nrabbitmqctl start_app\n#初始化node状态，会从集群中删除该节点\nrabbitmqctl reset\n#无条件的初始化node状态\nrabbitmqctl force_reset\n#[--ram]不写则默认为disc\nrabbitmqctl join_cluster <clusternode> [--ram]\nrabbitmqctl cluster_status\n\n```\n\n好啦，rabbitMQ的教程到这里结束了，感谢小伙伴的阅读。往下我们会学习 kafka 的相关知识。\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","source":"_posts/rabbitMQ-yunwei.md","raw":"---\ntitle: rabbitMQ 运维相关\ndate: 2020-12-17\ntags: 中间件\n---\n相对前面几个章节来说，这个章节知识点不是着重点。大家对这一章节知识的掌握程度为了解。好了，废话不多说，开始正文\n<!--more-->\n## rabbitMQ集群\n\n单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，如果对吞吐量要求更高就需要构建rabbitMQ集群了。RabbitMQ 集群允许消费者和生产者在 RabbitMQ 单个节点崩惯的情况下继续运行，它可以 通过添加更多的节点来线性地扩展消息通信的吞吐量。当失去一个 RabbitMQ 节点时，客户端 能够重新连接到集群中的任何其他节点并继续生产或者消费。\n\nRabbitMQ 集群不能保证消息的万无一失。即使将消息、队列、交换器等都设置为可持久化，生产端和消费端都正确地使用了确认方式，当集群中一个 RabbitMQ 节点崩溃时，该节 点上的所有队列中的消息也会丢失。 RabbitMQ 集群中的所有节点都会备份所有的元数据信息， 包括队列的名称及属性，交换器的名称及属性，交换器与队列或者交换器与交换器之间的绑定关系， 但是不会备份消息（可以通过镜像队列来解决这个问题）。\n\nrabbitmq可以通过三种方式来部署分布式集群系统，分别是：cluster、federation、shovel。\n\ncluster的特点为:\n\n- 不支持夸网段，用于同一个网段内的局域网\n- 可以随意动态的增加和减少\n- 节点之间需要运行相同版本的rabbitmq和erlang\n\nfederation特点为:\n\n- 需要配置联邦交换机和联邦队列\n- 应用于广域网，允许单台服务器上的交换机或队列接收发布到另一台服务器交换机或队列的消息\n- 消息会在联盟队列之间转发任意次，直到被消费者接受。\n\nshovel:连接方式与federation的连接方式类似，相当于建立一个消费者，来将消息从一个队列转移到另一个队列。\n\n## 常用命令\n\n```\n#开启WEB后台监控\n./rabbitmq-plugins enable rabbitmq_management\n#启停服务\nservice rabbitmq-server start\nservice rabbitmq-server stop\nservice rabbitmq-server restart\n#查看状态\nservice rabbitmq-server status\n#运行节点\nrabbitmq-server -detached\n# rabbitmqctl（命令行工具）\nrabbitmqctl stop_app\nrabbitmqctl start_app\n#初始化node状态，会从集群中删除该节点\nrabbitmqctl reset\n#无条件的初始化node状态\nrabbitmqctl force_reset\n#[--ram]不写则默认为disc\nrabbitmqctl join_cluster <clusternode> [--ram]\nrabbitmqctl cluster_status\n\n```\n\n好啦，rabbitMQ的教程到这里结束了，感谢小伙伴的阅读。往下我们会学习 kafka 的相关知识。\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","slug":"rabbitMQ-yunwei","published":1,"updated":"2021-01-12T03:57:35.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6p003000wicvvwd5um","content":"<p>相对前面几个章节来说，这个章节知识点不是着重点。大家对这一章节知识的掌握程度为了解。好了，废话不多说，开始正文</p>\n<a id=\"more\"></a>\n<h2 id=\"rabbitMQ集群\"><a href=\"#rabbitMQ集群\" class=\"headerlink\" title=\"rabbitMQ集群\"></a>rabbitMQ集群</h2><p>单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，如果对吞吐量要求更高就需要构建rabbitMQ集群了。RabbitMQ 集群允许消费者和生产者在 RabbitMQ 单个节点崩惯的情况下继续运行，它可以 通过添加更多的节点来线性地扩展消息通信的吞吐量。当失去一个 RabbitMQ 节点时，客户端 能够重新连接到集群中的任何其他节点并继续生产或者消费。</p>\n<p>RabbitMQ 集群不能保证消息的万无一失。即使将消息、队列、交换器等都设置为可持久化，生产端和消费端都正确地使用了确认方式，当集群中一个 RabbitMQ 节点崩溃时，该节 点上的所有队列中的消息也会丢失。 RabbitMQ 集群中的所有节点都会备份所有的元数据信息， 包括队列的名称及属性，交换器的名称及属性，交换器与队列或者交换器与交换器之间的绑定关系， 但是不会备份消息（可以通过镜像队列来解决这个问题）。</p>\n<p>rabbitmq可以通过三种方式来部署分布式集群系统，分别是：cluster、federation、shovel。</p>\n<p>cluster的特点为:</p>\n<ul>\n<li>不支持夸网段，用于同一个网段内的局域网</li>\n<li>可以随意动态的增加和减少</li>\n<li>节点之间需要运行相同版本的rabbitmq和erlang</li>\n</ul>\n<p>federation特点为:</p>\n<ul>\n<li>需要配置联邦交换机和联邦队列</li>\n<li>应用于广域网，允许单台服务器上的交换机或队列接收发布到另一台服务器交换机或队列的消息</li>\n<li>消息会在联盟队列之间转发任意次，直到被消费者接受。</li>\n</ul>\n<p>shovel:连接方式与federation的连接方式类似，相当于建立一个消费者，来将消息从一个队列转移到另一个队列。</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#开启WEB后台监控</span><br><span class=\"line\">.&#x2F;rabbitmq-plugins enable rabbitmq_management</span><br><span class=\"line\">#启停服务</span><br><span class=\"line\">service rabbitmq-server start</span><br><span class=\"line\">service rabbitmq-server stop</span><br><span class=\"line\">service rabbitmq-server restart</span><br><span class=\"line\">#查看状态</span><br><span class=\"line\">service rabbitmq-server status</span><br><span class=\"line\">#运行节点</span><br><span class=\"line\">rabbitmq-server -detached</span><br><span class=\"line\"># rabbitmqctl（命令行工具）</span><br><span class=\"line\">rabbitmqctl stop_app</span><br><span class=\"line\">rabbitmqctl start_app</span><br><span class=\"line\">#初始化node状态，会从集群中删除该节点</span><br><span class=\"line\">rabbitmqctl reset</span><br><span class=\"line\">#无条件的初始化node状态</span><br><span class=\"line\">rabbitmqctl force_reset</span><br><span class=\"line\">#[--ram]不写则默认为disc</span><br><span class=\"line\">rabbitmqctl join_cluster &lt;clusternode&gt; [--ram]</span><br><span class=\"line\">rabbitmqctl cluster_status</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>好啦，rabbitMQ的教程到这里结束了，感谢小伙伴的阅读。往下我们会学习 kafka 的相关知识。</p>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>\n","site":{"data":{}},"excerpt":"<p>相对前面几个章节来说，这个章节知识点不是着重点。大家对这一章节知识的掌握程度为了解。好了，废话不多说，开始正文</p>","more":"<h2 id=\"rabbitMQ集群\"><a href=\"#rabbitMQ集群\" class=\"headerlink\" title=\"rabbitMQ集群\"></a>rabbitMQ集群</h2><p>单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，如果对吞吐量要求更高就需要构建rabbitMQ集群了。RabbitMQ 集群允许消费者和生产者在 RabbitMQ 单个节点崩惯的情况下继续运行，它可以 通过添加更多的节点来线性地扩展消息通信的吞吐量。当失去一个 RabbitMQ 节点时，客户端 能够重新连接到集群中的任何其他节点并继续生产或者消费。</p>\n<p>RabbitMQ 集群不能保证消息的万无一失。即使将消息、队列、交换器等都设置为可持久化，生产端和消费端都正确地使用了确认方式，当集群中一个 RabbitMQ 节点崩溃时，该节 点上的所有队列中的消息也会丢失。 RabbitMQ 集群中的所有节点都会备份所有的元数据信息， 包括队列的名称及属性，交换器的名称及属性，交换器与队列或者交换器与交换器之间的绑定关系， 但是不会备份消息（可以通过镜像队列来解决这个问题）。</p>\n<p>rabbitmq可以通过三种方式来部署分布式集群系统，分别是：cluster、federation、shovel。</p>\n<p>cluster的特点为:</p>\n<ul>\n<li>不支持夸网段，用于同一个网段内的局域网</li>\n<li>可以随意动态的增加和减少</li>\n<li>节点之间需要运行相同版本的rabbitmq和erlang</li>\n</ul>\n<p>federation特点为:</p>\n<ul>\n<li>需要配置联邦交换机和联邦队列</li>\n<li>应用于广域网，允许单台服务器上的交换机或队列接收发布到另一台服务器交换机或队列的消息</li>\n<li>消息会在联盟队列之间转发任意次，直到被消费者接受。</li>\n</ul>\n<p>shovel:连接方式与federation的连接方式类似，相当于建立一个消费者，来将消息从一个队列转移到另一个队列。</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#开启WEB后台监控</span><br><span class=\"line\">.&#x2F;rabbitmq-plugins enable rabbitmq_management</span><br><span class=\"line\">#启停服务</span><br><span class=\"line\">service rabbitmq-server start</span><br><span class=\"line\">service rabbitmq-server stop</span><br><span class=\"line\">service rabbitmq-server restart</span><br><span class=\"line\">#查看状态</span><br><span class=\"line\">service rabbitmq-server status</span><br><span class=\"line\">#运行节点</span><br><span class=\"line\">rabbitmq-server -detached</span><br><span class=\"line\"># rabbitmqctl（命令行工具）</span><br><span class=\"line\">rabbitmqctl stop_app</span><br><span class=\"line\">rabbitmqctl start_app</span><br><span class=\"line\">#初始化node状态，会从集群中删除该节点</span><br><span class=\"line\">rabbitmqctl reset</span><br><span class=\"line\">#无条件的初始化node状态</span><br><span class=\"line\">rabbitmqctl force_reset</span><br><span class=\"line\">#[--ram]不写则默认为disc</span><br><span class=\"line\">rabbitmqctl join_cluster &lt;clusternode&gt; [--ram]</span><br><span class=\"line\">rabbitmqctl cluster_status</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>好啦，rabbitMQ的教程到这里结束了，感谢小伙伴的阅读。往下我们会学习 kafka 的相关知识。</p>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>"},{"title":"rabbitMQ安装与配置","date":"2020-12-11T16:00:00.000Z","_content":"\n对 rabbitMQ 我们已经有了初步的了解，现在我们来安装 rabbitMQ 来进行一些操作。因为大部分人的操作系统都是windows 而且作者本人使用的也windows系统。所以这里只介绍在windows上安装rabbitMQ。mac用户自行解决（仇富脸）。\n<!--more-->\n## erlang的安装\n\nerlang 不好的地方是它不是向下兼容的，也就是说 rabbitMQ的版本和erlang的版本不匹配的话，会安装失败。所以我们要先上 rabbitMQ的官方网站查询对应的版本号，再安装 网站：https://www.rabbitmq.com/which-erlang.html \n\n查询好版本后向erlang 官方网站下载安装程序，网址：http://www.erlang.org/downloads \n\n下载安装完成之后，配置erlang的环境变量（参考JAVA_HOME）。\n\n```\n变量名：ERLANG_HOME\n变量值：你的安装路径\n```\n\n然后将  `%ERLANG_HOME%\\bin` 加入到path中，和Java maven 这些程序的配置方式一样。然后在cmd 中输入 `erlang` 验证一下，完成。\n\n## rabbitMQ的安装\n\n下载地址：http://www.rabbitmq.com/download.html\n\n注意要找对版本下载安装。安装完成后进入RabbitMQ的sbin目录下在cmd中执行\n\n```\n./rabbitmq-plugins enable rabbitmq_management\n```\n\n这个指令是安装 `rabbitmq_management` 插件。安装完成后cmd中执行（sbin目录下）：\n\n```\n./rabbitmqctl status \n```\n\n可以看到rabbitMQ的一些信息，就说明rabbitMQ安装成功了。如果没有成功。检查一下版本和环境变量等信息，重新安装。\n\n## rabbitMQ的配置\n\n安装完成之后执行 sbin 下的 `rabbitmq-server.bat` 启动 rabbitMQ 访问 http://localhost:15672 。我们会看到一个登录界面。用户名和密码都是guest。登录进去后能看到一些交换机 队列 用户 等的信息。\n\n![图 1：rabbit的web管理界面](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/a.png)\n\n​\t\t\t\t\t\t\t\t\t\t图 1：rabbit的界面\n\nguest这个用户是只能本地访问rabbitMQ的，相当去 mysql 的 root 用户。下面我们配置一个可以远程使用的开发账号。\n\n创建用户指令：\n\n```\nrabbitmqctl.bat add_user [username] [password]\n## 示例\nrabbitmqctl set_user_tag test test\n```\n\n查看用户列表：\n\n```\nrabbitmqctl list_users\n```\n\n给用户设置权限（tag）\n\n```\nrabbitmqctl set_user_tag [tag1] [tag2]\n## 示例\nrabbitmqctl set_user_tag test administrator \n```\n\nrabbitMQ 有五个tag(权限) 分别是：\n\n-  超级管理员(administrator) 有所有权限\n-  监控者(monitoring) 有读权限\n-  策略制定者(policymaker) \n-  普通管理者(management) \n- 其他（none）\n\n配置完权限之后，我们再修改配置文件以支持新建账号的远程访问。我们打开 rabbitMQ安装目录的下的 `etc/rabbitmq.config.example` 搜索 `loopback_users` 会找到这一行：\n\n```\n  %% {loopback_users, []},\n```\n\n改成\n\n```\n{loopback_users, [\"username0\",\"username1\"]},\n```\n\n这里的username 是你的用户名。配置完成后重启服务：\n\n```\nsbin/rabbitmq-service.bat stop\nsbin/rabbitmq-service.bat start\n```\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任\n\n","source":"_posts/rabbitMQ安装与简单使用.md","raw":"---\ntitle: rabbitMQ安装与配置\ndate: 2020-12-12\ntags: 中间件\n---\n\n对 rabbitMQ 我们已经有了初步的了解，现在我们来安装 rabbitMQ 来进行一些操作。因为大部分人的操作系统都是windows 而且作者本人使用的也windows系统。所以这里只介绍在windows上安装rabbitMQ。mac用户自行解决（仇富脸）。\n<!--more-->\n## erlang的安装\n\nerlang 不好的地方是它不是向下兼容的，也就是说 rabbitMQ的版本和erlang的版本不匹配的话，会安装失败。所以我们要先上 rabbitMQ的官方网站查询对应的版本号，再安装 网站：https://www.rabbitmq.com/which-erlang.html \n\n查询好版本后向erlang 官方网站下载安装程序，网址：http://www.erlang.org/downloads \n\n下载安装完成之后，配置erlang的环境变量（参考JAVA_HOME）。\n\n```\n变量名：ERLANG_HOME\n变量值：你的安装路径\n```\n\n然后将  `%ERLANG_HOME%\\bin` 加入到path中，和Java maven 这些程序的配置方式一样。然后在cmd 中输入 `erlang` 验证一下，完成。\n\n## rabbitMQ的安装\n\n下载地址：http://www.rabbitmq.com/download.html\n\n注意要找对版本下载安装。安装完成后进入RabbitMQ的sbin目录下在cmd中执行\n\n```\n./rabbitmq-plugins enable rabbitmq_management\n```\n\n这个指令是安装 `rabbitmq_management` 插件。安装完成后cmd中执行（sbin目录下）：\n\n```\n./rabbitmqctl status \n```\n\n可以看到rabbitMQ的一些信息，就说明rabbitMQ安装成功了。如果没有成功。检查一下版本和环境变量等信息，重新安装。\n\n## rabbitMQ的配置\n\n安装完成之后执行 sbin 下的 `rabbitmq-server.bat` 启动 rabbitMQ 访问 http://localhost:15672 。我们会看到一个登录界面。用户名和密码都是guest。登录进去后能看到一些交换机 队列 用户 等的信息。\n\n![图 1：rabbit的web管理界面](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/a.png)\n\n​\t\t\t\t\t\t\t\t\t\t图 1：rabbit的界面\n\nguest这个用户是只能本地访问rabbitMQ的，相当去 mysql 的 root 用户。下面我们配置一个可以远程使用的开发账号。\n\n创建用户指令：\n\n```\nrabbitmqctl.bat add_user [username] [password]\n## 示例\nrabbitmqctl set_user_tag test test\n```\n\n查看用户列表：\n\n```\nrabbitmqctl list_users\n```\n\n给用户设置权限（tag）\n\n```\nrabbitmqctl set_user_tag [tag1] [tag2]\n## 示例\nrabbitmqctl set_user_tag test administrator \n```\n\nrabbitMQ 有五个tag(权限) 分别是：\n\n-  超级管理员(administrator) 有所有权限\n-  监控者(monitoring) 有读权限\n-  策略制定者(policymaker) \n-  普通管理者(management) \n- 其他（none）\n\n配置完权限之后，我们再修改配置文件以支持新建账号的远程访问。我们打开 rabbitMQ安装目录的下的 `etc/rabbitmq.config.example` 搜索 `loopback_users` 会找到这一行：\n\n```\n  %% {loopback_users, []},\n```\n\n改成\n\n```\n{loopback_users, [\"username0\",\"username1\"]},\n```\n\n这里的username 是你的用户名。配置完成后重启服务：\n\n```\nsbin/rabbitmq-service.bat stop\nsbin/rabbitmq-service.bat start\n```\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任\n\n","slug":"rabbitMQ安装与简单使用","published":1,"updated":"2021-01-12T04:00:12.768Z","_id":"ckjtgsh6p003300wifu7rgxrn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>对 rabbitMQ 我们已经有了初步的了解，现在我们来安装 rabbitMQ 来进行一些操作。因为大部分人的操作系统都是windows 而且作者本人使用的也windows系统。所以这里只介绍在windows上安装rabbitMQ。mac用户自行解决（仇富脸）。</p>\n<a id=\"more\"></a>\n<h2 id=\"erlang的安装\"><a href=\"#erlang的安装\" class=\"headerlink\" title=\"erlang的安装\"></a>erlang的安装</h2><p>erlang 不好的地方是它不是向下兼容的，也就是说 rabbitMQ的版本和erlang的版本不匹配的话，会安装失败。所以我们要先上 rabbitMQ的官方网站查询对应的版本号，再安装 网站：<a href=\"https://www.rabbitmq.com/which-erlang.html\">https://www.rabbitmq.com/which-erlang.html</a> </p>\n<p>查询好版本后向erlang 官方网站下载安装程序，网址：<a href=\"http://www.erlang.org/downloads\">http://www.erlang.org/downloads</a> </p>\n<p>下载安装完成之后，配置erlang的环境变量（参考JAVA_HOME）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量名：ERLANG_HOME</span><br><span class=\"line\">变量值：你的安装路径</span><br></pre></td></tr></table></figure>\n<p>然后将  <code>%ERLANG_HOME%\\bin</code> 加入到path中，和Java maven 这些程序的配置方式一样。然后在cmd 中输入 <code>erlang</code> 验证一下，完成。</p>\n<h2 id=\"rabbitMQ的安装\"><a href=\"#rabbitMQ的安装\" class=\"headerlink\" title=\"rabbitMQ的安装\"></a>rabbitMQ的安装</h2><p>下载地址：<a href=\"http://www.rabbitmq.com/download.html\">http://www.rabbitmq.com/download.html</a></p>\n<p>注意要找对版本下载安装。安装完成后进入RabbitMQ的sbin目录下在cmd中执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>\n<p>这个指令是安装 <code>rabbitmq_management</code> 插件。安装完成后cmd中执行（sbin目录下）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;rabbitmqctl status </span><br></pre></td></tr></table></figure>\n<p>可以看到rabbitMQ的一些信息，就说明rabbitMQ安装成功了。如果没有成功。检查一下版本和环境变量等信息，重新安装。</p>\n<h2 id=\"rabbitMQ的配置\"><a href=\"#rabbitMQ的配置\" class=\"headerlink\" title=\"rabbitMQ的配置\"></a>rabbitMQ的配置</h2><p>安装完成之后执行 sbin 下的 <code>rabbitmq-server.bat</code> 启动 rabbitMQ 访问 <a href=\"http://localhost:15672\">http://localhost:15672</a> 。我们会看到一个登录界面。用户名和密码都是guest。登录进去后能看到一些交换机 队列 用户 等的信息。</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/a.png\" alt=\"图 1：rabbit的web管理界面\"></p>\n<p>​                                        图 1：rabbit的界面</p>\n<p>guest这个用户是只能本地访问rabbitMQ的，相当去 mysql 的 root 用户。下面我们配置一个可以远程使用的开发账号。</p>\n<p>创建用户指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl.bat add_user [username] [password]</span><br><span class=\"line\">## 示例</span><br><span class=\"line\">rabbitmqctl set_user_tag test test</span><br></pre></td></tr></table></figure>\n<p>查看用户列表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>\n<p>给用户设置权限（tag）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_user_tag [tag1] [tag2]</span><br><span class=\"line\">## 示例</span><br><span class=\"line\">rabbitmqctl set_user_tag test administrator </span><br></pre></td></tr></table></figure>\n<p>rabbitMQ 有五个tag(权限) 分别是：</p>\n<ul>\n<li>超级管理员(administrator) 有所有权限</li>\n<li>监控者(monitoring) 有读权限</li>\n<li>策略制定者(policymaker) </li>\n<li>普通管理者(management) </li>\n<li>其他（none）</li>\n</ul>\n<p>配置完权限之后，我们再修改配置文件以支持新建账号的远程访问。我们打开 rabbitMQ安装目录的下的 <code>etc/rabbitmq.config.example</code> 搜索 <code>loopback_users</code> 会找到这一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% &#123;loopback_users, []&#125;,</span><br></pre></td></tr></table></figure>\n<p>改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;loopback_users, [&quot;username0&quot;,&quot;username1&quot;]&#125;,</span><br></pre></td></tr></table></figure>\n<p>这里的username 是你的用户名。配置完成后重启服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sbin&#x2F;rabbitmq-service.bat stop</span><br><span class=\"line\">sbin&#x2F;rabbitmq-service.bat start</span><br></pre></td></tr></table></figure>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>\n","site":{"data":{}},"excerpt":"<p>对 rabbitMQ 我们已经有了初步的了解，现在我们来安装 rabbitMQ 来进行一些操作。因为大部分人的操作系统都是windows 而且作者本人使用的也windows系统。所以这里只介绍在windows上安装rabbitMQ。mac用户自行解决（仇富脸）。</p>","more":"<h2 id=\"erlang的安装\"><a href=\"#erlang的安装\" class=\"headerlink\" title=\"erlang的安装\"></a>erlang的安装</h2><p>erlang 不好的地方是它不是向下兼容的，也就是说 rabbitMQ的版本和erlang的版本不匹配的话，会安装失败。所以我们要先上 rabbitMQ的官方网站查询对应的版本号，再安装 网站：<a href=\"https://www.rabbitmq.com/which-erlang.html\">https://www.rabbitmq.com/which-erlang.html</a> </p>\n<p>查询好版本后向erlang 官方网站下载安装程序，网址：<a href=\"http://www.erlang.org/downloads\">http://www.erlang.org/downloads</a> </p>\n<p>下载安装完成之后，配置erlang的环境变量（参考JAVA_HOME）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">变量名：ERLANG_HOME</span><br><span class=\"line\">变量值：你的安装路径</span><br></pre></td></tr></table></figure>\n<p>然后将  <code>%ERLANG_HOME%\\bin</code> 加入到path中，和Java maven 这些程序的配置方式一样。然后在cmd 中输入 <code>erlang</code> 验证一下，完成。</p>\n<h2 id=\"rabbitMQ的安装\"><a href=\"#rabbitMQ的安装\" class=\"headerlink\" title=\"rabbitMQ的安装\"></a>rabbitMQ的安装</h2><p>下载地址：<a href=\"http://www.rabbitmq.com/download.html\">http://www.rabbitmq.com/download.html</a></p>\n<p>注意要找对版本下载安装。安装完成后进入RabbitMQ的sbin目录下在cmd中执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>\n<p>这个指令是安装 <code>rabbitmq_management</code> 插件。安装完成后cmd中执行（sbin目录下）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;rabbitmqctl status </span><br></pre></td></tr></table></figure>\n<p>可以看到rabbitMQ的一些信息，就说明rabbitMQ安装成功了。如果没有成功。检查一下版本和环境变量等信息，重新安装。</p>\n<h2 id=\"rabbitMQ的配置\"><a href=\"#rabbitMQ的配置\" class=\"headerlink\" title=\"rabbitMQ的配置\"></a>rabbitMQ的配置</h2><p>安装完成之后执行 sbin 下的 <code>rabbitmq-server.bat</code> 启动 rabbitMQ 访问 <a href=\"http://localhost:15672\">http://localhost:15672</a> 。我们会看到一个登录界面。用户名和密码都是guest。登录进去后能看到一些交换机 队列 用户 等的信息。</p>\n<p><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/a.png\" alt=\"图 1：rabbit的web管理界面\"></p>\n<p>​                                        图 1：rabbit的界面</p>\n<p>guest这个用户是只能本地访问rabbitMQ的，相当去 mysql 的 root 用户。下面我们配置一个可以远程使用的开发账号。</p>\n<p>创建用户指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl.bat add_user [username] [password]</span><br><span class=\"line\">## 示例</span><br><span class=\"line\">rabbitmqctl set_user_tag test test</span><br></pre></td></tr></table></figure>\n<p>查看用户列表：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl list_users</span><br></pre></td></tr></table></figure>\n<p>给用户设置权限（tag）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_user_tag [tag1] [tag2]</span><br><span class=\"line\">## 示例</span><br><span class=\"line\">rabbitmqctl set_user_tag test administrator </span><br></pre></td></tr></table></figure>\n<p>rabbitMQ 有五个tag(权限) 分别是：</p>\n<ul>\n<li>超级管理员(administrator) 有所有权限</li>\n<li>监控者(monitoring) 有读权限</li>\n<li>策略制定者(policymaker) </li>\n<li>普通管理者(management) </li>\n<li>其他（none）</li>\n</ul>\n<p>配置完权限之后，我们再修改配置文件以支持新建账号的远程访问。我们打开 rabbitMQ安装目录的下的 <code>etc/rabbitmq.config.example</code> 搜索 <code>loopback_users</code> 会找到这一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% &#123;loopback_users, []&#125;,</span><br></pre></td></tr></table></figure>\n<p>改成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;loopback_users, [&quot;username0&quot;,&quot;username1&quot;]&#125;,</span><br></pre></td></tr></table></figure>\n<p>这里的username 是你的用户名。配置完成后重启服务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sbin&#x2F;rabbitmq-service.bat stop</span><br><span class=\"line\">sbin&#x2F;rabbitmq-service.bat start</span><br></pre></td></tr></table></figure>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>"},{"title":"rabbitMQ简介","date":"2020-12-12T16:00:00.000Z","_content":"\n前文我们学习了 MQ的相关知识，现在我们来学习一下实现了AMQP协议的 `rabbitMQ` 中间件。rabbitMQ 是使用 erlang 语言编写的中间件（erlang之父 19年4月去世的，很伟大一个程序员）。\n<!--more-->\n## rabbitMQ 的结构和的角色\n\n学习rabbtMQ我们先要弄清楚这几个概念：`exchange`,`queue`,`routing-key`,`binding-key`,`message`,`publisher`,`exchange`,`binding-key`,`Connection`,`Channel`,`consumer`,`broker`；下面对这些角色概念进行介绍。\n\n消息的发送方被称作`publisher`（生产者），而消息的接收方被称作`consumer`(消费者)，而消息队列服务器实体就是`broker`（指`rabbitMQ`）；消费者或者生产者对rabbitMQ的一个连接被称作`Connection`（连接）,在rabbit的连接模型中，为了提高连接传输效率，采用了`Channel`（管道）这种方式实现多路复用，类似于Nio中的模型；我们知道建立一个TCP连接代价很大，因此TCP连接建立后最好不要断开`Connection`-`Channel`连接模型就是为了达到这种目的；一个消费者（生产者）使用一个`channel`消费（发送）消息，而多个`Channel`共用一个`Connection`。\n\n一个生产者向rabbit投递消息，然后消费者消费这个消息的过程是这样的——生产者将消息投递给rabbit，在rabbit中`exchange`（交换机）首先会接收到这个消息，交换机相当于一个“分拣员”的角色，负责分拣消息，将这些消息存储到和自己绑定的`queue`（队列）中去，然后和队列绑定的消费者会消费这些消息。队列和交换机绑定通过一个`binding-key`（绑定键）来标记，而生产者投递消息给交换机的时候会指定一个`routing-key`（路由键），而交换机会根据路由和绑定键来判断将消息放到那些队列中去（扩展：kafka的数据是存储在 exchange 中，它的 queue 只是逻辑队列）。\n图一是rabbitMQ的一个概念简图：\n![rabbitMQ概念简图](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/rabbitmq架构.jpg)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图一：rabbitMQ 概念简图\n\n## rabbitMQ交换机类型\n\n在rabbit中交换机共有四种类型，下面对其类型和其消息路由规则做说明：\n\n- `direct exchange`(直连交换机)：消息中的`routing-key`如果和`binding-key`一致， 交换器就将消息发到对应的队列中,`routing-key`要与`binding-key`完全匹配。\n- `fanout exchange`(扇型交换机):扇型交换机会将交给自己的消息发到所有和自己绑定的队列中去，它不会去匹配`routing-key`和`binding-key`。\n- `topic exchange`(主题交换机):主题交换机的`routing-key`匹配`binding-key`的方式支持模糊匹配， 以.分割单词，`*`匹配一个单词，`#`匹配多个单词，比如如路由键是`com.muggle.first` 能被`com.#`和`*.muggle.*`绑定键匹配。\n- `headers exchange`(头交换机):类似主题交换机，但是头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。当交换机的`x-match`属性为`any`时，消息头的任意一个值被匹配就可以满足条件,当为`all`的时候，就需要消息头的所有值都匹配成功,这种交换机在实际生产中用的并不多。\n\n在实际生产中，我们可以选择不同交换机类型来灵活的配置我们的生产者和消费者之间消息的消费关系。如延时队列，消息广播等的功能。\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","source":"_posts/rabbitMQ简介.md","raw":"---\ntitle: rabbitMQ简介\ndate: 2020-12-13\ntags: 中间件\n---\n\n前文我们学习了 MQ的相关知识，现在我们来学习一下实现了AMQP协议的 `rabbitMQ` 中间件。rabbitMQ 是使用 erlang 语言编写的中间件（erlang之父 19年4月去世的，很伟大一个程序员）。\n<!--more-->\n## rabbitMQ 的结构和的角色\n\n学习rabbtMQ我们先要弄清楚这几个概念：`exchange`,`queue`,`routing-key`,`binding-key`,`message`,`publisher`,`exchange`,`binding-key`,`Connection`,`Channel`,`consumer`,`broker`；下面对这些角色概念进行介绍。\n\n消息的发送方被称作`publisher`（生产者），而消息的接收方被称作`consumer`(消费者)，而消息队列服务器实体就是`broker`（指`rabbitMQ`）；消费者或者生产者对rabbitMQ的一个连接被称作`Connection`（连接）,在rabbit的连接模型中，为了提高连接传输效率，采用了`Channel`（管道）这种方式实现多路复用，类似于Nio中的模型；我们知道建立一个TCP连接代价很大，因此TCP连接建立后最好不要断开`Connection`-`Channel`连接模型就是为了达到这种目的；一个消费者（生产者）使用一个`channel`消费（发送）消息，而多个`Channel`共用一个`Connection`。\n\n一个生产者向rabbit投递消息，然后消费者消费这个消息的过程是这样的——生产者将消息投递给rabbit，在rabbit中`exchange`（交换机）首先会接收到这个消息，交换机相当于一个“分拣员”的角色，负责分拣消息，将这些消息存储到和自己绑定的`queue`（队列）中去，然后和队列绑定的消费者会消费这些消息。队列和交换机绑定通过一个`binding-key`（绑定键）来标记，而生产者投递消息给交换机的时候会指定一个`routing-key`（路由键），而交换机会根据路由和绑定键来判断将消息放到那些队列中去（扩展：kafka的数据是存储在 exchange 中，它的 queue 只是逻辑队列）。\n图一是rabbitMQ的一个概念简图：\n![rabbitMQ概念简图](https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/rabbitmq架构.jpg)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t图一：rabbitMQ 概念简图\n\n## rabbitMQ交换机类型\n\n在rabbit中交换机共有四种类型，下面对其类型和其消息路由规则做说明：\n\n- `direct exchange`(直连交换机)：消息中的`routing-key`如果和`binding-key`一致， 交换器就将消息发到对应的队列中,`routing-key`要与`binding-key`完全匹配。\n- `fanout exchange`(扇型交换机):扇型交换机会将交给自己的消息发到所有和自己绑定的队列中去，它不会去匹配`routing-key`和`binding-key`。\n- `topic exchange`(主题交换机):主题交换机的`routing-key`匹配`binding-key`的方式支持模糊匹配， 以.分割单词，`*`匹配一个单词，`#`匹配多个单词，比如如路由键是`com.muggle.first` 能被`com.#`和`*.muggle.*`绑定键匹配。\n- `headers exchange`(头交换机):类似主题交换机，但是头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。当交换机的`x-match`属性为`any`时，消息头的任意一个值被匹配就可以满足条件,当为`all`的时候，就需要消息头的所有值都匹配成功,这种交换机在实际生产中用的并不多。\n\n在实际生产中，我们可以选择不同交换机类型来灵活的配置我们的生产者和消费者之间消息的消费关系。如延时队列，消息广播等的功能。\n\n---\n\n作者：muggle [点我关注作者](https://muggle.javaboy.org/2019/03/20/home/) \n\n出处：https://muggle-book.gitee.io/\n\n版权：本文版权归作者所有 \n\n转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任","slug":"rabbitMQ简介","published":1,"updated":"2021-01-12T03:46:23.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6q003500wi86zab88m","content":"<p>前文我们学习了 MQ的相关知识，现在我们来学习一下实现了AMQP协议的 <code>rabbitMQ</code> 中间件。rabbitMQ 是使用 erlang 语言编写的中间件（erlang之父 19年4月去世的，很伟大一个程序员）。</p>\n<a id=\"more\"></a>\n<h2 id=\"rabbitMQ-的结构和的角色\"><a href=\"#rabbitMQ-的结构和的角色\" class=\"headerlink\" title=\"rabbitMQ 的结构和的角色\"></a>rabbitMQ 的结构和的角色</h2><p>学习rabbtMQ我们先要弄清楚这几个概念：<code>exchange</code>,<code>queue</code>,<code>routing-key</code>,<code>binding-key</code>,<code>message</code>,<code>publisher</code>,<code>exchange</code>,<code>binding-key</code>,<code>Connection</code>,<code>Channel</code>,<code>consumer</code>,<code>broker</code>；下面对这些角色概念进行介绍。</p>\n<p>消息的发送方被称作<code>publisher</code>（生产者），而消息的接收方被称作<code>consumer</code>(消费者)，而消息队列服务器实体就是<code>broker</code>（指<code>rabbitMQ</code>）；消费者或者生产者对rabbitMQ的一个连接被称作<code>Connection</code>（连接）,在rabbit的连接模型中，为了提高连接传输效率，采用了<code>Channel</code>（管道）这种方式实现多路复用，类似于Nio中的模型；我们知道建立一个TCP连接代价很大，因此TCP连接建立后最好不要断开<code>Connection</code>-<code>Channel</code>连接模型就是为了达到这种目的；一个消费者（生产者）使用一个<code>channel</code>消费（发送）消息，而多个<code>Channel</code>共用一个<code>Connection</code>。</p>\n<p>一个生产者向rabbit投递消息，然后消费者消费这个消息的过程是这样的——生产者将消息投递给rabbit，在rabbit中<code>exchange</code>（交换机）首先会接收到这个消息，交换机相当于一个“分拣员”的角色，负责分拣消息，将这些消息存储到和自己绑定的<code>queue</code>（队列）中去，然后和队列绑定的消费者会消费这些消息。队列和交换机绑定通过一个<code>binding-key</code>（绑定键）来标记，而生产者投递消息给交换机的时候会指定一个<code>routing-key</code>（路由键），而交换机会根据路由和绑定键来判断将消息放到那些队列中去（扩展：kafka的数据是存储在 exchange 中，它的 queue 只是逻辑队列）。<br>图一是rabbitMQ的一个概念简图：<br><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/rabbitmq%E6%9E%B6%E6%9E%84.jpg\" alt=\"rabbitMQ概念简图\"><br>                                                                    图一：rabbitMQ 概念简图</p>\n<h2 id=\"rabbitMQ交换机类型\"><a href=\"#rabbitMQ交换机类型\" class=\"headerlink\" title=\"rabbitMQ交换机类型\"></a>rabbitMQ交换机类型</h2><p>在rabbit中交换机共有四种类型，下面对其类型和其消息路由规则做说明：</p>\n<ul>\n<li><code>direct exchange</code>(直连交换机)：消息中的<code>routing-key</code>如果和<code>binding-key</code>一致， 交换器就将消息发到对应的队列中,<code>routing-key</code>要与<code>binding-key</code>完全匹配。</li>\n<li><code>fanout exchange</code>(扇型交换机):扇型交换机会将交给自己的消息发到所有和自己绑定的队列中去，它不会去匹配<code>routing-key</code>和<code>binding-key</code>。</li>\n<li><code>topic exchange</code>(主题交换机):主题交换机的<code>routing-key</code>匹配<code>binding-key</code>的方式支持模糊匹配， 以.分割单词，<code>*</code>匹配一个单词，<code>#</code>匹配多个单词，比如如路由键是<code>com.muggle.first</code> 能被<code>com.#</code>和<code>*.muggle.*</code>绑定键匹配。</li>\n<li><code>headers exchange</code>(头交换机):类似主题交换机，但是头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。当交换机的<code>x-match</code>属性为<code>any</code>时，消息头的任意一个值被匹配就可以满足条件,当为<code>all</code>的时候，就需要消息头的所有值都匹配成功,这种交换机在实际生产中用的并不多。</li>\n</ul>\n<p>在实际生产中，我们可以选择不同交换机类型来灵活的配置我们的生产者和消费者之间消息的消费关系。如延时队列，消息广播等的功能。</p>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>\n","site":{"data":{}},"excerpt":"<p>前文我们学习了 MQ的相关知识，现在我们来学习一下实现了AMQP协议的 <code>rabbitMQ</code> 中间件。rabbitMQ 是使用 erlang 语言编写的中间件（erlang之父 19年4月去世的，很伟大一个程序员）。</p>","more":"<h2 id=\"rabbitMQ-的结构和的角色\"><a href=\"#rabbitMQ-的结构和的角色\" class=\"headerlink\" title=\"rabbitMQ 的结构和的角色\"></a>rabbitMQ 的结构和的角色</h2><p>学习rabbtMQ我们先要弄清楚这几个概念：<code>exchange</code>,<code>queue</code>,<code>routing-key</code>,<code>binding-key</code>,<code>message</code>,<code>publisher</code>,<code>exchange</code>,<code>binding-key</code>,<code>Connection</code>,<code>Channel</code>,<code>consumer</code>,<code>broker</code>；下面对这些角色概念进行介绍。</p>\n<p>消息的发送方被称作<code>publisher</code>（生产者），而消息的接收方被称作<code>consumer</code>(消费者)，而消息队列服务器实体就是<code>broker</code>（指<code>rabbitMQ</code>）；消费者或者生产者对rabbitMQ的一个连接被称作<code>Connection</code>（连接）,在rabbit的连接模型中，为了提高连接传输效率，采用了<code>Channel</code>（管道）这种方式实现多路复用，类似于Nio中的模型；我们知道建立一个TCP连接代价很大，因此TCP连接建立后最好不要断开<code>Connection</code>-<code>Channel</code>连接模型就是为了达到这种目的；一个消费者（生产者）使用一个<code>channel</code>消费（发送）消息，而多个<code>Channel</code>共用一个<code>Connection</code>。</p>\n<p>一个生产者向rabbit投递消息，然后消费者消费这个消息的过程是这样的——生产者将消息投递给rabbit，在rabbit中<code>exchange</code>（交换机）首先会接收到这个消息，交换机相当于一个“分拣员”的角色，负责分拣消息，将这些消息存储到和自己绑定的<code>queue</code>（队列）中去，然后和队列绑定的消费者会消费这些消息。队列和交换机绑定通过一个<code>binding-key</code>（绑定键）来标记，而生产者投递消息给交换机的时候会指定一个<code>routing-key</code>（路由键），而交换机会根据路由和绑定键来判断将消息放到那些队列中去（扩展：kafka的数据是存储在 exchange 中，它的 queue 只是逻辑队列）。<br>图一是rabbitMQ的一个概念简图：<br><img src=\"https://raw.githubusercontent.com/muggle0/muggle0.github.io/master/rabbitmq%E6%9E%B6%E6%9E%84.jpg\" alt=\"rabbitMQ概念简图\"><br>                                                                    图一：rabbitMQ 概念简图</p>\n<h2 id=\"rabbitMQ交换机类型\"><a href=\"#rabbitMQ交换机类型\" class=\"headerlink\" title=\"rabbitMQ交换机类型\"></a>rabbitMQ交换机类型</h2><p>在rabbit中交换机共有四种类型，下面对其类型和其消息路由规则做说明：</p>\n<ul>\n<li><code>direct exchange</code>(直连交换机)：消息中的<code>routing-key</code>如果和<code>binding-key</code>一致， 交换器就将消息发到对应的队列中,<code>routing-key</code>要与<code>binding-key</code>完全匹配。</li>\n<li><code>fanout exchange</code>(扇型交换机):扇型交换机会将交给自己的消息发到所有和自己绑定的队列中去，它不会去匹配<code>routing-key</code>和<code>binding-key</code>。</li>\n<li><code>topic exchange</code>(主题交换机):主题交换机的<code>routing-key</code>匹配<code>binding-key</code>的方式支持模糊匹配， 以.分割单词，<code>*</code>匹配一个单词，<code>#</code>匹配多个单词，比如如路由键是<code>com.muggle.first</code> 能被<code>com.#</code>和<code>*.muggle.*</code>绑定键匹配。</li>\n<li><code>headers exchange</code>(头交换机):类似主题交换机，但是头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。当交换机的<code>x-match</code>属性为<code>any</code>时，消息头的任意一个值被匹配就可以满足条件,当为<code>all</code>的时候，就需要消息头的所有值都匹配成功,这种交换机在实际生产中用的并不多。</li>\n</ul>\n<p>在实际生产中，我们可以选择不同交换机类型来灵活的配置我们的生产者和消费者之间消息的消费关系。如延时队列，消息广播等的功能。</p>\n<hr>\n<p>作者：muggle <a href=\"https://muggle.javaboy.org/2019/03/20/home/\">点我关注作者</a> </p>\n<p>出处：<a href=\"https://muggle-book.gitee.io/\">https://muggle-book.gitee.io/</a></p>\n<p>版权：本文版权归作者所有 </p>\n<p>转载：欢迎转载，但未经作者同意，必须保留此段声明；必须在文章中给出原文连接；否则必究法律责任</p>"},{"title":"java撸一只爬虫","date":"2019-04-30T08:06:11.000Z","_content":"\n<!--more-->","source":"_posts/reptile.md","raw":"---\ntitle: java撸一只爬虫\ndate: 2019-04-30 16:06:11\ntags: javase\n---\n\n<!--more-->","slug":"reptile","published":1,"updated":"2021-01-11T07:31:23.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6r003800wi7famduxm","content":"<a id=\"more\"></a>","site":{"data":{}},"excerpt":"","more":""},{"title":"spi和jar","date":"2019-05-17T03:47:30.000Z","_content":"\n今天介绍两个大家每天都在用但是却很少去了解它的知识点：spi和jar运行机制，废话不多说，开始正题\n\n# spi\n\n是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。spi机制是这样的：读取`META-INF/services/`目录下的元信息，然后ServiceLoader根据信息加载对应的类，你可以在自己的代码中使用这个被加载的类。要使用Java SPI，需要遵循如下约定：\n\n<!--more-->\n\n- 当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；\n- 接口实现类所在的jar包放在主程序的classpath中；\n- 主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；\n- SPI的实现类必须携带一个不带参数的构造方法；\n\n现在我们来简单的使用一下吧\n\n## spi使用示例\n\n建一个maven项目，定义一个接口 (`com.test.SpiTest`)，并实现该接口（`com.test.SpiTestImpl`）；然后在 `src/main/resources/` 下建立 `/META-INF/services` 目录， 新增一个以接口命名的文件 (`com.test.SpiTest`)，内容是要应用的实现类（`com.test.SpiTestImpl`）。\n\n```java\npublic interface SpiTest {\n    void test();\n}\n\n\npublic class SpiTestImpl implements SpiTest {\n    @Override\n    public void test() {\n        System.out.println(\"test\");\n    }\n}\n\n```\n\n\n\n然后在我们的应用程序中使用 `ServiceLoader `来加载配置文件中指定的实现。\n\n```java\npublic static void main(String[] args) {\n        ServiceLoader<SpiTest> load = ServiceLoader.load(SpiTest.class);\n        SpiTest next = load.iterator().next();\n        next.test();\n      \n    }\n```\n\n这便是spi的使用方式了，简约而不简单\n\n## spi技术的应用\n\n那这一项技术有哪些方面的应用呢？最直接的jdbc中我们需要指定数据库驱动的全限定名，这便是spi技术。还有不少框架比如dubbo，都会预留spi扩展点比如：[dubbo spi](<http://dubbo.apache.org/zh-cn/docs/dev/impls/protocol.html>)\n\n为什么要这么做呢？在spring框架中我们注入一个bean 很容易，通过注解或者xml配置即可，然后在其他的地方就能使用这个bean。在非spring框架下，我们想要有同样的效果就可以考虑spi技术了。\n\n写过springboot 的starter的都知道，需要在 `src/main/resources/` 下建立 `/META-INF/spring.factories` 文件。这其实也是一种spi技术的变形。\n\n# jar机制\n\n通常项目中我们打jar包都是通过maven来进行的，导致很多人忽略了这个东西的存在，就像很多人不知道jdb.exe 是啥玩意一样。下面我们不借助任何工具来打一个jar包并对jar文件结构进行解析。\n\n## 命令行打jar包\n\n首先我们建立一个普通的java项目，新建几个class类，然后在根目录下新建`META-INF/MAINFEST.MF` 这个文件包含了jar的元信息，当我们执行java -jar的时候首先会读取该文件的信息做相关的处理。我们来看看这个文件中可以配置哪些信息 ：\n\n- Manifest-Version：用来定义manifest文件的版本，例如：Manifest-Version: 1.0\n- Main-Class：定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。\n- Class-Path：指定该jar包所依赖的外部jar包，以当前jar包所在的位置为相对路径，无法指定jar包内部的jar包\n- 签名相关属性，包括`Name`，`Digest-Algorithms`，`SHA-Digest`等\n\n定义好元信息之后我们就可以打jar包了，以下是打包的一些常用命令\n\n```shell\n/* 1. 默认打包 */\n// 生成的test.jar中就含test目录和jar自动生成的META-INF目录（内含MAINFEST.MF清单文件）\njar -cvf test.jar test\n\n/* 2. 查看包内容 */\njar -tvf test.jar\n\n/* 3. 解压jar包 */\njar -xvf test.jar\n\n/* 4. 提取jar包部分内容 */\njar -xvf test.jar test\\test.class\n\n/* 5. 追加内容到jar包 */\n//追加MAINFEST.MF清单文件以外的文件，会追加整个目录结构\njar -uvf test.jar other\\ss.class\n\n//追加清单文件，会追加整个目录结构(test.jar会包含META-INF目录)\njar -uMvf test.jar META-INF\\MAINFEST.MF\n\n/* 6. 创建自定义MAINFEST.MF的jar包 */\njar -cMvf test.jar test META-INF\n\n// 通过-m选项配置自定义MAINFEST.MF文件时，自定义MAINFEST.MF文件必须在位于工作目录下才可以\njar -cmvf MAINFEST.MF test.jar test\n```\n\n## jar运行的过程\n\njar运行过程和类加载机制有关，而类加载机制又和我们自定义的类加载器有关，现在我们先来了解一下双亲委派模式。\n\njava中类加载器分为三个：\n\n- BootstrapClassLoader负责加载`${JAVA_HOME}/jre/lib`部分jar包\n- ExtClassLoader加载`${JAVA_HOME}/jre/lib/ext`下面的jar包\n- AppClassLoader加载用户自定义-classpath或者Jar包的Class-Path定义的第三方包\n\n类的生命周期为：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using) 和 卸载(Unloading)七个阶段。\n\n当我们执行 java -jar的时候 jar文件以二进制流的形式被读取到内存，但不会加载到jvm中，类会在一个合适的时机加载到虚拟机中。类加载的时机：\n\n- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先对其进行初始化。成这四条指令的最常见的Java代码场景是使用new关键字实例化对象的时候，读取或设置一个类的静态字段调用一个类的静态方法的时候。\n- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。\n- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。\n\n当触发类加载的时候，类加载器也不是直接加载这个类。首先交给`AppClassLoader`，它会查看自己有没有加载过这个类，如果有直接拿出来，无须再次加载，如果没有就将加载任务传递给`ExtClassLoader`，而`ExtClassLoader`也会先检查自己有没有加载过，没有又会将任务传递给`BootstrapClassLoader`，最后`BootstrapClassLoader`会检查自己有没有加载过这个类，如果没有就会去自己要寻找的区域去寻找这个类，如果找不到又将任务传递给`ExtClassLoader`，以此类推最后才是`AppClassLoader`加载我们的类。这样做是确保类只会被加载一次。通常我们的类加载器只识别classpath（这里的classpath指项目根路径，也就是jar包内的位置）下.class文件。jar中其他的文件包括jar包被当做了资源文件，而不会去读取里面的.class 文件。但实际上我们可以通过自定义类加载器来实现一些特别的操作\n\n## Tomcat 的类加载器\n\nTomcat的类加载机制是违反了双亲委托原则的，对于一些未加载的非基础类(Object,String等)，各个web应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给commonClassLoader走双亲委托。\n\ntomcat的类加载器：\n\n- Common类加载器：负责加载/common目录的类库，这儿存放的类库可被tomcat以及所有的应用使用。\n- Catalina类加载器：负责加载/server目录的类库，只能被tomcat使用。\n- Shared类加载器：负载加载/shared目录的类库，可被所有的web应用使用，但tomcat不可使用。\n- WebApp类加载器：负载加载单个Web应用下classes目录以及lib目录的类库，只能当前应用使用。\n- Jsp类加载器：负责加载Jsp，每一个Jsp文件都对应一个Jsp加载器。\n\n我们将一堆jar包放到tomcat的项目文件夹下，tomcat 运行的时候能加载到这些jar包的class就是因为这些类加载器对读取到的二进制数据进行处理解析从中拿到了需要的类\n\n## springboot的jar包的特别之处\n\n当我们将一个springboot项目打好包之后，不妨解压看看里面的结构是什么样子的的\n\n```java\nrun.jar\n|——org\n|  |——springframework\n|     |——boot\n|        |——loader\n|           |——JarLauncher.class\n|           |——Launcher.class\n|——META-INF\n|  |——MANIFEST.MF  \n|——BOOT-INF\n|  |——class\n|     |——Main.class\n|     |——Begin.class\n|  |——lib\n|     |——commons.jar\n|     |——plugin.jar\n|  |——resource\n|     |——a.jpg\n\n|     |——b.jpg\n\n```\n\n`classpath`可加载的类只有`JarLauncher.class`，`Launcher.class`，`Main.class`，`Begin.class`。在`BOOT-INF/lib`和`BOOT-INF/class`里面的文件不属于classloader搜素对象直接访问的话会报`NoClassDefDoundErr`异常。Jar包里面的资源以 `Stream` 的形式存在（他们本就处于Jar包之中），java程序时可以访问到的。当springboot运行main方法时在main中会运行`org.springframework.boot.loader.JarLauncher`和`Launcher.class`这两个个加载器（你是否还及得前文提到过得spi技术），这个加载器去加载受stream中的jar包中的class。这样就实现了加载jar包中的jar这个功能否则正常的类加载器是无法加载jar包中的jar的class的，只会根据`MAINFEST.MF`来加载jar外部的jar来读取里面的class。\n\n## 如何自定义类加载器\n\n1）继承ClassLoader    重写findClass（）方法  \n\n```java\npublic class MyClassLoader extends ClassLoader{\n\n    private String classpath;\n    \n    public MyClassLoader(String classpath) {\n        \n        this.classpath = classpath;\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n       // 该方法是根据一个name加载一个类，我们可以使用一个流来读取path中的文件然后从文件中解析出class来\n    }\n    \n}\n```\n\n调用defineClass（）方法加载类\n\n```java\npublic static void main(String []args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException{\n        //自定义类加载器的加载路径\n        MyClassLoader myClassLoader=new MyClassLoader(\"D:\\\\lib\");\n        //包名+类名\n        Class c=myClassLoader.loadClass(\"com.test.Test\");\n        \n        if(c!=null){\n           // 做点啥\n        }\n    }\n```\n\n# 总结\n\n本文从比较基础的层面解读了我们频繁使用却大部分人不是很了解的两个知识点——spi和jar机制。希望大家看完这篇文章后能对springboot中的一些“黑魔法”有更深入的了解，而不是停留在表面。\n\n","source":"_posts/spi.md","raw":"---\ntitle: spi和jar\ndate: 2019-05-17 11:47:30\ntags: javase\n---\n\n今天介绍两个大家每天都在用但是却很少去了解它的知识点：spi和jar运行机制，废话不多说，开始正题\n\n# spi\n\n是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。spi机制是这样的：读取`META-INF/services/`目录下的元信息，然后ServiceLoader根据信息加载对应的类，你可以在自己的代码中使用这个被加载的类。要使用Java SPI，需要遵循如下约定：\n\n<!--more-->\n\n- 当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；\n- 接口实现类所在的jar包放在主程序的classpath中；\n- 主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；\n- SPI的实现类必须携带一个不带参数的构造方法；\n\n现在我们来简单的使用一下吧\n\n## spi使用示例\n\n建一个maven项目，定义一个接口 (`com.test.SpiTest`)，并实现该接口（`com.test.SpiTestImpl`）；然后在 `src/main/resources/` 下建立 `/META-INF/services` 目录， 新增一个以接口命名的文件 (`com.test.SpiTest`)，内容是要应用的实现类（`com.test.SpiTestImpl`）。\n\n```java\npublic interface SpiTest {\n    void test();\n}\n\n\npublic class SpiTestImpl implements SpiTest {\n    @Override\n    public void test() {\n        System.out.println(\"test\");\n    }\n}\n\n```\n\n\n\n然后在我们的应用程序中使用 `ServiceLoader `来加载配置文件中指定的实现。\n\n```java\npublic static void main(String[] args) {\n        ServiceLoader<SpiTest> load = ServiceLoader.load(SpiTest.class);\n        SpiTest next = load.iterator().next();\n        next.test();\n      \n    }\n```\n\n这便是spi的使用方式了，简约而不简单\n\n## spi技术的应用\n\n那这一项技术有哪些方面的应用呢？最直接的jdbc中我们需要指定数据库驱动的全限定名，这便是spi技术。还有不少框架比如dubbo，都会预留spi扩展点比如：[dubbo spi](<http://dubbo.apache.org/zh-cn/docs/dev/impls/protocol.html>)\n\n为什么要这么做呢？在spring框架中我们注入一个bean 很容易，通过注解或者xml配置即可，然后在其他的地方就能使用这个bean。在非spring框架下，我们想要有同样的效果就可以考虑spi技术了。\n\n写过springboot 的starter的都知道，需要在 `src/main/resources/` 下建立 `/META-INF/spring.factories` 文件。这其实也是一种spi技术的变形。\n\n# jar机制\n\n通常项目中我们打jar包都是通过maven来进行的，导致很多人忽略了这个东西的存在，就像很多人不知道jdb.exe 是啥玩意一样。下面我们不借助任何工具来打一个jar包并对jar文件结构进行解析。\n\n## 命令行打jar包\n\n首先我们建立一个普通的java项目，新建几个class类，然后在根目录下新建`META-INF/MAINFEST.MF` 这个文件包含了jar的元信息，当我们执行java -jar的时候首先会读取该文件的信息做相关的处理。我们来看看这个文件中可以配置哪些信息 ：\n\n- Manifest-Version：用来定义manifest文件的版本，例如：Manifest-Version: 1.0\n- Main-Class：定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。\n- Class-Path：指定该jar包所依赖的外部jar包，以当前jar包所在的位置为相对路径，无法指定jar包内部的jar包\n- 签名相关属性，包括`Name`，`Digest-Algorithms`，`SHA-Digest`等\n\n定义好元信息之后我们就可以打jar包了，以下是打包的一些常用命令\n\n```shell\n/* 1. 默认打包 */\n// 生成的test.jar中就含test目录和jar自动生成的META-INF目录（内含MAINFEST.MF清单文件）\njar -cvf test.jar test\n\n/* 2. 查看包内容 */\njar -tvf test.jar\n\n/* 3. 解压jar包 */\njar -xvf test.jar\n\n/* 4. 提取jar包部分内容 */\njar -xvf test.jar test\\test.class\n\n/* 5. 追加内容到jar包 */\n//追加MAINFEST.MF清单文件以外的文件，会追加整个目录结构\njar -uvf test.jar other\\ss.class\n\n//追加清单文件，会追加整个目录结构(test.jar会包含META-INF目录)\njar -uMvf test.jar META-INF\\MAINFEST.MF\n\n/* 6. 创建自定义MAINFEST.MF的jar包 */\njar -cMvf test.jar test META-INF\n\n// 通过-m选项配置自定义MAINFEST.MF文件时，自定义MAINFEST.MF文件必须在位于工作目录下才可以\njar -cmvf MAINFEST.MF test.jar test\n```\n\n## jar运行的过程\n\njar运行过程和类加载机制有关，而类加载机制又和我们自定义的类加载器有关，现在我们先来了解一下双亲委派模式。\n\njava中类加载器分为三个：\n\n- BootstrapClassLoader负责加载`${JAVA_HOME}/jre/lib`部分jar包\n- ExtClassLoader加载`${JAVA_HOME}/jre/lib/ext`下面的jar包\n- AppClassLoader加载用户自定义-classpath或者Jar包的Class-Path定义的第三方包\n\n类的生命周期为：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using) 和 卸载(Unloading)七个阶段。\n\n当我们执行 java -jar的时候 jar文件以二进制流的形式被读取到内存，但不会加载到jvm中，类会在一个合适的时机加载到虚拟机中。类加载的时机：\n\n- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先对其进行初始化。成这四条指令的最常见的Java代码场景是使用new关键字实例化对象的时候，读取或设置一个类的静态字段调用一个类的静态方法的时候。\n- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。\n- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。\n\n当触发类加载的时候，类加载器也不是直接加载这个类。首先交给`AppClassLoader`，它会查看自己有没有加载过这个类，如果有直接拿出来，无须再次加载，如果没有就将加载任务传递给`ExtClassLoader`，而`ExtClassLoader`也会先检查自己有没有加载过，没有又会将任务传递给`BootstrapClassLoader`，最后`BootstrapClassLoader`会检查自己有没有加载过这个类，如果没有就会去自己要寻找的区域去寻找这个类，如果找不到又将任务传递给`ExtClassLoader`，以此类推最后才是`AppClassLoader`加载我们的类。这样做是确保类只会被加载一次。通常我们的类加载器只识别classpath（这里的classpath指项目根路径，也就是jar包内的位置）下.class文件。jar中其他的文件包括jar包被当做了资源文件，而不会去读取里面的.class 文件。但实际上我们可以通过自定义类加载器来实现一些特别的操作\n\n## Tomcat 的类加载器\n\nTomcat的类加载机制是违反了双亲委托原则的，对于一些未加载的非基础类(Object,String等)，各个web应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给commonClassLoader走双亲委托。\n\ntomcat的类加载器：\n\n- Common类加载器：负责加载/common目录的类库，这儿存放的类库可被tomcat以及所有的应用使用。\n- Catalina类加载器：负责加载/server目录的类库，只能被tomcat使用。\n- Shared类加载器：负载加载/shared目录的类库，可被所有的web应用使用，但tomcat不可使用。\n- WebApp类加载器：负载加载单个Web应用下classes目录以及lib目录的类库，只能当前应用使用。\n- Jsp类加载器：负责加载Jsp，每一个Jsp文件都对应一个Jsp加载器。\n\n我们将一堆jar包放到tomcat的项目文件夹下，tomcat 运行的时候能加载到这些jar包的class就是因为这些类加载器对读取到的二进制数据进行处理解析从中拿到了需要的类\n\n## springboot的jar包的特别之处\n\n当我们将一个springboot项目打好包之后，不妨解压看看里面的结构是什么样子的的\n\n```java\nrun.jar\n|——org\n|  |——springframework\n|     |——boot\n|        |——loader\n|           |——JarLauncher.class\n|           |——Launcher.class\n|——META-INF\n|  |——MANIFEST.MF  \n|——BOOT-INF\n|  |——class\n|     |——Main.class\n|     |——Begin.class\n|  |——lib\n|     |——commons.jar\n|     |——plugin.jar\n|  |——resource\n|     |——a.jpg\n\n|     |——b.jpg\n\n```\n\n`classpath`可加载的类只有`JarLauncher.class`，`Launcher.class`，`Main.class`，`Begin.class`。在`BOOT-INF/lib`和`BOOT-INF/class`里面的文件不属于classloader搜素对象直接访问的话会报`NoClassDefDoundErr`异常。Jar包里面的资源以 `Stream` 的形式存在（他们本就处于Jar包之中），java程序时可以访问到的。当springboot运行main方法时在main中会运行`org.springframework.boot.loader.JarLauncher`和`Launcher.class`这两个个加载器（你是否还及得前文提到过得spi技术），这个加载器去加载受stream中的jar包中的class。这样就实现了加载jar包中的jar这个功能否则正常的类加载器是无法加载jar包中的jar的class的，只会根据`MAINFEST.MF`来加载jar外部的jar来读取里面的class。\n\n## 如何自定义类加载器\n\n1）继承ClassLoader    重写findClass（）方法  \n\n```java\npublic class MyClassLoader extends ClassLoader{\n\n    private String classpath;\n    \n    public MyClassLoader(String classpath) {\n        \n        this.classpath = classpath;\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n       // 该方法是根据一个name加载一个类，我们可以使用一个流来读取path中的文件然后从文件中解析出class来\n    }\n    \n}\n```\n\n调用defineClass（）方法加载类\n\n```java\npublic static void main(String []args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException{\n        //自定义类加载器的加载路径\n        MyClassLoader myClassLoader=new MyClassLoader(\"D:\\\\lib\");\n        //包名+类名\n        Class c=myClassLoader.loadClass(\"com.test.Test\");\n        \n        if(c!=null){\n           // 做点啥\n        }\n    }\n```\n\n# 总结\n\n本文从比较基础的层面解读了我们频繁使用却大部分人不是很了解的两个知识点——spi和jar机制。希望大家看完这篇文章后能对springboot中的一些“黑魔法”有更深入的了解，而不是停留在表面。\n\n","slug":"spi","published":1,"updated":"2021-01-11T07:31:23.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6s003a00wi50j6dhe2","content":"<p>今天介绍两个大家每天都在用但是却很少去了解它的知识点：spi和jar运行机制，废话不多说，开始正题</p>\n<h1 id=\"spi\"><a href=\"#spi\" class=\"headerlink\" title=\"spi\"></a>spi</h1><p>是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。spi机制是这样的：读取<code>META-INF/services/</code>目录下的元信息，然后ServiceLoader根据信息加载对应的类，你可以在自己的代码中使用这个被加载的类。要使用Java SPI，需要遵循如下约定：</p>\n<a id=\"more\"></a>\n\n<ul>\n<li>当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</li>\n<li>接口实现类所在的jar包放在主程序的classpath中；</li>\n<li>主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；</li>\n<li>SPI的实现类必须携带一个不带参数的构造方法；</li>\n</ul>\n<p>现在我们来简单的使用一下吧</p>\n<h2 id=\"spi使用示例\"><a href=\"#spi使用示例\" class=\"headerlink\" title=\"spi使用示例\"></a>spi使用示例</h2><p>建一个maven项目，定义一个接口 (<code>com.test.SpiTest</code>)，并实现该接口（<code>com.test.SpiTestImpl</code>）；然后在 <code>src/main/resources/</code> 下建立 <code>/META-INF/services</code> 目录， 新增一个以接口命名的文件 (<code>com.test.SpiTest</code>)，内容是要应用的实现类（<code>com.test.SpiTestImpl</code>）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">SpiTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpiTestImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">SpiTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>然后在我们的应用程序中使用 <code>ServiceLoader</code>来加载配置文件中指定的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ServiceLoader&lt;SpiTest&gt; load = ServiceLoader.load(SpiTest.class);</span><br><span class=\"line\">        SpiTest next = load.iterator().next();</span><br><span class=\"line\">        next.test();</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这便是spi的使用方式了，简约而不简单</p>\n<h2 id=\"spi技术的应用\"><a href=\"#spi技术的应用\" class=\"headerlink\" title=\"spi技术的应用\"></a>spi技术的应用</h2><p>那这一项技术有哪些方面的应用呢？最直接的jdbc中我们需要指定数据库驱动的全限定名，这便是spi技术。还有不少框架比如dubbo，都会预留spi扩展点比如：<a href=\"http://dubbo.apache.org/zh-cn/docs/dev/impls/protocol.html\">dubbo spi</a></p>\n<p>为什么要这么做呢？在spring框架中我们注入一个bean 很容易，通过注解或者xml配置即可，然后在其他的地方就能使用这个bean。在非spring框架下，我们想要有同样的效果就可以考虑spi技术了。</p>\n<p>写过springboot 的starter的都知道，需要在 <code>src/main/resources/</code> 下建立 <code>/META-INF/spring.factories</code> 文件。这其实也是一种spi技术的变形。</p>\n<h1 id=\"jar机制\"><a href=\"#jar机制\" class=\"headerlink\" title=\"jar机制\"></a>jar机制</h1><p>通常项目中我们打jar包都是通过maven来进行的，导致很多人忽略了这个东西的存在，就像很多人不知道jdb.exe 是啥玩意一样。下面我们不借助任何工具来打一个jar包并对jar文件结构进行解析。</p>\n<h2 id=\"命令行打jar包\"><a href=\"#命令行打jar包\" class=\"headerlink\" title=\"命令行打jar包\"></a>命令行打jar包</h2><p>首先我们建立一个普通的java项目，新建几个class类，然后在根目录下新建<code>META-INF/MAINFEST.MF</code> 这个文件包含了jar的元信息，当我们执行java -jar的时候首先会读取该文件的信息做相关的处理。我们来看看这个文件中可以配置哪些信息 ：</p>\n<ul>\n<li>Manifest-Version：用来定义manifest文件的版本，例如：Manifest-Version: 1.0</li>\n<li>Main-Class：定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。</li>\n<li>Class-Path：指定该jar包所依赖的外部jar包，以当前jar包所在的位置为相对路径，无法指定jar包内部的jar包</li>\n<li>签名相关属性，包括<code>Name</code>，<code>Digest-Algorithms</code>，<code>SHA-Digest</code>等</li>\n</ul>\n<p>定义好元信息之后我们就可以打jar包了，以下是打包的一些常用命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 1. 默认打包 */</span><br><span class=\"line\">// 生成的test.jar中就含test目录和jar自动生成的META-INF目录（内含MAINFEST.MF清单文件）</span><br><span class=\"line\">jar -cvf test.jar test</span><br><span class=\"line\"></span><br><span class=\"line\">/* 2. 查看包内容 */</span><br><span class=\"line\">jar -tvf test.jar</span><br><span class=\"line\"></span><br><span class=\"line\">/* 3. 解压jar包 */</span><br><span class=\"line\">jar -xvf test.jar</span><br><span class=\"line\"></span><br><span class=\"line\">/* 4. 提取jar包部分内容 */</span><br><span class=\"line\">jar -xvf test.jar test\\test.class</span><br><span class=\"line\"></span><br><span class=\"line\">/* 5. 追加内容到jar包 */</span><br><span class=\"line\">//追加MAINFEST.MF清单文件以外的文件，会追加整个目录结构</span><br><span class=\"line\">jar -uvf test.jar other\\ss.class</span><br><span class=\"line\"></span><br><span class=\"line\">//追加清单文件，会追加整个目录结构(test.jar会包含META-INF目录)</span><br><span class=\"line\">jar -uMvf test.jar META-INF\\MAINFEST.MF</span><br><span class=\"line\"></span><br><span class=\"line\">/* 6. 创建自定义MAINFEST.MF的jar包 */</span><br><span class=\"line\">jar -cMvf test.jar test META-INF</span><br><span class=\"line\"></span><br><span class=\"line\">// 通过-m选项配置自定义MAINFEST.MF文件时，自定义MAINFEST.MF文件必须在位于工作目录下才可以</span><br><span class=\"line\">jar -cmvf MAINFEST.MF test.jar test</span><br></pre></td></tr></table></figure>\n<h2 id=\"jar运行的过程\"><a href=\"#jar运行的过程\" class=\"headerlink\" title=\"jar运行的过程\"></a>jar运行的过程</h2><p>jar运行过程和类加载机制有关，而类加载机制又和我们自定义的类加载器有关，现在我们先来了解一下双亲委派模式。</p>\n<p>java中类加载器分为三个：</p>\n<ul>\n<li>BootstrapClassLoader负责加载<code>$&#123;JAVA_HOME&#125;/jre/lib</code>部分jar包</li>\n<li>ExtClassLoader加载<code>$&#123;JAVA_HOME&#125;/jre/lib/ext</code>下面的jar包</li>\n<li>AppClassLoader加载用户自定义-classpath或者Jar包的Class-Path定义的第三方包</li>\n</ul>\n<p>类的生命周期为：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using) 和 卸载(Unloading)七个阶段。</p>\n<p>当我们执行 java -jar的时候 jar文件以二进制流的形式被读取到内存，但不会加载到jvm中，类会在一个合适的时机加载到虚拟机中。类加载的时机：</p>\n<ul>\n<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先对其进行初始化。成这四条指令的最常见的Java代码场景是使用new关键字实例化对象的时候，读取或设置一个类的静态字段调用一个类的静态方法的时候。</li>\n<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>\n</ul>\n<p>当触发类加载的时候，类加载器也不是直接加载这个类。首先交给<code>AppClassLoader</code>，它会查看自己有没有加载过这个类，如果有直接拿出来，无须再次加载，如果没有就将加载任务传递给<code>ExtClassLoader</code>，而<code>ExtClassLoader</code>也会先检查自己有没有加载过，没有又会将任务传递给<code>BootstrapClassLoader</code>，最后<code>BootstrapClassLoader</code>会检查自己有没有加载过这个类，如果没有就会去自己要寻找的区域去寻找这个类，如果找不到又将任务传递给<code>ExtClassLoader</code>，以此类推最后才是<code>AppClassLoader</code>加载我们的类。这样做是确保类只会被加载一次。通常我们的类加载器只识别classpath（这里的classpath指项目根路径，也就是jar包内的位置）下.class文件。jar中其他的文件包括jar包被当做了资源文件，而不会去读取里面的.class 文件。但实际上我们可以通过自定义类加载器来实现一些特别的操作</p>\n<h2 id=\"Tomcat-的类加载器\"><a href=\"#Tomcat-的类加载器\" class=\"headerlink\" title=\"Tomcat 的类加载器\"></a>Tomcat 的类加载器</h2><p>Tomcat的类加载机制是违反了双亲委托原则的，对于一些未加载的非基础类(Object,String等)，各个web应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给commonClassLoader走双亲委托。</p>\n<p>tomcat的类加载器：</p>\n<ul>\n<li>Common类加载器：负责加载/common目录的类库，这儿存放的类库可被tomcat以及所有的应用使用。</li>\n<li>Catalina类加载器：负责加载/server目录的类库，只能被tomcat使用。</li>\n<li>Shared类加载器：负载加载/shared目录的类库，可被所有的web应用使用，但tomcat不可使用。</li>\n<li>WebApp类加载器：负载加载单个Web应用下classes目录以及lib目录的类库，只能当前应用使用。</li>\n<li>Jsp类加载器：负责加载Jsp，每一个Jsp文件都对应一个Jsp加载器。</li>\n</ul>\n<p>我们将一堆jar包放到tomcat的项目文件夹下，tomcat 运行的时候能加载到这些jar包的class就是因为这些类加载器对读取到的二进制数据进行处理解析从中拿到了需要的类</p>\n<h2 id=\"springboot的jar包的特别之处\"><a href=\"#springboot的jar包的特别之处\" class=\"headerlink\" title=\"springboot的jar包的特别之处\"></a>springboot的jar包的特别之处</h2><p>当我们将一个springboot项目打好包之后，不妨解压看看里面的结构是什么样子的的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">run.jar</span><br><span class=\"line\">|——org</span><br><span class=\"line\">|  |——springframework</span><br><span class=\"line\">|     |——boot</span><br><span class=\"line\">|        |——loader</span><br><span class=\"line\">|           |——JarLauncher.class</span><br><span class=\"line\">|           |——Launcher.class</span><br><span class=\"line\">|——META-INF</span><br><span class=\"line\">|  |——MANIFEST.MF  </span><br><span class=\"line\">|——BOOT-INF</span><br><span class=\"line\">|  |——<span class=\"class\"><span class=\"keyword\">class</span></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">Main</span>.<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">Begin</span>.<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\">|  |——<span class=\"title\">lib</span></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">commons</span>.<span class=\"title\">jar</span></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">plugin</span>.<span class=\"title\">jar</span></span></span><br><span class=\"line\"><span class=\"class\">|  |——<span class=\"title\">resource</span></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">a</span>.<span class=\"title\">jpg</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">b</span>.<span class=\"title\">jpg</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br></pre></td></tr></table></figure>\n<p><code>classpath</code>可加载的类只有<code>JarLauncher.class</code>，<code>Launcher.class</code>，<code>Main.class</code>，<code>Begin.class</code>。在<code>BOOT-INF/lib</code>和<code>BOOT-INF/class</code>里面的文件不属于classloader搜素对象直接访问的话会报<code>NoClassDefDoundErr</code>异常。Jar包里面的资源以 <code>Stream</code> 的形式存在（他们本就处于Jar包之中），java程序时可以访问到的。当springboot运行main方法时在main中会运行<code>org.springframework.boot.loader.JarLauncher</code>和<code>Launcher.class</code>这两个个加载器（你是否还及得前文提到过得spi技术），这个加载器去加载受stream中的jar包中的class。这样就实现了加载jar包中的jar这个功能否则正常的类加载器是无法加载jar包中的jar的class的，只会根据<code>MAINFEST.MF</code>来加载jar外部的jar来读取里面的class。</p>\n<h2 id=\"如何自定义类加载器\"><a href=\"#如何自定义类加载器\" class=\"headerlink\" title=\"如何自定义类加载器\"></a>如何自定义类加载器</h2><p>1）继承ClassLoader    重写findClass（）方法  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String classpath;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyClassLoader</span><span class=\"params\">(String classpath)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.classpath = classpath;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 该方法是根据一个name加载一个类，我们可以使用一个流来读取path中的文件然后从文件中解析出class来</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用defineClass（）方法加载类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String []args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//自定义类加载器的加载路径</span></span><br><span class=\"line\">        MyClassLoader myClassLoader=<span class=\"keyword\">new</span> MyClassLoader(<span class=\"string\">&quot;D:\\\\lib&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//包名+类名</span></span><br><span class=\"line\">        Class c=myClassLoader.loadClass(<span class=\"string\">&quot;com.test.Test&quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">           <span class=\"comment\">// 做点啥</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文从比较基础的层面解读了我们频繁使用却大部分人不是很了解的两个知识点——spi和jar机制。希望大家看完这篇文章后能对springboot中的一些“黑魔法”有更深入的了解，而不是停留在表面。</p>\n","site":{"data":{}},"excerpt":"<p>今天介绍两个大家每天都在用但是却很少去了解它的知识点：spi和jar运行机制，废话不多说，开始正题</p>\n<h1 id=\"spi\"><a href=\"#spi\" class=\"headerlink\" title=\"spi\"></a>spi</h1><p>是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。spi机制是这样的：读取<code>META-INF/services/</code>目录下的元信息，然后ServiceLoader根据信息加载对应的类，你可以在自己的代码中使用这个被加载的类。要使用Java SPI，需要遵循如下约定：</p>","more":"<ul>\n<li>当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；</li>\n<li>接口实现类所在的jar包放在主程序的classpath中；</li>\n<li>主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；</li>\n<li>SPI的实现类必须携带一个不带参数的构造方法；</li>\n</ul>\n<p>现在我们来简单的使用一下吧</p>\n<h2 id=\"spi使用示例\"><a href=\"#spi使用示例\" class=\"headerlink\" title=\"spi使用示例\"></a>spi使用示例</h2><p>建一个maven项目，定义一个接口 (<code>com.test.SpiTest</code>)，并实现该接口（<code>com.test.SpiTestImpl</code>）；然后在 <code>src/main/resources/</code> 下建立 <code>/META-INF/services</code> 目录， 新增一个以接口命名的文件 (<code>com.test.SpiTest</code>)，内容是要应用的实现类（<code>com.test.SpiTestImpl</code>）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">SpiTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpiTestImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">SpiTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>然后在我们的应用程序中使用 <code>ServiceLoader</code>来加载配置文件中指定的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ServiceLoader&lt;SpiTest&gt; load = ServiceLoader.load(SpiTest.class);</span><br><span class=\"line\">        SpiTest next = load.iterator().next();</span><br><span class=\"line\">        next.test();</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这便是spi的使用方式了，简约而不简单</p>\n<h2 id=\"spi技术的应用\"><a href=\"#spi技术的应用\" class=\"headerlink\" title=\"spi技术的应用\"></a>spi技术的应用</h2><p>那这一项技术有哪些方面的应用呢？最直接的jdbc中我们需要指定数据库驱动的全限定名，这便是spi技术。还有不少框架比如dubbo，都会预留spi扩展点比如：<a href=\"http://dubbo.apache.org/zh-cn/docs/dev/impls/protocol.html\">dubbo spi</a></p>\n<p>为什么要这么做呢？在spring框架中我们注入一个bean 很容易，通过注解或者xml配置即可，然后在其他的地方就能使用这个bean。在非spring框架下，我们想要有同样的效果就可以考虑spi技术了。</p>\n<p>写过springboot 的starter的都知道，需要在 <code>src/main/resources/</code> 下建立 <code>/META-INF/spring.factories</code> 文件。这其实也是一种spi技术的变形。</p>\n<h1 id=\"jar机制\"><a href=\"#jar机制\" class=\"headerlink\" title=\"jar机制\"></a>jar机制</h1><p>通常项目中我们打jar包都是通过maven来进行的，导致很多人忽略了这个东西的存在，就像很多人不知道jdb.exe 是啥玩意一样。下面我们不借助任何工具来打一个jar包并对jar文件结构进行解析。</p>\n<h2 id=\"命令行打jar包\"><a href=\"#命令行打jar包\" class=\"headerlink\" title=\"命令行打jar包\"></a>命令行打jar包</h2><p>首先我们建立一个普通的java项目，新建几个class类，然后在根目录下新建<code>META-INF/MAINFEST.MF</code> 这个文件包含了jar的元信息，当我们执行java -jar的时候首先会读取该文件的信息做相关的处理。我们来看看这个文件中可以配置哪些信息 ：</p>\n<ul>\n<li>Manifest-Version：用来定义manifest文件的版本，例如：Manifest-Version: 1.0</li>\n<li>Main-Class：定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。</li>\n<li>Class-Path：指定该jar包所依赖的外部jar包，以当前jar包所在的位置为相对路径，无法指定jar包内部的jar包</li>\n<li>签名相关属性，包括<code>Name</code>，<code>Digest-Algorithms</code>，<code>SHA-Digest</code>等</li>\n</ul>\n<p>定义好元信息之后我们就可以打jar包了，以下是打包的一些常用命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 1. 默认打包 */</span><br><span class=\"line\">// 生成的test.jar中就含test目录和jar自动生成的META-INF目录（内含MAINFEST.MF清单文件）</span><br><span class=\"line\">jar -cvf test.jar test</span><br><span class=\"line\"></span><br><span class=\"line\">/* 2. 查看包内容 */</span><br><span class=\"line\">jar -tvf test.jar</span><br><span class=\"line\"></span><br><span class=\"line\">/* 3. 解压jar包 */</span><br><span class=\"line\">jar -xvf test.jar</span><br><span class=\"line\"></span><br><span class=\"line\">/* 4. 提取jar包部分内容 */</span><br><span class=\"line\">jar -xvf test.jar test\\test.class</span><br><span class=\"line\"></span><br><span class=\"line\">/* 5. 追加内容到jar包 */</span><br><span class=\"line\">//追加MAINFEST.MF清单文件以外的文件，会追加整个目录结构</span><br><span class=\"line\">jar -uvf test.jar other\\ss.class</span><br><span class=\"line\"></span><br><span class=\"line\">//追加清单文件，会追加整个目录结构(test.jar会包含META-INF目录)</span><br><span class=\"line\">jar -uMvf test.jar META-INF\\MAINFEST.MF</span><br><span class=\"line\"></span><br><span class=\"line\">/* 6. 创建自定义MAINFEST.MF的jar包 */</span><br><span class=\"line\">jar -cMvf test.jar test META-INF</span><br><span class=\"line\"></span><br><span class=\"line\">// 通过-m选项配置自定义MAINFEST.MF文件时，自定义MAINFEST.MF文件必须在位于工作目录下才可以</span><br><span class=\"line\">jar -cmvf MAINFEST.MF test.jar test</span><br></pre></td></tr></table></figure>\n<h2 id=\"jar运行的过程\"><a href=\"#jar运行的过程\" class=\"headerlink\" title=\"jar运行的过程\"></a>jar运行的过程</h2><p>jar运行过程和类加载机制有关，而类加载机制又和我们自定义的类加载器有关，现在我们先来了解一下双亲委派模式。</p>\n<p>java中类加载器分为三个：</p>\n<ul>\n<li>BootstrapClassLoader负责加载<code>$&#123;JAVA_HOME&#125;/jre/lib</code>部分jar包</li>\n<li>ExtClassLoader加载<code>$&#123;JAVA_HOME&#125;/jre/lib/ext</code>下面的jar包</li>\n<li>AppClassLoader加载用户自定义-classpath或者Jar包的Class-Path定义的第三方包</li>\n</ul>\n<p>类的生命周期为：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using) 和 卸载(Unloading)七个阶段。</p>\n<p>当我们执行 java -jar的时候 jar文件以二进制流的形式被读取到内存，但不会加载到jvm中，类会在一个合适的时机加载到虚拟机中。类加载的时机：</p>\n<ul>\n<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先对其进行初始化。成这四条指令的最常见的Java代码场景是使用new关键字实例化对象的时候，读取或设置一个类的静态字段调用一个类的静态方法的时候。</li>\n<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>\n</ul>\n<p>当触发类加载的时候，类加载器也不是直接加载这个类。首先交给<code>AppClassLoader</code>，它会查看自己有没有加载过这个类，如果有直接拿出来，无须再次加载，如果没有就将加载任务传递给<code>ExtClassLoader</code>，而<code>ExtClassLoader</code>也会先检查自己有没有加载过，没有又会将任务传递给<code>BootstrapClassLoader</code>，最后<code>BootstrapClassLoader</code>会检查自己有没有加载过这个类，如果没有就会去自己要寻找的区域去寻找这个类，如果找不到又将任务传递给<code>ExtClassLoader</code>，以此类推最后才是<code>AppClassLoader</code>加载我们的类。这样做是确保类只会被加载一次。通常我们的类加载器只识别classpath（这里的classpath指项目根路径，也就是jar包内的位置）下.class文件。jar中其他的文件包括jar包被当做了资源文件，而不会去读取里面的.class 文件。但实际上我们可以通过自定义类加载器来实现一些特别的操作</p>\n<h2 id=\"Tomcat-的类加载器\"><a href=\"#Tomcat-的类加载器\" class=\"headerlink\" title=\"Tomcat 的类加载器\"></a>Tomcat 的类加载器</h2><p>Tomcat的类加载机制是违反了双亲委托原则的，对于一些未加载的非基础类(Object,String等)，各个web应用自己的类加载器(WebAppClassLoader)会优先加载，加载不到时再交给commonClassLoader走双亲委托。</p>\n<p>tomcat的类加载器：</p>\n<ul>\n<li>Common类加载器：负责加载/common目录的类库，这儿存放的类库可被tomcat以及所有的应用使用。</li>\n<li>Catalina类加载器：负责加载/server目录的类库，只能被tomcat使用。</li>\n<li>Shared类加载器：负载加载/shared目录的类库，可被所有的web应用使用，但tomcat不可使用。</li>\n<li>WebApp类加载器：负载加载单个Web应用下classes目录以及lib目录的类库，只能当前应用使用。</li>\n<li>Jsp类加载器：负责加载Jsp，每一个Jsp文件都对应一个Jsp加载器。</li>\n</ul>\n<p>我们将一堆jar包放到tomcat的项目文件夹下，tomcat 运行的时候能加载到这些jar包的class就是因为这些类加载器对读取到的二进制数据进行处理解析从中拿到了需要的类</p>\n<h2 id=\"springboot的jar包的特别之处\"><a href=\"#springboot的jar包的特别之处\" class=\"headerlink\" title=\"springboot的jar包的特别之处\"></a>springboot的jar包的特别之处</h2><p>当我们将一个springboot项目打好包之后，不妨解压看看里面的结构是什么样子的的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">run.jar</span><br><span class=\"line\">|——org</span><br><span class=\"line\">|  |——springframework</span><br><span class=\"line\">|     |——boot</span><br><span class=\"line\">|        |——loader</span><br><span class=\"line\">|           |——JarLauncher.class</span><br><span class=\"line\">|           |——Launcher.class</span><br><span class=\"line\">|——META-INF</span><br><span class=\"line\">|  |——MANIFEST.MF  </span><br><span class=\"line\">|——BOOT-INF</span><br><span class=\"line\">|  |——<span class=\"class\"><span class=\"keyword\">class</span></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">Main</span>.<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">Begin</span>.<span class=\"title\">class</span></span></span><br><span class=\"line\"><span class=\"class\">|  |——<span class=\"title\">lib</span></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">commons</span>.<span class=\"title\">jar</span></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">plugin</span>.<span class=\"title\">jar</span></span></span><br><span class=\"line\"><span class=\"class\">|  |——<span class=\"title\">resource</span></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">a</span>.<span class=\"title\">jpg</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br><span class=\"line\"><span class=\"class\">|     |——<span class=\"title\">b</span>.<span class=\"title\">jpg</span></span></span><br><span class=\"line\"><span class=\"class\"></span></span><br></pre></td></tr></table></figure>\n<p><code>classpath</code>可加载的类只有<code>JarLauncher.class</code>，<code>Launcher.class</code>，<code>Main.class</code>，<code>Begin.class</code>。在<code>BOOT-INF/lib</code>和<code>BOOT-INF/class</code>里面的文件不属于classloader搜素对象直接访问的话会报<code>NoClassDefDoundErr</code>异常。Jar包里面的资源以 <code>Stream</code> 的形式存在（他们本就处于Jar包之中），java程序时可以访问到的。当springboot运行main方法时在main中会运行<code>org.springframework.boot.loader.JarLauncher</code>和<code>Launcher.class</code>这两个个加载器（你是否还及得前文提到过得spi技术），这个加载器去加载受stream中的jar包中的class。这样就实现了加载jar包中的jar这个功能否则正常的类加载器是无法加载jar包中的jar的class的，只会根据<code>MAINFEST.MF</code>来加载jar外部的jar来读取里面的class。</p>\n<h2 id=\"如何自定义类加载器\"><a href=\"#如何自定义类加载器\" class=\"headerlink\" title=\"如何自定义类加载器\"></a>如何自定义类加载器</h2><p>1）继承ClassLoader    重写findClass（）方法  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassLoader</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String classpath;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyClassLoader</span><span class=\"params\">(String classpath)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.classpath = classpath;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 该方法是根据一个name加载一个类，我们可以使用一个流来读取path中的文件然后从文件中解析出class来</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用defineClass（）方法加载类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String []args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//自定义类加载器的加载路径</span></span><br><span class=\"line\">        MyClassLoader myClassLoader=<span class=\"keyword\">new</span> MyClassLoader(<span class=\"string\">&quot;D:\\\\lib&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//包名+类名</span></span><br><span class=\"line\">        Class c=myClassLoader.loadClass(<span class=\"string\">&quot;com.test.Test&quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">           <span class=\"comment\">// 做点啥</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文从比较基础的层面解读了我们频繁使用却大部分人不是很了解的两个知识点——spi和jar机制。希望大家看完这篇文章后能对springboot中的一些“黑魔法”有更深入的了解，而不是停留在表面。</p>"},{"title":"security-oauth2学习笔记","date":"2019-04-12T02:49:16.000Z","_content":"作者：muggle\n\n## oauth2 相关概念\n\n文章参考[理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n### oauth2 角色关系\n\n在oauth2中分为以下几个角色：Resource server、Authorization server、Resource Owner、application。\n\nResource server:资源服务器\n\nAuthorization server:认证服务器\n\nResource Owner:资源拥有者\n\napplication:第三方应用\n\noauth2的一次请求流程为：\n\n第三方应用获取认证token 向认证服务器认证，认证服务器通过认证后第三方应用便可向资源服务器拿资源；第三方应用的获取资源的范围由资源拥有者授权。\n\n显然由流程可知，oauth2要保证以下几点：\n1.token的有效期和更新方式要可控，安全性要好\n2.用户授权第三方应用要可以控制授权范围\n<!-- more -->\n\n### oauth2的授权方式\n\n第三方应用必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。\n\n授权码模式（authorization code）\n简化模式（implicit）\n密码模式（resource owner password credentials）\n客户端模式（client credentials\n\n各个模式具体流程略微复杂，这里节省时间不做介绍，想了解的请参看[理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n## spring-security-oauth2原理分析\n\n在oauth2的框架中，其流程是基于security扩展起来的，在原先的流程上最后面加了一个endpoint节点。其认证服务器其实可以看做拥有两套代码，一套是对第三方应用的权限进行管控的代码，一套是对用户权限进行管控的代码。\n\n对应的配置类分别是：`AuthorizationServerConfigurerAdapter` 和`WebSecurityConfigurerAdapter`\n\n\n\n### 授权端点一览表\n\noauth2提供了一系列URL来完成相应的认证授权相关功能，这些URL都是可配置的，下面贴出各url及其功能；\n\n| 授权端点             | /oauth/authorize      |                  |\n| -------------------- | --------------------- | ---------------- |\n| 令牌端点             | /oauth/token          | 获取一个令牌     |\n| 用户确认授权提交端点 | /oauth/confirm_access | 供用户授权第三方 |\n| 授权服务错误信息端点 | /oauth/error          |                  |\n| 令牌解析端点         | /oauth/check_token    |                  |\n| 公钥端点             | /oauth/token_key      |                  |\n\n\n\n### 认证服务器配置\n\n认证服务器相关配置继承`AuthorizationServerConfigurerAdapter`重写configure方法实现\n\n```java\npublic class AuthorizationServerConfigurerAdapter implements AuthorizationServerConfigurer {\n    public AuthorizationServerConfigurerAdapter() {\n    }\n\n    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {\n    }\n\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n    }\n\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\n    }\n}\n```\n\n\n\n*ClientDetailsServiceConfigurer* 验证客户端的方式\n\n> 当一个客户端向认证服务器请求认证的时候，我们需要判别这个客户端是否通过认证；ClientDetailsServiceConfigurer提供了三种认证方式 ：\n>\n> - clients.withClientDetails()：类似于springSecurity的UserDetailService，对应的也有ClientDetailsService 和 ClientDetails；\n> \n>- clients.jdbc():传入一个dataSource(detaliService 是自定义service，更加灵活，这个是为基于数据库准备的)；\n> \n> - clients.inMemory() 基于内存，也就是在代码里写死\n\n验证参数说明\n\n>从ClientDetails我们就能很清晰的分辨出客户端需要配置哪些参数\n>\n>clientId:客户端ID\n>secret:客户端密钥\n>scope:客户受限的范围。如果范围未定义或为空（默认值），则客户端不受范围限制\n>\n>authorizedGrantTypes:授权客户端使用的授权类型。默认值为空。\n>\n>authorities：授予客户端的权限（常规Spring Security权限）\n>\n>如果我们使用的是数据库存储第三方应用的信息，框架替我们提供了建表语句，https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql  但对于 MYSQL 来说，默认建表语句中主键为 Varchar(256)，这超过了最大的主键长度，可改成 128，并用 BLOB 替换语句中的 LONGVARBINARY 类型\n\n*AuthorizationServerSecurityConfigurer*\n\n>该类共有13个配置相关的方法：\n>\n>- passwordEncoder():编解码器\n>- tokenKeyAccess（）：oauth2授权服务器会提供一个`/oauth/token_key`的url来供资源服务器获取公钥，这个方法就是配置获取公钥的权限范围，它使用的是SpEL表达式且默认不开启，如果你没用到公钥，则不必管他，在[官方文档](<http://projects.spring.io/spring-security-oauth/docs/oauth2.html#resource-server-configuration>) 上使用JwtToken中使用了该方法，如果你用的是JwtToken请注意\n>- checkTokenAccess（）：授权服务器提供一个`/oauth/check_token`的url来供资源服务器解码令牌，该方法就是配置权限范围，同样使用的是SpEL表达式且默认不开启\n>- sslOnly()：普通HTTP适用于测试，但授权服务器只能在生产中通过SSL使用，调用方法`sslOnly()`则强制使用ssl。\n>- getTokenKeyAccess()：就方法名的意思，获得tokenKeyAccess所设置的SpEL表达式\n>- getCheckTokenAccess()：获得checkTokenAccess所设置的SpEL表达式\n>- accessDeniedHandler()：拒绝访问处理器\n>- realm()：默认值为 \"oauth2/client\",用处未知\n>- authenticationEntryPoint()：处理验证失败的\n>- 是allowFormAuthenticationForClients： 允许客户端进行表单身份验证，主要是让/oauth/token支持client_id以及client_secret作登录认证\n>- addTokenEndpointAuthenticationFilter：添加令牌端点身份验证过滤器\n>- tokenEndpointAuthenticationFilters：添加多个过滤器\n>- init():初始化方法\n>\n\n*AuthorizationServerEndpointsConfigurer*\n\n>该类配置方法太多了，且官方资料不全，在这里只列举几个常用的配置方法\n>\n>- pathMapping()：修改授权端点一览表的那些URL\n>- tokenStore()：生成Token后的存储方式，可以new RedisTokenStore()来使用redis存储\n>-  authenticationManager()：用于密码授权的AuthenticationManager。 当采用密码模式的时候，第三方应用直接提供用户的用户名密码，所以这里需要配置AuthenticationManager（AuthenticationManager的作用参考我security配置解析的文章）\n>- allowedTokenEndpointRequestMethods()：允许的请求方式\n\n### 补充说明\n\noauth2中增加了两个很重要的类`TokenEndPoint`类和`AuthorizationEndpoint`类。`AuthorizationEndpoint` 为授权码模式的端点，它在执行流程的最后位置，它会检验用户是否已经登陆，检验第三方用户，检验授权范围，最后生成code重定向到redirect_uri。\n\n`TokenEndPoint`和`AuthorizationEndpoint` `类似，它用于获取token，在返回token时也会做相应的校验\n\n### 认证服务器使用\n\n为便于学习，我们单独搭一个认证服务器并使用它\n\n依赖：\n\n```xml\n     <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-oauth2</artifactId>\n            <version>2.0.0.RELEASE</version>\n        </dependency>\n```\n\n配置：\n\n```java\n@SpringBootApplication\n@EnableAuthorizationServer\npublic class PoseidonCloudOauthApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(PoseidonCloudOauthApplication.class, args);\n    }\n\n    @Bean\n    public WebSecurityConfigurerAdapter webSecurityConfigurerAdapter() {\n        return new WebSecurityConfigurerAdapter() {\n            @Override\n            public void configure(HttpSecurity httpSecurity) throws Exception {\n                httpSecurity.formLogin().and().csrf().disable();\n            }\n        };\n    }\n}\n```\n\n测试用例：\n\n```java\n    @Autowired\n    private TestRestTemplate restTemplate;\n\t// 密码模式测试\n    @Test\n    public void token_password() {\n        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n        params.add(\"grant_type\", \"password\");\n        params.add(\"username\", \"admin\");\n        params.add(\"password\", \"admin\");\n        params.add(\"scope\", \"scope1 scope2\");\n//        第三方应用登陆\n        String response = restTemplate.withBasicAuth(\"clientId\", \"clientSecret\").\n//                用户的用户名密码\n                postForObject(\"/oauth/token\", params, String.class);\n        System.out.println(response);\n    }\n// 客户端模式\n    @Test\n    public void token_client() {\n        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n        params.add(\"grant_type\", \"client_credentials\");\n        String response = restTemplate.withBasicAuth(\"clientId\", \"clientSecret\").\n                postForObject(\"/oauth/token\", params, String.class);\n        System.out.println(response);\n    }\n```\n\n授权码模式要通过测试工具来测；\n\n这里涉及到一个`BasicAuth`的概念，说明一下，其实就是将用户名密码用`username:password` 这样的形式拼接，然后base64编码后得到一个code，在请求头的`Authorization` 中添加 `Basic code`。而postman也支持`BasicAuth`,测试细节略。\n\n## oauth2扩展\n\n","source":"_posts/security-oauth2学习笔记.md","raw":"---\ntitle: security-oauth2学习笔记\ndate: 2019-04-12 10:49:16\ntags: security\n---\n作者：muggle\n\n## oauth2 相关概念\n\n文章参考[理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n### oauth2 角色关系\n\n在oauth2中分为以下几个角色：Resource server、Authorization server、Resource Owner、application。\n\nResource server:资源服务器\n\nAuthorization server:认证服务器\n\nResource Owner:资源拥有者\n\napplication:第三方应用\n\noauth2的一次请求流程为：\n\n第三方应用获取认证token 向认证服务器认证，认证服务器通过认证后第三方应用便可向资源服务器拿资源；第三方应用的获取资源的范围由资源拥有者授权。\n\n显然由流程可知，oauth2要保证以下几点：\n1.token的有效期和更新方式要可控，安全性要好\n2.用户授权第三方应用要可以控制授权范围\n<!-- more -->\n\n### oauth2的授权方式\n\n第三方应用必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。\n\n授权码模式（authorization code）\n简化模式（implicit）\n密码模式（resource owner password credentials）\n客户端模式（client credentials\n\n各个模式具体流程略微复杂，这里节省时间不做介绍，想了解的请参看[理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n## spring-security-oauth2原理分析\n\n在oauth2的框架中，其流程是基于security扩展起来的，在原先的流程上最后面加了一个endpoint节点。其认证服务器其实可以看做拥有两套代码，一套是对第三方应用的权限进行管控的代码，一套是对用户权限进行管控的代码。\n\n对应的配置类分别是：`AuthorizationServerConfigurerAdapter` 和`WebSecurityConfigurerAdapter`\n\n\n\n### 授权端点一览表\n\noauth2提供了一系列URL来完成相应的认证授权相关功能，这些URL都是可配置的，下面贴出各url及其功能；\n\n| 授权端点             | /oauth/authorize      |                  |\n| -------------------- | --------------------- | ---------------- |\n| 令牌端点             | /oauth/token          | 获取一个令牌     |\n| 用户确认授权提交端点 | /oauth/confirm_access | 供用户授权第三方 |\n| 授权服务错误信息端点 | /oauth/error          |                  |\n| 令牌解析端点         | /oauth/check_token    |                  |\n| 公钥端点             | /oauth/token_key      |                  |\n\n\n\n### 认证服务器配置\n\n认证服务器相关配置继承`AuthorizationServerConfigurerAdapter`重写configure方法实现\n\n```java\npublic class AuthorizationServerConfigurerAdapter implements AuthorizationServerConfigurer {\n    public AuthorizationServerConfigurerAdapter() {\n    }\n\n    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {\n    }\n\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n    }\n\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\n    }\n}\n```\n\n\n\n*ClientDetailsServiceConfigurer* 验证客户端的方式\n\n> 当一个客户端向认证服务器请求认证的时候，我们需要判别这个客户端是否通过认证；ClientDetailsServiceConfigurer提供了三种认证方式 ：\n>\n> - clients.withClientDetails()：类似于springSecurity的UserDetailService，对应的也有ClientDetailsService 和 ClientDetails；\n> \n>- clients.jdbc():传入一个dataSource(detaliService 是自定义service，更加灵活，这个是为基于数据库准备的)；\n> \n> - clients.inMemory() 基于内存，也就是在代码里写死\n\n验证参数说明\n\n>从ClientDetails我们就能很清晰的分辨出客户端需要配置哪些参数\n>\n>clientId:客户端ID\n>secret:客户端密钥\n>scope:客户受限的范围。如果范围未定义或为空（默认值），则客户端不受范围限制\n>\n>authorizedGrantTypes:授权客户端使用的授权类型。默认值为空。\n>\n>authorities：授予客户端的权限（常规Spring Security权限）\n>\n>如果我们使用的是数据库存储第三方应用的信息，框架替我们提供了建表语句，https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql  但对于 MYSQL 来说，默认建表语句中主键为 Varchar(256)，这超过了最大的主键长度，可改成 128，并用 BLOB 替换语句中的 LONGVARBINARY 类型\n\n*AuthorizationServerSecurityConfigurer*\n\n>该类共有13个配置相关的方法：\n>\n>- passwordEncoder():编解码器\n>- tokenKeyAccess（）：oauth2授权服务器会提供一个`/oauth/token_key`的url来供资源服务器获取公钥，这个方法就是配置获取公钥的权限范围，它使用的是SpEL表达式且默认不开启，如果你没用到公钥，则不必管他，在[官方文档](<http://projects.spring.io/spring-security-oauth/docs/oauth2.html#resource-server-configuration>) 上使用JwtToken中使用了该方法，如果你用的是JwtToken请注意\n>- checkTokenAccess（）：授权服务器提供一个`/oauth/check_token`的url来供资源服务器解码令牌，该方法就是配置权限范围，同样使用的是SpEL表达式且默认不开启\n>- sslOnly()：普通HTTP适用于测试，但授权服务器只能在生产中通过SSL使用，调用方法`sslOnly()`则强制使用ssl。\n>- getTokenKeyAccess()：就方法名的意思，获得tokenKeyAccess所设置的SpEL表达式\n>- getCheckTokenAccess()：获得checkTokenAccess所设置的SpEL表达式\n>- accessDeniedHandler()：拒绝访问处理器\n>- realm()：默认值为 \"oauth2/client\",用处未知\n>- authenticationEntryPoint()：处理验证失败的\n>- 是allowFormAuthenticationForClients： 允许客户端进行表单身份验证，主要是让/oauth/token支持client_id以及client_secret作登录认证\n>- addTokenEndpointAuthenticationFilter：添加令牌端点身份验证过滤器\n>- tokenEndpointAuthenticationFilters：添加多个过滤器\n>- init():初始化方法\n>\n\n*AuthorizationServerEndpointsConfigurer*\n\n>该类配置方法太多了，且官方资料不全，在这里只列举几个常用的配置方法\n>\n>- pathMapping()：修改授权端点一览表的那些URL\n>- tokenStore()：生成Token后的存储方式，可以new RedisTokenStore()来使用redis存储\n>-  authenticationManager()：用于密码授权的AuthenticationManager。 当采用密码模式的时候，第三方应用直接提供用户的用户名密码，所以这里需要配置AuthenticationManager（AuthenticationManager的作用参考我security配置解析的文章）\n>- allowedTokenEndpointRequestMethods()：允许的请求方式\n\n### 补充说明\n\noauth2中增加了两个很重要的类`TokenEndPoint`类和`AuthorizationEndpoint`类。`AuthorizationEndpoint` 为授权码模式的端点，它在执行流程的最后位置，它会检验用户是否已经登陆，检验第三方用户，检验授权范围，最后生成code重定向到redirect_uri。\n\n`TokenEndPoint`和`AuthorizationEndpoint` `类似，它用于获取token，在返回token时也会做相应的校验\n\n### 认证服务器使用\n\n为便于学习，我们单独搭一个认证服务器并使用它\n\n依赖：\n\n```xml\n     <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-oauth2</artifactId>\n            <version>2.0.0.RELEASE</version>\n        </dependency>\n```\n\n配置：\n\n```java\n@SpringBootApplication\n@EnableAuthorizationServer\npublic class PoseidonCloudOauthApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(PoseidonCloudOauthApplication.class, args);\n    }\n\n    @Bean\n    public WebSecurityConfigurerAdapter webSecurityConfigurerAdapter() {\n        return new WebSecurityConfigurerAdapter() {\n            @Override\n            public void configure(HttpSecurity httpSecurity) throws Exception {\n                httpSecurity.formLogin().and().csrf().disable();\n            }\n        };\n    }\n}\n```\n\n测试用例：\n\n```java\n    @Autowired\n    private TestRestTemplate restTemplate;\n\t// 密码模式测试\n    @Test\n    public void token_password() {\n        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n        params.add(\"grant_type\", \"password\");\n        params.add(\"username\", \"admin\");\n        params.add(\"password\", \"admin\");\n        params.add(\"scope\", \"scope1 scope2\");\n//        第三方应用登陆\n        String response = restTemplate.withBasicAuth(\"clientId\", \"clientSecret\").\n//                用户的用户名密码\n                postForObject(\"/oauth/token\", params, String.class);\n        System.out.println(response);\n    }\n// 客户端模式\n    @Test\n    public void token_client() {\n        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n        params.add(\"grant_type\", \"client_credentials\");\n        String response = restTemplate.withBasicAuth(\"clientId\", \"clientSecret\").\n                postForObject(\"/oauth/token\", params, String.class);\n        System.out.println(response);\n    }\n```\n\n授权码模式要通过测试工具来测；\n\n这里涉及到一个`BasicAuth`的概念，说明一下，其实就是将用户名密码用`username:password` 这样的形式拼接，然后base64编码后得到一个code，在请求头的`Authorization` 中添加 `Basic code`。而postman也支持`BasicAuth`,测试细节略。\n\n## oauth2扩展\n\n","slug":"security-oauth2学习笔记","published":1,"updated":"2021-01-11T07:31:23.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6s003d00wi41k7ej59","content":"<p>作者：muggle</p>\n<h2 id=\"oauth2-相关概念\"><a href=\"#oauth2-相关概念\" class=\"headerlink\" title=\"oauth2 相关概念\"></a>oauth2 相关概念</h2><p>文章参考<a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">理解OAuth 2.0</a></p>\n<h3 id=\"oauth2-角色关系\"><a href=\"#oauth2-角色关系\" class=\"headerlink\" title=\"oauth2 角色关系\"></a>oauth2 角色关系</h3><p>在oauth2中分为以下几个角色：Resource server、Authorization server、Resource Owner、application。</p>\n<p>Resource server:资源服务器</p>\n<p>Authorization server:认证服务器</p>\n<p>Resource Owner:资源拥有者</p>\n<p>application:第三方应用</p>\n<p>oauth2的一次请求流程为：</p>\n<p>第三方应用获取认证token 向认证服务器认证，认证服务器通过认证后第三方应用便可向资源服务器拿资源；第三方应用的获取资源的范围由资源拥有者授权。</p>\n<p>显然由流程可知，oauth2要保证以下几点：<br>1.token的有效期和更新方式要可控，安全性要好<br>2.用户授权第三方应用要可以控制授权范围</p>\n<a id=\"more\"></a>\n\n<h3 id=\"oauth2的授权方式\"><a href=\"#oauth2的授权方式\" class=\"headerlink\" title=\"oauth2的授权方式\"></a>oauth2的授权方式</h3><p>第三方应用必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p>\n<p>授权码模式（authorization code）<br>简化模式（implicit）<br>密码模式（resource owner password credentials）<br>客户端模式（client credentials</p>\n<p>各个模式具体流程略微复杂，这里节省时间不做介绍，想了解的请参看<a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">理解OAuth 2.0</a></p>\n<h2 id=\"spring-security-oauth2原理分析\"><a href=\"#spring-security-oauth2原理分析\" class=\"headerlink\" title=\"spring-security-oauth2原理分析\"></a>spring-security-oauth2原理分析</h2><p>在oauth2的框架中，其流程是基于security扩展起来的，在原先的流程上最后面加了一个endpoint节点。其认证服务器其实可以看做拥有两套代码，一套是对第三方应用的权限进行管控的代码，一套是对用户权限进行管控的代码。</p>\n<p>对应的配置类分别是：<code>AuthorizationServerConfigurerAdapter</code> 和<code>WebSecurityConfigurerAdapter</code></p>\n<h3 id=\"授权端点一览表\"><a href=\"#授权端点一览表\" class=\"headerlink\" title=\"授权端点一览表\"></a>授权端点一览表</h3><p>oauth2提供了一系列URL来完成相应的认证授权相关功能，这些URL都是可配置的，下面贴出各url及其功能；</p>\n<table>\n<thead>\n<tr>\n<th>授权端点</th>\n<th>/oauth/authorize</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>令牌端点</td>\n<td>/oauth/token</td>\n<td>获取一个令牌</td>\n</tr>\n<tr>\n<td>用户确认授权提交端点</td>\n<td>/oauth/confirm_access</td>\n<td>供用户授权第三方</td>\n</tr>\n<tr>\n<td>授权服务错误信息端点</td>\n<td>/oauth/error</td>\n<td></td>\n</tr>\n<tr>\n<td>令牌解析端点</td>\n<td>/oauth/check_token</td>\n<td></td>\n</tr>\n<tr>\n<td>公钥端点</td>\n<td>/oauth/token_key</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"认证服务器配置\"><a href=\"#认证服务器配置\" class=\"headerlink\" title=\"认证服务器配置\"></a>认证服务器配置</h3><p>认证服务器相关配置继承<code>AuthorizationServerConfigurerAdapter</code>重写configure方法实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthorizationServerConfigurerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthorizationServerConfigurer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AuthorizationServerConfigurerAdapter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthorizationServerSecurityConfigurer security)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ClientDetailsServiceConfigurer clients)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><em>ClientDetailsServiceConfigurer</em> 验证客户端的方式</p>\n<blockquote>\n<p>当一个客户端向认证服务器请求认证的时候，我们需要判别这个客户端是否通过认证；ClientDetailsServiceConfigurer提供了三种认证方式 ：</p>\n<ul>\n<li><p>clients.withClientDetails()：类似于springSecurity的UserDetailService，对应的也有ClientDetailsService 和 ClientDetails；</p>\n</li>\n<li><p>clients.jdbc():传入一个dataSource(detaliService 是自定义service，更加灵活，这个是为基于数据库准备的)；</p>\n</li>\n<li><p>clients.inMemory() 基于内存，也就是在代码里写死</p>\n</li>\n</ul>\n</blockquote>\n<p>验证参数说明</p>\n<blockquote>\n<p>从ClientDetails我们就能很清晰的分辨出客户端需要配置哪些参数</p>\n<p>clientId:客户端ID<br>secret:客户端密钥<br>scope:客户受限的范围。如果范围未定义或为空（默认值），则客户端不受范围限制</p>\n<p>authorizedGrantTypes:授权客户端使用的授权类型。默认值为空。</p>\n<p>authorities：授予客户端的权限（常规Spring Security权限）</p>\n<p>如果我们使用的是数据库存储第三方应用的信息，框架替我们提供了建表语句，<a href=\"https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql\">https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql</a>  但对于 MYSQL 来说，默认建表语句中主键为 Varchar(256)，这超过了最大的主键长度，可改成 128，并用 BLOB 替换语句中的 LONGVARBINARY 类型</p>\n</blockquote>\n<p><em>AuthorizationServerSecurityConfigurer</em></p>\n<blockquote>\n<p>该类共有13个配置相关的方法：</p>\n<ul>\n<li>passwordEncoder():编解码器</li>\n<li>tokenKeyAccess（）：oauth2授权服务器会提供一个<code>/oauth/token_key</code>的url来供资源服务器获取公钥，这个方法就是配置获取公钥的权限范围，它使用的是SpEL表达式且默认不开启，如果你没用到公钥，则不必管他，在<a href=\"http://projects.spring.io/spring-security-oauth/docs/oauth2.html#resource-server-configuration\">官方文档</a> 上使用JwtToken中使用了该方法，如果你用的是JwtToken请注意</li>\n<li>checkTokenAccess（）：授权服务器提供一个<code>/oauth/check_token</code>的url来供资源服务器解码令牌，该方法就是配置权限范围，同样使用的是SpEL表达式且默认不开启</li>\n<li>sslOnly()：普通HTTP适用于测试，但授权服务器只能在生产中通过SSL使用，调用方法<code>sslOnly()</code>则强制使用ssl。</li>\n<li>getTokenKeyAccess()：就方法名的意思，获得tokenKeyAccess所设置的SpEL表达式</li>\n<li>getCheckTokenAccess()：获得checkTokenAccess所设置的SpEL表达式</li>\n<li>accessDeniedHandler()：拒绝访问处理器</li>\n<li>realm()：默认值为 “oauth2/client”,用处未知</li>\n<li>authenticationEntryPoint()：处理验证失败的</li>\n<li>是allowFormAuthenticationForClients： 允许客户端进行表单身份验证，主要是让/oauth/token支持client_id以及client_secret作登录认证</li>\n<li>addTokenEndpointAuthenticationFilter：添加令牌端点身份验证过滤器</li>\n<li>tokenEndpointAuthenticationFilters：添加多个过滤器</li>\n<li>init():初始化方法</li>\n</ul>\n</blockquote>\n<p><em>AuthorizationServerEndpointsConfigurer</em></p>\n<blockquote>\n<p>该类配置方法太多了，且官方资料不全，在这里只列举几个常用的配置方法</p>\n<ul>\n<li>pathMapping()：修改授权端点一览表的那些URL</li>\n<li>tokenStore()：生成Token后的存储方式，可以new RedisTokenStore()来使用redis存储</li>\n<li>authenticationManager()：用于密码授权的AuthenticationManager。 当采用密码模式的时候，第三方应用直接提供用户的用户名密码，所以这里需要配置AuthenticationManager（AuthenticationManager的作用参考我security配置解析的文章）</li>\n<li>allowedTokenEndpointRequestMethods()：允许的请求方式</li>\n</ul>\n</blockquote>\n<h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><p>oauth2中增加了两个很重要的类<code>TokenEndPoint</code>类和<code>AuthorizationEndpoint</code>类。<code>AuthorizationEndpoint</code> 为授权码模式的端点，它在执行流程的最后位置，它会检验用户是否已经登陆，检验第三方用户，检验授权范围，最后生成code重定向到redirect_uri。</p>\n<p><code>TokenEndPoint</code>和<code>AuthorizationEndpoint</code> `类似，它用于获取token，在返回token时也会做相应的校验</p>\n<h3 id=\"认证服务器使用\"><a href=\"#认证服务器使用\" class=\"headerlink\" title=\"认证服务器使用\"></a>认证服务器使用</h3><p>为便于学习，我们单独搭一个认证服务器并使用它</p>\n<p>依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAuthorizationServer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoseidonCloudOauthApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(PoseidonCloudOauthApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebSecurityConfigurerAdapter <span class=\"title\">webSecurityConfigurerAdapter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WebSecurityConfigurerAdapter() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity httpSecurity)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                httpSecurity.formLogin().and().csrf().disable();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试用例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestRestTemplate restTemplate;</span><br><span class=\"line\">\t<span class=\"comment\">// 密码模式测试</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">token_password</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        MultiValueMap&lt;String, String&gt; params = <span class=\"keyword\">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class=\"line\">        params.add(<span class=\"string\">&quot;grant_type&quot;</span>, <span class=\"string\">&quot;password&quot;</span>);</span><br><span class=\"line\">        params.add(<span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        params.add(<span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        params.add(<span class=\"string\">&quot;scope&quot;</span>, <span class=\"string\">&quot;scope1 scope2&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        第三方应用登陆</span></span><br><span class=\"line\">        String response = restTemplate.withBasicAuth(<span class=\"string\">&quot;clientId&quot;</span>, <span class=\"string\">&quot;clientSecret&quot;</span>).</span><br><span class=\"line\"><span class=\"comment\">//                用户的用户名密码</span></span><br><span class=\"line\">                postForObject(<span class=\"string\">&quot;/oauth/token&quot;</span>, params, String.class);</span><br><span class=\"line\">        System.out.println(response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 客户端模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">token_client</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        MultiValueMap&lt;String, String&gt; params = <span class=\"keyword\">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class=\"line\">        params.add(<span class=\"string\">&quot;grant_type&quot;</span>, <span class=\"string\">&quot;client_credentials&quot;</span>);</span><br><span class=\"line\">        String response = restTemplate.withBasicAuth(<span class=\"string\">&quot;clientId&quot;</span>, <span class=\"string\">&quot;clientSecret&quot;</span>).</span><br><span class=\"line\">                postForObject(<span class=\"string\">&quot;/oauth/token&quot;</span>, params, String.class);</span><br><span class=\"line\">        System.out.println(response);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>授权码模式要通过测试工具来测；</p>\n<p>这里涉及到一个<code>BasicAuth</code>的概念，说明一下，其实就是将用户名密码用<code>username:password</code> 这样的形式拼接，然后base64编码后得到一个code，在请求头的<code>Authorization</code> 中添加 <code>Basic code</code>。而postman也支持<code>BasicAuth</code>,测试细节略。</p>\n<h2 id=\"oauth2扩展\"><a href=\"#oauth2扩展\" class=\"headerlink\" title=\"oauth2扩展\"></a>oauth2扩展</h2>","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h2 id=\"oauth2-相关概念\"><a href=\"#oauth2-相关概念\" class=\"headerlink\" title=\"oauth2 相关概念\"></a>oauth2 相关概念</h2><p>文章参考<a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">理解OAuth 2.0</a></p>\n<h3 id=\"oauth2-角色关系\"><a href=\"#oauth2-角色关系\" class=\"headerlink\" title=\"oauth2 角色关系\"></a>oauth2 角色关系</h3><p>在oauth2中分为以下几个角色：Resource server、Authorization server、Resource Owner、application。</p>\n<p>Resource server:资源服务器</p>\n<p>Authorization server:认证服务器</p>\n<p>Resource Owner:资源拥有者</p>\n<p>application:第三方应用</p>\n<p>oauth2的一次请求流程为：</p>\n<p>第三方应用获取认证token 向认证服务器认证，认证服务器通过认证后第三方应用便可向资源服务器拿资源；第三方应用的获取资源的范围由资源拥有者授权。</p>\n<p>显然由流程可知，oauth2要保证以下几点：<br>1.token的有效期和更新方式要可控，安全性要好<br>2.用户授权第三方应用要可以控制授权范围</p>","more":"<h3 id=\"oauth2的授权方式\"><a href=\"#oauth2的授权方式\" class=\"headerlink\" title=\"oauth2的授权方式\"></a>oauth2的授权方式</h3><p>第三方应用必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p>\n<p>授权码模式（authorization code）<br>简化模式（implicit）<br>密码模式（resource owner password credentials）<br>客户端模式（client credentials</p>\n<p>各个模式具体流程略微复杂，这里节省时间不做介绍，想了解的请参看<a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">理解OAuth 2.0</a></p>\n<h2 id=\"spring-security-oauth2原理分析\"><a href=\"#spring-security-oauth2原理分析\" class=\"headerlink\" title=\"spring-security-oauth2原理分析\"></a>spring-security-oauth2原理分析</h2><p>在oauth2的框架中，其流程是基于security扩展起来的，在原先的流程上最后面加了一个endpoint节点。其认证服务器其实可以看做拥有两套代码，一套是对第三方应用的权限进行管控的代码，一套是对用户权限进行管控的代码。</p>\n<p>对应的配置类分别是：<code>AuthorizationServerConfigurerAdapter</code> 和<code>WebSecurityConfigurerAdapter</code></p>\n<h3 id=\"授权端点一览表\"><a href=\"#授权端点一览表\" class=\"headerlink\" title=\"授权端点一览表\"></a>授权端点一览表</h3><p>oauth2提供了一系列URL来完成相应的认证授权相关功能，这些URL都是可配置的，下面贴出各url及其功能；</p>\n<table>\n<thead>\n<tr>\n<th>授权端点</th>\n<th>/oauth/authorize</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>令牌端点</td>\n<td>/oauth/token</td>\n<td>获取一个令牌</td>\n</tr>\n<tr>\n<td>用户确认授权提交端点</td>\n<td>/oauth/confirm_access</td>\n<td>供用户授权第三方</td>\n</tr>\n<tr>\n<td>授权服务错误信息端点</td>\n<td>/oauth/error</td>\n<td></td>\n</tr>\n<tr>\n<td>令牌解析端点</td>\n<td>/oauth/check_token</td>\n<td></td>\n</tr>\n<tr>\n<td>公钥端点</td>\n<td>/oauth/token_key</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"认证服务器配置\"><a href=\"#认证服务器配置\" class=\"headerlink\" title=\"认证服务器配置\"></a>认证服务器配置</h3><p>认证服务器相关配置继承<code>AuthorizationServerConfigurerAdapter</code>重写configure方法实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthorizationServerConfigurerAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthorizationServerConfigurer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AuthorizationServerConfigurerAdapter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthorizationServerSecurityConfigurer security)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ClientDetailsServiceConfigurer clients)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><em>ClientDetailsServiceConfigurer</em> 验证客户端的方式</p>\n<blockquote>\n<p>当一个客户端向认证服务器请求认证的时候，我们需要判别这个客户端是否通过认证；ClientDetailsServiceConfigurer提供了三种认证方式 ：</p>\n<ul>\n<li><p>clients.withClientDetails()：类似于springSecurity的UserDetailService，对应的也有ClientDetailsService 和 ClientDetails；</p>\n</li>\n<li><p>clients.jdbc():传入一个dataSource(detaliService 是自定义service，更加灵活，这个是为基于数据库准备的)；</p>\n</li>\n<li><p>clients.inMemory() 基于内存，也就是在代码里写死</p>\n</li>\n</ul>\n</blockquote>\n<p>验证参数说明</p>\n<blockquote>\n<p>从ClientDetails我们就能很清晰的分辨出客户端需要配置哪些参数</p>\n<p>clientId:客户端ID<br>secret:客户端密钥<br>scope:客户受限的范围。如果范围未定义或为空（默认值），则客户端不受范围限制</p>\n<p>authorizedGrantTypes:授权客户端使用的授权类型。默认值为空。</p>\n<p>authorities：授予客户端的权限（常规Spring Security权限）</p>\n<p>如果我们使用的是数据库存储第三方应用的信息，框架替我们提供了建表语句，<a href=\"https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql\">https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql</a>  但对于 MYSQL 来说，默认建表语句中主键为 Varchar(256)，这超过了最大的主键长度，可改成 128，并用 BLOB 替换语句中的 LONGVARBINARY 类型</p>\n</blockquote>\n<p><em>AuthorizationServerSecurityConfigurer</em></p>\n<blockquote>\n<p>该类共有13个配置相关的方法：</p>\n<ul>\n<li>passwordEncoder():编解码器</li>\n<li>tokenKeyAccess（）：oauth2授权服务器会提供一个<code>/oauth/token_key</code>的url来供资源服务器获取公钥，这个方法就是配置获取公钥的权限范围，它使用的是SpEL表达式且默认不开启，如果你没用到公钥，则不必管他，在<a href=\"http://projects.spring.io/spring-security-oauth/docs/oauth2.html#resource-server-configuration\">官方文档</a> 上使用JwtToken中使用了该方法，如果你用的是JwtToken请注意</li>\n<li>checkTokenAccess（）：授权服务器提供一个<code>/oauth/check_token</code>的url来供资源服务器解码令牌，该方法就是配置权限范围，同样使用的是SpEL表达式且默认不开启</li>\n<li>sslOnly()：普通HTTP适用于测试，但授权服务器只能在生产中通过SSL使用，调用方法<code>sslOnly()</code>则强制使用ssl。</li>\n<li>getTokenKeyAccess()：就方法名的意思，获得tokenKeyAccess所设置的SpEL表达式</li>\n<li>getCheckTokenAccess()：获得checkTokenAccess所设置的SpEL表达式</li>\n<li>accessDeniedHandler()：拒绝访问处理器</li>\n<li>realm()：默认值为 “oauth2/client”,用处未知</li>\n<li>authenticationEntryPoint()：处理验证失败的</li>\n<li>是allowFormAuthenticationForClients： 允许客户端进行表单身份验证，主要是让/oauth/token支持client_id以及client_secret作登录认证</li>\n<li>addTokenEndpointAuthenticationFilter：添加令牌端点身份验证过滤器</li>\n<li>tokenEndpointAuthenticationFilters：添加多个过滤器</li>\n<li>init():初始化方法</li>\n</ul>\n</blockquote>\n<p><em>AuthorizationServerEndpointsConfigurer</em></p>\n<blockquote>\n<p>该类配置方法太多了，且官方资料不全，在这里只列举几个常用的配置方法</p>\n<ul>\n<li>pathMapping()：修改授权端点一览表的那些URL</li>\n<li>tokenStore()：生成Token后的存储方式，可以new RedisTokenStore()来使用redis存储</li>\n<li>authenticationManager()：用于密码授权的AuthenticationManager。 当采用密码模式的时候，第三方应用直接提供用户的用户名密码，所以这里需要配置AuthenticationManager（AuthenticationManager的作用参考我security配置解析的文章）</li>\n<li>allowedTokenEndpointRequestMethods()：允许的请求方式</li>\n</ul>\n</blockquote>\n<h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><p>oauth2中增加了两个很重要的类<code>TokenEndPoint</code>类和<code>AuthorizationEndpoint</code>类。<code>AuthorizationEndpoint</code> 为授权码模式的端点，它在执行流程的最后位置，它会检验用户是否已经登陆，检验第三方用户，检验授权范围，最后生成code重定向到redirect_uri。</p>\n<p><code>TokenEndPoint</code>和<code>AuthorizationEndpoint</code> `类似，它用于获取token，在返回token时也会做相应的校验</p>\n<h3 id=\"认证服务器使用\"><a href=\"#认证服务器使用\" class=\"headerlink\" title=\"认证服务器使用\"></a>认证服务器使用</h3><p>为便于学习，我们单独搭一个认证服务器并使用它</p>\n<p>依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAuthorizationServer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoseidonCloudOauthApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(PoseidonCloudOauthApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebSecurityConfigurerAdapter <span class=\"title\">webSecurityConfigurerAdapter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WebSecurityConfigurerAdapter() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity httpSecurity)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                httpSecurity.formLogin().and().csrf().disable();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试用例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestRestTemplate restTemplate;</span><br><span class=\"line\">\t<span class=\"comment\">// 密码模式测试</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">token_password</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        MultiValueMap&lt;String, String&gt; params = <span class=\"keyword\">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class=\"line\">        params.add(<span class=\"string\">&quot;grant_type&quot;</span>, <span class=\"string\">&quot;password&quot;</span>);</span><br><span class=\"line\">        params.add(<span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        params.add(<span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        params.add(<span class=\"string\">&quot;scope&quot;</span>, <span class=\"string\">&quot;scope1 scope2&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        第三方应用登陆</span></span><br><span class=\"line\">        String response = restTemplate.withBasicAuth(<span class=\"string\">&quot;clientId&quot;</span>, <span class=\"string\">&quot;clientSecret&quot;</span>).</span><br><span class=\"line\"><span class=\"comment\">//                用户的用户名密码</span></span><br><span class=\"line\">                postForObject(<span class=\"string\">&quot;/oauth/token&quot;</span>, params, String.class);</span><br><span class=\"line\">        System.out.println(response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 客户端模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">token_client</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        MultiValueMap&lt;String, String&gt; params = <span class=\"keyword\">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class=\"line\">        params.add(<span class=\"string\">&quot;grant_type&quot;</span>, <span class=\"string\">&quot;client_credentials&quot;</span>);</span><br><span class=\"line\">        String response = restTemplate.withBasicAuth(<span class=\"string\">&quot;clientId&quot;</span>, <span class=\"string\">&quot;clientSecret&quot;</span>).</span><br><span class=\"line\">                postForObject(<span class=\"string\">&quot;/oauth/token&quot;</span>, params, String.class);</span><br><span class=\"line\">        System.out.println(response);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>授权码模式要通过测试工具来测；</p>\n<p>这里涉及到一个<code>BasicAuth</code>的概念，说明一下，其实就是将用户名密码用<code>username:password</code> 这样的形式拼接，然后base64编码后得到一个code，在请求头的<code>Authorization</code> 中添加 <code>Basic code</code>。而postman也支持<code>BasicAuth</code>,测试细节略。</p>\n<h2 id=\"oauth2扩展\"><a href=\"#oauth2扩展\" class=\"headerlink\" title=\"oauth2扩展\"></a>oauth2扩展</h2>"},{"title":"springboot全面解读系列第一篇","date":"2019-04-16T02:35:48.000Z","_content":"\n作者：muggle\n\n## 序\n\n如果你研究过springboot，你就会发现它不仅仅是方便了我们搭建项目整合框架，它其中有许多很高明的编程思想值得去学习研究和模仿；\n\n<!--more-->\n\n## 如何构建springboot项目\n\n## springboot 项目结构分析\n\n## 嵌入式WEB容器\n\n## 自动装配 \n\n组件和角色\n\n@component的派生和层级\n\n@enable 模块\n\n具有相同领域是功能组件集合，组合所形成的一个独立的单元\n\n@enablewebmvc @enableAutoconfiguration\n\n实现方式： 编程和注解\n\n@enableWebmvc                     webmvc \n\n@enableTransactionManagement         事物\n\n@enbaleCahing   caching\n\n@enableMBeanExport   jmx\n\n@enableAsync 异步处理\n\n@enablewebflux   webflux\n\n@enableAspectJAutoProxy\n\n@enable AutoConfiguration\n\n@enableManagementContext\n\n@EnableConfigurationProperties\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/sppringboot.md","raw":"---\ntitle: springboot全面解读系列第一篇\ndate: 2019-04-16 10:35:48\ntags: springboot\n---\n\n作者：muggle\n\n## 序\n\n如果你研究过springboot，你就会发现它不仅仅是方便了我们搭建项目整合框架，它其中有许多很高明的编程思想值得去学习研究和模仿；\n\n<!--more-->\n\n## 如何构建springboot项目\n\n## springboot 项目结构分析\n\n## 嵌入式WEB容器\n\n## 自动装配 \n\n组件和角色\n\n@component的派生和层级\n\n@enable 模块\n\n具有相同领域是功能组件集合，组合所形成的一个独立的单元\n\n@enablewebmvc @enableAutoconfiguration\n\n实现方式： 编程和注解\n\n@enableWebmvc                     webmvc \n\n@enableTransactionManagement         事物\n\n@enbaleCahing   caching\n\n@enableMBeanExport   jmx\n\n@enableAsync 异步处理\n\n@enablewebflux   webflux\n\n@enableAspectJAutoProxy\n\n@enable AutoConfiguration\n\n@enableManagementContext\n\n@EnableConfigurationProperties\n\n\n\n\n\n\n\n\n\n\n\n","slug":"sppringboot","published":1,"updated":"2021-01-11T07:31:23.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6t003f00wibpml90ww","content":"<p>作者：muggle</p>\n<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>如果你研究过springboot，你就会发现它不仅仅是方便了我们搭建项目整合框架，它其中有许多很高明的编程思想值得去学习研究和模仿；</p>\n<a id=\"more\"></a>\n\n<h2 id=\"如何构建springboot项目\"><a href=\"#如何构建springboot项目\" class=\"headerlink\" title=\"如何构建springboot项目\"></a>如何构建springboot项目</h2><h2 id=\"springboot-项目结构分析\"><a href=\"#springboot-项目结构分析\" class=\"headerlink\" title=\"springboot 项目结构分析\"></a>springboot 项目结构分析</h2><h2 id=\"嵌入式WEB容器\"><a href=\"#嵌入式WEB容器\" class=\"headerlink\" title=\"嵌入式WEB容器\"></a>嵌入式WEB容器</h2><h2 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h2><p>组件和角色</p>\n<p>@component的派生和层级</p>\n<p>@enable 模块</p>\n<p>具有相同领域是功能组件集合，组合所形成的一个独立的单元</p>\n<p>@enablewebmvc @enableAutoconfiguration</p>\n<p>实现方式： 编程和注解</p>\n<p>@enableWebmvc                     webmvc </p>\n<p>@enableTransactionManagement         事物</p>\n<p>@enbaleCahing   caching</p>\n<p>@enableMBeanExport   jmx</p>\n<p>@enableAsync 异步处理</p>\n<p>@enablewebflux   webflux</p>\n<p>@enableAspectJAutoProxy</p>\n<p>@enable AutoConfiguration</p>\n<p>@enableManagementContext</p>\n<p>@EnableConfigurationProperties</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>如果你研究过springboot，你就会发现它不仅仅是方便了我们搭建项目整合框架，它其中有许多很高明的编程思想值得去学习研究和模仿；</p>","more":"<h2 id=\"如何构建springboot项目\"><a href=\"#如何构建springboot项目\" class=\"headerlink\" title=\"如何构建springboot项目\"></a>如何构建springboot项目</h2><h2 id=\"springboot-项目结构分析\"><a href=\"#springboot-项目结构分析\" class=\"headerlink\" title=\"springboot 项目结构分析\"></a>springboot 项目结构分析</h2><h2 id=\"嵌入式WEB容器\"><a href=\"#嵌入式WEB容器\" class=\"headerlink\" title=\"嵌入式WEB容器\"></a>嵌入式WEB容器</h2><h2 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h2><p>组件和角色</p>\n<p>@component的派生和层级</p>\n<p>@enable 模块</p>\n<p>具有相同领域是功能组件集合，组合所形成的一个独立的单元</p>\n<p>@enablewebmvc @enableAutoconfiguration</p>\n<p>实现方式： 编程和注解</p>\n<p>@enableWebmvc                     webmvc </p>\n<p>@enableTransactionManagement         事物</p>\n<p>@enbaleCahing   caching</p>\n<p>@enableMBeanExport   jmx</p>\n<p>@enableAsync 异步处理</p>\n<p>@enablewebflux   webflux</p>\n<p>@enableAspectJAutoProxy</p>\n<p>@enable AutoConfiguration</p>\n<p>@enableManagementContext</p>\n<p>@EnableConfigurationProperties</p>"},{"title":"spring笔记","date":"2019-05-08T09:54:00.000Z","_content":"\n分为20个模块\n\ncore container\n\n<!--more-->\n\ncore beans context expression language\n\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-f726082d79be3e72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-16a1a229cda57201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\nspring\n\n1. 读取bean的配置信息\n2. 根据配置信息实例化一个bean\n3. 调用实例化后的实例\n\nbeanFactory\n\nbean被当做一种资源，各个factory完成对bean的增删改查，注入读取，初始化等功能\n\ninputStreamSource 封装inputstream\n\nfactoryBean :\n\nspring的标准实例化bean的流程是在xml中提供配置信息然后读取配置信息。factoryBean通过实现接口的方式实例化bean（java代码配置bean信息）\n\ndemo\n\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-ca7b32793a6d88cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n单例在spring同一个容器中只会被创建一次，后续直接从单例缓存中获取\n\n循环依赖\n\nobjectFactory\n\nsingletonFactory\n\n1. 检查缓存是否已经加载过\n2. 若没加载就记录下来\n\n创建bean\n\n1. classname\n2. 检查override\n3. 检查bean是否已经存在\n4. 创建bean\n\n实例化前置处理器\n\n实例化后置处理器\n\n循环依赖\n\n检查是否循环依赖\n\n循环依赖会导致内存溢出\n\n构造器循环依赖\n\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-3ca9287803145b3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n支持用户扩展\n\n### SpringMVC流程\n\n1、 用户发送请求至前端控制器DispatcherServlet。\n\n2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。\n\n3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。\n\n4、 DispatcherServlet调用HandlerAdapter处理器适配器。\n\n5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。\n\n6、 Controller执行完成返回ModelAndView。\n\n7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。\n\n8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。\n\n9、 ViewReslover解析后返回具体View。\n\n10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。\n\n11、 DispatcherServlet响应用户。\n\n**组件：**  **1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供**  作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。  用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。\n\n**2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供**  作用：根据请求的url查找Handler  HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。\n\n**3、处理器适配器HandlerAdapter**  作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler  通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。\n\n**4、处理器Handler(需要工程师开发)**  **注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler**  Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。  由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。\n\n**5、视图解析器View resolver(不需要工程师开发),由框架提供**  作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）  View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。  一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。\n\n**6、视图View(需要工程师开发jsp...)**  View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...）\n\n**核心架构的具体流程步骤如下：**  1、首先用户发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；  2、DispatcherServlet——>HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；  3、DispatcherServlet——>HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；  4、HandlerAdapter——>处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；  5、ModelAndView的逻辑视图名——> ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；  6、View——>渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；  7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。\n\n下边两个组件通常情况下需要开发：\n\nHandler：处理器，即后端控制器用controller表示。\n\nView：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。\n\nWebApplicationContext\n\nServletContext\n\nApplicationContext\n\n问：\n\n我们可以通过\n\nApplicationContext ap = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\n得到一个spring容器，那么在传统ssm项目中是如何。。知道了\n\n## spring bean的生命周期\n\n实例化bean对象(通过构造方法或者工厂方法)\n\n设置对象属性(setter等)（依赖注入）\n\n如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）\n\n如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身\n\n将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法\n\n调用Bean的初始化方法\n\n将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法\n\n使用Bean\n\n容器关闭之前，调用Bean的销毁方法\n\n","source":"_posts/spring-1.md","raw":"---\ntitle: spring笔记\ndate: 2019-05-08 17:54:00\ntags: spring\n---\n\n分为20个模块\n\ncore container\n\n<!--more-->\n\ncore beans context expression language\n\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-f726082d79be3e72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-16a1a229cda57201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\nspring\n\n1. 读取bean的配置信息\n2. 根据配置信息实例化一个bean\n3. 调用实例化后的实例\n\nbeanFactory\n\nbean被当做一种资源，各个factory完成对bean的增删改查，注入读取，初始化等功能\n\ninputStreamSource 封装inputstream\n\nfactoryBean :\n\nspring的标准实例化bean的流程是在xml中提供配置信息然后读取配置信息。factoryBean通过实现接口的方式实例化bean（java代码配置bean信息）\n\ndemo\n\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-ca7b32793a6d88cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n单例在spring同一个容器中只会被创建一次，后续直接从单例缓存中获取\n\n循环依赖\n\nobjectFactory\n\nsingletonFactory\n\n1. 检查缓存是否已经加载过\n2. 若没加载就记录下来\n\n创建bean\n\n1. classname\n2. 检查override\n3. 检查bean是否已经存在\n4. 创建bean\n\n实例化前置处理器\n\n实例化后置处理器\n\n循环依赖\n\n检查是否循环依赖\n\n循环依赖会导致内存溢出\n\n构造器循环依赖\n\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-3ca9287803145b3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n支持用户扩展\n\n### SpringMVC流程\n\n1、 用户发送请求至前端控制器DispatcherServlet。\n\n2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。\n\n3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。\n\n4、 DispatcherServlet调用HandlerAdapter处理器适配器。\n\n5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。\n\n6、 Controller执行完成返回ModelAndView。\n\n7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。\n\n8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。\n\n9、 ViewReslover解析后返回具体View。\n\n10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。\n\n11、 DispatcherServlet响应用户。\n\n**组件：**  **1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供**  作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。  用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。\n\n**2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供**  作用：根据请求的url查找Handler  HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。\n\n**3、处理器适配器HandlerAdapter**  作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler  通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。\n\n**4、处理器Handler(需要工程师开发)**  **注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler**  Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。  由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。\n\n**5、视图解析器View resolver(不需要工程师开发),由框架提供**  作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）  View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。  一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。\n\n**6、视图View(需要工程师开发jsp...)**  View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...）\n\n**核心架构的具体流程步骤如下：**  1、首先用户发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；  2、DispatcherServlet——>HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；  3、DispatcherServlet——>HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；  4、HandlerAdapter——>处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；  5、ModelAndView的逻辑视图名——> ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；  6、View——>渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；  7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。\n\n下边两个组件通常情况下需要开发：\n\nHandler：处理器，即后端控制器用controller表示。\n\nView：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。\n\nWebApplicationContext\n\nServletContext\n\nApplicationContext\n\n问：\n\n我们可以通过\n\nApplicationContext ap = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\n得到一个spring容器，那么在传统ssm项目中是如何。。知道了\n\n## spring bean的生命周期\n\n实例化bean对象(通过构造方法或者工厂方法)\n\n设置对象属性(setter等)（依赖注入）\n\n如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）\n\n如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身\n\n将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法\n\n调用Bean的初始化方法\n\n将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法\n\n使用Bean\n\n容器关闭之前，调用Bean的销毁方法\n\n","slug":"spring-1","published":1,"updated":"2021-01-11T07:31:23.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6u003i00wi6bref7j4","content":"<p>分为20个模块</p>\n<p>core container</p>\n<a id=\"more\"></a>\n\n<p>core beans context expression language</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-f726082d79be3e72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-16a1a229cda57201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>spring</p>\n<ol>\n<li>读取bean的配置信息</li>\n<li>根据配置信息实例化一个bean</li>\n<li>调用实例化后的实例</li>\n</ol>\n<p>beanFactory</p>\n<p>bean被当做一种资源，各个factory完成对bean的增删改查，注入读取，初始化等功能</p>\n<p>inputStreamSource 封装inputstream</p>\n<p>factoryBean :</p>\n<p>spring的标准实例化bean的流程是在xml中提供配置信息然后读取配置信息。factoryBean通过实现接口的方式实例化bean（java代码配置bean信息）</p>\n<p>demo</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-ca7b32793a6d88cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>单例在spring同一个容器中只会被创建一次，后续直接从单例缓存中获取</p>\n<p>循环依赖</p>\n<p>objectFactory</p>\n<p>singletonFactory</p>\n<ol>\n<li>检查缓存是否已经加载过</li>\n<li>若没加载就记录下来</li>\n</ol>\n<p>创建bean</p>\n<ol>\n<li>classname</li>\n<li>检查override</li>\n<li>检查bean是否已经存在</li>\n<li>创建bean</li>\n</ol>\n<p>实例化前置处理器</p>\n<p>实例化后置处理器</p>\n<p>循环依赖</p>\n<p>检查是否循环依赖</p>\n<p>循环依赖会导致内存溢出</p>\n<p>构造器循环依赖</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-3ca9287803145b3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>支持用户扩展</p>\n<h3 id=\"SpringMVC流程\"><a href=\"#SpringMVC流程\" class=\"headerlink\" title=\"SpringMVC流程\"></a>SpringMVC流程</h3><p>1、 用户发送请求至前端控制器DispatcherServlet。</p>\n<p>2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>\n<p>3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>\n<p>4、 DispatcherServlet调用HandlerAdapter处理器适配器。</p>\n<p>5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p>\n<p>6、 Controller执行完成返回ModelAndView。</p>\n<p>7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p>\n<p>8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p>\n<p>9、 ViewReslover解析后返回具体View。</p>\n<p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p>\n<p>11、 DispatcherServlet响应用户。</p>\n<p><strong>组件：</strong>  <strong>1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供</strong>  作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。  用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>\n<p><strong>2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong>  作用：根据请求的url查找Handler  HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>\n<p><strong>3、处理器适配器HandlerAdapter</strong>  作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler  通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>\n<p><strong>4、处理器Handler(需要工程师开发)</strong>  <strong>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</strong>  Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。  由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p>\n<p><strong>5、视图解析器View resolver(不需要工程师开发),由框架提供</strong>  作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）  View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。  一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p>\n<p><strong>6、视图View(需要工程师开发jsp…)</strong>  View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p>\n<p><strong>核心架构的具体流程步骤如下：</strong>  1、首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；  2、DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；  3、DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；  4、HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；  5、ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；  6、View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；  7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p>\n<p>下边两个组件通常情况下需要开发：</p>\n<p>Handler：处理器，即后端控制器用controller表示。</p>\n<p>View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。</p>\n<p>WebApplicationContext</p>\n<p>ServletContext</p>\n<p>ApplicationContext</p>\n<p>问：</p>\n<p>我们可以通过</p>\n<p>ApplicationContext ap = new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>\n<p>得到一个spring容器，那么在传统ssm项目中是如何。。知道了</p>\n<h2 id=\"spring-bean的生命周期\"><a href=\"#spring-bean的生命周期\" class=\"headerlink\" title=\"spring bean的生命周期\"></a>spring bean的生命周期</h2><p>实例化bean对象(通过构造方法或者工厂方法)</p>\n<p>设置对象属性(setter等)（依赖注入）</p>\n<p>如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）</p>\n<p>如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身</p>\n<p>将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法</p>\n<p>调用Bean的初始化方法</p>\n<p>将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法</p>\n<p>使用Bean</p>\n<p>容器关闭之前，调用Bean的销毁方法</p>\n","site":{"data":{}},"excerpt":"<p>分为20个模块</p>\n<p>core container</p>","more":"<p>core beans context expression language</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-f726082d79be3e72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-16a1a229cda57201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>spring</p>\n<ol>\n<li>读取bean的配置信息</li>\n<li>根据配置信息实例化一个bean</li>\n<li>调用实例化后的实例</li>\n</ol>\n<p>beanFactory</p>\n<p>bean被当做一种资源，各个factory完成对bean的增删改查，注入读取，初始化等功能</p>\n<p>inputStreamSource 封装inputstream</p>\n<p>factoryBean :</p>\n<p>spring的标准实例化bean的流程是在xml中提供配置信息然后读取配置信息。factoryBean通过实现接口的方式实例化bean（java代码配置bean信息）</p>\n<p>demo</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-ca7b32793a6d88cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>单例在spring同一个容器中只会被创建一次，后续直接从单例缓存中获取</p>\n<p>循环依赖</p>\n<p>objectFactory</p>\n<p>singletonFactory</p>\n<ol>\n<li>检查缓存是否已经加载过</li>\n<li>若没加载就记录下来</li>\n</ol>\n<p>创建bean</p>\n<ol>\n<li>classname</li>\n<li>检查override</li>\n<li>检查bean是否已经存在</li>\n<li>创建bean</li>\n</ol>\n<p>实例化前置处理器</p>\n<p>实例化后置处理器</p>\n<p>循环依赖</p>\n<p>检查是否循环依赖</p>\n<p>循环依赖会导致内存溢出</p>\n<p>构造器循环依赖</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-3ca9287803145b3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>支持用户扩展</p>\n<h3 id=\"SpringMVC流程\"><a href=\"#SpringMVC流程\" class=\"headerlink\" title=\"SpringMVC流程\"></a>SpringMVC流程</h3><p>1、 用户发送请求至前端控制器DispatcherServlet。</p>\n<p>2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>\n<p>3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>\n<p>4、 DispatcherServlet调用HandlerAdapter处理器适配器。</p>\n<p>5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p>\n<p>6、 Controller执行完成返回ModelAndView。</p>\n<p>7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p>\n<p>8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p>\n<p>9、 ViewReslover解析后返回具体View。</p>\n<p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p>\n<p>11、 DispatcherServlet响应用户。</p>\n<p><strong>组件：</strong>  <strong>1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供</strong>  作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。  用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p>\n<p><strong>2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong>  作用：根据请求的url查找Handler  HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>\n<p><strong>3、处理器适配器HandlerAdapter</strong>  作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler  通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>\n<p><strong>4、处理器Handler(需要工程师开发)</strong>  <strong>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</strong>  Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。  由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p>\n<p><strong>5、视图解析器View resolver(不需要工程师开发),由框架提供</strong>  作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）  View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。  一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p>\n<p><strong>6、视图View(需要工程师开发jsp…)</strong>  View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p>\n<p><strong>核心架构的具体流程步骤如下：</strong>  1、首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；  2、DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；  3、DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；  4、HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；  5、ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；  6、View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；  7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p>\n<p>下边两个组件通常情况下需要开发：</p>\n<p>Handler：处理器，即后端控制器用controller表示。</p>\n<p>View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。</p>\n<p>WebApplicationContext</p>\n<p>ServletContext</p>\n<p>ApplicationContext</p>\n<p>问：</p>\n<p>我们可以通过</p>\n<p>ApplicationContext ap = new ClassPathXmlApplicationContext(“applicationContext.xml”);</p>\n<p>得到一个spring容器，那么在传统ssm项目中是如何。。知道了</p>\n<h2 id=\"spring-bean的生命周期\"><a href=\"#spring-bean的生命周期\" class=\"headerlink\" title=\"spring bean的生命周期\"></a>spring bean的生命周期</h2><p>实例化bean对象(通过构造方法或者工厂方法)</p>\n<p>设置对象属性(setter等)（依赖注入）</p>\n<p>如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）</p>\n<p>如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身</p>\n<p>将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法</p>\n<p>调用Bean的初始化方法</p>\n<p>将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法</p>\n<p>使用Bean</p>\n<p>容器关闭之前，调用Bean的销毁方法</p>"},{"title":"写一个spring-boot-starter","date":"2019-05-15T08:27:12.000Z","_content":"\n废话不多说直接开始\n\n1）新建maven项目，pom结构如下：\n\n<!--more-->\n\n```java\n<groupId>com.muggle</groupId>\n    <artifactId>test-spring-boot-starter</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <packaging>jar</packaging>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-autoconfigure</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n        </dependency>\n\n  \n       \n    </dependencies>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <!-- Import dependency management from Spring Boot -->\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-dependencies</artifactId>\n                <version>2.0.6.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n\n主要的依赖就是`spring-boot-configuration-processor`和`spring-boot-autoconfigure`一个是支持代码提示的依赖包，一个是自动化配置的依赖包。新建controller\n\n```java\n@RestController\npublic class TestController {\n\n    @GetMapping(\"/test\")\n    public String test(){\n        return \"nihao\";\n    }\n}\n```\n\n创建属性类，prefix = “helloworld”代表该项目在属性文件中配置的前缀，即可以在属性文件中通过 helloworld.words=springboot，就可以改变属性类字段 words 的值了。\n\n```java\n@ConfigurationProperties(prefix = \"helloworld\")\npublic class HelloworldProperties {\n  public static final String DEFAULT_WORDS = \"world\";\n\n  private String words = DEFAULT_WORDS;\n\n  public String getWords() {\n    return words;\n  }\n\n  public void setWords(String words) {\n    this.words = words;\n  }\n}\n```\n\n添加自动化配置类\n\n```java\n@Configuration\n@ConditionalOnClass(TestController.class)\n@EnableConfigurationProperties(HelloworldProperties.class)\npublic class AutoConfig {\n\n    @Bean\n    @ConditionalOnMissingBean(TestController.class)//当容器中没有指定Bean的情况下\n    public TestController bookService(){\n        TestController bookService = new TestController();\n        return bookService;\n    }\n}\n```\n\n在resource下新建`META-INF/spring.factories`内容为：\n\n```java\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=com.muggle.controller.AutoConfig\n```\n\n这个starter就算是做好了，很简单。","source":"_posts/spring-boot-starter.md","raw":"---\ntitle: 写一个spring-boot-starter\ndate: 2019-05-15 16:27:12\ntags: developing\n---\n\n废话不多说直接开始\n\n1）新建maven项目，pom结构如下：\n\n<!--more-->\n\n```java\n<groupId>com.muggle</groupId>\n    <artifactId>test-spring-boot-starter</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <packaging>jar</packaging>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-configuration-processor</artifactId>\n            <optional>true</optional>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-autoconfigure</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n        </dependency>\n\n  \n       \n    </dependencies>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <!-- Import dependency management from Spring Boot -->\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-dependencies</artifactId>\n                <version>2.0.6.RELEASE</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n\n主要的依赖就是`spring-boot-configuration-processor`和`spring-boot-autoconfigure`一个是支持代码提示的依赖包，一个是自动化配置的依赖包。新建controller\n\n```java\n@RestController\npublic class TestController {\n\n    @GetMapping(\"/test\")\n    public String test(){\n        return \"nihao\";\n    }\n}\n```\n\n创建属性类，prefix = “helloworld”代表该项目在属性文件中配置的前缀，即可以在属性文件中通过 helloworld.words=springboot，就可以改变属性类字段 words 的值了。\n\n```java\n@ConfigurationProperties(prefix = \"helloworld\")\npublic class HelloworldProperties {\n  public static final String DEFAULT_WORDS = \"world\";\n\n  private String words = DEFAULT_WORDS;\n\n  public String getWords() {\n    return words;\n  }\n\n  public void setWords(String words) {\n    this.words = words;\n  }\n}\n```\n\n添加自动化配置类\n\n```java\n@Configuration\n@ConditionalOnClass(TestController.class)\n@EnableConfigurationProperties(HelloworldProperties.class)\npublic class AutoConfig {\n\n    @Bean\n    @ConditionalOnMissingBean(TestController.class)//当容器中没有指定Bean的情况下\n    public TestController bookService(){\n        TestController bookService = new TestController();\n        return bookService;\n    }\n}\n```\n\n在resource下新建`META-INF/spring.factories`内容为：\n\n```java\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=com.muggle.controller.AutoConfig\n```\n\n这个starter就算是做好了，很简单。","slug":"spring-boot-starter","published":1,"updated":"2021-01-11T07:31:23.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6v003k00wi9i1w5uc6","content":"<p>废话不多说直接开始</p>\n<p>1）新建maven项目，pom结构如下：</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;groupId&gt;com.muggle&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;test-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;!-- https:<span class=\"comment\">//mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">       </span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;dependencyManagement&gt;</span><br><span class=\"line\">        &lt;dependencies&gt;</span><br><span class=\"line\">            &lt;dependency&gt;</span><br><span class=\"line\">                &lt;!-- Import dependency management from Spring Boot --&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;</span><br><span class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">            &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;/dependencies&gt;</span><br><span class=\"line\">    &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>\n<p>主要的依赖就是<code>spring-boot-configuration-processor</code>和<code>spring-boot-autoconfigure</code>一个是支持代码提示的依赖包，一个是自动化配置的依赖包。新建controller</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;nihao&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建属性类，prefix = “helloworld”代表该项目在属性文件中配置的前缀，即可以在属性文件中通过 helloworld.words=springboot，就可以改变属性类字段 words 的值了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(prefix = &quot;helloworld&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloworldProperties</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_WORDS = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String words = DEFAULT_WORDS;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWords</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> words;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWords</span><span class=\"params\">(String words)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.words = words;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>添加自动化配置类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(TestController.class)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(HelloworldProperties.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean(TestController.class)</span><span class=\"comment\">//当容器中没有指定Bean的情况下</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TestController <span class=\"title\">bookService</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        TestController bookService = <span class=\"keyword\">new</span> TestController();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bookService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在resource下新建<code>META-INF/spring.factories</code>内容为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.muggle.controller.AutoConfig</span><br></pre></td></tr></table></figure>\n<p>这个starter就算是做好了，很简单。</p>\n","site":{"data":{}},"excerpt":"<p>废话不多说直接开始</p>\n<p>1）新建maven项目，pom结构如下：</p>","more":"<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;groupId&gt;com.muggle&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;test-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;!-- https:<span class=\"comment\">//mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">       </span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;dependencyManagement&gt;</span><br><span class=\"line\">        &lt;dependencies&gt;</span><br><span class=\"line\">            &lt;dependency&gt;</span><br><span class=\"line\">                &lt;!-- Import dependency management from Spring Boot --&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;</span><br><span class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">            &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;/dependencies&gt;</span><br><span class=\"line\">    &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>\n<p>主要的依赖就是<code>spring-boot-configuration-processor</code>和<code>spring-boot-autoconfigure</code>一个是支持代码提示的依赖包，一个是自动化配置的依赖包。新建controller</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;nihao&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建属性类，prefix = “helloworld”代表该项目在属性文件中配置的前缀，即可以在属性文件中通过 helloworld.words=springboot，就可以改变属性类字段 words 的值了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(prefix = &quot;helloworld&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloworldProperties</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_WORDS = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String words = DEFAULT_WORDS;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWords</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> words;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWords</span><span class=\"params\">(String words)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.words = words;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>添加自动化配置类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(TestController.class)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(HelloworldProperties.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean(TestController.class)</span><span class=\"comment\">//当容器中没有指定Bean的情况下</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TestController <span class=\"title\">bookService</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        TestController bookService = <span class=\"keyword\">new</span> TestController();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bookService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在resource下新建<code>META-INF/spring.factories</code>内容为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.muggle.controller.AutoConfig</span><br></pre></td></tr></table></figure>\n<p>这个starter就算是做好了，很简单。</p>"},{"title":"springcloud核心组件介绍","date":"2019-04-26T03:30:45.000Z","_content":"\n作者：muggle\n\n注：参考大佬博客[牧码小子](https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247483878&idx=1&sn=d49f2eb61bada3d34443a0a4017a7b72&scene=21#wechat_redirect) \n\n### springcloud的核心功能：\n\n> 负载均衡，服务注册与发现，监控，分布式配置管理，api网关 分布式追踪\n\n<!--more-->\n\n###  SpringCloudGateway：\n\n> Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。\n\n### SpringCloudNetflix\n\n> 包含组件有Netflix Eureka，Netflix Hystrix，Netflix Zuul等\n\n### SpringCloudConfig\n\n> 配置中心，配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。\n\n### SpringCloudBus\n\n> Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控\n\n### SpringCloudforCloudFoundry\n\n> Spring Cloud for Cloudfoundry可以轻松在Cloud Foundry（平台即服务）中运行Spring Cloud应用程序。 Cloud Foundry有一个“服务”的概念，它是“绑定”到应用程序的中间件，本质上为其提供包含凭据的环境变量（例如，用于服务的位置和用户名）。——不太明白这玩意\n\n### SpringCloudCluster\n\n> Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现。\n\n### SpringCloudConsul\n\n> Consul是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.\n> Spring Cloud Consul封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。\n\n### Spring Cloud Security\n\n> 安全框架\n\n### Spring Cloud Sleuth\n\n> 日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。\n\n还有其他组件，不再罗列","source":"_posts/springcloud-1.md","raw":"---\ntitle: springcloud核心组件介绍\ndate: 2019-04-26 11:30:45\ntags: cloud\n---\n\n作者：muggle\n\n注：参考大佬博客[牧码小子](https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247483878&idx=1&sn=d49f2eb61bada3d34443a0a4017a7b72&scene=21#wechat_redirect) \n\n### springcloud的核心功能：\n\n> 负载均衡，服务注册与发现，监控，分布式配置管理，api网关 分布式追踪\n\n<!--more-->\n\n###  SpringCloudGateway：\n\n> Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。\n\n### SpringCloudNetflix\n\n> 包含组件有Netflix Eureka，Netflix Hystrix，Netflix Zuul等\n\n### SpringCloudConfig\n\n> 配置中心，配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。\n\n### SpringCloudBus\n\n> Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控\n\n### SpringCloudforCloudFoundry\n\n> Spring Cloud for Cloudfoundry可以轻松在Cloud Foundry（平台即服务）中运行Spring Cloud应用程序。 Cloud Foundry有一个“服务”的概念，它是“绑定”到应用程序的中间件，本质上为其提供包含凭据的环境变量（例如，用于服务的位置和用户名）。——不太明白这玩意\n\n### SpringCloudCluster\n\n> Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现。\n\n### SpringCloudConsul\n\n> Consul是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.\n> Spring Cloud Consul封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。\n\n### Spring Cloud Security\n\n> 安全框架\n\n### Spring Cloud Sleuth\n\n> 日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。\n\n还有其他组件，不再罗列","slug":"springcloud-1","published":1,"updated":"2021-01-11T07:31:23.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6v003n00wibgg803ao","content":"<p>作者：muggle</p>\n<p>注：参考大佬博客<a href=\"https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247483878&idx=1&sn=d49f2eb61bada3d34443a0a4017a7b72&scene=21#wechat_redirect\">牧码小子</a> </p>\n<h3 id=\"springcloud的核心功能：\"><a href=\"#springcloud的核心功能：\" class=\"headerlink\" title=\"springcloud的核心功能：\"></a>springcloud的核心功能：</h3><blockquote>\n<p>负载均衡，服务注册与发现，监控，分布式配置管理，api网关 分布式追踪</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"SpringCloudGateway：\"><a href=\"#SpringCloudGateway：\" class=\"headerlink\" title=\"SpringCloudGateway：\"></a>SpringCloudGateway：</h3><blockquote>\n<p>Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。</p>\n</blockquote>\n<h3 id=\"SpringCloudNetflix\"><a href=\"#SpringCloudNetflix\" class=\"headerlink\" title=\"SpringCloudNetflix\"></a>SpringCloudNetflix</h3><blockquote>\n<p>包含组件有Netflix Eureka，Netflix Hystrix，Netflix Zuul等</p>\n</blockquote>\n<h3 id=\"SpringCloudConfig\"><a href=\"#SpringCloudConfig\" class=\"headerlink\" title=\"SpringCloudConfig\"></a>SpringCloudConfig</h3><blockquote>\n<p>配置中心，配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。</p>\n</blockquote>\n<h3 id=\"SpringCloudBus\"><a href=\"#SpringCloudBus\" class=\"headerlink\" title=\"SpringCloudBus\"></a>SpringCloudBus</h3><blockquote>\n<p>Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控</p>\n</blockquote>\n<h3 id=\"SpringCloudforCloudFoundry\"><a href=\"#SpringCloudforCloudFoundry\" class=\"headerlink\" title=\"SpringCloudforCloudFoundry\"></a>SpringCloudforCloudFoundry</h3><blockquote>\n<p>Spring Cloud for Cloudfoundry可以轻松在Cloud Foundry（平台即服务）中运行Spring Cloud应用程序。 Cloud Foundry有一个“服务”的概念，它是“绑定”到应用程序的中间件，本质上为其提供包含凭据的环境变量（例如，用于服务的位置和用户名）。——不太明白这玩意</p>\n</blockquote>\n<h3 id=\"SpringCloudCluster\"><a href=\"#SpringCloudCluster\" class=\"headerlink\" title=\"SpringCloudCluster\"></a>SpringCloudCluster</h3><blockquote>\n<p>Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现。</p>\n</blockquote>\n<h3 id=\"SpringCloudConsul\"><a href=\"#SpringCloudConsul\" class=\"headerlink\" title=\"SpringCloudConsul\"></a>SpringCloudConsul</h3><blockquote>\n<p>Consul是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.<br>Spring Cloud Consul封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</p>\n</blockquote>\n<h3 id=\"Spring-Cloud-Security\"><a href=\"#Spring-Cloud-Security\" class=\"headerlink\" title=\"Spring Cloud Security\"></a>Spring Cloud Security</h3><blockquote>\n<p>安全框架</p>\n</blockquote>\n<h3 id=\"Spring-Cloud-Sleuth\"><a href=\"#Spring-Cloud-Sleuth\" class=\"headerlink\" title=\"Spring Cloud Sleuth\"></a>Spring Cloud Sleuth</h3><blockquote>\n<p>日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。</p>\n</blockquote>\n<p>还有其他组件，不再罗列</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<p>注：参考大佬博客<a href=\"https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247483878&idx=1&sn=d49f2eb61bada3d34443a0a4017a7b72&scene=21#wechat_redirect\">牧码小子</a> </p>\n<h3 id=\"springcloud的核心功能：\"><a href=\"#springcloud的核心功能：\" class=\"headerlink\" title=\"springcloud的核心功能：\"></a>springcloud的核心功能：</h3><blockquote>\n<p>负载均衡，服务注册与发现，监控，分布式配置管理，api网关 分布式追踪</p>\n</blockquote>","more":"<h3 id=\"SpringCloudGateway：\"><a href=\"#SpringCloudGateway：\" class=\"headerlink\" title=\"SpringCloudGateway：\"></a>SpringCloudGateway：</h3><blockquote>\n<p>Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring Cloud Gateway作为Spring Cloud生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。</p>\n</blockquote>\n<h3 id=\"SpringCloudNetflix\"><a href=\"#SpringCloudNetflix\" class=\"headerlink\" title=\"SpringCloudNetflix\"></a>SpringCloudNetflix</h3><blockquote>\n<p>包含组件有Netflix Eureka，Netflix Hystrix，Netflix Zuul等</p>\n</blockquote>\n<h3 id=\"SpringCloudConfig\"><a href=\"#SpringCloudConfig\" class=\"headerlink\" title=\"SpringCloudConfig\"></a>SpringCloudConfig</h3><blockquote>\n<p>配置中心，配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。</p>\n</blockquote>\n<h3 id=\"SpringCloudBus\"><a href=\"#SpringCloudBus\" class=\"headerlink\" title=\"SpringCloudBus\"></a>SpringCloudBus</h3><blockquote>\n<p>Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控</p>\n</blockquote>\n<h3 id=\"SpringCloudforCloudFoundry\"><a href=\"#SpringCloudforCloudFoundry\" class=\"headerlink\" title=\"SpringCloudforCloudFoundry\"></a>SpringCloudforCloudFoundry</h3><blockquote>\n<p>Spring Cloud for Cloudfoundry可以轻松在Cloud Foundry（平台即服务）中运行Spring Cloud应用程序。 Cloud Foundry有一个“服务”的概念，它是“绑定”到应用程序的中间件，本质上为其提供包含凭据的环境变量（例如，用于服务的位置和用户名）。——不太明白这玩意</p>\n</blockquote>\n<h3 id=\"SpringCloudCluster\"><a href=\"#SpringCloudCluster\" class=\"headerlink\" title=\"SpringCloudCluster\"></a>SpringCloudCluster</h3><blockquote>\n<p>Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现。</p>\n</blockquote>\n<h3 id=\"SpringCloudConsul\"><a href=\"#SpringCloudConsul\" class=\"headerlink\" title=\"SpringCloudConsul\"></a>SpringCloudConsul</h3><blockquote>\n<p>Consul是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.<br>Spring Cloud Consul封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</p>\n</blockquote>\n<h3 id=\"Spring-Cloud-Security\"><a href=\"#Spring-Cloud-Security\" class=\"headerlink\" title=\"Spring Cloud Security\"></a>Spring Cloud Security</h3><blockquote>\n<p>安全框架</p>\n</blockquote>\n<h3 id=\"Spring-Cloud-Sleuth\"><a href=\"#Spring-Cloud-Sleuth\" class=\"headerlink\" title=\"Spring Cloud Sleuth\"></a>Spring Cloud Sleuth</h3><blockquote>\n<p>日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。</p>\n</blockquote>\n<p>还有其他组件，不再罗列</p>"},{"title":"springcloud-Eureka","date":"2019-04-26T03:34:15.000Z","_content":"\n作者：muggle\n\n### 服务治理\n\n 服务治理是微服务架构中最为核心和基础的模块。它主要用来实现各个微服务实例的自动化注册与发现。随着服务的越来越多，越来越杂，服务之间的调用会越来越复杂，越来越难以管理。而当某个服务发生了变化，或者由于压力性能问题，多部署了几台服务，怎么让服务的消费者知晓变化，就显得很重要了。不然就会存在调用的服务其实已经下线了，但调用者不知道等异常情况。这个时候有个服务组件去统一治理就相当重要了。Eureka便是服务治理的组件。\n\n<!--more-->\n\n### Eureka介绍\n\n Eureka包含Server和Client两部分。Server也称为注册中心，用于提供服务的注册与发现（服务注册是指微服务在启动时，将自己的信息注册到服务治理组件上的过程，服务发现是指查询可用微服务列表及其网络地址的机制。）。支持高可用配置，依托与强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。\n\n Client主要处理服务的注册与发现；客户端服务通过注解和参数配置方式，嵌入在客户端的应用程序代码中，在应用程序启动时，向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。\n\n### 创建Eureka服务端\n\n1.创建一个springboot工程，导入依赖：\n\n```java\n<dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n\n```\n\n2.配置\n\n```java\nspring.application.name=eureka-service\n# 修改端口\nserver.port=8180\n\n# 实例的主机名称\neureka.instance.hostname=localhost\n\n## 不要向注册中心注册自己\neureka.client.register-with-eureka=false\n## 表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它也不需要去检索其他服务\neureka.client.fetch-registry=false\n\n# 指定服务注册中心地址 这里直接指向了本服务 localhost:8180/eureka/\n# map对象，使用IDE的提示功能是不会出现 注意大小写\neureka.client.service-url.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/\n\n```\n\n3.启动类上添加注解@EnableEurekaServer\n\n```java\nEnableEurekaServer\n@SpringBootApplication\npublic class SpringcloudApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringcloudApplication.class, args);\n    }\n}\n```\n\n启动项目后访问 http://localhost:8180/ 就能看到注册中心界面了\n\n### 创建Eureka客户端\n\nEureka客户端，其实就是服务的提供方，对外提供服务的应用。\n\n1.创建一个springboot项目，导入依赖\n\n```java\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n    // 写一个接口方便测试\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n\n```\n\n2.配置\n\n```java\nspring.application.name=eureka-client\nserver.port=8080\n\n# 注册中心地址\neureka.client.service-url.defaultZone=http://localhost:8180/eureka\n# 启用ip配置 这样在注册中心列表中看见的是以ip+端口呈现的\neureka.instance.prefer-ip-address=true\n# 实例名称  最后呈现地址：ip:8080\neureka.instance.instance-id=${spring.cloud.client.ip-address}:${server.port}\n\n```\n\n3.启动类加入注解@EnableEurekaClient (也可使用 @EnableDiscoveryClient)\n\n```java\n@EnableEurekaClient\n@SpringBootApplication\npublic class MsetApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MsetApplication.class, args);\n    }\n}\n```\n\n4.写个接口\n\n```java\nRestController\npublic class TestController {\n    @GetMapping(\"/\")\n    public String index(){\n        return \"sss\";\n    }\n}\n```\n\n启动应用，再次访问：http://localhost:8180/ ，可以看见服务已经注册成功。\n\n### Eureka自我保护模式\n\n默认情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例（默认90秒）。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，这就可能变得非常危险了，因为微服务本身是健康的，此时本不应该注销这个微服务。\n\nEureka Server通过“自我保护模式”来解决这个问题，当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。\n\n可以通过配置：\n\n```java\neureka.server.enable-self-preservation=false\n```\n\n关闭自我保护模式。\n\n[springcloud官方文档](http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html#_appendix_compendium_of_configuration_properties)","source":"_posts/springcloud-2.md","raw":"---\ntitle: springcloud-Eureka\ndate: 2019-04-26 11:34:15\ntags: cloud\n---\n\n作者：muggle\n\n### 服务治理\n\n 服务治理是微服务架构中最为核心和基础的模块。它主要用来实现各个微服务实例的自动化注册与发现。随着服务的越来越多，越来越杂，服务之间的调用会越来越复杂，越来越难以管理。而当某个服务发生了变化，或者由于压力性能问题，多部署了几台服务，怎么让服务的消费者知晓变化，就显得很重要了。不然就会存在调用的服务其实已经下线了，但调用者不知道等异常情况。这个时候有个服务组件去统一治理就相当重要了。Eureka便是服务治理的组件。\n\n<!--more-->\n\n### Eureka介绍\n\n Eureka包含Server和Client两部分。Server也称为注册中心，用于提供服务的注册与发现（服务注册是指微服务在启动时，将自己的信息注册到服务治理组件上的过程，服务发现是指查询可用微服务列表及其网络地址的机制。）。支持高可用配置，依托与强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。\n\n Client主要处理服务的注册与发现；客户端服务通过注解和参数配置方式，嵌入在客户端的应用程序代码中，在应用程序启动时，向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。\n\n### 创建Eureka服务端\n\n1.创建一个springboot工程，导入依赖：\n\n```java\n<dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n\n```\n\n2.配置\n\n```java\nspring.application.name=eureka-service\n# 修改端口\nserver.port=8180\n\n# 实例的主机名称\neureka.instance.hostname=localhost\n\n## 不要向注册中心注册自己\neureka.client.register-with-eureka=false\n## 表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它也不需要去检索其他服务\neureka.client.fetch-registry=false\n\n# 指定服务注册中心地址 这里直接指向了本服务 localhost:8180/eureka/\n# map对象，使用IDE的提示功能是不会出现 注意大小写\neureka.client.service-url.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/\n\n```\n\n3.启动类上添加注解@EnableEurekaServer\n\n```java\nEnableEurekaServer\n@SpringBootApplication\npublic class SpringcloudApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringcloudApplication.class, args);\n    }\n}\n```\n\n启动项目后访问 http://localhost:8180/ 就能看到注册中心界面了\n\n### 创建Eureka客户端\n\nEureka客户端，其实就是服务的提供方，对外提供服务的应用。\n\n1.创建一个springboot项目，导入依赖\n\n```java\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n    // 写一个接口方便测试\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n\n```\n\n2.配置\n\n```java\nspring.application.name=eureka-client\nserver.port=8080\n\n# 注册中心地址\neureka.client.service-url.defaultZone=http://localhost:8180/eureka\n# 启用ip配置 这样在注册中心列表中看见的是以ip+端口呈现的\neureka.instance.prefer-ip-address=true\n# 实例名称  最后呈现地址：ip:8080\neureka.instance.instance-id=${spring.cloud.client.ip-address}:${server.port}\n\n```\n\n3.启动类加入注解@EnableEurekaClient (也可使用 @EnableDiscoveryClient)\n\n```java\n@EnableEurekaClient\n@SpringBootApplication\npublic class MsetApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MsetApplication.class, args);\n    }\n}\n```\n\n4.写个接口\n\n```java\nRestController\npublic class TestController {\n    @GetMapping(\"/\")\n    public String index(){\n        return \"sss\";\n    }\n}\n```\n\n启动应用，再次访问：http://localhost:8180/ ，可以看见服务已经注册成功。\n\n### Eureka自我保护模式\n\n默认情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例（默认90秒）。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，这就可能变得非常危险了，因为微服务本身是健康的，此时本不应该注销这个微服务。\n\nEureka Server通过“自我保护模式”来解决这个问题，当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。\n\n可以通过配置：\n\n```java\neureka.server.enable-self-preservation=false\n```\n\n关闭自我保护模式。\n\n[springcloud官方文档](http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html#_appendix_compendium_of_configuration_properties)","slug":"springcloud-2","published":1,"updated":"2021-01-11T07:31:23.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6w003p00wihm6nffx1","content":"<p>作者：muggle</p>\n<h3 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h3><p> 服务治理是微服务架构中最为核心和基础的模块。它主要用来实现各个微服务实例的自动化注册与发现。随着服务的越来越多，越来越杂，服务之间的调用会越来越复杂，越来越难以管理。而当某个服务发生了变化，或者由于压力性能问题，多部署了几台服务，怎么让服务的消费者知晓变化，就显得很重要了。不然就会存在调用的服务其实已经下线了，但调用者不知道等异常情况。这个时候有个服务组件去统一治理就相当重要了。Eureka便是服务治理的组件。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Eureka介绍\"><a href=\"#Eureka介绍\" class=\"headerlink\" title=\"Eureka介绍\"></a>Eureka介绍</h3><p> Eureka包含Server和Client两部分。Server也称为注册中心，用于提供服务的注册与发现（服务注册是指微服务在启动时，将自己的信息注册到服务治理组件上的过程，服务发现是指查询可用微服务列表及其网络地址的机制。）。支持高可用配置，依托与强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。</p>\n<p> Client主要处理服务的注册与发现；客户端服务通过注解和参数配置方式，嵌入在客户端的应用程序代码中，在应用程序启动时，向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。</p>\n<h3 id=\"创建Eureka服务端\"><a href=\"#创建Eureka服务端\" class=\"headerlink\" title=\"创建Eureka服务端\"></a>创建Eureka服务端</h3><p>1.创建一个springboot工程，导入依赖：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2.配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-service</span><br><span class=\"line\"># 修改端口</span><br><span class=\"line\">server.port=<span class=\"number\">8180</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 实例的主机名称</span><br><span class=\"line\">eureka.instance.hostname=localhost</span><br><span class=\"line\"></span><br><span class=\"line\">## 不要向注册中心注册自己</span><br><span class=\"line\">eureka.client.register-with-eureka=<span class=\"keyword\">false</span></span><br><span class=\"line\">## 表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它也不需要去检索其他服务</span><br><span class=\"line\">eureka.client.fetch-registry=<span class=\"keyword\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 指定服务注册中心地址 这里直接指向了本服务 localhost:8180/eureka/</span><br><span class=\"line\"># map对象，使用IDE的提示功能是不会出现 注意大小写</span><br><span class=\"line\">eureka.client.service-url.defaultZone=http:<span class=\"comment\">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3.启动类上添加注解@EnableEurekaServer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EnableEurekaServer</span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringcloudApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(SpringcloudApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动项目后访问 <a href=\"http://localhost:8180/\">http://localhost:8180/</a> 就能看到注册中心界面了</p>\n<h3 id=\"创建Eureka客户端\"><a href=\"#创建Eureka客户端\" class=\"headerlink\" title=\"创建Eureka客户端\"></a>创建Eureka客户端</h3><p>Eureka客户端，其实就是服务的提供方，对外提供服务的应用。</p>\n<p>1.创建一个springboot项目，导入依赖</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"><span class=\"comment\">// 写一个接口方便测试</span></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2.配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-client</span><br><span class=\"line\">server.port=<span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 注册中心地址</span><br><span class=\"line\">eureka.client.service-url.defaultZone=http:<span class=\"comment\">//localhost:8180/eureka</span></span><br><span class=\"line\"># 启用ip配置 这样在注册中心列表中看见的是以ip+端口呈现的</span><br><span class=\"line\">eureka.instance.prefer-ip-address=<span class=\"keyword\">true</span></span><br><span class=\"line\"># 实例名称  最后呈现地址：ip:8080</span><br><span class=\"line\">eureka.instance.instance-id=$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3.启动类加入注解@EnableEurekaClient (也可使用 @EnableDiscoveryClient)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableEurekaClient</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MsetApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(MsetApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.写个接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RestController</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">index</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;sss&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动应用，再次访问：<a href=\"http://localhost:8180/\">http://localhost:8180/</a> ，可以看见服务已经注册成功。</p>\n<h3 id=\"Eureka自我保护模式\"><a href=\"#Eureka自我保护模式\" class=\"headerlink\" title=\"Eureka自我保护模式\"></a>Eureka自我保护模式</h3><p>默认情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例（默认90秒）。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，这就可能变得非常危险了，因为微服务本身是健康的，此时本不应该注销这个微服务。</p>\n<p>Eureka Server通过“自我保护模式”来解决这个问题，当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。</p>\n<p>可以通过配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eureka.server.enable-self-preservation=<span class=\"keyword\">false</span></span><br></pre></td></tr></table></figure>\n<p>关闭自我保护模式。</p>\n<p><a href=\"http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html#_appendix_compendium_of_configuration_properties\">springcloud官方文档</a></p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h3 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h3><p> 服务治理是微服务架构中最为核心和基础的模块。它主要用来实现各个微服务实例的自动化注册与发现。随着服务的越来越多，越来越杂，服务之间的调用会越来越复杂，越来越难以管理。而当某个服务发生了变化，或者由于压力性能问题，多部署了几台服务，怎么让服务的消费者知晓变化，就显得很重要了。不然就会存在调用的服务其实已经下线了，但调用者不知道等异常情况。这个时候有个服务组件去统一治理就相当重要了。Eureka便是服务治理的组件。</p>","more":"<h3 id=\"Eureka介绍\"><a href=\"#Eureka介绍\" class=\"headerlink\" title=\"Eureka介绍\"></a>Eureka介绍</h3><p> Eureka包含Server和Client两部分。Server也称为注册中心，用于提供服务的注册与发现（服务注册是指微服务在启动时，将自己的信息注册到服务治理组件上的过程，服务发现是指查询可用微服务列表及其网络地址的机制。）。支持高可用配置，依托与强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。</p>\n<p> Client主要处理服务的注册与发现；客户端服务通过注解和参数配置方式，嵌入在客户端的应用程序代码中，在应用程序启动时，向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。</p>\n<h3 id=\"创建Eureka服务端\"><a href=\"#创建Eureka服务端\" class=\"headerlink\" title=\"创建Eureka服务端\"></a>创建Eureka服务端</h3><p>1.创建一个springboot工程，导入依赖：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2.配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-service</span><br><span class=\"line\"># 修改端口</span><br><span class=\"line\">server.port=<span class=\"number\">8180</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 实例的主机名称</span><br><span class=\"line\">eureka.instance.hostname=localhost</span><br><span class=\"line\"></span><br><span class=\"line\">## 不要向注册中心注册自己</span><br><span class=\"line\">eureka.client.register-with-eureka=<span class=\"keyword\">false</span></span><br><span class=\"line\">## 表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它也不需要去检索其他服务</span><br><span class=\"line\">eureka.client.fetch-registry=<span class=\"keyword\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 指定服务注册中心地址 这里直接指向了本服务 localhost:8180/eureka/</span><br><span class=\"line\"># map对象，使用IDE的提示功能是不会出现 注意大小写</span><br><span class=\"line\">eureka.client.service-url.defaultZone=http:<span class=\"comment\">//$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3.启动类上添加注解@EnableEurekaServer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EnableEurekaServer</span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringcloudApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(SpringcloudApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动项目后访问 <a href=\"http://localhost:8180/\">http://localhost:8180/</a> 就能看到注册中心界面了</p>\n<h3 id=\"创建Eureka客户端\"><a href=\"#创建Eureka客户端\" class=\"headerlink\" title=\"创建Eureka客户端\"></a>创建Eureka客户端</h3><p>Eureka客户端，其实就是服务的提供方，对外提供服务的应用。</p>\n<p>1.创建一个springboot项目，导入依赖</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"><span class=\"comment\">// 写一个接口方便测试</span></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2.配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-client</span><br><span class=\"line\">server.port=<span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 注册中心地址</span><br><span class=\"line\">eureka.client.service-url.defaultZone=http:<span class=\"comment\">//localhost:8180/eureka</span></span><br><span class=\"line\"># 启用ip配置 这样在注册中心列表中看见的是以ip+端口呈现的</span><br><span class=\"line\">eureka.instance.prefer-ip-address=<span class=\"keyword\">true</span></span><br><span class=\"line\"># 实例名称  最后呈现地址：ip:8080</span><br><span class=\"line\">eureka.instance.instance-id=$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3.启动类加入注解@EnableEurekaClient (也可使用 @EnableDiscoveryClient)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableEurekaClient</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MsetApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(MsetApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4.写个接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RestController</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">index</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;sss&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动应用，再次访问：<a href=\"http://localhost:8180/\">http://localhost:8180/</a> ，可以看见服务已经注册成功。</p>\n<h3 id=\"Eureka自我保护模式\"><a href=\"#Eureka自我保护模式\" class=\"headerlink\" title=\"Eureka自我保护模式\"></a>Eureka自我保护模式</h3><p>默认情况下，如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例（默认90秒）。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，这就可能变得非常危险了，因为微服务本身是健康的，此时本不应该注销这个微服务。</p>\n<p>Eureka Server通过“自我保护模式”来解决这个问题，当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。</p>\n<p>可以通过配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eureka.server.enable-self-preservation=<span class=\"keyword\">false</span></span><br></pre></td></tr></table></figure>\n<p>关闭自我保护模式。</p>\n<p><a href=\"http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html#_appendix_compendium_of_configuration_properties\">springcloud官方文档</a></p>"},{"title":"springCloud学习笔记——配置高可用Eureka","date":"2019-04-27T02:02:18.000Z","_content":"\n# CAP 定理\n\n> 原文链接 http://www.ruanyifeng.com/blog/2018/07/cap.html<br>\n>  分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。\n\n- Consistency 中文叫做\"一致性\"。意思是，写操作之后的读操作，必须返回该值。\n- Availability Availability 中文叫做\"可用性\"，意思是只要收到用户的请求，服务器就必须给出回应。\n- Partition tolerance 中文叫做\"分区容错\"。大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。\n\n 这三个指标不可能同时做到，一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。对于Eureka而言，其是满足AP的。\n\n<!--more-->\n\n# Eureka特性：\n> - 优先保证可用性\n\n- 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务\n- 在向某个Eureka注册时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)\n\n# Eureka的高可用:\n\nEureka Server可以运行多个实例来构建集群，解决单点问题，Eureka Server采用的是Peer to Peer对等通信。这是一种去中心化的架构，无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。\n\n如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。\n\nEureka Server的高可用，实际上就是将自己也作为服务向其他服务注册中心进行注册，这样就可以形成一组相互注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。\n\n通过点对点配置，Eureka注册中心通过相互注册来实现高可用配置。以下构建一个双节点的集群模式。\n\n1.创建一个application-tran.properties配置文件，同时修改application.properties文件。修改本地的hosts文件\n增加两个域名\n\n```java\n127.0.0.1 test1\n127.0.0.1 test2\n```\n\napplication-tran.properties:\n\n```java\nspring.application.name=eureka-service\n# 修改端口\nserver.port=8181\n\n# 实例名称 两个名称需要不一样 值为域名或者ip\neureka.instance.hostname=test2\n\n## 不要向注册中心注册自己\neureka.client.register-with-eureka=false\n## 表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它也不需要去检索其他服务\neureka.client.fetch-registry=false\n\n# 指定服务注册中心地址\neureka.client.service-url.defaultZone=http://test1:8180/eureka\n\n```\n\napplication.properties:\n\n```java\nspring.application.name=eureka-service\nserver.port=8180\n# 实例名称 两个名称需要不一样 值为域名或者ip\neureka.instance.hostname=test1\neureka.client.register-with-eureka=false\neureka.client.fetch-registry=false\neureka.client.service-url.defaultZone=http://test2:8181/eureka\n```\n\n使用spring.profiles.active特性来启动注册中心，spring.profiles.active相关知识这里不做介绍，第一个注册中心启动时会报错，等另外一个启动成功就正常了。\n而向注册中心注册服务只需改一个地方\n\n```java\neureka.client.service-url.defaultZone=http://test1:8180/eureka,http://test2:8181/eureka\n```\n\n也可只注册到某个节点上，其他的节点也会有此服务列表的，一般建议以集群方式进行配置，即多注册中心配置。避免单点故障，Eureka在搜索注册中心时，根据defaultZone列表，找到一个可用的，之后就不会继续去下一个注册中心地址拉取服务列表了，此时若其中一个注册中心挂了，这个时候客户端会继续去第二个注册中心拉取服务列表的。","source":"_posts/springcloud-3.md","raw":"---\ntitle: springCloud学习笔记——配置高可用Eureka\ndate: 2019-04-27 10:02:18\ntags: cloud\n---\n\n# CAP 定理\n\n> 原文链接 http://www.ruanyifeng.com/blog/2018/07/cap.html<br>\n>  分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。\n\n- Consistency 中文叫做\"一致性\"。意思是，写操作之后的读操作，必须返回该值。\n- Availability Availability 中文叫做\"可用性\"，意思是只要收到用户的请求，服务器就必须给出回应。\n- Partition tolerance 中文叫做\"分区容错\"。大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。\n\n 这三个指标不可能同时做到，一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。对于Eureka而言，其是满足AP的。\n\n<!--more-->\n\n# Eureka特性：\n> - 优先保证可用性\n\n- 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务\n- 在向某个Eureka注册时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)\n\n# Eureka的高可用:\n\nEureka Server可以运行多个实例来构建集群，解决单点问题，Eureka Server采用的是Peer to Peer对等通信。这是一种去中心化的架构，无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。\n\n如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。\n\nEureka Server的高可用，实际上就是将自己也作为服务向其他服务注册中心进行注册，这样就可以形成一组相互注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。\n\n通过点对点配置，Eureka注册中心通过相互注册来实现高可用配置。以下构建一个双节点的集群模式。\n\n1.创建一个application-tran.properties配置文件，同时修改application.properties文件。修改本地的hosts文件\n增加两个域名\n\n```java\n127.0.0.1 test1\n127.0.0.1 test2\n```\n\napplication-tran.properties:\n\n```java\nspring.application.name=eureka-service\n# 修改端口\nserver.port=8181\n\n# 实例名称 两个名称需要不一样 值为域名或者ip\neureka.instance.hostname=test2\n\n## 不要向注册中心注册自己\neureka.client.register-with-eureka=false\n## 表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它也不需要去检索其他服务\neureka.client.fetch-registry=false\n\n# 指定服务注册中心地址\neureka.client.service-url.defaultZone=http://test1:8180/eureka\n\n```\n\napplication.properties:\n\n```java\nspring.application.name=eureka-service\nserver.port=8180\n# 实例名称 两个名称需要不一样 值为域名或者ip\neureka.instance.hostname=test1\neureka.client.register-with-eureka=false\neureka.client.fetch-registry=false\neureka.client.service-url.defaultZone=http://test2:8181/eureka\n```\n\n使用spring.profiles.active特性来启动注册中心，spring.profiles.active相关知识这里不做介绍，第一个注册中心启动时会报错，等另外一个启动成功就正常了。\n而向注册中心注册服务只需改一个地方\n\n```java\neureka.client.service-url.defaultZone=http://test1:8180/eureka,http://test2:8181/eureka\n```\n\n也可只注册到某个节点上，其他的节点也会有此服务列表的，一般建议以集群方式进行配置，即多注册中心配置。避免单点故障，Eureka在搜索注册中心时，根据defaultZone列表，找到一个可用的，之后就不会继续去下一个注册中心地址拉取服务列表了，此时若其中一个注册中心挂了，这个时候客户端会继续去第二个注册中心拉取服务列表的。","slug":"springcloud-3","published":1,"updated":"2021-01-11T07:31:23.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6x003s00wi3hq1b2ai","content":"<h1 id=\"CAP-定理\"><a href=\"#CAP-定理\" class=\"headerlink\" title=\"CAP 定理\"></a>CAP 定理</h1><blockquote>\n<p>原文链接 <a href=\"http://www.ruanyifeng.com/blog/2018/07/cap.html\">http://www.ruanyifeng.com/blog/2018/07/cap.html</a><br><br> 分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。</p>\n</blockquote>\n<ul>\n<li><p>Consistency 中文叫做”一致性”。意思是，写操作之后的读操作，必须返回该值。</p>\n</li>\n<li><p>Availability Availability 中文叫做”可用性”，意思是只要收到用户的请求，服务器就必须给出回应。</p>\n</li>\n<li><p>Partition tolerance 中文叫做”分区容错”。大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。</p>\n<p>这三个指标不可能同时做到，一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。对于Eureka而言，其是满足AP的。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<h1 id=\"Eureka特性：\"><a href=\"#Eureka特性：\" class=\"headerlink\" title=\"Eureka特性：\"></a>Eureka特性：</h1><blockquote>\n<ul>\n<li>优先保证可用性</li>\n</ul>\n</blockquote>\n<ul>\n<li>各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务</li>\n<li>在向某个Eureka注册时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)</li>\n</ul>\n<h1 id=\"Eureka的高可用\"><a href=\"#Eureka的高可用\" class=\"headerlink\" title=\"Eureka的高可用:\"></a>Eureka的高可用:</h1><p>Eureka Server可以运行多个实例来构建集群，解决单点问题，Eureka Server采用的是Peer to Peer对等通信。这是一种去中心化的架构，无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。</p>\n<p>如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。</p>\n<p>Eureka Server的高可用，实际上就是将自己也作为服务向其他服务注册中心进行注册，这样就可以形成一组相互注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。</p>\n<p>通过点对点配置，Eureka注册中心通过相互注册来实现高可用配置。以下构建一个双节点的集群模式。</p>\n<p>1.创建一个application-tran.properties配置文件，同时修改application.properties文件。修改本地的hosts文件<br>增加两个域名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> test1</span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> test2</span><br></pre></td></tr></table></figure>\n<p>application-tran.properties:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-service</span><br><span class=\"line\"># 修改端口</span><br><span class=\"line\">server.port=<span class=\"number\">8181</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 实例名称 两个名称需要不一样 值为域名或者ip</span><br><span class=\"line\">eureka.instance.hostname=test2</span><br><span class=\"line\"></span><br><span class=\"line\">## 不要向注册中心注册自己</span><br><span class=\"line\">eureka.client.register-with-eureka=<span class=\"keyword\">false</span></span><br><span class=\"line\">## 表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它也不需要去检索其他服务</span><br><span class=\"line\">eureka.client.fetch-registry=<span class=\"keyword\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 指定服务注册中心地址</span><br><span class=\"line\">eureka.client.service-url.defaultZone=http:<span class=\"comment\">//test1:8180/eureka</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>application.properties:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-service</span><br><span class=\"line\">server.port=<span class=\"number\">8180</span></span><br><span class=\"line\"># 实例名称 两个名称需要不一样 值为域名或者ip</span><br><span class=\"line\">eureka.instance.hostname=test1</span><br><span class=\"line\">eureka.client.register-with-eureka=<span class=\"keyword\">false</span></span><br><span class=\"line\">eureka.client.fetch-registry=<span class=\"keyword\">false</span></span><br><span class=\"line\">eureka.client.service-url.defaultZone=http:<span class=\"comment\">//test2:8181/eureka</span></span><br></pre></td></tr></table></figure>\n<p>使用spring.profiles.active特性来启动注册中心，spring.profiles.active相关知识这里不做介绍，第一个注册中心启动时会报错，等另外一个启动成功就正常了。<br>而向注册中心注册服务只需改一个地方</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eureka.client.service-url.defaultZone=http:<span class=\"comment\">//test1:8180/eureka,http://test2:8181/eureka</span></span><br></pre></td></tr></table></figure>\n<p>也可只注册到某个节点上，其他的节点也会有此服务列表的，一般建议以集群方式进行配置，即多注册中心配置。避免单点故障，Eureka在搜索注册中心时，根据defaultZone列表，找到一个可用的，之后就不会继续去下一个注册中心地址拉取服务列表了，此时若其中一个注册中心挂了，这个时候客户端会继续去第二个注册中心拉取服务列表的。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"CAP-定理\"><a href=\"#CAP-定理\" class=\"headerlink\" title=\"CAP 定理\"></a>CAP 定理</h1><blockquote>\n<p>原文链接 <a href=\"http://www.ruanyifeng.com/blog/2018/07/cap.html\">http://www.ruanyifeng.com/blog/2018/07/cap.html</a><br><br> 分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。</p>\n</blockquote>\n<ul>\n<li><p>Consistency 中文叫做”一致性”。意思是，写操作之后的读操作，必须返回该值。</p>\n</li>\n<li><p>Availability Availability 中文叫做”可用性”，意思是只要收到用户的请求，服务器就必须给出回应。</p>\n</li>\n<li><p>Partition tolerance 中文叫做”分区容错”。大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。</p>\n<p>这三个指标不可能同时做到，一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。对于Eureka而言，其是满足AP的。</p>\n</li>\n</ul>","more":"<h1 id=\"Eureka特性：\"><a href=\"#Eureka特性：\" class=\"headerlink\" title=\"Eureka特性：\"></a>Eureka特性：</h1><blockquote>\n<ul>\n<li>优先保证可用性</li>\n</ul>\n</blockquote>\n<ul>\n<li>各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务</li>\n<li>在向某个Eureka注册时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)</li>\n</ul>\n<h1 id=\"Eureka的高可用\"><a href=\"#Eureka的高可用\" class=\"headerlink\" title=\"Eureka的高可用:\"></a>Eureka的高可用:</h1><p>Eureka Server可以运行多个实例来构建集群，解决单点问题，Eureka Server采用的是Peer to Peer对等通信。这是一种去中心化的架构，无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。</p>\n<p>如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。</p>\n<p>Eureka Server的高可用，实际上就是将自己也作为服务向其他服务注册中心进行注册，这样就可以形成一组相互注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。</p>\n<p>通过点对点配置，Eureka注册中心通过相互注册来实现高可用配置。以下构建一个双节点的集群模式。</p>\n<p>1.创建一个application-tran.properties配置文件，同时修改application.properties文件。修改本地的hosts文件<br>增加两个域名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> test1</span><br><span class=\"line\"><span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> test2</span><br></pre></td></tr></table></figure>\n<p>application-tran.properties:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-service</span><br><span class=\"line\"># 修改端口</span><br><span class=\"line\">server.port=<span class=\"number\">8181</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 实例名称 两个名称需要不一样 值为域名或者ip</span><br><span class=\"line\">eureka.instance.hostname=test2</span><br><span class=\"line\"></span><br><span class=\"line\">## 不要向注册中心注册自己</span><br><span class=\"line\">eureka.client.register-with-eureka=<span class=\"keyword\">false</span></span><br><span class=\"line\">## 表示不去检索其他的服务，因为服务注册中心本身的职责就是维护服务实例，它也不需要去检索其他服务</span><br><span class=\"line\">eureka.client.fetch-registry=<span class=\"keyword\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 指定服务注册中心地址</span><br><span class=\"line\">eureka.client.service-url.defaultZone=http:<span class=\"comment\">//test1:8180/eureka</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>application.properties:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.application.name=eureka-service</span><br><span class=\"line\">server.port=<span class=\"number\">8180</span></span><br><span class=\"line\"># 实例名称 两个名称需要不一样 值为域名或者ip</span><br><span class=\"line\">eureka.instance.hostname=test1</span><br><span class=\"line\">eureka.client.register-with-eureka=<span class=\"keyword\">false</span></span><br><span class=\"line\">eureka.client.fetch-registry=<span class=\"keyword\">false</span></span><br><span class=\"line\">eureka.client.service-url.defaultZone=http:<span class=\"comment\">//test2:8181/eureka</span></span><br></pre></td></tr></table></figure>\n<p>使用spring.profiles.active特性来启动注册中心，spring.profiles.active相关知识这里不做介绍，第一个注册中心启动时会报错，等另外一个启动成功就正常了。<br>而向注册中心注册服务只需改一个地方</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eureka.client.service-url.defaultZone=http:<span class=\"comment\">//test1:8180/eureka,http://test2:8181/eureka</span></span><br></pre></td></tr></table></figure>\n<p>也可只注册到某个节点上，其他的节点也会有此服务列表的，一般建议以集群方式进行配置，即多注册中心配置。避免单点故障，Eureka在搜索注册中心时，根据defaultZone列表，找到一个可用的，之后就不会继续去下一个注册中心地址拉取服务列表了，此时若其中一个注册中心挂了，这个时候客户端会继续去第二个注册中心拉取服务列表的。</p>"},{"title":"多线程编程基础第一篇","date":"2019-04-22T08:20:55.000Z","_content":"\n作者：muggle\n## java并发相关概念\n\n### 同步和异步\n同步和异步通常来形容一次方法的调用。同步方法一旦开始，调用者必须等到方法结束才能执行后续动作；异步方法则是在调用该方法后不必等到该方法执行完就能执行后面的代码，该方法会在另一个线程异步执行，异步方法总是伴随着回调，通过回调来获得异步方法的执行结果；\n\n### 并发和并行\n很多人都将并发与并行混淆在一起，它们虽然都可以表示两个或者多个任务一起执行，但执行过程上是有区别的。并发是多个任务交替执行，多任务之间还是串行的；而并行是多个任务同时执行，和并发有本质区别。\n对计算机而言，如果系统内只有一个cpu，而使用多进程或者多线程执行任务，那么这种情况下多线程或者多进程就是并行执行，并行只可能出现在多核系统中。当然，对java程序而言，我们不必去关心程序是并行还是并发。\n\n<!--more-->\n\n### 临界区\n\n临界区表示的是多个线程共享但同时只能有一个线程使用它的资源。在并行程序中临界区资源是受保护的，必须确保同一时刻只有一个线程能使用它。\n\n### 阻塞\n\n如果一个线程占有了临界区的资源，其他需要使用这个临界区资源的线程必须在这个临界区进行等待——线程被挂起，这种情况就是发生了阻塞——线程停滞不前。\n\n### 死锁\\饥饿\\活锁\n\n死锁就是多个线程需要其他线程的资源才能释放它所拥有的资源，而其他线程释放这个线程需要的资源必须先获得这个线程所拥有的资源，这样造成了矛盾无法解开；如图1情形就是发生死锁现象：\n\n![](http://a2.qpic.cn/psb?/V13ysUCU2bV4he/zBrKU1zKzRRphjYm8*58YnBjOH0x7EvRxnWkrr.0oeE!/b/dMEAAAAAAAAA&ek=1&kp=1&pt=0&bo=2QENAQAAAAARF*Q!&tl=3&vuin=1793769323&tm=1555678800&sce=60-2-2&rf=viewer_4)\n\n<center>图1：生活中的死锁现象</center>\n\n活锁就是两个线程互相谦让资源，结果就是谁也拿不到资源导致活锁；就好比过马路，行人给车让道，车又给行人让道，结果就是车和行人都停在那不走。\n\n饥饿就是，某个线程优先级特别低老是拿不到资源，导致这个线程一直无法执行\n\n### 并发级别\n\n并发级别分为阻塞，无饥饿，无障碍，无锁，无等待几个级别；根据名字我们也能大概猜出这几个级别对应的什么情形；阻塞，无饥饿和无锁都好理解；我们说一下无障碍和无等待；\n\n无障碍：无障碍级别默认各个线程不会发生冲突，不会互相抢占资源，一旦抢占资源就认为线程发生错误，进行回滚。\n\n无等待：无等待是在无锁上的进一步优化，限制每个线程完成任务的步数；\n\n### 并行的两个定理\n\n加速比：加速比=优化前系统耗时/优化后系统耗时\n\nAmdahl定理： 加速比=1/[F+(1-F)/n] 其中 n表示处理器个数 ，F是程序中只能串行执行的比例——串行率；由公式可知，想要以最小投入，得到最高加速比即 F+(1-F)/n取到最小值，F和n都对结果有很大影响，在深入研究就是数学问题了；\n\nGustafson定律： 加速比=n-F(n-1)，这两定律区别不大，都体现了单纯的减少串行率，或者单纯的加CPU都无法得到最优解。\n\n## Java中的并行基础\n\n### volatile关键字和程序的原子性，可见性，有序性\n\n原子性指的是一个操作是不可中断的，要么成功要么失败，不会被其他线程所干扰；比如 int=1,这一操作在cpu中分为好几个指令，但对程序而言这几个指令是一体的，只有可能执行成功或者失败，不可能发生只执行了一半的操作；对不同CPU而言保证原子性的的实现方式各有不同，就英特尔CPU而言是使用一个lock指令来保证的。\n\n可见性指某一线程改变某一共享变量，其他线程未必会马上知道。\n\n有序性指对一个操作而言指令是按一定顺序执行的，但编译器为了提高程序执行的速度，会重排程序指令；cpu在执行指令的时候采用的是流水线的形式，上一个指令和下一个指令差一个工步。比如A指令分三个工步：1. 操作内存a，2.操作内存b，3.操作内存c；现假设有个指令B操作流程和A一样，那么先执行指令A在执行指令B时间全利用上了，中间没有停顿等待；但如果有三个这样的指令在流水线上执行：a>b>c，b>e>c，c>e>a；这样的指令顺序就会发生等待降低了CPU的效率，编译器为了避免这种事情发生，会适当优化指令的顺序进行重排。\n\nvolatile关键字在java中的作用是保证变量的可见性和防止指令重排。\n\n### 线程的相关操作\n\n*创建线程有三种方法*\n\n- 继承Thread类创建线程\n- 实现Runnable接口创建线程\n- 使用Callable和Future创建线程\n\n*终止线程的方法*\n\n终止线程可调用stop()方法，但这个方法是被废弃不建议使用的，因为强制终止一个线程会引起数据的不一致问题。比如一个线程数据写到一半被终止了，释放了锁，其他线程拿到锁继续写数据，结果导致数据发生了错误。终止线程比较好的方法是“让程序自己终止”，比如定义一个标识符，当标识符为true的时候直让程序走到终点，这样就能达到“自己终止”的目的。\n\n*线程的中断等待和通知*\n\ninterrupt()方法可以中断当前程序，object.wait() 方法让线程进入等待队列，object.notify()随机唤醒等待队列的一个线程， object.notifyAll()唤醒等待队列的所有线程。object.wait()必须在synchronzied语句中调用；执行wait，notify方法必须获得对象的监视器，执行结束后释放监视器供其他线程获取。\n\n*join*\n\njoin()方法功能是等待其他线程“加入”，可以理解为将某个线程并为自己的子线程，等子线程走完或者等子线程走规定的时间，主线程才往下走；join的本质是调用调用线程对象的wait方法，当我们执行wait或者notify方法不应该获取线程对象的的监听器，因为可能会影响到其他线程的join。\n\n*yield*\n\nyield是线程的“谦让”机制，可以理解为当线程抢到cpu资源时，放弃这次资源重新抢占，yield()是Thread里的一个静态方法。\n\n### 线程组\n\n如果一个多线程系统线程数量众多而且分工明确，那么可以使用线程组来分类。\n\n```java\n\t\n    @Test\n    public void contextLoads() {\n        ThreadGroup testGroup=new ThreadGroup(\"testGroup\");\n        Thread a = new Thread(testGroup, new MyRunnable(), \"a\");\n        Thread b = new Thread(testGroup, new MyRunnable(), \"b\");\n        a.start();\n        b.start();\n        int i = testGroup.activeCount();\n    }\n\n    public static class MyRunnable implements Runnable{\n        @Override\n        public void run() {\n            System.out.println(\"test\");\n        }\n    }\n```\n\n图示代码创建了一个\"testGroup\"线程组。\n\n### 守护线程\n\n守护线程是一种特殊线程，它类似java中的异常系统，主要是概念上的分类，与之对应的是用户线程。它功能应该是在后台完成一些系统性的服务；设置一个线程为守护线程应该在线程start之前setDaemon()。\n\n### 线程优先级\n\njava中线程可以有自己的优先级，优先级高的更有优势抢占资源；线程优先级高的不一定能抢占到资源，只是一个概率问题，而对应优先级低的线程可能会发生饥饿；\n\n在java中使用1到10表示线程的优先级，使用setPriority()方法来进行设置，数字越大代表优先级越高；\n\n","source":"_posts/thread-1.md","raw":"---\ntitle: 多线程编程基础第一篇\ndate: 2019-04-22 16:20:55\ntags: thread\n---\n\n作者：muggle\n## java并发相关概念\n\n### 同步和异步\n同步和异步通常来形容一次方法的调用。同步方法一旦开始，调用者必须等到方法结束才能执行后续动作；异步方法则是在调用该方法后不必等到该方法执行完就能执行后面的代码，该方法会在另一个线程异步执行，异步方法总是伴随着回调，通过回调来获得异步方法的执行结果；\n\n### 并发和并行\n很多人都将并发与并行混淆在一起，它们虽然都可以表示两个或者多个任务一起执行，但执行过程上是有区别的。并发是多个任务交替执行，多任务之间还是串行的；而并行是多个任务同时执行，和并发有本质区别。\n对计算机而言，如果系统内只有一个cpu，而使用多进程或者多线程执行任务，那么这种情况下多线程或者多进程就是并行执行，并行只可能出现在多核系统中。当然，对java程序而言，我们不必去关心程序是并行还是并发。\n\n<!--more-->\n\n### 临界区\n\n临界区表示的是多个线程共享但同时只能有一个线程使用它的资源。在并行程序中临界区资源是受保护的，必须确保同一时刻只有一个线程能使用它。\n\n### 阻塞\n\n如果一个线程占有了临界区的资源，其他需要使用这个临界区资源的线程必须在这个临界区进行等待——线程被挂起，这种情况就是发生了阻塞——线程停滞不前。\n\n### 死锁\\饥饿\\活锁\n\n死锁就是多个线程需要其他线程的资源才能释放它所拥有的资源，而其他线程释放这个线程需要的资源必须先获得这个线程所拥有的资源，这样造成了矛盾无法解开；如图1情形就是发生死锁现象：\n\n![](http://a2.qpic.cn/psb?/V13ysUCU2bV4he/zBrKU1zKzRRphjYm8*58YnBjOH0x7EvRxnWkrr.0oeE!/b/dMEAAAAAAAAA&ek=1&kp=1&pt=0&bo=2QENAQAAAAARF*Q!&tl=3&vuin=1793769323&tm=1555678800&sce=60-2-2&rf=viewer_4)\n\n<center>图1：生活中的死锁现象</center>\n\n活锁就是两个线程互相谦让资源，结果就是谁也拿不到资源导致活锁；就好比过马路，行人给车让道，车又给行人让道，结果就是车和行人都停在那不走。\n\n饥饿就是，某个线程优先级特别低老是拿不到资源，导致这个线程一直无法执行\n\n### 并发级别\n\n并发级别分为阻塞，无饥饿，无障碍，无锁，无等待几个级别；根据名字我们也能大概猜出这几个级别对应的什么情形；阻塞，无饥饿和无锁都好理解；我们说一下无障碍和无等待；\n\n无障碍：无障碍级别默认各个线程不会发生冲突，不会互相抢占资源，一旦抢占资源就认为线程发生错误，进行回滚。\n\n无等待：无等待是在无锁上的进一步优化，限制每个线程完成任务的步数；\n\n### 并行的两个定理\n\n加速比：加速比=优化前系统耗时/优化后系统耗时\n\nAmdahl定理： 加速比=1/[F+(1-F)/n] 其中 n表示处理器个数 ，F是程序中只能串行执行的比例——串行率；由公式可知，想要以最小投入，得到最高加速比即 F+(1-F)/n取到最小值，F和n都对结果有很大影响，在深入研究就是数学问题了；\n\nGustafson定律： 加速比=n-F(n-1)，这两定律区别不大，都体现了单纯的减少串行率，或者单纯的加CPU都无法得到最优解。\n\n## Java中的并行基础\n\n### volatile关键字和程序的原子性，可见性，有序性\n\n原子性指的是一个操作是不可中断的，要么成功要么失败，不会被其他线程所干扰；比如 int=1,这一操作在cpu中分为好几个指令，但对程序而言这几个指令是一体的，只有可能执行成功或者失败，不可能发生只执行了一半的操作；对不同CPU而言保证原子性的的实现方式各有不同，就英特尔CPU而言是使用一个lock指令来保证的。\n\n可见性指某一线程改变某一共享变量，其他线程未必会马上知道。\n\n有序性指对一个操作而言指令是按一定顺序执行的，但编译器为了提高程序执行的速度，会重排程序指令；cpu在执行指令的时候采用的是流水线的形式，上一个指令和下一个指令差一个工步。比如A指令分三个工步：1. 操作内存a，2.操作内存b，3.操作内存c；现假设有个指令B操作流程和A一样，那么先执行指令A在执行指令B时间全利用上了，中间没有停顿等待；但如果有三个这样的指令在流水线上执行：a>b>c，b>e>c，c>e>a；这样的指令顺序就会发生等待降低了CPU的效率，编译器为了避免这种事情发生，会适当优化指令的顺序进行重排。\n\nvolatile关键字在java中的作用是保证变量的可见性和防止指令重排。\n\n### 线程的相关操作\n\n*创建线程有三种方法*\n\n- 继承Thread类创建线程\n- 实现Runnable接口创建线程\n- 使用Callable和Future创建线程\n\n*终止线程的方法*\n\n终止线程可调用stop()方法，但这个方法是被废弃不建议使用的，因为强制终止一个线程会引起数据的不一致问题。比如一个线程数据写到一半被终止了，释放了锁，其他线程拿到锁继续写数据，结果导致数据发生了错误。终止线程比较好的方法是“让程序自己终止”，比如定义一个标识符，当标识符为true的时候直让程序走到终点，这样就能达到“自己终止”的目的。\n\n*线程的中断等待和通知*\n\ninterrupt()方法可以中断当前程序，object.wait() 方法让线程进入等待队列，object.notify()随机唤醒等待队列的一个线程， object.notifyAll()唤醒等待队列的所有线程。object.wait()必须在synchronzied语句中调用；执行wait，notify方法必须获得对象的监视器，执行结束后释放监视器供其他线程获取。\n\n*join*\n\njoin()方法功能是等待其他线程“加入”，可以理解为将某个线程并为自己的子线程，等子线程走完或者等子线程走规定的时间，主线程才往下走；join的本质是调用调用线程对象的wait方法，当我们执行wait或者notify方法不应该获取线程对象的的监听器，因为可能会影响到其他线程的join。\n\n*yield*\n\nyield是线程的“谦让”机制，可以理解为当线程抢到cpu资源时，放弃这次资源重新抢占，yield()是Thread里的一个静态方法。\n\n### 线程组\n\n如果一个多线程系统线程数量众多而且分工明确，那么可以使用线程组来分类。\n\n```java\n\t\n    @Test\n    public void contextLoads() {\n        ThreadGroup testGroup=new ThreadGroup(\"testGroup\");\n        Thread a = new Thread(testGroup, new MyRunnable(), \"a\");\n        Thread b = new Thread(testGroup, new MyRunnable(), \"b\");\n        a.start();\n        b.start();\n        int i = testGroup.activeCount();\n    }\n\n    public static class MyRunnable implements Runnable{\n        @Override\n        public void run() {\n            System.out.println(\"test\");\n        }\n    }\n```\n\n图示代码创建了一个\"testGroup\"线程组。\n\n### 守护线程\n\n守护线程是一种特殊线程，它类似java中的异常系统，主要是概念上的分类，与之对应的是用户线程。它功能应该是在后台完成一些系统性的服务；设置一个线程为守护线程应该在线程start之前setDaemon()。\n\n### 线程优先级\n\njava中线程可以有自己的优先级，优先级高的更有优势抢占资源；线程优先级高的不一定能抢占到资源，只是一个概率问题，而对应优先级低的线程可能会发生饥饿；\n\n在java中使用1到10表示线程的优先级，使用setPriority()方法来进行设置，数字越大代表优先级越高；\n\n","slug":"thread-1","published":1,"updated":"2021-01-11T07:31:23.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6x003u00wi2vwcfih1","content":"<p>作者：muggle</p>\n<h2 id=\"java并发相关概念\"><a href=\"#java并发相关概念\" class=\"headerlink\" title=\"java并发相关概念\"></a>java并发相关概念</h2><h3 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h3><p>同步和异步通常来形容一次方法的调用。同步方法一旦开始，调用者必须等到方法结束才能执行后续动作；异步方法则是在调用该方法后不必等到该方法执行完就能执行后面的代码，该方法会在另一个线程异步执行，异步方法总是伴随着回调，通过回调来获得异步方法的执行结果；</p>\n<h3 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h3><p>很多人都将并发与并行混淆在一起，它们虽然都可以表示两个或者多个任务一起执行，但执行过程上是有区别的。并发是多个任务交替执行，多任务之间还是串行的；而并行是多个任务同时执行，和并发有本质区别。<br>对计算机而言，如果系统内只有一个cpu，而使用多进程或者多线程执行任务，那么这种情况下多线程或者多进程就是并行执行，并行只可能出现在多核系统中。当然，对java程序而言，我们不必去关心程序是并行还是并发。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h3><p>临界区表示的是多个线程共享但同时只能有一个线程使用它的资源。在并行程序中临界区资源是受保护的，必须确保同一时刻只有一个线程能使用它。</p>\n<h3 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h3><p>如果一个线程占有了临界区的资源，其他需要使用这个临界区资源的线程必须在这个临界区进行等待——线程被挂起，这种情况就是发生了阻塞——线程停滞不前。</p>\n<h3 id=\"死锁-饥饿-活锁\"><a href=\"#死锁-饥饿-活锁\" class=\"headerlink\" title=\"死锁\\饥饿\\活锁\"></a>死锁\\饥饿\\活锁</h3><p>死锁就是多个线程需要其他线程的资源才能释放它所拥有的资源，而其他线程释放这个线程需要的资源必须先获得这个线程所拥有的资源，这样造成了矛盾无法解开；如图1情形就是发生死锁现象：</p>\n<p><img src=\"http://a2.qpic.cn/psb?/V13ysUCU2bV4he/zBrKU1zKzRRphjYm8*58YnBjOH0x7EvRxnWkrr.0oeE!/b/dMEAAAAAAAAA&ek=1&kp=1&pt=0&bo=2QENAQAAAAARF*Q!&tl=3&vuin=1793769323&tm=1555678800&sce=60-2-2&rf=viewer_4\" alt=\"\"></p>\n<center>图1：生活中的死锁现象</center>\n\n<p>活锁就是两个线程互相谦让资源，结果就是谁也拿不到资源导致活锁；就好比过马路，行人给车让道，车又给行人让道，结果就是车和行人都停在那不走。</p>\n<p>饥饿就是，某个线程优先级特别低老是拿不到资源，导致这个线程一直无法执行</p>\n<h3 id=\"并发级别\"><a href=\"#并发级别\" class=\"headerlink\" title=\"并发级别\"></a>并发级别</h3><p>并发级别分为阻塞，无饥饿，无障碍，无锁，无等待几个级别；根据名字我们也能大概猜出这几个级别对应的什么情形；阻塞，无饥饿和无锁都好理解；我们说一下无障碍和无等待；</p>\n<p>无障碍：无障碍级别默认各个线程不会发生冲突，不会互相抢占资源，一旦抢占资源就认为线程发生错误，进行回滚。</p>\n<p>无等待：无等待是在无锁上的进一步优化，限制每个线程完成任务的步数；</p>\n<h3 id=\"并行的两个定理\"><a href=\"#并行的两个定理\" class=\"headerlink\" title=\"并行的两个定理\"></a>并行的两个定理</h3><p>加速比：加速比=优化前系统耗时/优化后系统耗时</p>\n<p>Amdahl定理： 加速比=1/[F+(1-F)/n] 其中 n表示处理器个数 ，F是程序中只能串行执行的比例——串行率；由公式可知，想要以最小投入，得到最高加速比即 F+(1-F)/n取到最小值，F和n都对结果有很大影响，在深入研究就是数学问题了；</p>\n<p>Gustafson定律： 加速比=n-F(n-1)，这两定律区别不大，都体现了单纯的减少串行率，或者单纯的加CPU都无法得到最优解。</p>\n<h2 id=\"Java中的并行基础\"><a href=\"#Java中的并行基础\" class=\"headerlink\" title=\"Java中的并行基础\"></a>Java中的并行基础</h2><h3 id=\"volatile关键字和程序的原子性，可见性，有序性\"><a href=\"#volatile关键字和程序的原子性，可见性，有序性\" class=\"headerlink\" title=\"volatile关键字和程序的原子性，可见性，有序性\"></a>volatile关键字和程序的原子性，可见性，有序性</h3><p>原子性指的是一个操作是不可中断的，要么成功要么失败，不会被其他线程所干扰；比如 int=1,这一操作在cpu中分为好几个指令，但对程序而言这几个指令是一体的，只有可能执行成功或者失败，不可能发生只执行了一半的操作；对不同CPU而言保证原子性的的实现方式各有不同，就英特尔CPU而言是使用一个lock指令来保证的。</p>\n<p>可见性指某一线程改变某一共享变量，其他线程未必会马上知道。</p>\n<p>有序性指对一个操作而言指令是按一定顺序执行的，但编译器为了提高程序执行的速度，会重排程序指令；cpu在执行指令的时候采用的是流水线的形式，上一个指令和下一个指令差一个工步。比如A指令分三个工步：1. 操作内存a，2.操作内存b，3.操作内存c；现假设有个指令B操作流程和A一样，那么先执行指令A在执行指令B时间全利用上了，中间没有停顿等待；但如果有三个这样的指令在流水线上执行：a&gt;b&gt;c，b&gt;e&gt;c，c&gt;e&gt;a；这样的指令顺序就会发生等待降低了CPU的效率，编译器为了避免这种事情发生，会适当优化指令的顺序进行重排。</p>\n<p>volatile关键字在java中的作用是保证变量的可见性和防止指令重排。</p>\n<h3 id=\"线程的相关操作\"><a href=\"#线程的相关操作\" class=\"headerlink\" title=\"线程的相关操作\"></a>线程的相关操作</h3><p><em>创建线程有三种方法</em></p>\n<ul>\n<li>继承Thread类创建线程</li>\n<li>实现Runnable接口创建线程</li>\n<li>使用Callable和Future创建线程</li>\n</ul>\n<p><em>终止线程的方法</em></p>\n<p>终止线程可调用stop()方法，但这个方法是被废弃不建议使用的，因为强制终止一个线程会引起数据的不一致问题。比如一个线程数据写到一半被终止了，释放了锁，其他线程拿到锁继续写数据，结果导致数据发生了错误。终止线程比较好的方法是“让程序自己终止”，比如定义一个标识符，当标识符为true的时候直让程序走到终点，这样就能达到“自己终止”的目的。</p>\n<p><em>线程的中断等待和通知</em></p>\n<p>interrupt()方法可以中断当前程序，object.wait() 方法让线程进入等待队列，object.notify()随机唤醒等待队列的一个线程， object.notifyAll()唤醒等待队列的所有线程。object.wait()必须在synchronzied语句中调用；执行wait，notify方法必须获得对象的监视器，执行结束后释放监视器供其他线程获取。</p>\n<p><em>join</em></p>\n<p>join()方法功能是等待其他线程“加入”，可以理解为将某个线程并为自己的子线程，等子线程走完或者等子线程走规定的时间，主线程才往下走；join的本质是调用调用线程对象的wait方法，当我们执行wait或者notify方法不应该获取线程对象的的监听器，因为可能会影响到其他线程的join。</p>\n<p><em>yield</em></p>\n<p>yield是线程的“谦让”机制，可以理解为当线程抢到cpu资源时，放弃这次资源重新抢占，yield()是Thread里的一个静态方法。</p>\n<h3 id=\"线程组\"><a href=\"#线程组\" class=\"headerlink\" title=\"线程组\"></a>线程组</h3><p>如果一个多线程系统线程数量众多而且分工明确，那么可以使用线程组来分类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextLoads</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ThreadGroup testGroup=<span class=\"keyword\">new</span> ThreadGroup(<span class=\"string\">&quot;testGroup&quot;</span>);</span><br><span class=\"line\">    Thread a = <span class=\"keyword\">new</span> Thread(testGroup, <span class=\"keyword\">new</span> MyRunnable(), <span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    Thread b = <span class=\"keyword\">new</span> Thread(testGroup, <span class=\"keyword\">new</span> MyRunnable(), <span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    a.start();</span><br><span class=\"line\">    b.start();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = testGroup.activeCount();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>图示代码创建了一个”testGroup”线程组。</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>守护线程是一种特殊线程，它类似java中的异常系统，主要是概念上的分类，与之对应的是用户线程。它功能应该是在后台完成一些系统性的服务；设置一个线程为守护线程应该在线程start之前setDaemon()。</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p>java中线程可以有自己的优先级，优先级高的更有优势抢占资源；线程优先级高的不一定能抢占到资源，只是一个概率问题，而对应优先级低的线程可能会发生饥饿；</p>\n<p>在java中使用1到10表示线程的优先级，使用setPriority()方法来进行设置，数字越大代表优先级越高；</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h2 id=\"java并发相关概念\"><a href=\"#java并发相关概念\" class=\"headerlink\" title=\"java并发相关概念\"></a>java并发相关概念</h2><h3 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h3><p>同步和异步通常来形容一次方法的调用。同步方法一旦开始，调用者必须等到方法结束才能执行后续动作；异步方法则是在调用该方法后不必等到该方法执行完就能执行后面的代码，该方法会在另一个线程异步执行，异步方法总是伴随着回调，通过回调来获得异步方法的执行结果；</p>\n<h3 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h3><p>很多人都将并发与并行混淆在一起，它们虽然都可以表示两个或者多个任务一起执行，但执行过程上是有区别的。并发是多个任务交替执行，多任务之间还是串行的；而并行是多个任务同时执行，和并发有本质区别。<br>对计算机而言，如果系统内只有一个cpu，而使用多进程或者多线程执行任务，那么这种情况下多线程或者多进程就是并行执行，并行只可能出现在多核系统中。当然，对java程序而言，我们不必去关心程序是并行还是并发。</p>","more":"<h3 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h3><p>临界区表示的是多个线程共享但同时只能有一个线程使用它的资源。在并行程序中临界区资源是受保护的，必须确保同一时刻只有一个线程能使用它。</p>\n<h3 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h3><p>如果一个线程占有了临界区的资源，其他需要使用这个临界区资源的线程必须在这个临界区进行等待——线程被挂起，这种情况就是发生了阻塞——线程停滞不前。</p>\n<h3 id=\"死锁-饥饿-活锁\"><a href=\"#死锁-饥饿-活锁\" class=\"headerlink\" title=\"死锁\\饥饿\\活锁\"></a>死锁\\饥饿\\活锁</h3><p>死锁就是多个线程需要其他线程的资源才能释放它所拥有的资源，而其他线程释放这个线程需要的资源必须先获得这个线程所拥有的资源，这样造成了矛盾无法解开；如图1情形就是发生死锁现象：</p>\n<p><img src=\"http://a2.qpic.cn/psb?/V13ysUCU2bV4he/zBrKU1zKzRRphjYm8*58YnBjOH0x7EvRxnWkrr.0oeE!/b/dMEAAAAAAAAA&ek=1&kp=1&pt=0&bo=2QENAQAAAAARF*Q!&tl=3&vuin=1793769323&tm=1555678800&sce=60-2-2&rf=viewer_4\" alt=\"\"></p>\n<center>图1：生活中的死锁现象</center>\n\n<p>活锁就是两个线程互相谦让资源，结果就是谁也拿不到资源导致活锁；就好比过马路，行人给车让道，车又给行人让道，结果就是车和行人都停在那不走。</p>\n<p>饥饿就是，某个线程优先级特别低老是拿不到资源，导致这个线程一直无法执行</p>\n<h3 id=\"并发级别\"><a href=\"#并发级别\" class=\"headerlink\" title=\"并发级别\"></a>并发级别</h3><p>并发级别分为阻塞，无饥饿，无障碍，无锁，无等待几个级别；根据名字我们也能大概猜出这几个级别对应的什么情形；阻塞，无饥饿和无锁都好理解；我们说一下无障碍和无等待；</p>\n<p>无障碍：无障碍级别默认各个线程不会发生冲突，不会互相抢占资源，一旦抢占资源就认为线程发生错误，进行回滚。</p>\n<p>无等待：无等待是在无锁上的进一步优化，限制每个线程完成任务的步数；</p>\n<h3 id=\"并行的两个定理\"><a href=\"#并行的两个定理\" class=\"headerlink\" title=\"并行的两个定理\"></a>并行的两个定理</h3><p>加速比：加速比=优化前系统耗时/优化后系统耗时</p>\n<p>Amdahl定理： 加速比=1/[F+(1-F)/n] 其中 n表示处理器个数 ，F是程序中只能串行执行的比例——串行率；由公式可知，想要以最小投入，得到最高加速比即 F+(1-F)/n取到最小值，F和n都对结果有很大影响，在深入研究就是数学问题了；</p>\n<p>Gustafson定律： 加速比=n-F(n-1)，这两定律区别不大，都体现了单纯的减少串行率，或者单纯的加CPU都无法得到最优解。</p>\n<h2 id=\"Java中的并行基础\"><a href=\"#Java中的并行基础\" class=\"headerlink\" title=\"Java中的并行基础\"></a>Java中的并行基础</h2><h3 id=\"volatile关键字和程序的原子性，可见性，有序性\"><a href=\"#volatile关键字和程序的原子性，可见性，有序性\" class=\"headerlink\" title=\"volatile关键字和程序的原子性，可见性，有序性\"></a>volatile关键字和程序的原子性，可见性，有序性</h3><p>原子性指的是一个操作是不可中断的，要么成功要么失败，不会被其他线程所干扰；比如 int=1,这一操作在cpu中分为好几个指令，但对程序而言这几个指令是一体的，只有可能执行成功或者失败，不可能发生只执行了一半的操作；对不同CPU而言保证原子性的的实现方式各有不同，就英特尔CPU而言是使用一个lock指令来保证的。</p>\n<p>可见性指某一线程改变某一共享变量，其他线程未必会马上知道。</p>\n<p>有序性指对一个操作而言指令是按一定顺序执行的，但编译器为了提高程序执行的速度，会重排程序指令；cpu在执行指令的时候采用的是流水线的形式，上一个指令和下一个指令差一个工步。比如A指令分三个工步：1. 操作内存a，2.操作内存b，3.操作内存c；现假设有个指令B操作流程和A一样，那么先执行指令A在执行指令B时间全利用上了，中间没有停顿等待；但如果有三个这样的指令在流水线上执行：a&gt;b&gt;c，b&gt;e&gt;c，c&gt;e&gt;a；这样的指令顺序就会发生等待降低了CPU的效率，编译器为了避免这种事情发生，会适当优化指令的顺序进行重排。</p>\n<p>volatile关键字在java中的作用是保证变量的可见性和防止指令重排。</p>\n<h3 id=\"线程的相关操作\"><a href=\"#线程的相关操作\" class=\"headerlink\" title=\"线程的相关操作\"></a>线程的相关操作</h3><p><em>创建线程有三种方法</em></p>\n<ul>\n<li>继承Thread类创建线程</li>\n<li>实现Runnable接口创建线程</li>\n<li>使用Callable和Future创建线程</li>\n</ul>\n<p><em>终止线程的方法</em></p>\n<p>终止线程可调用stop()方法，但这个方法是被废弃不建议使用的，因为强制终止一个线程会引起数据的不一致问题。比如一个线程数据写到一半被终止了，释放了锁，其他线程拿到锁继续写数据，结果导致数据发生了错误。终止线程比较好的方法是“让程序自己终止”，比如定义一个标识符，当标识符为true的时候直让程序走到终点，这样就能达到“自己终止”的目的。</p>\n<p><em>线程的中断等待和通知</em></p>\n<p>interrupt()方法可以中断当前程序，object.wait() 方法让线程进入等待队列，object.notify()随机唤醒等待队列的一个线程， object.notifyAll()唤醒等待队列的所有线程。object.wait()必须在synchronzied语句中调用；执行wait，notify方法必须获得对象的监视器，执行结束后释放监视器供其他线程获取。</p>\n<p><em>join</em></p>\n<p>join()方法功能是等待其他线程“加入”，可以理解为将某个线程并为自己的子线程，等子线程走完或者等子线程走规定的时间，主线程才往下走；join的本质是调用调用线程对象的wait方法，当我们执行wait或者notify方法不应该获取线程对象的的监听器，因为可能会影响到其他线程的join。</p>\n<p><em>yield</em></p>\n<p>yield是线程的“谦让”机制，可以理解为当线程抢到cpu资源时，放弃这次资源重新抢占，yield()是Thread里的一个静态方法。</p>\n<h3 id=\"线程组\"><a href=\"#线程组\" class=\"headerlink\" title=\"线程组\"></a>线程组</h3><p>如果一个多线程系统线程数量众多而且分工明确，那么可以使用线程组来分类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextLoads</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ThreadGroup testGroup=<span class=\"keyword\">new</span> ThreadGroup(<span class=\"string\">&quot;testGroup&quot;</span>);</span><br><span class=\"line\">    Thread a = <span class=\"keyword\">new</span> Thread(testGroup, <span class=\"keyword\">new</span> MyRunnable(), <span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    Thread b = <span class=\"keyword\">new</span> Thread(testGroup, <span class=\"keyword\">new</span> MyRunnable(), <span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    a.start();</span><br><span class=\"line\">    b.start();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = testGroup.activeCount();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>图示代码创建了一个”testGroup”线程组。</p>\n<h3 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h3><p>守护线程是一种特殊线程，它类似java中的异常系统，主要是概念上的分类，与之对应的是用户线程。它功能应该是在后台完成一些系统性的服务；设置一个线程为守护线程应该在线程start之前setDaemon()。</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p>java中线程可以有自己的优先级，优先级高的更有优势抢占资源；线程优先级高的不一定能抢占到资源，只是一个概率问题，而对应优先级低的线程可能会发生饥饿；</p>\n<p>在java中使用1到10表示线程的优先级，使用setPriority()方法来进行设置，数字越大代表优先级越高；</p>"},{"title":"多线程编程基础第二篇","date":"2019-04-23T01:22:05.000Z","_content":"\n作者：muggle\n\n## 扩展\n\ncas(比较替换)：无锁策略的一种实现方式，过程为获取到变量旧值（每个线程都有一份变量值的副本），和变量目前的新值做比较，如果一样证明变量没被其他线程修改过，这个线程就可以更新这个变量，否则不能更新；通俗的说就是通过不加锁的方式来修改共享资源并同时保证安全性。\n\n使用cas的话对于属性变量不能再用传统的int ,long等；要使用原子类代替原先的数据类型操作，比如AtomicBoolean，AtomicInteger，AtomicInteger等。\n\n## java线程锁的分类与实现\n\n以下分类是从多个同角度来划分，而不是以某一标准来划分，请注意\n\n- 阻塞锁：当一个线程获得锁，其他线程就会被阻塞挂起，直到抢占到锁才继续执行，这样会导致CPU切换上下文，切换上下文对CPU而言是很耗费时间的\n- 非阻塞锁：当一个线程获得锁，其他线程直接跳过锁资源相关的代码继续执行，就是非阻塞锁\n- 自旋锁：当一个线程获得锁，其他线程则在不停进行空循环，直到抢到锁，这样做的好处是避免了上下文切换\n- 可重入锁：也叫做递归锁，当一个线程外层函数获得锁之后 ，内层递归函数仍然可以该锁的相关代码，不受影响。\n- 互斥锁：互斥锁保证了某一时刻只能有一个线程占有该资源。\n- 读写锁：将代码功能分为读和写，读不互斥，写互斥；\n- 公平锁/非公平锁：公平锁就是在等待队列里排最前面的的先获得锁，非公平锁就是谁抢到谁用；\n- 重量级锁/轻量级锁/偏向锁：使用操作系统“Mutex Lock”功能来实现锁机制的叫重量级锁，因为这种锁成本高；轻量级锁是对重量级锁的优化，提高性能；偏向锁是对轻量级锁的优化，在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。\n\n<!--more-->\n\n###  synchronized\n\n属于阻塞锁，互斥锁，非公平锁，可重入锁，在JDK1.6以前属于重量级锁，后来做了优化；\n\n用法：\n- 指定加锁对象；\n- 用于静态代码块/方法\n- 用于动态代码块/方法\n\n示例\n\n```\n\t\tpublic static synchronized void test1(){\n            System.out.println(\"test\");\n        }\n\n        public  synchronized void test2(){\n            System.out.println(\"test\");\n        }\n                 \n        public void test3(){\n            synchronized (this){\n                System.out.println(\"test\");\n            }\n        }\n```\n\n当锁加在静态代码块/方法上时，锁作用于整个类，凡是属于这个类的对象的相关都会被上锁，当用于动态代码块/方法/对象时锁作用于对象；除此之外，synchronized可以保证线程的可见性和有序性。\n\n### Lock\n\nlock 是一个接口，其下有多个实现类；\n\n方法说明：\n\n- lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。\n- tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，这个方法还可以设置一个获取锁的等待时长，如果时间内获取不到直接返回。\n- 两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程\n- unLock()方法是用来释放锁\n- newCondition()：生成一个和线程绑定的Condition实例，利用该实例我们可以让线程在合适的时候等待，在特定的时候继续执行；相当于得到这个线程的wait和notify方法；\n\n### ReentrantLock\n\nReentrantLock重入锁，是实现Lock接口的一个类，它对公平锁和非公平锁都支持；在构造方法中传入一个boolean值，true时为公平锁，false时为非公平锁\n\n### Semaphore(信号量)\n\n信号量是对锁的扩展，锁每次只允许一个线程访问一个资源，而信号量却可以指定多个线程访问某个资源；信号量的构造函数为\n\n```java\npublic Semaphore(int permits) {\n        sync = new NonfairSync(permits);\n    }\npublic Semaphore(int permits, boolean fair) {\n        sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n    }\n```\n\n第一个方法指定了可使用的线程数，第二个方法的布尔值表示是否为公平锁；\n\nacquire()方法尝试获得一个许可，如果获取不到则等待；tryAcquire()方法尝试获取一个许可，成功返回true，失败返回false，不会阻塞，tryAcquire(int i) 指定等待时间；release()方法释放一个许可。\n\n### ReadWriteLock\n\n读写分离锁， 读写分离锁可以有效的减少锁竞争，读锁是共享锁，可以被多个线程同时获取，写锁是互斥只能被一个线程占有，ReadWriteLock是一个接口，其中readLock()获得读锁，writeLock()获得写锁 其实现类ReentrantReadWriteLock是一个可重入得的读写锁，它支持锁的降级(在获得写锁的情况下可以再持有读锁)，不支持锁的升级（在获得读锁的情况下不能再获得写锁）；读锁和写锁也是互斥的，也就是一个资源要么被上了一个写锁，要么被上了多个读锁，不会发生这个资即被上写锁又被上读锁的情况。\n\n## 并发下集合类\n\n并发集合类主要有：\n\n- ConcurrentHashMap：支持多线程的分段哈希表，它通过将整个哈希表分成多段的方式减小锁粒度\n- ConcurrentSkipListMap：ConcurrentSkipListMap的底层是通过跳表来实现的。跳表是一个链表，但是通过使用“跳跃式”查找的方式使得插入、读取数据时复杂度变成了O（logn）;\n- ConCurrentSkipListSet：参考ConcurrentSkipListMap；\n- CopyOnWriteArrayList：是ArrayList 的一个线程安全的变形，其中所有可变操作（添加、设置，等等）都是通过对基础数组进行一次新的复制来实现的; \n- CopyOnWriteArraySet：参考CopyOnWriteArrayList; \n-  ConcurrentLinkedQueue：cas实现的非阻塞并发队列;\n\n## 线程池\n\n### 介绍\n\n多线程的设计优点是能很大限度的发挥多核处理器的计算能力，但是，若不控制好线程资源反而会拖累cpu，降低系统性能，这就涉及到了线程的回收复用等一系列问题；而且本身线程的创建和销毁也很耗费资源，因此找到一个合适的方法来提高线程的复用就很必要了。\n\n线程池就是解决这类问题的一个很好的方法：线程池中本身有很多个线程，当需要使用线程的时候拿一个线程出来，当用完则还回去，而不是每次都创建和销毁。在JDK中提供了一套Executor线程池框架，帮助开发人员有效的进行线程控制。\n\n### Executor使用\n\n获得线程池的方法：\n\n- newFixedThreadPool(int nThreads) ：创建固定数目线程的线程池；\n- newCachedThreadPool：创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线 程并添加到池中；\n- newSingleThreadExecutor：创建一个单线程化的Executor；\n- newScheduledThreadPool：创建一个支持定时及周期性的任务执行的线程池。\n\n以上方法都是返回一个ExecutorService对象，executorService.execute()传入一个Runnable对象，可执行一个线程任务\n\n下面看示例代码\n\n```java\npublic class Test implements Runnable{\n\tint i=0;\n\tpublic Test(int i){\n\t\tthis.i=i;\n\t}\n\tpublic void run() {\n\t\tSystem.out.println(Thread.currentThread().getName()+\"=====\"+i);\n\t}\n    public static void main(String[] args) throws InterruptedException {\n\t\tExecutorService cachedThreadPool = Executors.newCachedThreadPool();\n\t\tfor(int i=0;i<10;i++){\n\t\t\tcachedThreadPool.execute(new Test(i));\n\t\t\tThread.sleep(1000);\n\t\t}\n\t}\n}\n\n```\n\n线程池是一个庞大而复杂的体系，本系列文章定位是基础，不对其做更深入的研究，感兴趣的小伙伴可以自行查资料进行学习。\n\n### ScheduledExecutorService\n\nnewScheduledThreadPool(int corePoolSize)会返回一个ScheduledExecutorService对象，可以根据时间对线程进行调度；其下有三个执行线程任务的方法：schedule()，scheduleAtFixedRate()，scheduleWithFixedDelay()；该线程池可解决定时任务的问题。\n\n示例：\n\n```java\nclass Test implements Runnable {\n    \n    private String testStr;\n    \n    Test(String testStr) {\n        this.testStr = testStr;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(testStr + \" >>>> print\");\n    }\n    \n    public static void main(String[] args) {\n        ScheduledExecutorService service = Executors.newScheduledThreadPool(10);\n        long wait = 1;\n        long period = 1;\n        service.scheduleAtFixedRate(new MyScheduledExecutor(\"job1\"), wait, period, TimeUnit.SECONDS);\n        service.scheduleWithFixedDelay(new MyScheduledExecutor(\"job2\"), wait, period, TimeUnit.SECONDS);\n        scheduledExecutorService.schedule(new MyScheduledExecutor(\"job3\"), wait, TimeUnit.SECONDS);//延时waits 执行\n    }\n}\n```\n\njob1的执行方式是任务发起后间隔`wait`秒开始执行，每隔`period`秒(注意：不包括上一个线程的执行时间)执行一次；\n\njob2的执行方式是任务发起后间隔`wait`秒开始执行，等线程结束后隔`period`秒开始执行下一个线程；\n\njob3只执行一次，延迟`wait`秒执行；\n\nScheduledExecutorService还可以配合Callable使用来回调获得线程执行结果，还可以取消队列中的执行任务等操作，这属于比较复杂的用法，我们这里掌握基本的即可，到实际遇到相应的问题时我们在现学现用，节省学习成本。","source":"_posts/thread-2.md","raw":"---\ntitle: 多线程编程基础第二篇\ndate: 2019-04-23 09:22:05\ntags: thread\n---\n\n作者：muggle\n\n## 扩展\n\ncas(比较替换)：无锁策略的一种实现方式，过程为获取到变量旧值（每个线程都有一份变量值的副本），和变量目前的新值做比较，如果一样证明变量没被其他线程修改过，这个线程就可以更新这个变量，否则不能更新；通俗的说就是通过不加锁的方式来修改共享资源并同时保证安全性。\n\n使用cas的话对于属性变量不能再用传统的int ,long等；要使用原子类代替原先的数据类型操作，比如AtomicBoolean，AtomicInteger，AtomicInteger等。\n\n## java线程锁的分类与实现\n\n以下分类是从多个同角度来划分，而不是以某一标准来划分，请注意\n\n- 阻塞锁：当一个线程获得锁，其他线程就会被阻塞挂起，直到抢占到锁才继续执行，这样会导致CPU切换上下文，切换上下文对CPU而言是很耗费时间的\n- 非阻塞锁：当一个线程获得锁，其他线程直接跳过锁资源相关的代码继续执行，就是非阻塞锁\n- 自旋锁：当一个线程获得锁，其他线程则在不停进行空循环，直到抢到锁，这样做的好处是避免了上下文切换\n- 可重入锁：也叫做递归锁，当一个线程外层函数获得锁之后 ，内层递归函数仍然可以该锁的相关代码，不受影响。\n- 互斥锁：互斥锁保证了某一时刻只能有一个线程占有该资源。\n- 读写锁：将代码功能分为读和写，读不互斥，写互斥；\n- 公平锁/非公平锁：公平锁就是在等待队列里排最前面的的先获得锁，非公平锁就是谁抢到谁用；\n- 重量级锁/轻量级锁/偏向锁：使用操作系统“Mutex Lock”功能来实现锁机制的叫重量级锁，因为这种锁成本高；轻量级锁是对重量级锁的优化，提高性能；偏向锁是对轻量级锁的优化，在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。\n\n<!--more-->\n\n###  synchronized\n\n属于阻塞锁，互斥锁，非公平锁，可重入锁，在JDK1.6以前属于重量级锁，后来做了优化；\n\n用法：\n- 指定加锁对象；\n- 用于静态代码块/方法\n- 用于动态代码块/方法\n\n示例\n\n```\n\t\tpublic static synchronized void test1(){\n            System.out.println(\"test\");\n        }\n\n        public  synchronized void test2(){\n            System.out.println(\"test\");\n        }\n                 \n        public void test3(){\n            synchronized (this){\n                System.out.println(\"test\");\n            }\n        }\n```\n\n当锁加在静态代码块/方法上时，锁作用于整个类，凡是属于这个类的对象的相关都会被上锁，当用于动态代码块/方法/对象时锁作用于对象；除此之外，synchronized可以保证线程的可见性和有序性。\n\n### Lock\n\nlock 是一个接口，其下有多个实现类；\n\n方法说明：\n\n- lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。\n- tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，这个方法还可以设置一个获取锁的等待时长，如果时间内获取不到直接返回。\n- 两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程\n- unLock()方法是用来释放锁\n- newCondition()：生成一个和线程绑定的Condition实例，利用该实例我们可以让线程在合适的时候等待，在特定的时候继续执行；相当于得到这个线程的wait和notify方法；\n\n### ReentrantLock\n\nReentrantLock重入锁，是实现Lock接口的一个类，它对公平锁和非公平锁都支持；在构造方法中传入一个boolean值，true时为公平锁，false时为非公平锁\n\n### Semaphore(信号量)\n\n信号量是对锁的扩展，锁每次只允许一个线程访问一个资源，而信号量却可以指定多个线程访问某个资源；信号量的构造函数为\n\n```java\npublic Semaphore(int permits) {\n        sync = new NonfairSync(permits);\n    }\npublic Semaphore(int permits, boolean fair) {\n        sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n    }\n```\n\n第一个方法指定了可使用的线程数，第二个方法的布尔值表示是否为公平锁；\n\nacquire()方法尝试获得一个许可，如果获取不到则等待；tryAcquire()方法尝试获取一个许可，成功返回true，失败返回false，不会阻塞，tryAcquire(int i) 指定等待时间；release()方法释放一个许可。\n\n### ReadWriteLock\n\n读写分离锁， 读写分离锁可以有效的减少锁竞争，读锁是共享锁，可以被多个线程同时获取，写锁是互斥只能被一个线程占有，ReadWriteLock是一个接口，其中readLock()获得读锁，writeLock()获得写锁 其实现类ReentrantReadWriteLock是一个可重入得的读写锁，它支持锁的降级(在获得写锁的情况下可以再持有读锁)，不支持锁的升级（在获得读锁的情况下不能再获得写锁）；读锁和写锁也是互斥的，也就是一个资源要么被上了一个写锁，要么被上了多个读锁，不会发生这个资即被上写锁又被上读锁的情况。\n\n## 并发下集合类\n\n并发集合类主要有：\n\n- ConcurrentHashMap：支持多线程的分段哈希表，它通过将整个哈希表分成多段的方式减小锁粒度\n- ConcurrentSkipListMap：ConcurrentSkipListMap的底层是通过跳表来实现的。跳表是一个链表，但是通过使用“跳跃式”查找的方式使得插入、读取数据时复杂度变成了O（logn）;\n- ConCurrentSkipListSet：参考ConcurrentSkipListMap；\n- CopyOnWriteArrayList：是ArrayList 的一个线程安全的变形，其中所有可变操作（添加、设置，等等）都是通过对基础数组进行一次新的复制来实现的; \n- CopyOnWriteArraySet：参考CopyOnWriteArrayList; \n-  ConcurrentLinkedQueue：cas实现的非阻塞并发队列;\n\n## 线程池\n\n### 介绍\n\n多线程的设计优点是能很大限度的发挥多核处理器的计算能力，但是，若不控制好线程资源反而会拖累cpu，降低系统性能，这就涉及到了线程的回收复用等一系列问题；而且本身线程的创建和销毁也很耗费资源，因此找到一个合适的方法来提高线程的复用就很必要了。\n\n线程池就是解决这类问题的一个很好的方法：线程池中本身有很多个线程，当需要使用线程的时候拿一个线程出来，当用完则还回去，而不是每次都创建和销毁。在JDK中提供了一套Executor线程池框架，帮助开发人员有效的进行线程控制。\n\n### Executor使用\n\n获得线程池的方法：\n\n- newFixedThreadPool(int nThreads) ：创建固定数目线程的线程池；\n- newCachedThreadPool：创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线 程并添加到池中；\n- newSingleThreadExecutor：创建一个单线程化的Executor；\n- newScheduledThreadPool：创建一个支持定时及周期性的任务执行的线程池。\n\n以上方法都是返回一个ExecutorService对象，executorService.execute()传入一个Runnable对象，可执行一个线程任务\n\n下面看示例代码\n\n```java\npublic class Test implements Runnable{\n\tint i=0;\n\tpublic Test(int i){\n\t\tthis.i=i;\n\t}\n\tpublic void run() {\n\t\tSystem.out.println(Thread.currentThread().getName()+\"=====\"+i);\n\t}\n    public static void main(String[] args) throws InterruptedException {\n\t\tExecutorService cachedThreadPool = Executors.newCachedThreadPool();\n\t\tfor(int i=0;i<10;i++){\n\t\t\tcachedThreadPool.execute(new Test(i));\n\t\t\tThread.sleep(1000);\n\t\t}\n\t}\n}\n\n```\n\n线程池是一个庞大而复杂的体系，本系列文章定位是基础，不对其做更深入的研究，感兴趣的小伙伴可以自行查资料进行学习。\n\n### ScheduledExecutorService\n\nnewScheduledThreadPool(int corePoolSize)会返回一个ScheduledExecutorService对象，可以根据时间对线程进行调度；其下有三个执行线程任务的方法：schedule()，scheduleAtFixedRate()，scheduleWithFixedDelay()；该线程池可解决定时任务的问题。\n\n示例：\n\n```java\nclass Test implements Runnable {\n    \n    private String testStr;\n    \n    Test(String testStr) {\n        this.testStr = testStr;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(testStr + \" >>>> print\");\n    }\n    \n    public static void main(String[] args) {\n        ScheduledExecutorService service = Executors.newScheduledThreadPool(10);\n        long wait = 1;\n        long period = 1;\n        service.scheduleAtFixedRate(new MyScheduledExecutor(\"job1\"), wait, period, TimeUnit.SECONDS);\n        service.scheduleWithFixedDelay(new MyScheduledExecutor(\"job2\"), wait, period, TimeUnit.SECONDS);\n        scheduledExecutorService.schedule(new MyScheduledExecutor(\"job3\"), wait, TimeUnit.SECONDS);//延时waits 执行\n    }\n}\n```\n\njob1的执行方式是任务发起后间隔`wait`秒开始执行，每隔`period`秒(注意：不包括上一个线程的执行时间)执行一次；\n\njob2的执行方式是任务发起后间隔`wait`秒开始执行，等线程结束后隔`period`秒开始执行下一个线程；\n\njob3只执行一次，延迟`wait`秒执行；\n\nScheduledExecutorService还可以配合Callable使用来回调获得线程执行结果，还可以取消队列中的执行任务等操作，这属于比较复杂的用法，我们这里掌握基本的即可，到实际遇到相应的问题时我们在现学现用，节省学习成本。","slug":"thread-2","published":1,"updated":"2021-01-11T07:31:23.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh6y003w00wi1q6202j1","content":"<p>作者：muggle</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>cas(比较替换)：无锁策略的一种实现方式，过程为获取到变量旧值（每个线程都有一份变量值的副本），和变量目前的新值做比较，如果一样证明变量没被其他线程修改过，这个线程就可以更新这个变量，否则不能更新；通俗的说就是通过不加锁的方式来修改共享资源并同时保证安全性。</p>\n<p>使用cas的话对于属性变量不能再用传统的int ,long等；要使用原子类代替原先的数据类型操作，比如AtomicBoolean，AtomicInteger，AtomicInteger等。</p>\n<h2 id=\"java线程锁的分类与实现\"><a href=\"#java线程锁的分类与实现\" class=\"headerlink\" title=\"java线程锁的分类与实现\"></a>java线程锁的分类与实现</h2><p>以下分类是从多个同角度来划分，而不是以某一标准来划分，请注意</p>\n<ul>\n<li>阻塞锁：当一个线程获得锁，其他线程就会被阻塞挂起，直到抢占到锁才继续执行，这样会导致CPU切换上下文，切换上下文对CPU而言是很耗费时间的</li>\n<li>非阻塞锁：当一个线程获得锁，其他线程直接跳过锁资源相关的代码继续执行，就是非阻塞锁</li>\n<li>自旋锁：当一个线程获得锁，其他线程则在不停进行空循环，直到抢到锁，这样做的好处是避免了上下文切换</li>\n<li>可重入锁：也叫做递归锁，当一个线程外层函数获得锁之后 ，内层递归函数仍然可以该锁的相关代码，不受影响。</li>\n<li>互斥锁：互斥锁保证了某一时刻只能有一个线程占有该资源。</li>\n<li>读写锁：将代码功能分为读和写，读不互斥，写互斥；</li>\n<li>公平锁/非公平锁：公平锁就是在等待队列里排最前面的的先获得锁，非公平锁就是谁抢到谁用；</li>\n<li>重量级锁/轻量级锁/偏向锁：使用操作系统“Mutex Lock”功能来实现锁机制的叫重量级锁，因为这种锁成本高；轻量级锁是对重量级锁的优化，提高性能；偏向锁是对轻量级锁的优化，在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><p>属于阻塞锁，互斥锁，非公平锁，可重入锁，在JDK1.6以前属于重量级锁，后来做了优化；</p>\n<p>用法：</p>\n<ul>\n<li>指定加锁对象；</li>\n<li>用于静态代码块/方法</li>\n<li>用于动态代码块/方法</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static synchronized void test1()&#123;</span><br><span class=\"line\">          System.out.println(&quot;test&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public  synchronized void test2()&#123;</span><br><span class=\"line\">          System.out.println(&quot;test&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">               </span><br><span class=\"line\">      public void test3()&#123;</span><br><span class=\"line\">          synchronized (this)&#123;</span><br><span class=\"line\">              System.out.println(&quot;test&quot;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>当锁加在静态代码块/方法上时，锁作用于整个类，凡是属于这个类的对象的相关都会被上锁，当用于动态代码块/方法/对象时锁作用于对象；除此之外，synchronized可以保证线程的可见性和有序性。</p>\n<h3 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h3><p>lock 是一个接口，其下有多个实现类；</p>\n<p>方法说明：</p>\n<ul>\n<li>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</li>\n<li>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，这个方法还可以设置一个获取锁的等待时长，如果时间内获取不到直接返回。</li>\n<li>两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程</li>\n<li>unLock()方法是用来释放锁</li>\n<li>newCondition()：生成一个和线程绑定的Condition实例，利用该实例我们可以让线程在合适的时候等待，在特定的时候继续执行；相当于得到这个线程的wait和notify方法；</li>\n</ul>\n<h3 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h3><p>ReentrantLock重入锁，是实现Lock接口的一个类，它对公平锁和非公平锁都支持；在构造方法中传入一个boolean值，true时为公平锁，false时为非公平锁</p>\n<h3 id=\"Semaphore-信号量\"><a href=\"#Semaphore-信号量\" class=\"headerlink\" title=\"Semaphore(信号量)\"></a>Semaphore(信号量)</h3><p>信号量是对锁的扩展，锁每次只允许一个线程访问一个资源，而信号量却可以指定多个线程访问某个资源；信号量的构造函数为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> </span>&#123;</span><br><span class=\"line\">        sync = <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits, <span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">        sync = fair ? <span class=\"keyword\">new</span> FairSync(permits) : <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>第一个方法指定了可使用的线程数，第二个方法的布尔值表示是否为公平锁；</p>\n<p>acquire()方法尝试获得一个许可，如果获取不到则等待；tryAcquire()方法尝试获取一个许可，成功返回true，失败返回false，不会阻塞，tryAcquire(int i) 指定等待时间；release()方法释放一个许可。</p>\n<h3 id=\"ReadWriteLock\"><a href=\"#ReadWriteLock\" class=\"headerlink\" title=\"ReadWriteLock\"></a>ReadWriteLock</h3><p>读写分离锁， 读写分离锁可以有效的减少锁竞争，读锁是共享锁，可以被多个线程同时获取，写锁是互斥只能被一个线程占有，ReadWriteLock是一个接口，其中readLock()获得读锁，writeLock()获得写锁 其实现类ReentrantReadWriteLock是一个可重入得的读写锁，它支持锁的降级(在获得写锁的情况下可以再持有读锁)，不支持锁的升级（在获得读锁的情况下不能再获得写锁）；读锁和写锁也是互斥的，也就是一个资源要么被上了一个写锁，要么被上了多个读锁，不会发生这个资即被上写锁又被上读锁的情况。</p>\n<h2 id=\"并发下集合类\"><a href=\"#并发下集合类\" class=\"headerlink\" title=\"并发下集合类\"></a>并发下集合类</h2><p>并发集合类主要有：</p>\n<ul>\n<li>ConcurrentHashMap：支持多线程的分段哈希表，它通过将整个哈希表分成多段的方式减小锁粒度</li>\n<li>ConcurrentSkipListMap：ConcurrentSkipListMap的底层是通过跳表来实现的。跳表是一个链表，但是通过使用“跳跃式”查找的方式使得插入、读取数据时复杂度变成了O（logn）;</li>\n<li>ConCurrentSkipListSet：参考ConcurrentSkipListMap；</li>\n<li>CopyOnWriteArrayList：是ArrayList 的一个线程安全的变形，其中所有可变操作（添加、设置，等等）都是通过对基础数组进行一次新的复制来实现的; </li>\n<li>CopyOnWriteArraySet：参考CopyOnWriteArrayList; </li>\n<li>ConcurrentLinkedQueue：cas实现的非阻塞并发队列;</li>\n</ul>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>多线程的设计优点是能很大限度的发挥多核处理器的计算能力，但是，若不控制好线程资源反而会拖累cpu，降低系统性能，这就涉及到了线程的回收复用等一系列问题；而且本身线程的创建和销毁也很耗费资源，因此找到一个合适的方法来提高线程的复用就很必要了。</p>\n<p>线程池就是解决这类问题的一个很好的方法：线程池中本身有很多个线程，当需要使用线程的时候拿一个线程出来，当用完则还回去，而不是每次都创建和销毁。在JDK中提供了一套Executor线程池框架，帮助开发人员有效的进行线程控制。</p>\n<h3 id=\"Executor使用\"><a href=\"#Executor使用\" class=\"headerlink\" title=\"Executor使用\"></a>Executor使用</h3><p>获得线程池的方法：</p>\n<ul>\n<li>newFixedThreadPool(int nThreads) ：创建固定数目线程的线程池；</li>\n<li>newCachedThreadPool：创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线 程并添加到池中；</li>\n<li>newSingleThreadExecutor：创建一个单线程化的Executor；</li>\n<li>newScheduledThreadPool：创建一个支持定时及周期性的任务执行的线程池。</li>\n</ul>\n<p>以上方法都是返回一个ExecutorService对象，executorService.execute()传入一个Runnable对象，可执行一个线程任务</p>\n<p>下面看示例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.i=i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;=====&quot;</span>+i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t\tExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">\t\t\tcachedThreadPool.execute(<span class=\"keyword\">new</span> Test(i));</span><br><span class=\"line\">\t\t\tThread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>线程池是一个庞大而复杂的体系，本系列文章定位是基础，不对其做更深入的研究，感兴趣的小伙伴可以自行查资料进行学习。</p>\n<h3 id=\"ScheduledExecutorService\"><a href=\"#ScheduledExecutorService\" class=\"headerlink\" title=\"ScheduledExecutorService\"></a>ScheduledExecutorService</h3><p>newScheduledThreadPool(int corePoolSize)会返回一个ScheduledExecutorService对象，可以根据时间对线程进行调度；其下有三个执行线程任务的方法：schedule()，scheduleAtFixedRate()，scheduleWithFixedDelay()；该线程池可解决定时任务的问题。</p>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String testStr;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Test(String testStr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.testStr = testStr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(testStr + <span class=\"string\">&quot; &gt;&gt;&gt;&gt; print&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> wait = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> period = <span class=\"number\">1</span>;</span><br><span class=\"line\">        service.scheduleAtFixedRate(<span class=\"keyword\">new</span> MyScheduledExecutor(<span class=\"string\">&quot;job1&quot;</span>), wait, period, TimeUnit.SECONDS);</span><br><span class=\"line\">        service.scheduleWithFixedDelay(<span class=\"keyword\">new</span> MyScheduledExecutor(<span class=\"string\">&quot;job2&quot;</span>), wait, period, TimeUnit.SECONDS);</span><br><span class=\"line\">        scheduledExecutorService.schedule(<span class=\"keyword\">new</span> MyScheduledExecutor(<span class=\"string\">&quot;job3&quot;</span>), wait, TimeUnit.SECONDS);<span class=\"comment\">//延时waits 执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>job1的执行方式是任务发起后间隔<code>wait</code>秒开始执行，每隔<code>period</code>秒(注意：不包括上一个线程的执行时间)执行一次；</p>\n<p>job2的执行方式是任务发起后间隔<code>wait</code>秒开始执行，等线程结束后隔<code>period</code>秒开始执行下一个线程；</p>\n<p>job3只执行一次，延迟<code>wait</code>秒执行；</p>\n<p>ScheduledExecutorService还可以配合Callable使用来回调获得线程执行结果，还可以取消队列中的执行任务等操作，这属于比较复杂的用法，我们这里掌握基本的即可，到实际遇到相应的问题时我们在现学现用，节省学习成本。</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>cas(比较替换)：无锁策略的一种实现方式，过程为获取到变量旧值（每个线程都有一份变量值的副本），和变量目前的新值做比较，如果一样证明变量没被其他线程修改过，这个线程就可以更新这个变量，否则不能更新；通俗的说就是通过不加锁的方式来修改共享资源并同时保证安全性。</p>\n<p>使用cas的话对于属性变量不能再用传统的int ,long等；要使用原子类代替原先的数据类型操作，比如AtomicBoolean，AtomicInteger，AtomicInteger等。</p>\n<h2 id=\"java线程锁的分类与实现\"><a href=\"#java线程锁的分类与实现\" class=\"headerlink\" title=\"java线程锁的分类与实现\"></a>java线程锁的分类与实现</h2><p>以下分类是从多个同角度来划分，而不是以某一标准来划分，请注意</p>\n<ul>\n<li>阻塞锁：当一个线程获得锁，其他线程就会被阻塞挂起，直到抢占到锁才继续执行，这样会导致CPU切换上下文，切换上下文对CPU而言是很耗费时间的</li>\n<li>非阻塞锁：当一个线程获得锁，其他线程直接跳过锁资源相关的代码继续执行，就是非阻塞锁</li>\n<li>自旋锁：当一个线程获得锁，其他线程则在不停进行空循环，直到抢到锁，这样做的好处是避免了上下文切换</li>\n<li>可重入锁：也叫做递归锁，当一个线程外层函数获得锁之后 ，内层递归函数仍然可以该锁的相关代码，不受影响。</li>\n<li>互斥锁：互斥锁保证了某一时刻只能有一个线程占有该资源。</li>\n<li>读写锁：将代码功能分为读和写，读不互斥，写互斥；</li>\n<li>公平锁/非公平锁：公平锁就是在等待队列里排最前面的的先获得锁，非公平锁就是谁抢到谁用；</li>\n<li>重量级锁/轻量级锁/偏向锁：使用操作系统“Mutex Lock”功能来实现锁机制的叫重量级锁，因为这种锁成本高；轻量级锁是对重量级锁的优化，提高性能；偏向锁是对轻量级锁的优化，在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。</li>\n</ul>","more":"<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><p>属于阻塞锁，互斥锁，非公平锁，可重入锁，在JDK1.6以前属于重量级锁，后来做了优化；</p>\n<p>用法：</p>\n<ul>\n<li>指定加锁对象；</li>\n<li>用于静态代码块/方法</li>\n<li>用于动态代码块/方法</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static synchronized void test1()&#123;</span><br><span class=\"line\">          System.out.println(&quot;test&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      public  synchronized void test2()&#123;</span><br><span class=\"line\">          System.out.println(&quot;test&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">               </span><br><span class=\"line\">      public void test3()&#123;</span><br><span class=\"line\">          synchronized (this)&#123;</span><br><span class=\"line\">              System.out.println(&quot;test&quot;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<p>当锁加在静态代码块/方法上时，锁作用于整个类，凡是属于这个类的对象的相关都会被上锁，当用于动态代码块/方法/对象时锁作用于对象；除此之外，synchronized可以保证线程的可见性和有序性。</p>\n<h3 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h3><p>lock 是一个接口，其下有多个实现类；</p>\n<p>方法说明：</p>\n<ul>\n<li>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</li>\n<li>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，这个方法还可以设置一个获取锁的等待时长，如果时间内获取不到直接返回。</li>\n<li>两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程</li>\n<li>unLock()方法是用来释放锁</li>\n<li>newCondition()：生成一个和线程绑定的Condition实例，利用该实例我们可以让线程在合适的时候等待，在特定的时候继续执行；相当于得到这个线程的wait和notify方法；</li>\n</ul>\n<h3 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h3><p>ReentrantLock重入锁，是实现Lock接口的一个类，它对公平锁和非公平锁都支持；在构造方法中传入一个boolean值，true时为公平锁，false时为非公平锁</p>\n<h3 id=\"Semaphore-信号量\"><a href=\"#Semaphore-信号量\" class=\"headerlink\" title=\"Semaphore(信号量)\"></a>Semaphore(信号量)</h3><p>信号量是对锁的扩展，锁每次只允许一个线程访问一个资源，而信号量却可以指定多个线程访问某个资源；信号量的构造函数为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> </span>&#123;</span><br><span class=\"line\">        sync = <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits, <span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">        sync = fair ? <span class=\"keyword\">new</span> FairSync(permits) : <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>第一个方法指定了可使用的线程数，第二个方法的布尔值表示是否为公平锁；</p>\n<p>acquire()方法尝试获得一个许可，如果获取不到则等待；tryAcquire()方法尝试获取一个许可，成功返回true，失败返回false，不会阻塞，tryAcquire(int i) 指定等待时间；release()方法释放一个许可。</p>\n<h3 id=\"ReadWriteLock\"><a href=\"#ReadWriteLock\" class=\"headerlink\" title=\"ReadWriteLock\"></a>ReadWriteLock</h3><p>读写分离锁， 读写分离锁可以有效的减少锁竞争，读锁是共享锁，可以被多个线程同时获取，写锁是互斥只能被一个线程占有，ReadWriteLock是一个接口，其中readLock()获得读锁，writeLock()获得写锁 其实现类ReentrantReadWriteLock是一个可重入得的读写锁，它支持锁的降级(在获得写锁的情况下可以再持有读锁)，不支持锁的升级（在获得读锁的情况下不能再获得写锁）；读锁和写锁也是互斥的，也就是一个资源要么被上了一个写锁，要么被上了多个读锁，不会发生这个资即被上写锁又被上读锁的情况。</p>\n<h2 id=\"并发下集合类\"><a href=\"#并发下集合类\" class=\"headerlink\" title=\"并发下集合类\"></a>并发下集合类</h2><p>并发集合类主要有：</p>\n<ul>\n<li>ConcurrentHashMap：支持多线程的分段哈希表，它通过将整个哈希表分成多段的方式减小锁粒度</li>\n<li>ConcurrentSkipListMap：ConcurrentSkipListMap的底层是通过跳表来实现的。跳表是一个链表，但是通过使用“跳跃式”查找的方式使得插入、读取数据时复杂度变成了O（logn）;</li>\n<li>ConCurrentSkipListSet：参考ConcurrentSkipListMap；</li>\n<li>CopyOnWriteArrayList：是ArrayList 的一个线程安全的变形，其中所有可变操作（添加、设置，等等）都是通过对基础数组进行一次新的复制来实现的; </li>\n<li>CopyOnWriteArraySet：参考CopyOnWriteArrayList; </li>\n<li>ConcurrentLinkedQueue：cas实现的非阻塞并发队列;</li>\n</ul>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>多线程的设计优点是能很大限度的发挥多核处理器的计算能力，但是，若不控制好线程资源反而会拖累cpu，降低系统性能，这就涉及到了线程的回收复用等一系列问题；而且本身线程的创建和销毁也很耗费资源，因此找到一个合适的方法来提高线程的复用就很必要了。</p>\n<p>线程池就是解决这类问题的一个很好的方法：线程池中本身有很多个线程，当需要使用线程的时候拿一个线程出来，当用完则还回去，而不是每次都创建和销毁。在JDK中提供了一套Executor线程池框架，帮助开发人员有效的进行线程控制。</p>\n<h3 id=\"Executor使用\"><a href=\"#Executor使用\" class=\"headerlink\" title=\"Executor使用\"></a>Executor使用</h3><p>获得线程池的方法：</p>\n<ul>\n<li>newFixedThreadPool(int nThreads) ：创建固定数目线程的线程池；</li>\n<li>newCachedThreadPool：创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线 程并添加到池中；</li>\n<li>newSingleThreadExecutor：创建一个单线程化的Executor；</li>\n<li>newScheduledThreadPool：创建一个支持定时及周期性的任务执行的线程池。</li>\n</ul>\n<p>以上方法都是返回一个ExecutorService对象，executorService.execute()传入一个Runnable对象，可执行一个线程任务</p>\n<p>下面看示例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.i=i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot;=====&quot;</span>+i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">\t\tExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">\t\t\tcachedThreadPool.execute(<span class=\"keyword\">new</span> Test(i));</span><br><span class=\"line\">\t\t\tThread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>线程池是一个庞大而复杂的体系，本系列文章定位是基础，不对其做更深入的研究，感兴趣的小伙伴可以自行查资料进行学习。</p>\n<h3 id=\"ScheduledExecutorService\"><a href=\"#ScheduledExecutorService\" class=\"headerlink\" title=\"ScheduledExecutorService\"></a>ScheduledExecutorService</h3><p>newScheduledThreadPool(int corePoolSize)会返回一个ScheduledExecutorService对象，可以根据时间对线程进行调度；其下有三个执行线程任务的方法：schedule()，scheduleAtFixedRate()，scheduleWithFixedDelay()；该线程池可解决定时任务的问题。</p>\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String testStr;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Test(String testStr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.testStr = testStr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(testStr + <span class=\"string\">&quot; &gt;&gt;&gt;&gt; print&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> wait = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> period = <span class=\"number\">1</span>;</span><br><span class=\"line\">        service.scheduleAtFixedRate(<span class=\"keyword\">new</span> MyScheduledExecutor(<span class=\"string\">&quot;job1&quot;</span>), wait, period, TimeUnit.SECONDS);</span><br><span class=\"line\">        service.scheduleWithFixedDelay(<span class=\"keyword\">new</span> MyScheduledExecutor(<span class=\"string\">&quot;job2&quot;</span>), wait, period, TimeUnit.SECONDS);</span><br><span class=\"line\">        scheduledExecutorService.schedule(<span class=\"keyword\">new</span> MyScheduledExecutor(<span class=\"string\">&quot;job3&quot;</span>), wait, TimeUnit.SECONDS);<span class=\"comment\">//延时waits 执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>job1的执行方式是任务发起后间隔<code>wait</code>秒开始执行，每隔<code>period</code>秒(注意：不包括上一个线程的执行时间)执行一次；</p>\n<p>job2的执行方式是任务发起后间隔<code>wait</code>秒开始执行，等线程结束后隔<code>period</code>秒开始执行下一个线程；</p>\n<p>job3只执行一次，延迟<code>wait</code>秒执行；</p>\n<p>ScheduledExecutorService还可以配合Callable使用来回调获得线程执行结果，还可以取消队列中的执行任务等操作，这属于比较复杂的用法，我们这里掌握基本的即可，到实际遇到相应的问题时我们在现学现用，节省学习成本。</p>"},{"title":"多线程编程进阶篇","date":"2019-04-23T01:24:43.000Z","_content":"\n作者：muggle\n\n ## 锁优化\n\n### 减小锁持有时间\n\n减小锁的持有时间可有效的减少锁的竞争。如果线程持有锁的时间越长，那么锁的竞争程度就会越激烈。因此，应尽可能减少线程对某个锁的占有时间，进而减少线程间互斥的可能。\n\n减少锁持有时间的方法有：\n\n- 进行条件判断，只对必要的情况进行加锁，而不是整个方法加锁；\n- 减少加锁代码的行数，只对必要的步骤加锁。\n\n<!--more-->\n\n### 减小锁粒度\n\n减小锁的范围，减少锁住的代码行数可减少锁范围，减小共享资源的范围也可减小锁的范围。减小锁共享资源的范围的方式比较常见的有分段锁，比如`ConcurrentHashMap`，它将数据分为了多段，当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。\n\n### 锁分离 \n\n锁分离最常见的操作就是读写分离了，读写分离的操作参考**ReadWriteLock**章节，而对读写分离进一步的延伸就是锁分离了。为了提高线程的并行量，我们可以针对不同的功能（情形）采用不同的锁，而不是统统用同一把锁。比如说有一个同步方法未进行锁分离之前，它只有一把锁，任何线程来了，只有拿到锁才有资格运行；进行锁分离之后就不是这种情形了——来一个线程，先判断一下它要干嘛，然后发一个对应的锁给它，这样就能一定程度上提高线程的并行数。\n\n### 锁粗化\n\n一般为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，也就是说锁住的代码尽量少。但是如果如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。比如有三个步骤：a、b、c，a同步，b不同步，c同步；那么一个线程来时候会上锁释放锁然后又上锁释放锁。这样反而可能会降低线程的执行效率，这个时候我们可能将锁粗化可能会更好——执行a的时候上锁，执行完c再释放锁\n\n## 锁扩展\n\n### 分布式锁\n\njdk提供的锁在单体项目中不会有什么问题，但是在集群项目中就会有问题了。在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。jdk锁显然无法满足我们的需求，于是就有了分布式锁。\n\n分布式锁的实现有三种方式：\n\n- 基于数据库实现分布式锁\n- 基于缓存（redis，memcached，tair）实现分布式锁 \n- 基于Zookeeper实现分布式锁\n\n基于redis的分布式锁比较使用普遍，在这里介绍其原理和使用。redis实现锁的机制是setnx指令，setnx是原子操作命令，锁存在不能设置值，返回0；锁不存在，则设置锁，返回1，根据返回值来判断上锁是否成功。看到这里你可能想为啥不先get有没有值，再set上锁；首先我们要知道，redis是单线程的，同一时刻只有可能有一个线程操作内存，然后setnx 是一个操作步骤(具有原子性)，而get再set是两个步骤（不具有原子性）。如果使用第二种可能会发生这种情况：客户端 a get发现没有锁，这个时候被切换到客户端b，b get也发现没锁，然后b set，这个时候又切换到a客户端 a set；这种情况下，锁完全没起作用。所以，redis分布式锁，原子性是关键。\n\n对于web应用中redis客户端用的比较多的是lettuce，jedis，redisson。springboot的redis的start包底层是lettuce，但对redis分布式锁支持得最好的是redisson（如果用redisson你就享受不到redis自动化配置的好处了）；不过springboot的redisTemplete支持手写lua脚本，我们可以通过手写lua脚本来实现redis锁\n\n代码示例：\n\n```java\npublic boolean lockByLua(String key, String value, Long expiredTime){\n        String strExprie = String.valueOf(expiredTime);\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"if redis.call(\\\"setnx\\\",KEYS[1],ARGV[1])==1 \");\n        sb.append(\"then \");\n        sb.append(\"    redis.call(\\\"pexpire\\\",KEYS[1],KEYS[2]) \");\n        sb.append(\"    return 1 \");\n        sb.append(\"else \");\n        sb.append(\"    return 0 \");\n        sb.append(\"end \");\n        String script = sb.toString();\n        RedisCallback<Boolean> callback = (connection) -> {\n            return connection.eval(script.getBytes(), ReturnType.BOOLEAN, 2, key.getBytes(Charset.forName(\"UTF-8\")),strExprie.getBytes(Charset.forName(\"UTF-8\")), value.getBytes(Charset.forName(\"UTF-8\")));\n        };\n        Boolean execute = stringRedisTemplate.execute(callback);\n        return execute;\n    }\n```\n\n关于lua脚本的语法我就不做介绍了。\n\n在github上也有开源的redis锁项目，比如[spring-boot-klock-starter](https://github.com/kekingcn/spring-boot-klock-starter) 感兴趣的小伙伴可以去试用一下。\n\n### 数据库锁     \n\n对于存在多线程问题的项目，比如商品货物的进销存，订单系统单据流转这种，我们可以通过代码上锁来控制并发，也可以使用数据库锁来控制并发，数据库锁从机制上来说分数据库锁分乐观锁和悲观锁。\n\n悲观锁：\n\n悲观锁分为共享锁（S锁）和排他锁（X锁），mysql数据库读操作分为三种——快照读，当前读；快照读就是普通的读操作，如：\n\n```sql\nselect *from table\n```\n\n当前读就是对数据库上悲观锁了；其中\n\n```sql\nselect ... lock in share mode\n```\n\n属于共享锁，多个事务对于同一数据可以共享，但只能读不能修改。而下面三种sql\n\n```sql\nselect ...for update\nupdate ... set...\ninsert into ...\n```\n\n属于排他锁，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改，排他锁是阻塞锁。\n\n乐观锁：\n\n就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，如果有则更新失败。一种实现方式为在数据库表中加一个版本号字段version，任何update语句where 后面都要跟上version=？，并且每次update版本号都加1。如果a线程要修改某条数据，它需要先select快照读获得版本号，然后update，同时版本号加一。这样就保证了在a线程修改某条数据的时候，确保其他线程没有修改过这条数据，一旦其他线程修改过，就会导致a线程版本号对不上而更新失败（这其实是一个简化版的mvcc）。\n\n乐观锁适用于允许更新失败的业务场景，悲观锁适用于确保更新操作被执行的场景。\n\n## 并发编程相关\n\n- 善用java 8 Stream\n- 对于生产者消费者模式，条件判断是使用while而不是if\n- 懒汉单例采用双重检查和锁保证线程安全\n- 善用Future模式\n- 合理使用ThreadLocal\n\njava8引入lambda表达式使在java中使用函数式编程很方便。而java8中的stream对数据的处理能使线程执行速度得以优化。Future模式是一种对异步线程的回调机制；现在cpu都是多核的，我们在处理一些较为费时的任务时可使用异步，在后台开启多个线程同时处理，等到异步线程处理完再通过Future回调拿到处理的结果。\n\nThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量(这里原理就不说了，网上资料很多)，总之就是我们如果想在多线程的类里面使用线程安全的变量就用ThreadLocal。但是请一定要注意**用完记得remove**，不然会发生内存泄漏。\n\n## 总结\n\n随着后端发展，现在单体项目越来越少，基本上都是集群和分布式，这样也使得jdk的锁慢慢变得无用武之地。但是万变不离其宗，虽然锁的实现方式变了，但其机制是没变的；无论是分布式锁还是jdk锁，其目的和处理方式都是一个机制，只是处理对象不一样而已。\n\n我们在平时编写程序时对多线程最应该注意的就是线程优化和锁问题。我们脑中要对锁机制有一套体系，而对线程的优化经验在于平时的积累和留心。\n\n","source":"_posts/thread-3.md","raw":"---\ntitle: 多线程编程进阶篇\ndate: 2019-04-23 09:24:43\ntags: thread\n---\n\n作者：muggle\n\n ## 锁优化\n\n### 减小锁持有时间\n\n减小锁的持有时间可有效的减少锁的竞争。如果线程持有锁的时间越长，那么锁的竞争程度就会越激烈。因此，应尽可能减少线程对某个锁的占有时间，进而减少线程间互斥的可能。\n\n减少锁持有时间的方法有：\n\n- 进行条件判断，只对必要的情况进行加锁，而不是整个方法加锁；\n- 减少加锁代码的行数，只对必要的步骤加锁。\n\n<!--more-->\n\n### 减小锁粒度\n\n减小锁的范围，减少锁住的代码行数可减少锁范围，减小共享资源的范围也可减小锁的范围。减小锁共享资源的范围的方式比较常见的有分段锁，比如`ConcurrentHashMap`，它将数据分为了多段，当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。\n\n### 锁分离 \n\n锁分离最常见的操作就是读写分离了，读写分离的操作参考**ReadWriteLock**章节，而对读写分离进一步的延伸就是锁分离了。为了提高线程的并行量，我们可以针对不同的功能（情形）采用不同的锁，而不是统统用同一把锁。比如说有一个同步方法未进行锁分离之前，它只有一把锁，任何线程来了，只有拿到锁才有资格运行；进行锁分离之后就不是这种情形了——来一个线程，先判断一下它要干嘛，然后发一个对应的锁给它，这样就能一定程度上提高线程的并行数。\n\n### 锁粗化\n\n一般为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，也就是说锁住的代码尽量少。但是如果如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。比如有三个步骤：a、b、c，a同步，b不同步，c同步；那么一个线程来时候会上锁释放锁然后又上锁释放锁。这样反而可能会降低线程的执行效率，这个时候我们可能将锁粗化可能会更好——执行a的时候上锁，执行完c再释放锁\n\n## 锁扩展\n\n### 分布式锁\n\njdk提供的锁在单体项目中不会有什么问题，但是在集群项目中就会有问题了。在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。jdk锁显然无法满足我们的需求，于是就有了分布式锁。\n\n分布式锁的实现有三种方式：\n\n- 基于数据库实现分布式锁\n- 基于缓存（redis，memcached，tair）实现分布式锁 \n- 基于Zookeeper实现分布式锁\n\n基于redis的分布式锁比较使用普遍，在这里介绍其原理和使用。redis实现锁的机制是setnx指令，setnx是原子操作命令，锁存在不能设置值，返回0；锁不存在，则设置锁，返回1，根据返回值来判断上锁是否成功。看到这里你可能想为啥不先get有没有值，再set上锁；首先我们要知道，redis是单线程的，同一时刻只有可能有一个线程操作内存，然后setnx 是一个操作步骤(具有原子性)，而get再set是两个步骤（不具有原子性）。如果使用第二种可能会发生这种情况：客户端 a get发现没有锁，这个时候被切换到客户端b，b get也发现没锁，然后b set，这个时候又切换到a客户端 a set；这种情况下，锁完全没起作用。所以，redis分布式锁，原子性是关键。\n\n对于web应用中redis客户端用的比较多的是lettuce，jedis，redisson。springboot的redis的start包底层是lettuce，但对redis分布式锁支持得最好的是redisson（如果用redisson你就享受不到redis自动化配置的好处了）；不过springboot的redisTemplete支持手写lua脚本，我们可以通过手写lua脚本来实现redis锁\n\n代码示例：\n\n```java\npublic boolean lockByLua(String key, String value, Long expiredTime){\n        String strExprie = String.valueOf(expiredTime);\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"if redis.call(\\\"setnx\\\",KEYS[1],ARGV[1])==1 \");\n        sb.append(\"then \");\n        sb.append(\"    redis.call(\\\"pexpire\\\",KEYS[1],KEYS[2]) \");\n        sb.append(\"    return 1 \");\n        sb.append(\"else \");\n        sb.append(\"    return 0 \");\n        sb.append(\"end \");\n        String script = sb.toString();\n        RedisCallback<Boolean> callback = (connection) -> {\n            return connection.eval(script.getBytes(), ReturnType.BOOLEAN, 2, key.getBytes(Charset.forName(\"UTF-8\")),strExprie.getBytes(Charset.forName(\"UTF-8\")), value.getBytes(Charset.forName(\"UTF-8\")));\n        };\n        Boolean execute = stringRedisTemplate.execute(callback);\n        return execute;\n    }\n```\n\n关于lua脚本的语法我就不做介绍了。\n\n在github上也有开源的redis锁项目，比如[spring-boot-klock-starter](https://github.com/kekingcn/spring-boot-klock-starter) 感兴趣的小伙伴可以去试用一下。\n\n### 数据库锁     \n\n对于存在多线程问题的项目，比如商品货物的进销存，订单系统单据流转这种，我们可以通过代码上锁来控制并发，也可以使用数据库锁来控制并发，数据库锁从机制上来说分数据库锁分乐观锁和悲观锁。\n\n悲观锁：\n\n悲观锁分为共享锁（S锁）和排他锁（X锁），mysql数据库读操作分为三种——快照读，当前读；快照读就是普通的读操作，如：\n\n```sql\nselect *from table\n```\n\n当前读就是对数据库上悲观锁了；其中\n\n```sql\nselect ... lock in share mode\n```\n\n属于共享锁，多个事务对于同一数据可以共享，但只能读不能修改。而下面三种sql\n\n```sql\nselect ...for update\nupdate ... set...\ninsert into ...\n```\n\n属于排他锁，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改，排他锁是阻塞锁。\n\n乐观锁：\n\n就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，如果有则更新失败。一种实现方式为在数据库表中加一个版本号字段version，任何update语句where 后面都要跟上version=？，并且每次update版本号都加1。如果a线程要修改某条数据，它需要先select快照读获得版本号，然后update，同时版本号加一。这样就保证了在a线程修改某条数据的时候，确保其他线程没有修改过这条数据，一旦其他线程修改过，就会导致a线程版本号对不上而更新失败（这其实是一个简化版的mvcc）。\n\n乐观锁适用于允许更新失败的业务场景，悲观锁适用于确保更新操作被执行的场景。\n\n## 并发编程相关\n\n- 善用java 8 Stream\n- 对于生产者消费者模式，条件判断是使用while而不是if\n- 懒汉单例采用双重检查和锁保证线程安全\n- 善用Future模式\n- 合理使用ThreadLocal\n\njava8引入lambda表达式使在java中使用函数式编程很方便。而java8中的stream对数据的处理能使线程执行速度得以优化。Future模式是一种对异步线程的回调机制；现在cpu都是多核的，我们在处理一些较为费时的任务时可使用异步，在后台开启多个线程同时处理，等到异步线程处理完再通过Future回调拿到处理的结果。\n\nThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量(这里原理就不说了，网上资料很多)，总之就是我们如果想在多线程的类里面使用线程安全的变量就用ThreadLocal。但是请一定要注意**用完记得remove**，不然会发生内存泄漏。\n\n## 总结\n\n随着后端发展，现在单体项目越来越少，基本上都是集群和分布式，这样也使得jdk的锁慢慢变得无用武之地。但是万变不离其宗，虽然锁的实现方式变了，但其机制是没变的；无论是分布式锁还是jdk锁，其目的和处理方式都是一个机制，只是处理对象不一样而已。\n\n我们在平时编写程序时对多线程最应该注意的就是线程优化和锁问题。我们脑中要对锁机制有一套体系，而对线程的优化经验在于平时的积累和留心。\n\n","slug":"thread-3","published":1,"updated":"2021-01-11T07:31:23.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh73004e00wi40hx2587","content":"<p>作者：muggle</p>\n<h2 id=\"锁优化\"><a href=\"#锁优化\" class=\"headerlink\" title=\"锁优化\"></a>锁优化</h2><h3 id=\"减小锁持有时间\"><a href=\"#减小锁持有时间\" class=\"headerlink\" title=\"减小锁持有时间\"></a>减小锁持有时间</h3><p>减小锁的持有时间可有效的减少锁的竞争。如果线程持有锁的时间越长，那么锁的竞争程度就会越激烈。因此，应尽可能减少线程对某个锁的占有时间，进而减少线程间互斥的可能。</p>\n<p>减少锁持有时间的方法有：</p>\n<ul>\n<li>进行条件判断，只对必要的情况进行加锁，而不是整个方法加锁；</li>\n<li>减少加锁代码的行数，只对必要的步骤加锁。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"减小锁粒度\"><a href=\"#减小锁粒度\" class=\"headerlink\" title=\"减小锁粒度\"></a>减小锁粒度</h3><p>减小锁的范围，减少锁住的代码行数可减少锁范围，减小共享资源的范围也可减小锁的范围。减小锁共享资源的范围的方式比较常见的有分段锁，比如<code>ConcurrentHashMap</code>，它将数据分为了多段，当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p>\n<h3 id=\"锁分离\"><a href=\"#锁分离\" class=\"headerlink\" title=\"锁分离\"></a>锁分离</h3><p>锁分离最常见的操作就是读写分离了，读写分离的操作参考<strong>ReadWriteLock</strong>章节，而对读写分离进一步的延伸就是锁分离了。为了提高线程的并行量，我们可以针对不同的功能（情形）采用不同的锁，而不是统统用同一把锁。比如说有一个同步方法未进行锁分离之前，它只有一把锁，任何线程来了，只有拿到锁才有资格运行；进行锁分离之后就不是这种情形了——来一个线程，先判断一下它要干嘛，然后发一个对应的锁给它，这样就能一定程度上提高线程的并行数。</p>\n<h3 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h3><p>一般为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，也就是说锁住的代码尽量少。但是如果如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。比如有三个步骤：a、b、c，a同步，b不同步，c同步；那么一个线程来时候会上锁释放锁然后又上锁释放锁。这样反而可能会降低线程的执行效率，这个时候我们可能将锁粗化可能会更好——执行a的时候上锁，执行完c再释放锁</p>\n<h2 id=\"锁扩展\"><a href=\"#锁扩展\" class=\"headerlink\" title=\"锁扩展\"></a>锁扩展</h2><h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><p>jdk提供的锁在单体项目中不会有什么问题，但是在集群项目中就会有问题了。在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。jdk锁显然无法满足我们的需求，于是就有了分布式锁。</p>\n<p>分布式锁的实现有三种方式：</p>\n<ul>\n<li>基于数据库实现分布式锁</li>\n<li>基于缓存（redis，memcached，tair）实现分布式锁 </li>\n<li>基于Zookeeper实现分布式锁</li>\n</ul>\n<p>基于redis的分布式锁比较使用普遍，在这里介绍其原理和使用。redis实现锁的机制是setnx指令，setnx是原子操作命令，锁存在不能设置值，返回0；锁不存在，则设置锁，返回1，根据返回值来判断上锁是否成功。看到这里你可能想为啥不先get有没有值，再set上锁；首先我们要知道，redis是单线程的，同一时刻只有可能有一个线程操作内存，然后setnx 是一个操作步骤(具有原子性)，而get再set是两个步骤（不具有原子性）。如果使用第二种可能会发生这种情况：客户端 a get发现没有锁，这个时候被切换到客户端b，b get也发现没锁，然后b set，这个时候又切换到a客户端 a set；这种情况下，锁完全没起作用。所以，redis分布式锁，原子性是关键。</p>\n<p>对于web应用中redis客户端用的比较多的是lettuce，jedis，redisson。springboot的redis的start包底层是lettuce，但对redis分布式锁支持得最好的是redisson（如果用redisson你就享受不到redis自动化配置的好处了）；不过springboot的redisTemplete支持手写lua脚本，我们可以通过手写lua脚本来实现redis锁</p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lockByLua</span><span class=\"params\">(String key, String value, Long expiredTime)</span></span>&#123;</span><br><span class=\"line\">        String strExprie = String.valueOf(expiredTime);</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;if redis.call(\\&quot;setnx\\&quot;,KEYS[1],ARGV[1])==1 &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;then &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;    redis.call(\\&quot;pexpire\\&quot;,KEYS[1],KEYS[2]) &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;    return 1 &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;else &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;    return 0 &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;end &quot;</span>);</span><br><span class=\"line\">        String script = sb.toString();</span><br><span class=\"line\">        RedisCallback&lt;Boolean&gt; callback = (connection) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> connection.eval(script.getBytes(), ReturnType.BOOLEAN, <span class=\"number\">2</span>, key.getBytes(Charset.forName(<span class=\"string\">&quot;UTF-8&quot;</span>)),strExprie.getBytes(Charset.forName(<span class=\"string\">&quot;UTF-8&quot;</span>)), value.getBytes(Charset.forName(<span class=\"string\">&quot;UTF-8&quot;</span>)));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Boolean execute = stringRedisTemplate.execute(callback);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> execute;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>关于lua脚本的语法我就不做介绍了。</p>\n<p>在github上也有开源的redis锁项目，比如<a href=\"https://github.com/kekingcn/spring-boot-klock-starter\">spring-boot-klock-starter</a> 感兴趣的小伙伴可以去试用一下。</p>\n<h3 id=\"数据库锁\"><a href=\"#数据库锁\" class=\"headerlink\" title=\"数据库锁\"></a>数据库锁</h3><p>对于存在多线程问题的项目，比如商品货物的进销存，订单系统单据流转这种，我们可以通过代码上锁来控制并发，也可以使用数据库锁来控制并发，数据库锁从机制上来说分数据库锁分乐观锁和悲观锁。</p>\n<p>悲观锁：</p>\n<p>悲观锁分为共享锁（S锁）和排他锁（X锁），mysql数据库读操作分为三种——快照读，当前读；快照读就是普通的读操作，如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span><span class=\"keyword\">from</span> <span class=\"keyword\">table</span></span><br></pre></td></tr></table></figure>\n<p>当前读就是对数据库上悲观锁了；其中</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> ... lock <span class=\"keyword\">in</span> share mode</span><br></pre></td></tr></table></figure>\n<p>属于共享锁，多个事务对于同一数据可以共享，但只能读不能修改。而下面三种sql</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> ...<span class=\"keyword\">for</span> <span class=\"keyword\">update</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> ... set...</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> ...</span><br></pre></td></tr></table></figure>\n<p>属于排他锁，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改，排他锁是阻塞锁。</p>\n<p>乐观锁：</p>\n<p>就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，如果有则更新失败。一种实现方式为在数据库表中加一个版本号字段version，任何update语句where 后面都要跟上version=？，并且每次update版本号都加1。如果a线程要修改某条数据，它需要先select快照读获得版本号，然后update，同时版本号加一。这样就保证了在a线程修改某条数据的时候，确保其他线程没有修改过这条数据，一旦其他线程修改过，就会导致a线程版本号对不上而更新失败（这其实是一个简化版的mvcc）。</p>\n<p>乐观锁适用于允许更新失败的业务场景，悲观锁适用于确保更新操作被执行的场景。</p>\n<h2 id=\"并发编程相关\"><a href=\"#并发编程相关\" class=\"headerlink\" title=\"并发编程相关\"></a>并发编程相关</h2><ul>\n<li>善用java 8 Stream</li>\n<li>对于生产者消费者模式，条件判断是使用while而不是if</li>\n<li>懒汉单例采用双重检查和锁保证线程安全</li>\n<li>善用Future模式</li>\n<li>合理使用ThreadLocal</li>\n</ul>\n<p>java8引入lambda表达式使在java中使用函数式编程很方便。而java8中的stream对数据的处理能使线程执行速度得以优化。Future模式是一种对异步线程的回调机制；现在cpu都是多核的，我们在处理一些较为费时的任务时可使用异步，在后台开启多个线程同时处理，等到异步线程处理完再通过Future回调拿到处理的结果。</p>\n<p>ThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量(这里原理就不说了，网上资料很多)，总之就是我们如果想在多线程的类里面使用线程安全的变量就用ThreadLocal。但是请一定要注意<strong>用完记得remove</strong>，不然会发生内存泄漏。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>随着后端发展，现在单体项目越来越少，基本上都是集群和分布式，这样也使得jdk的锁慢慢变得无用武之地。但是万变不离其宗，虽然锁的实现方式变了，但其机制是没变的；无论是分布式锁还是jdk锁，其目的和处理方式都是一个机制，只是处理对象不一样而已。</p>\n<p>我们在平时编写程序时对多线程最应该注意的就是线程优化和锁问题。我们脑中要对锁机制有一套体系，而对线程的优化经验在于平时的积累和留心。</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h2 id=\"锁优化\"><a href=\"#锁优化\" class=\"headerlink\" title=\"锁优化\"></a>锁优化</h2><h3 id=\"减小锁持有时间\"><a href=\"#减小锁持有时间\" class=\"headerlink\" title=\"减小锁持有时间\"></a>减小锁持有时间</h3><p>减小锁的持有时间可有效的减少锁的竞争。如果线程持有锁的时间越长，那么锁的竞争程度就会越激烈。因此，应尽可能减少线程对某个锁的占有时间，进而减少线程间互斥的可能。</p>\n<p>减少锁持有时间的方法有：</p>\n<ul>\n<li>进行条件判断，只对必要的情况进行加锁，而不是整个方法加锁；</li>\n<li>减少加锁代码的行数，只对必要的步骤加锁。</li>\n</ul>","more":"<h3 id=\"减小锁粒度\"><a href=\"#减小锁粒度\" class=\"headerlink\" title=\"减小锁粒度\"></a>减小锁粒度</h3><p>减小锁的范围，减少锁住的代码行数可减少锁范围，减小共享资源的范围也可减小锁的范围。减小锁共享资源的范围的方式比较常见的有分段锁，比如<code>ConcurrentHashMap</code>，它将数据分为了多段，当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p>\n<h3 id=\"锁分离\"><a href=\"#锁分离\" class=\"headerlink\" title=\"锁分离\"></a>锁分离</h3><p>锁分离最常见的操作就是读写分离了，读写分离的操作参考<strong>ReadWriteLock</strong>章节，而对读写分离进一步的延伸就是锁分离了。为了提高线程的并行量，我们可以针对不同的功能（情形）采用不同的锁，而不是统统用同一把锁。比如说有一个同步方法未进行锁分离之前，它只有一把锁，任何线程来了，只有拿到锁才有资格运行；进行锁分离之后就不是这种情形了——来一个线程，先判断一下它要干嘛，然后发一个对应的锁给它，这样就能一定程度上提高线程的并行数。</p>\n<h3 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h3><p>一般为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，也就是说锁住的代码尽量少。但是如果如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。比如有三个步骤：a、b、c，a同步，b不同步，c同步；那么一个线程来时候会上锁释放锁然后又上锁释放锁。这样反而可能会降低线程的执行效率，这个时候我们可能将锁粗化可能会更好——执行a的时候上锁，执行完c再释放锁</p>\n<h2 id=\"锁扩展\"><a href=\"#锁扩展\" class=\"headerlink\" title=\"锁扩展\"></a>锁扩展</h2><h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><p>jdk提供的锁在单体项目中不会有什么问题，但是在集群项目中就会有问题了。在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。jdk锁显然无法满足我们的需求，于是就有了分布式锁。</p>\n<p>分布式锁的实现有三种方式：</p>\n<ul>\n<li>基于数据库实现分布式锁</li>\n<li>基于缓存（redis，memcached，tair）实现分布式锁 </li>\n<li>基于Zookeeper实现分布式锁</li>\n</ul>\n<p>基于redis的分布式锁比较使用普遍，在这里介绍其原理和使用。redis实现锁的机制是setnx指令，setnx是原子操作命令，锁存在不能设置值，返回0；锁不存在，则设置锁，返回1，根据返回值来判断上锁是否成功。看到这里你可能想为啥不先get有没有值，再set上锁；首先我们要知道，redis是单线程的，同一时刻只有可能有一个线程操作内存，然后setnx 是一个操作步骤(具有原子性)，而get再set是两个步骤（不具有原子性）。如果使用第二种可能会发生这种情况：客户端 a get发现没有锁，这个时候被切换到客户端b，b get也发现没锁，然后b set，这个时候又切换到a客户端 a set；这种情况下，锁完全没起作用。所以，redis分布式锁，原子性是关键。</p>\n<p>对于web应用中redis客户端用的比较多的是lettuce，jedis，redisson。springboot的redis的start包底层是lettuce，但对redis分布式锁支持得最好的是redisson（如果用redisson你就享受不到redis自动化配置的好处了）；不过springboot的redisTemplete支持手写lua脚本，我们可以通过手写lua脚本来实现redis锁</p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lockByLua</span><span class=\"params\">(String key, String value, Long expiredTime)</span></span>&#123;</span><br><span class=\"line\">        String strExprie = String.valueOf(expiredTime);</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;if redis.call(\\&quot;setnx\\&quot;,KEYS[1],ARGV[1])==1 &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;then &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;    redis.call(\\&quot;pexpire\\&quot;,KEYS[1],KEYS[2]) &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;    return 1 &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;else &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;    return 0 &quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;end &quot;</span>);</span><br><span class=\"line\">        String script = sb.toString();</span><br><span class=\"line\">        RedisCallback&lt;Boolean&gt; callback = (connection) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> connection.eval(script.getBytes(), ReturnType.BOOLEAN, <span class=\"number\">2</span>, key.getBytes(Charset.forName(<span class=\"string\">&quot;UTF-8&quot;</span>)),strExprie.getBytes(Charset.forName(<span class=\"string\">&quot;UTF-8&quot;</span>)), value.getBytes(Charset.forName(<span class=\"string\">&quot;UTF-8&quot;</span>)));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Boolean execute = stringRedisTemplate.execute(callback);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> execute;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>关于lua脚本的语法我就不做介绍了。</p>\n<p>在github上也有开源的redis锁项目，比如<a href=\"https://github.com/kekingcn/spring-boot-klock-starter\">spring-boot-klock-starter</a> 感兴趣的小伙伴可以去试用一下。</p>\n<h3 id=\"数据库锁\"><a href=\"#数据库锁\" class=\"headerlink\" title=\"数据库锁\"></a>数据库锁</h3><p>对于存在多线程问题的项目，比如商品货物的进销存，订单系统单据流转这种，我们可以通过代码上锁来控制并发，也可以使用数据库锁来控制并发，数据库锁从机制上来说分数据库锁分乐观锁和悲观锁。</p>\n<p>悲观锁：</p>\n<p>悲观锁分为共享锁（S锁）和排他锁（X锁），mysql数据库读操作分为三种——快照读，当前读；快照读就是普通的读操作，如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span><span class=\"keyword\">from</span> <span class=\"keyword\">table</span></span><br></pre></td></tr></table></figure>\n<p>当前读就是对数据库上悲观锁了；其中</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> ... lock <span class=\"keyword\">in</span> share mode</span><br></pre></td></tr></table></figure>\n<p>属于共享锁，多个事务对于同一数据可以共享，但只能读不能修改。而下面三种sql</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> ...<span class=\"keyword\">for</span> <span class=\"keyword\">update</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> ... set...</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> ...</span><br></pre></td></tr></table></figure>\n<p>属于排他锁，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改，排他锁是阻塞锁。</p>\n<p>乐观锁：</p>\n<p>就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，如果有则更新失败。一种实现方式为在数据库表中加一个版本号字段version，任何update语句where 后面都要跟上version=？，并且每次update版本号都加1。如果a线程要修改某条数据，它需要先select快照读获得版本号，然后update，同时版本号加一。这样就保证了在a线程修改某条数据的时候，确保其他线程没有修改过这条数据，一旦其他线程修改过，就会导致a线程版本号对不上而更新失败（这其实是一个简化版的mvcc）。</p>\n<p>乐观锁适用于允许更新失败的业务场景，悲观锁适用于确保更新操作被执行的场景。</p>\n<h2 id=\"并发编程相关\"><a href=\"#并发编程相关\" class=\"headerlink\" title=\"并发编程相关\"></a>并发编程相关</h2><ul>\n<li>善用java 8 Stream</li>\n<li>对于生产者消费者模式，条件判断是使用while而不是if</li>\n<li>懒汉单例采用双重检查和锁保证线程安全</li>\n<li>善用Future模式</li>\n<li>合理使用ThreadLocal</li>\n</ul>\n<p>java8引入lambda表达式使在java中使用函数式编程很方便。而java8中的stream对数据的处理能使线程执行速度得以优化。Future模式是一种对异步线程的回调机制；现在cpu都是多核的，我们在处理一些较为费时的任务时可使用异步，在后台开启多个线程同时处理，等到异步线程处理完再通过Future回调拿到处理的结果。</p>\n<p>ThreadLocal的实例代表了一个线程局部的变量，每条线程都只能看到自己的值，并不会意识到其它的线程中也存在该变量(这里原理就不说了，网上资料很多)，总之就是我们如果想在多线程的类里面使用线程安全的变量就用ThreadLocal。但是请一定要注意<strong>用完记得remove</strong>，不然会发生内存泄漏。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>随着后端发展，现在单体项目越来越少，基本上都是集群和分布式，这样也使得jdk的锁慢慢变得无用武之地。但是万变不离其宗，虽然锁的实现方式变了，但其机制是没变的；无论是分布式锁还是jdk锁，其目的和处理方式都是一个机制，只是处理对象不一样而已。</p>\n<p>我们在平时编写程序时对多线程最应该注意的就是线程优化和锁问题。我们脑中要对锁机制有一套体系，而对线程的优化经验在于平时的积累和留心。</p>"},{"title":"windows使用技巧","date":"2019-05-01T02:04:45.000Z","_content":"\n**每次开机都启动一堆软件，很麻烦，该肿么办？**\n\n写个批处理文件 步骤（这里以启动微信为例 ）：\n\n1. 新建一个文本文档\n2. 输入以下命令：\n\n> start \"xx\" \"xxx\"\n\nxx 代表程序名称，可以随便起；xxx代表你想启动的程序的位置 获取程序位置的方法：\n\n<!--more-->\n\n> 右击程序对应的桌面快捷方式，选择属性，其中的目标栏就是程序的位置了\n\n![image](http://upload-images.jianshu.io/upload_images/13612520-236984bb739b0420?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n获得程序的位置信息\n\n3.将.txt后缀改为.bat(你的电脑可能设置隐藏后缀，让它显示出来就行)\n\n结果就像这样：\n\n![image](http://upload-images.jianshu.io/upload_images/13612520-6aa760879ee20e25?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n编写程序启动命名\n\n![image](http://upload-images.jianshu.io/upload_images/13612520-8af85a2b881eec7c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![image](http://upload-images.jianshu.io/upload_images/13612520-74ed965c7bb7ad54?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n修改文件后缀\n\n点击一下就可以启动微信了，想一次性启动多个程序在下一行添加对应的命令就可以，像这样：\n\n![image](http://upload-images.jianshu.io/upload_images/13612520-05960c45af65d05c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n编写多条启动命令\n\n这样就能做到点一下启动多个程序了。\n\n#### 一些简单好用的快捷键和命令\n\n1.  win+d:显示桌面\n\n2.  alt+tab 切换\n\n3.  win+l 锁屏\n\n4.  win+r：运行常用命令，这些命令比较好用的有cmd(控制台窗口)、control(控制面板)、mspaint(画图)、regedit(注册表)、explorer(资源管理器)、services.msc(查看服务，可以利用这个命令禁用服务列表里的windows更新程序，免得它老是提示更新)，mstsc(远程连接，需要进行相应的设置)","source":"_posts/windows.md","raw":"---\ntitle: windows使用技巧\ndate: 2019-05-01 10:04:45\ntags: tool\n---\n\n**每次开机都启动一堆软件，很麻烦，该肿么办？**\n\n写个批处理文件 步骤（这里以启动微信为例 ）：\n\n1. 新建一个文本文档\n2. 输入以下命令：\n\n> start \"xx\" \"xxx\"\n\nxx 代表程序名称，可以随便起；xxx代表你想启动的程序的位置 获取程序位置的方法：\n\n<!--more-->\n\n> 右击程序对应的桌面快捷方式，选择属性，其中的目标栏就是程序的位置了\n\n![image](http://upload-images.jianshu.io/upload_images/13612520-236984bb739b0420?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n获得程序的位置信息\n\n3.将.txt后缀改为.bat(你的电脑可能设置隐藏后缀，让它显示出来就行)\n\n结果就像这样：\n\n![image](http://upload-images.jianshu.io/upload_images/13612520-6aa760879ee20e25?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n编写程序启动命名\n\n![image](http://upload-images.jianshu.io/upload_images/13612520-8af85a2b881eec7c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![image](http://upload-images.jianshu.io/upload_images/13612520-74ed965c7bb7ad54?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n修改文件后缀\n\n点击一下就可以启动微信了，想一次性启动多个程序在下一行添加对应的命令就可以，像这样：\n\n![image](http://upload-images.jianshu.io/upload_images/13612520-05960c45af65d05c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n编写多条启动命令\n\n这样就能做到点一下启动多个程序了。\n\n#### 一些简单好用的快捷键和命令\n\n1.  win+d:显示桌面\n\n2.  alt+tab 切换\n\n3.  win+l 锁屏\n\n4.  win+r：运行常用命令，这些命令比较好用的有cmd(控制台窗口)、control(控制面板)、mspaint(画图)、regedit(注册表)、explorer(资源管理器)、services.msc(查看服务，可以利用这个命令禁用服务列表里的windows更新程序，免得它老是提示更新)，mstsc(远程连接，需要进行相应的设置)","slug":"windows","published":1,"updated":"2021-01-11T07:31:23.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh73004f00wice511plk","content":"<p><strong>每次开机都启动一堆软件，很麻烦，该肿么办？</strong></p>\n<p>写个批处理文件 步骤（这里以启动微信为例 ）：</p>\n<ol>\n<li>新建一个文本文档</li>\n<li>输入以下命令：</li>\n</ol>\n<blockquote>\n<p>start “xx” “xxx”</p>\n</blockquote>\n<p>xx 代表程序名称，可以随便起；xxx代表你想启动的程序的位置 获取程序位置的方法：</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>右击程序对应的桌面快捷方式，选择属性，其中的目标栏就是程序的位置了</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-236984bb739b0420?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>获得程序的位置信息</p>\n<p>3.将.txt后缀改为.bat(你的电脑可能设置隐藏后缀，让它显示出来就行)</p>\n<p>结果就像这样：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-6aa760879ee20e25?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>编写程序启动命名</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-8af85a2b881eec7c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-74ed965c7bb7ad54?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>修改文件后缀</p>\n<p>点击一下就可以启动微信了，想一次性启动多个程序在下一行添加对应的命令就可以，像这样：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-05960c45af65d05c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>编写多条启动命令</p>\n<p>这样就能做到点一下启动多个程序了。</p>\n<h4 id=\"一些简单好用的快捷键和命令\"><a href=\"#一些简单好用的快捷键和命令\" class=\"headerlink\" title=\"一些简单好用的快捷键和命令\"></a>一些简单好用的快捷键和命令</h4><ol>\n<li><p>win+d:显示桌面</p>\n</li>\n<li><p>alt+tab 切换</p>\n</li>\n<li><p>win+l 锁屏</p>\n</li>\n<li><p>win+r：运行常用命令，这些命令比较好用的有cmd(控制台窗口)、control(控制面板)、mspaint(画图)、regedit(注册表)、explorer(资源管理器)、services.msc(查看服务，可以利用这个命令禁用服务列表里的windows更新程序，免得它老是提示更新)，mstsc(远程连接，需要进行相应的设置)</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><strong>每次开机都启动一堆软件，很麻烦，该肿么办？</strong></p>\n<p>写个批处理文件 步骤（这里以启动微信为例 ）：</p>\n<ol>\n<li>新建一个文本文档</li>\n<li>输入以下命令：</li>\n</ol>\n<blockquote>\n<p>start “xx” “xxx”</p>\n</blockquote>\n<p>xx 代表程序名称，可以随便起；xxx代表你想启动的程序的位置 获取程序位置的方法：</p>","more":"<blockquote>\n<p>右击程序对应的桌面快捷方式，选择属性，其中的目标栏就是程序的位置了</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-236984bb739b0420?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>获得程序的位置信息</p>\n<p>3.将.txt后缀改为.bat(你的电脑可能设置隐藏后缀，让它显示出来就行)</p>\n<p>结果就像这样：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-6aa760879ee20e25?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>编写程序启动命名</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-8af85a2b881eec7c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-74ed965c7bb7ad54?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>修改文件后缀</p>\n<p>点击一下就可以启动微信了，想一次性启动多个程序在下一行添加对应的命令就可以，像这样：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/13612520-05960c45af65d05c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>编写多条启动命令</p>\n<p>这样就能做到点一下启动多个程序了。</p>\n<h4 id=\"一些简单好用的快捷键和命令\"><a href=\"#一些简单好用的快捷键和命令\" class=\"headerlink\" title=\"一些简单好用的快捷键和命令\"></a>一些简单好用的快捷键和命令</h4><ol>\n<li><p>win+d:显示桌面</p>\n</li>\n<li><p>alt+tab 切换</p>\n</li>\n<li><p>win+l 锁屏</p>\n</li>\n<li><p>win+r：运行常用命令，这些命令比较好用的有cmd(控制台窗口)、control(控制面板)、mspaint(画图)、regedit(注册表)、explorer(资源管理器)、services.msc(查看服务，可以利用这个命令禁用服务列表里的windows更新程序，免得它老是提示更新)，mstsc(远程连接，需要进行相应的设置)</p>\n</li>\n</ol>"},{"title":"zookeeper 浅解","date":"2019-06-15T09:23:46.000Z","_content":"\n从官网 https://apache.org/dist/zookeeper/zookeeper-3.5.5/ 上下载zk(注意windows也是下载 tar.gz后解压)，./conf下有个`zoo_sample.cfg` 复制到同目录下改名为`zoo.cfg`，在目录下新建data和log文件夹，修改zoo.cfg中的 dataDir 和 `dataLogDir `为 data和log的路径。现在启动zk，在bin目录下有个`zkServer.cmd`，运行启动。启动ZK客户端对ZK进行简单的读写操作，在bin目录下打开cmd，运行：\n\n<!--more-->\n\n```cmd\n./zkCli.cmd 127.0.0.1:2181\n```\n\n## 1 ZK介绍\n`zookeeper`是基于观察者模式设计的分布式服务管理框架，它负责存储和管理比较重要的分布式数据并通知观察者数据的变化状态，直白的说zookeeper是一个数据存储加消息通知系统。zookeeper的应用场景有:\n\n- 统一命名服务：在分布式系统中给每个应用配置一个全局唯一名称，并统一管理\n- 统一配置管理：将分布式系统一些配置信息放入到ZK中进行管理\n- 统一集群管理：管理监听集群状态\n- 服务节点动态上下线：实时通知应用分布式系统中有哪些服务节点。\n\nzk的特性：\n- 顺序一致性： 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。\n- 原子性： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。\n- 单一系统映像 ： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。\n- 可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。\n\n## 2 ZNode\n\nzookeeper的数据结构整体上一棵树，每个节点被称作`ZNode`，每个ZNode默认存储1MB的数据，每个ZNode 都可以通过路径唯一标识。ZNode共有四种类型：\n- 持久节点：指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点。不会因为客户端会话失效而清除；\n- 持久顺序节点：在持久节点基础上增加了有序性，其每创建一个子节点都会自动为给节点名加上一个数字后缀作为新的节点名。\n\n- 临时节点：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。\n- 临时顺序节点：在临时节点基础上增加了有序性；参考持久顺序节点。\n\n## 3 ZK指令\n在ZK的安装包中有一个ZK客户端，启动ZK客户端可在其中输入相应的指令来操作ZK，下面对这些指令做简单介绍：\n\n| 指令              | 描述                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| help              | 显示所有操作命令                                             |\n| ls path [watch]   | 查看当前节点内容                                             |\n| ls2  path [watch] | 查看当前节点数据并能看到更新次数等数据                       |\n| create            | 不带参数创建普通持久节点，-s 创建持久顺序节点 -e 创建临时节点，-s -e 创建 临时顺序节点 |\n| get path [wathc]  | 获取节点值                                                   |\n| set path          | 给节点赋值                                                   |\n| stat path         | 查看节点状态                                                 |\n| delete path       | 删除节点                                                     |\n| rmr               | 递归删除节点 (参考rm-rf）                                    |\n操作示例：\n```shell\n# 连接zk\n./zkCli.sh -server master 2181\n\n# 列出 / 下的节点\nls /\n\n# 创建节点\ncreate /zk-test \"123\"\ncreate  -s   /zk-test  “test123”\ncreate -e /zk-test123 \"test1234\"\n\n# 删除节点\ndelete /zk-test\n\n# 获取节点\nget /zk-123\n\n#更新节点\nset  /zk-123 \"d\"\n\n```\n## 4 ZK配置文件\n示例：\n```shell\n\ntickTime=2000\ndataDir=E:/zookeeper/zookeeper-3.4.8 - colony/zookeeper-1/tmp/zookeeper/\nclientPort=2181\ninitLimit=10\nsyncLimit=5\nserver.1=127.0.0.1:2888:3888\nserver.2=127.0.0.1:2889:3889\nserver.3=127.0.0.1:2890:3890\n```\n配置项说明：\n简单列举，详细参考 http://www.aboutyun.com/forum.php?mod=viewthread&tid=13909\n\n- clientPort: 客户端连接server的端口，即zk对外服务端口，一般设置为2181。\n- dataDir : 把内存中的数据存储成快照文件snapshot的目录\n- tickTime: ZK中的一个时间单元\n- syncLimit: 如果Leader发出心跳包在syncLimit之后，还没有从Follower那里收到响应，那么就认为这个Follower已经不在线了。\n\n\n## 5 ZK机制\n### 5.1 Zookeeper工作原理\nZab协议 的全称是 Zookeeper Atomic Broadcast （Zookeeper原子广播）。ZAB协议定义了 选举（election）、发现（discovery）、同步（sync）、广播(Broadcast) 四个阶段；\n选举阶段就是选举出leader。发现阶段follower节点向准leader推送自己的信息，接受准leader的newEpoch指令，检查newEpoch有效性,如果校验没有问题则正式进入一个新的leader统治时期（epoch）。同步阶段将Follower与Leader的数据进行同步，由Leader发起同步指令，最终保持集群数据的一致性；广播阶段，leader发起广播，Follower开始提交事务。\n\n为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。zxid是一个64位的数字，它高32位用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的标识，代表当前leader，低32位用于递增计数。\n在ZK集群中，Server有三种状态： \n- LOOKING：当前Server不知道leader是谁，正在搜寻\n- LEADING：当前Server即为选举出来的leader\n- FOLLOWING：leader已经选举出来，当前Server与之同步\n\n当ZK的server挂掉半数以上，leader就认为集群不能再正常工作了；所以ZK集群一般为奇数个。 \n\n### 5.2 ZK选主流程\nZK集群中每个Server启动，首先会投自己一票，然后向外对其他ZK发送报文，如果有响应则互相交换投票结果，如果结果无法确定leader是谁则继续投票。投票规则是优先投票给id最大的server，且不能重复投某个server。因此一个server若想做leader，它的id要足够大（通过配置文件配置），而且还有尽快和其他server建立通讯。\n\n\n### 5.3 Broadcast(广播)\n当客户端提交事务请求时Leader节点为每一个请求生成一个Proposal(提案)，将其发送给集群中所有的Follower节点，收到过半Follower的反馈后开始对事务进行提交；只需要得到过半的Follower节点反馈Ack（同意）就可以对事务进行提交；过半的Follower节点反馈Ack 后，leader发送commit消息同时自身也会完成事务提交，Follower 接收到 commit 消息后，会将事务提交。\n\nFollower必须保证事务的顺序一致性的，也就是说先被发送的Proposal必须先被；消息广播使用了TCP协议进行通讯所有保证了接受和发送事务的顺序性。广播消息时Leader节点为每个Proposal分配一个全局递增的ZXID（事务ID），每个Proposal都按照ZXID顺序来处理。\n\n如果我们连接上某个zk发送一个写请求，如果这个zk不是Leader，那么它会把接受到的请求进一步转发给Leader，然后leader就会执行上面的广播过程。而其他的zk就能同步写数据，保证数据一致。\n\n\n## 6  ZK面试问题\n\n- 脑裂：由于心跳超时（网络原因导致的）认为master死了，但其实master还存活着（假死），假死会发起新的master选举，选举出一个新的master。但是客户端还能和旧的master通信，导致一部分客户端连接旧master（直连）,一部分客户端连接新的master\n- znode类型：临时无序，临时有序，持久无序，持久有序\n- Zookeeper通知机制：client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到zk的通知，然后client可以根据znode变化来做出业务上的改变等。\n- 概述zk 工作原理：Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\n\n\n\n","source":"_posts/zookeeper.md","raw":"---\ntitle: zookeeper 浅解\ndate: 2019-06-15 17:23:46\ntags: 中间件\n---\n\n从官网 https://apache.org/dist/zookeeper/zookeeper-3.5.5/ 上下载zk(注意windows也是下载 tar.gz后解压)，./conf下有个`zoo_sample.cfg` 复制到同目录下改名为`zoo.cfg`，在目录下新建data和log文件夹，修改zoo.cfg中的 dataDir 和 `dataLogDir `为 data和log的路径。现在启动zk，在bin目录下有个`zkServer.cmd`，运行启动。启动ZK客户端对ZK进行简单的读写操作，在bin目录下打开cmd，运行：\n\n<!--more-->\n\n```cmd\n./zkCli.cmd 127.0.0.1:2181\n```\n\n## 1 ZK介绍\n`zookeeper`是基于观察者模式设计的分布式服务管理框架，它负责存储和管理比较重要的分布式数据并通知观察者数据的变化状态，直白的说zookeeper是一个数据存储加消息通知系统。zookeeper的应用场景有:\n\n- 统一命名服务：在分布式系统中给每个应用配置一个全局唯一名称，并统一管理\n- 统一配置管理：将分布式系统一些配置信息放入到ZK中进行管理\n- 统一集群管理：管理监听集群状态\n- 服务节点动态上下线：实时通知应用分布式系统中有哪些服务节点。\n\nzk的特性：\n- 顺序一致性： 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。\n- 原子性： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。\n- 单一系统映像 ： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。\n- 可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。\n\n## 2 ZNode\n\nzookeeper的数据结构整体上一棵树，每个节点被称作`ZNode`，每个ZNode默认存储1MB的数据，每个ZNode 都可以通过路径唯一标识。ZNode共有四种类型：\n- 持久节点：指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点。不会因为客户端会话失效而清除；\n- 持久顺序节点：在持久节点基础上增加了有序性，其每创建一个子节点都会自动为给节点名加上一个数字后缀作为新的节点名。\n\n- 临时节点：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。\n- 临时顺序节点：在临时节点基础上增加了有序性；参考持久顺序节点。\n\n## 3 ZK指令\n在ZK的安装包中有一个ZK客户端，启动ZK客户端可在其中输入相应的指令来操作ZK，下面对这些指令做简单介绍：\n\n| 指令              | 描述                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| help              | 显示所有操作命令                                             |\n| ls path [watch]   | 查看当前节点内容                                             |\n| ls2  path [watch] | 查看当前节点数据并能看到更新次数等数据                       |\n| create            | 不带参数创建普通持久节点，-s 创建持久顺序节点 -e 创建临时节点，-s -e 创建 临时顺序节点 |\n| get path [wathc]  | 获取节点值                                                   |\n| set path          | 给节点赋值                                                   |\n| stat path         | 查看节点状态                                                 |\n| delete path       | 删除节点                                                     |\n| rmr               | 递归删除节点 (参考rm-rf）                                    |\n操作示例：\n```shell\n# 连接zk\n./zkCli.sh -server master 2181\n\n# 列出 / 下的节点\nls /\n\n# 创建节点\ncreate /zk-test \"123\"\ncreate  -s   /zk-test  “test123”\ncreate -e /zk-test123 \"test1234\"\n\n# 删除节点\ndelete /zk-test\n\n# 获取节点\nget /zk-123\n\n#更新节点\nset  /zk-123 \"d\"\n\n```\n## 4 ZK配置文件\n示例：\n```shell\n\ntickTime=2000\ndataDir=E:/zookeeper/zookeeper-3.4.8 - colony/zookeeper-1/tmp/zookeeper/\nclientPort=2181\ninitLimit=10\nsyncLimit=5\nserver.1=127.0.0.1:2888:3888\nserver.2=127.0.0.1:2889:3889\nserver.3=127.0.0.1:2890:3890\n```\n配置项说明：\n简单列举，详细参考 http://www.aboutyun.com/forum.php?mod=viewthread&tid=13909\n\n- clientPort: 客户端连接server的端口，即zk对外服务端口，一般设置为2181。\n- dataDir : 把内存中的数据存储成快照文件snapshot的目录\n- tickTime: ZK中的一个时间单元\n- syncLimit: 如果Leader发出心跳包在syncLimit之后，还没有从Follower那里收到响应，那么就认为这个Follower已经不在线了。\n\n\n## 5 ZK机制\n### 5.1 Zookeeper工作原理\nZab协议 的全称是 Zookeeper Atomic Broadcast （Zookeeper原子广播）。ZAB协议定义了 选举（election）、发现（discovery）、同步（sync）、广播(Broadcast) 四个阶段；\n选举阶段就是选举出leader。发现阶段follower节点向准leader推送自己的信息，接受准leader的newEpoch指令，检查newEpoch有效性,如果校验没有问题则正式进入一个新的leader统治时期（epoch）。同步阶段将Follower与Leader的数据进行同步，由Leader发起同步指令，最终保持集群数据的一致性；广播阶段，leader发起广播，Follower开始提交事务。\n\n为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。zxid是一个64位的数字，它高32位用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的标识，代表当前leader，低32位用于递增计数。\n在ZK集群中，Server有三种状态： \n- LOOKING：当前Server不知道leader是谁，正在搜寻\n- LEADING：当前Server即为选举出来的leader\n- FOLLOWING：leader已经选举出来，当前Server与之同步\n\n当ZK的server挂掉半数以上，leader就认为集群不能再正常工作了；所以ZK集群一般为奇数个。 \n\n### 5.2 ZK选主流程\nZK集群中每个Server启动，首先会投自己一票，然后向外对其他ZK发送报文，如果有响应则互相交换投票结果，如果结果无法确定leader是谁则继续投票。投票规则是优先投票给id最大的server，且不能重复投某个server。因此一个server若想做leader，它的id要足够大（通过配置文件配置），而且还有尽快和其他server建立通讯。\n\n\n### 5.3 Broadcast(广播)\n当客户端提交事务请求时Leader节点为每一个请求生成一个Proposal(提案)，将其发送给集群中所有的Follower节点，收到过半Follower的反馈后开始对事务进行提交；只需要得到过半的Follower节点反馈Ack（同意）就可以对事务进行提交；过半的Follower节点反馈Ack 后，leader发送commit消息同时自身也会完成事务提交，Follower 接收到 commit 消息后，会将事务提交。\n\nFollower必须保证事务的顺序一致性的，也就是说先被发送的Proposal必须先被；消息广播使用了TCP协议进行通讯所有保证了接受和发送事务的顺序性。广播消息时Leader节点为每个Proposal分配一个全局递增的ZXID（事务ID），每个Proposal都按照ZXID顺序来处理。\n\n如果我们连接上某个zk发送一个写请求，如果这个zk不是Leader，那么它会把接受到的请求进一步转发给Leader，然后leader就会执行上面的广播过程。而其他的zk就能同步写数据，保证数据一致。\n\n\n## 6  ZK面试问题\n\n- 脑裂：由于心跳超时（网络原因导致的）认为master死了，但其实master还存活着（假死），假死会发起新的master选举，选举出一个新的master。但是客户端还能和旧的master通信，导致一部分客户端连接旧master（直连）,一部分客户端连接新的master\n- znode类型：临时无序，临时有序，持久无序，持久有序\n- Zookeeper通知机制：client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到zk的通知，然后client可以根据znode变化来做出业务上的改变等。\n- 概述zk 工作原理：Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。\n\n\n\n","slug":"zookeeper","published":1,"updated":"2021-01-11T07:31:23.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh74004h00wifv0dbmrt","content":"<p>从官网 <a href=\"https://apache.org/dist/zookeeper/zookeeper-3.5.5/\">https://apache.org/dist/zookeeper/zookeeper-3.5.5/</a> 上下载zk(注意windows也是下载 tar.gz后解压)，./conf下有个<code>zoo_sample.cfg</code> 复制到同目录下改名为<code>zoo.cfg</code>，在目录下新建data和log文件夹，修改zoo.cfg中的 dataDir 和 <code>dataLogDir</code>为 data和log的路径。现在启动zk，在bin目录下有个<code>zkServer.cmd</code>，运行启动。启动ZK客户端对ZK进行简单的读写操作，在bin目录下打开cmd，运行：</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./zkCli.<span class=\"built_in\">cmd</span> <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">2181</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"1-ZK介绍\"><a href=\"#1-ZK介绍\" class=\"headerlink\" title=\"1 ZK介绍\"></a>1 ZK介绍</h2><p><code>zookeeper</code>是基于观察者模式设计的分布式服务管理框架，它负责存储和管理比较重要的分布式数据并通知观察者数据的变化状态，直白的说zookeeper是一个数据存储加消息通知系统。zookeeper的应用场景有:</p>\n<ul>\n<li>统一命名服务：在分布式系统中给每个应用配置一个全局唯一名称，并统一管理</li>\n<li>统一配置管理：将分布式系统一些配置信息放入到ZK中进行管理</li>\n<li>统一集群管理：管理监听集群状态</li>\n<li>服务节点动态上下线：实时通知应用分布式系统中有哪些服务节点。</li>\n</ul>\n<p>zk的特性：</p>\n<ul>\n<li>顺序一致性： 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>\n<li>原子性： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>\n<li>单一系统映像 ： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>\n<li>可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>\n</ul>\n<h2 id=\"2-ZNode\"><a href=\"#2-ZNode\" class=\"headerlink\" title=\"2 ZNode\"></a>2 ZNode</h2><p>zookeeper的数据结构整体上一棵树，每个节点被称作<code>ZNode</code>，每个ZNode默认存储1MB的数据，每个ZNode 都可以通过路径唯一标识。ZNode共有四种类型：</p>\n<ul>\n<li><p>持久节点：指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点。不会因为客户端会话失效而清除；</p>\n</li>\n<li><p>持久顺序节点：在持久节点基础上增加了有序性，其每创建一个子节点都会自动为给节点名加上一个数字后缀作为新的节点名。</p>\n</li>\n<li><p>临时节点：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。</p>\n</li>\n<li><p>临时顺序节点：在临时节点基础上增加了有序性；参考持久顺序节点。</p>\n</li>\n</ul>\n<h2 id=\"3-ZK指令\"><a href=\"#3-ZK指令\" class=\"headerlink\" title=\"3 ZK指令\"></a>3 ZK指令</h2><p>在ZK的安装包中有一个ZK客户端，启动ZK客户端可在其中输入相应的指令来操作ZK，下面对这些指令做简单介绍：</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>help</td>\n<td>显示所有操作命令</td>\n</tr>\n<tr>\n<td>ls path [watch]</td>\n<td>查看当前节点内容</td>\n</tr>\n<tr>\n<td>ls2  path [watch]</td>\n<td>查看当前节点数据并能看到更新次数等数据</td>\n</tr>\n<tr>\n<td>create</td>\n<td>不带参数创建普通持久节点，-s 创建持久顺序节点 -e 创建临时节点，-s -e 创建 临时顺序节点</td>\n</tr>\n<tr>\n<td>get path [wathc]</td>\n<td>获取节点值</td>\n</tr>\n<tr>\n<td>set path</td>\n<td>给节点赋值</td>\n</tr>\n<tr>\n<td>stat path</td>\n<td>查看节点状态</td>\n</tr>\n<tr>\n<td>delete path</td>\n<td>删除节点</td>\n</tr>\n<tr>\n<td>rmr</td>\n<td>递归删除节点 (参考rm-rf）</td>\n</tr>\n<tr>\n<td>操作示例：</td>\n<td></td>\n</tr>\n<tr>\n<td><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 连接zk</span></span><br><span class=\"line\">./zkCli.sh -server master 2181</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 列出 / 下的节点</span></span><br><span class=\"line\">ls /</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建节点</span></span><br><span class=\"line\">create /zk-test &quot;123&quot;</span><br><span class=\"line\">create  -s   /zk-test  “test123”</span><br><span class=\"line\">create -e /zk-test123 &quot;test1234&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除节点</span></span><br><span class=\"line\">delete /zk-test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 获取节点</span></span><br><span class=\"line\">get /zk-123</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">更新节点</span></span><br><span class=\"line\">set  /zk-123 &quot;d&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></td>\n<td></td>\n</tr>\n<tr>\n<td>## 4 ZK配置文件</td>\n<td></td>\n</tr>\n<tr>\n<td>示例：</td>\n<td></td>\n</tr>\n<tr>\n<td><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">tickTime=2000</span><br><span class=\"line\">dataDir=E:/zookeeper/zookeeper-3.4.8 - colony/zookeeper-1/tmp/zookeeper/</span><br><span class=\"line\">clientPort=2181</span><br><span class=\"line\">initLimit=10</span><br><span class=\"line\">syncLimit=5</span><br><span class=\"line\">server.1=127.0.0.1:2888:3888</span><br><span class=\"line\">server.2=127.0.0.1:2889:3889</span><br><span class=\"line\">server.3=127.0.0.1:2890:3890</span><br></pre></td></tr></table></figure></td>\n<td></td>\n</tr>\n<tr>\n<td>配置项说明：</td>\n<td></td>\n</tr>\n<tr>\n<td>简单列举，详细参考 <a href=\"http://www.aboutyun.com/forum.php?mod=viewthread&amp;tid=13909\">http://www.aboutyun.com/forum.php?mod=viewthread&amp;tid=13909</a></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li>clientPort: 客户端连接server的端口，即zk对外服务端口，一般设置为2181。</li>\n<li>dataDir : 把内存中的数据存储成快照文件snapshot的目录</li>\n<li>tickTime: ZK中的一个时间单元</li>\n<li>syncLimit: 如果Leader发出心跳包在syncLimit之后，还没有从Follower那里收到响应，那么就认为这个Follower已经不在线了。</li>\n</ul>\n<h2 id=\"5-ZK机制\"><a href=\"#5-ZK机制\" class=\"headerlink\" title=\"5 ZK机制\"></a>5 ZK机制</h2><h3 id=\"5-1-Zookeeper工作原理\"><a href=\"#5-1-Zookeeper工作原理\" class=\"headerlink\" title=\"5.1 Zookeeper工作原理\"></a>5.1 Zookeeper工作原理</h3><p>Zab协议 的全称是 Zookeeper Atomic Broadcast （Zookeeper原子广播）。ZAB协议定义了 选举（election）、发现（discovery）、同步（sync）、广播(Broadcast) 四个阶段；<br>选举阶段就是选举出leader。发现阶段follower节点向准leader推送自己的信息，接受准leader的newEpoch指令，检查newEpoch有效性,如果校验没有问题则正式进入一个新的leader统治时期（epoch）。同步阶段将Follower与Leader的数据进行同步，由Leader发起同步指令，最终保持集群数据的一致性；广播阶段，leader发起广播，Follower开始提交事务。</p>\n<p>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。zxid是一个64位的数字，它高32位用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的标识，代表当前leader，低32位用于递增计数。<br>在ZK集群中，Server有三种状态： </p>\n<ul>\n<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>\n<li>LEADING：当前Server即为选举出来的leader</li>\n<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>\n</ul>\n<p>当ZK的server挂掉半数以上，leader就认为集群不能再正常工作了；所以ZK集群一般为奇数个。 </p>\n<h3 id=\"5-2-ZK选主流程\"><a href=\"#5-2-ZK选主流程\" class=\"headerlink\" title=\"5.2 ZK选主流程\"></a>5.2 ZK选主流程</h3><p>ZK集群中每个Server启动，首先会投自己一票，然后向外对其他ZK发送报文，如果有响应则互相交换投票结果，如果结果无法确定leader是谁则继续投票。投票规则是优先投票给id最大的server，且不能重复投某个server。因此一个server若想做leader，它的id要足够大（通过配置文件配置），而且还有尽快和其他server建立通讯。</p>\n<h3 id=\"5-3-Broadcast-广播\"><a href=\"#5-3-Broadcast-广播\" class=\"headerlink\" title=\"5.3 Broadcast(广播)\"></a>5.3 Broadcast(广播)</h3><p>当客户端提交事务请求时Leader节点为每一个请求生成一个Proposal(提案)，将其发送给集群中所有的Follower节点，收到过半Follower的反馈后开始对事务进行提交；只需要得到过半的Follower节点反馈Ack（同意）就可以对事务进行提交；过半的Follower节点反馈Ack 后，leader发送commit消息同时自身也会完成事务提交，Follower 接收到 commit 消息后，会将事务提交。</p>\n<p>Follower必须保证事务的顺序一致性的，也就是说先被发送的Proposal必须先被；消息广播使用了TCP协议进行通讯所有保证了接受和发送事务的顺序性。广播消息时Leader节点为每个Proposal分配一个全局递增的ZXID（事务ID），每个Proposal都按照ZXID顺序来处理。</p>\n<p>如果我们连接上某个zk发送一个写请求，如果这个zk不是Leader，那么它会把接受到的请求进一步转发给Leader，然后leader就会执行上面的广播过程。而其他的zk就能同步写数据，保证数据一致。</p>\n<h2 id=\"6-ZK面试问题\"><a href=\"#6-ZK面试问题\" class=\"headerlink\" title=\"6  ZK面试问题\"></a>6  ZK面试问题</h2><ul>\n<li>脑裂：由于心跳超时（网络原因导致的）认为master死了，但其实master还存活着（假死），假死会发起新的master选举，选举出一个新的master。但是客户端还能和旧的master通信，导致一部分客户端连接旧master（直连）,一部分客户端连接新的master</li>\n<li>znode类型：临时无序，临时有序，持久无序，持久有序</li>\n<li>Zookeeper通知机制：client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到zk的通知，然后client可以根据znode变化来做出业务上的改变等。</li>\n<li>概述zk 工作原理：Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>从官网 <a href=\"https://apache.org/dist/zookeeper/zookeeper-3.5.5/\">https://apache.org/dist/zookeeper/zookeeper-3.5.5/</a> 上下载zk(注意windows也是下载 tar.gz后解压)，./conf下有个<code>zoo_sample.cfg</code> 复制到同目录下改名为<code>zoo.cfg</code>，在目录下新建data和log文件夹，修改zoo.cfg中的 dataDir 和 <code>dataLogDir</code>为 data和log的路径。现在启动zk，在bin目录下有个<code>zkServer.cmd</code>，运行启动。启动ZK客户端对ZK进行简单的读写操作，在bin目录下打开cmd，运行：</p>","more":"<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./zkCli.<span class=\"built_in\">cmd</span> <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">2181</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"1-ZK介绍\"><a href=\"#1-ZK介绍\" class=\"headerlink\" title=\"1 ZK介绍\"></a>1 ZK介绍</h2><p><code>zookeeper</code>是基于观察者模式设计的分布式服务管理框架，它负责存储和管理比较重要的分布式数据并通知观察者数据的变化状态，直白的说zookeeper是一个数据存储加消息通知系统。zookeeper的应用场景有:</p>\n<ul>\n<li>统一命名服务：在分布式系统中给每个应用配置一个全局唯一名称，并统一管理</li>\n<li>统一配置管理：将分布式系统一些配置信息放入到ZK中进行管理</li>\n<li>统一集群管理：管理监听集群状态</li>\n<li>服务节点动态上下线：实时通知应用分布式系统中有哪些服务节点。</li>\n</ul>\n<p>zk的特性：</p>\n<ul>\n<li>顺序一致性： 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>\n<li>原子性： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>\n<li>单一系统映像 ： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>\n<li>可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>\n</ul>\n<h2 id=\"2-ZNode\"><a href=\"#2-ZNode\" class=\"headerlink\" title=\"2 ZNode\"></a>2 ZNode</h2><p>zookeeper的数据结构整体上一棵树，每个节点被称作<code>ZNode</code>，每个ZNode默认存储1MB的数据，每个ZNode 都可以通过路径唯一标识。ZNode共有四种类型：</p>\n<ul>\n<li><p>持久节点：指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点。不会因为客户端会话失效而清除；</p>\n</li>\n<li><p>持久顺序节点：在持久节点基础上增加了有序性，其每创建一个子节点都会自动为给节点名加上一个数字后缀作为新的节点名。</p>\n</li>\n<li><p>临时节点：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。</p>\n</li>\n<li><p>临时顺序节点：在临时节点基础上增加了有序性；参考持久顺序节点。</p>\n</li>\n</ul>\n<h2 id=\"3-ZK指令\"><a href=\"#3-ZK指令\" class=\"headerlink\" title=\"3 ZK指令\"></a>3 ZK指令</h2><p>在ZK的安装包中有一个ZK客户端，启动ZK客户端可在其中输入相应的指令来操作ZK，下面对这些指令做简单介绍：</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>help</td>\n<td>显示所有操作命令</td>\n</tr>\n<tr>\n<td>ls path [watch]</td>\n<td>查看当前节点内容</td>\n</tr>\n<tr>\n<td>ls2  path [watch]</td>\n<td>查看当前节点数据并能看到更新次数等数据</td>\n</tr>\n<tr>\n<td>create</td>\n<td>不带参数创建普通持久节点，-s 创建持久顺序节点 -e 创建临时节点，-s -e 创建 临时顺序节点</td>\n</tr>\n<tr>\n<td>get path [wathc]</td>\n<td>获取节点值</td>\n</tr>\n<tr>\n<td>set path</td>\n<td>给节点赋值</td>\n</tr>\n<tr>\n<td>stat path</td>\n<td>查看节点状态</td>\n</tr>\n<tr>\n<td>delete path</td>\n<td>删除节点</td>\n</tr>\n<tr>\n<td>rmr</td>\n<td>递归删除节点 (参考rm-rf）</td>\n</tr>\n<tr>\n<td>操作示例：</td>\n<td></td>\n</tr>\n<tr>\n<td><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 连接zk</span></span><br><span class=\"line\">./zkCli.sh -server master 2181</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 列出 / 下的节点</span></span><br><span class=\"line\">ls /</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建节点</span></span><br><span class=\"line\">create /zk-test &quot;123&quot;</span><br><span class=\"line\">create  -s   /zk-test  “test123”</span><br><span class=\"line\">create -e /zk-test123 &quot;test1234&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除节点</span></span><br><span class=\"line\">delete /zk-test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 获取节点</span></span><br><span class=\"line\">get /zk-123</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">更新节点</span></span><br><span class=\"line\">set  /zk-123 &quot;d&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></td>\n<td></td>\n</tr>\n<tr>\n<td>## 4 ZK配置文件</td>\n<td></td>\n</tr>\n<tr>\n<td>示例：</td>\n<td></td>\n</tr>\n<tr>\n<td><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">tickTime=2000</span><br><span class=\"line\">dataDir=E:/zookeeper/zookeeper-3.4.8 - colony/zookeeper-1/tmp/zookeeper/</span><br><span class=\"line\">clientPort=2181</span><br><span class=\"line\">initLimit=10</span><br><span class=\"line\">syncLimit=5</span><br><span class=\"line\">server.1=127.0.0.1:2888:3888</span><br><span class=\"line\">server.2=127.0.0.1:2889:3889</span><br><span class=\"line\">server.3=127.0.0.1:2890:3890</span><br></pre></td></tr></table></figure></td>\n<td></td>\n</tr>\n<tr>\n<td>配置项说明：</td>\n<td></td>\n</tr>\n<tr>\n<td>简单列举，详细参考 <a href=\"http://www.aboutyun.com/forum.php?mod=viewthread&amp;tid=13909\">http://www.aboutyun.com/forum.php?mod=viewthread&amp;tid=13909</a></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li>clientPort: 客户端连接server的端口，即zk对外服务端口，一般设置为2181。</li>\n<li>dataDir : 把内存中的数据存储成快照文件snapshot的目录</li>\n<li>tickTime: ZK中的一个时间单元</li>\n<li>syncLimit: 如果Leader发出心跳包在syncLimit之后，还没有从Follower那里收到响应，那么就认为这个Follower已经不在线了。</li>\n</ul>\n<h2 id=\"5-ZK机制\"><a href=\"#5-ZK机制\" class=\"headerlink\" title=\"5 ZK机制\"></a>5 ZK机制</h2><h3 id=\"5-1-Zookeeper工作原理\"><a href=\"#5-1-Zookeeper工作原理\" class=\"headerlink\" title=\"5.1 Zookeeper工作原理\"></a>5.1 Zookeeper工作原理</h3><p>Zab协议 的全称是 Zookeeper Atomic Broadcast （Zookeeper原子广播）。ZAB协议定义了 选举（election）、发现（discovery）、同步（sync）、广播(Broadcast) 四个阶段；<br>选举阶段就是选举出leader。发现阶段follower节点向准leader推送自己的信息，接受准leader的newEpoch指令，检查newEpoch有效性,如果校验没有问题则正式进入一个新的leader统治时期（epoch）。同步阶段将Follower与Leader的数据进行同步，由Leader发起同步指令，最终保持集群数据的一致性；广播阶段，leader发起广播，Follower开始提交事务。</p>\n<p>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。zxid是一个64位的数字，它高32位用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的标识，代表当前leader，低32位用于递增计数。<br>在ZK集群中，Server有三种状态： </p>\n<ul>\n<li>LOOKING：当前Server不知道leader是谁，正在搜寻</li>\n<li>LEADING：当前Server即为选举出来的leader</li>\n<li>FOLLOWING：leader已经选举出来，当前Server与之同步</li>\n</ul>\n<p>当ZK的server挂掉半数以上，leader就认为集群不能再正常工作了；所以ZK集群一般为奇数个。 </p>\n<h3 id=\"5-2-ZK选主流程\"><a href=\"#5-2-ZK选主流程\" class=\"headerlink\" title=\"5.2 ZK选主流程\"></a>5.2 ZK选主流程</h3><p>ZK集群中每个Server启动，首先会投自己一票，然后向外对其他ZK发送报文，如果有响应则互相交换投票结果，如果结果无法确定leader是谁则继续投票。投票规则是优先投票给id最大的server，且不能重复投某个server。因此一个server若想做leader，它的id要足够大（通过配置文件配置），而且还有尽快和其他server建立通讯。</p>\n<h3 id=\"5-3-Broadcast-广播\"><a href=\"#5-3-Broadcast-广播\" class=\"headerlink\" title=\"5.3 Broadcast(广播)\"></a>5.3 Broadcast(广播)</h3><p>当客户端提交事务请求时Leader节点为每一个请求生成一个Proposal(提案)，将其发送给集群中所有的Follower节点，收到过半Follower的反馈后开始对事务进行提交；只需要得到过半的Follower节点反馈Ack（同意）就可以对事务进行提交；过半的Follower节点反馈Ack 后，leader发送commit消息同时自身也会完成事务提交，Follower 接收到 commit 消息后，会将事务提交。</p>\n<p>Follower必须保证事务的顺序一致性的，也就是说先被发送的Proposal必须先被；消息广播使用了TCP协议进行通讯所有保证了接受和发送事务的顺序性。广播消息时Leader节点为每个Proposal分配一个全局递增的ZXID（事务ID），每个Proposal都按照ZXID顺序来处理。</p>\n<p>如果我们连接上某个zk发送一个写请求，如果这个zk不是Leader，那么它会把接受到的请求进一步转发给Leader，然后leader就会执行上面的广播过程。而其他的zk就能同步写数据，保证数据一致。</p>\n<h2 id=\"6-ZK面试问题\"><a href=\"#6-ZK面试问题\" class=\"headerlink\" title=\"6  ZK面试问题\"></a>6  ZK面试问题</h2><ul>\n<li>脑裂：由于心跳超时（网络原因导致的）认为master死了，但其实master还存活着（假死），假死会发起新的master选举，选举出一个新的master。但是客户端还能和旧的master通信，导致一部分客户端连接旧master（直连）,一部分客户端连接新的master</li>\n<li>znode类型：临时无序，临时有序，持久无序，持久有序</li>\n<li>Zookeeper通知机制：client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到zk的通知，然后client可以根据znode变化来做出业务上的改变等。</li>\n<li>概述zk 工作原理：Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</li>\n</ul>"},{"title":"在vscode中编写markdown ","date":"2019-04-12T03:50:38.000Z","_content":"作者：muggle\n\n#### 为什么要markdown\n\n&nbsp;&nbsp;markdown语法学习成本低，而且非常方便排版，如果你经常写文章，那么你就很有必要掌握markdown了，而且在vscode中编写markdown也非常方便，只需掌握几个快捷键，安装几个插件就能极大的提高你的写作效率。\n\n#### 插件安装使用\n\n##### 使用设置相关\n\nctr+shift+x 输入markdown preview enhanced下载安装，\n安装好之后新建 .md文件就能愉快的写文章了，这里对markdown语法就不做介绍了，比较简单；\n说一下插件怎么使用\nctrl+shift+v 打开预览，按F1或者ctr+shift+p输入Markdown Preview Enhanced: Customize Css 可改预览样式；对于一些常用的代码段还可以在vsocde中设置代码段快捷键，一键生成代码或文字。\n<!--more-->\n\n附上自己常用的预览样式\n\n```js\n.markdown-preview.markdown-preview {\n  background-color: rgb(46, 45, 45);\n  color: rgb(204,120,50);\n  font-size: 16px;\n  font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;\n  h1{\n    font-size: 70px;\n    color: bisque;\n  }\n  h2{\n    font-size: 55px;\n    color: bisque;\n  }\n  h3{\n    font-size: 40px;\n    color: bisque;\n  }\n  h4{\n    font-size: 30px;\n    color: bisque;\n  }\n  h5{\n    font-size: 20px;\n    color: bisque;\n  }\n  h6{\n    font-size: 15px;\n    color: bisque;\n  }\n  code{\n    color: red;\n    \n  }\n  pre{\n    // color:oldlace;\n    \n  }\n  \n  blockquote{\n    color: skyblue;\n  }\n  .slides{\n    color: antiquewhite;\n  }\n}\n\n```\n\n##### 插件使用的一些语法\n\n具体使用细节可查看[markdown preview enhanced](https://www.bookstack.cn/read/mpe/zh-cn-customize-css.md),这里只是对常用功能做介绍\n\n###### toc\n\n在你的文档里输入\n> [TOC]\n\n就能产生一个目录\n\n###### 引入外部文件\n语法为：\n> @import \"你的文件\"\n\n可引入 md 图片 html等，文件的路径为绝对路径或相对路径或者网络路径\n\n###### 制作幻灯片\n幻灯片语法为：\n```js\n---\npresentation:\n  width: 800\n  height: 600\n---\n<!-- slide -->\n在这里编写你的幻灯片。。。\n\n```\n\n##### 导出为PDF Word 等\npdf需要在 markdown 文件中的 front-matter 里声明 pdf_document 的输出类型：\n```js\n---\ntitle: \"test\"\nauthor: test\ndate: March 22, 2020\noutput: pdf_document\n---\n```\n你可以通过 path 来定义文档的输出路径。例如：\n```js\n---\ntitle: \"Habits\"\noutput:\n  pdf_document:\n    path: /Exports/Habits.pdf\n---\n```\nword需要在 markdown 文件中的 front-matter 里声明 word_document 的输出类型：\n```\n---\ntitle: \"Habits\"\nauthor: John Doe\ndate: March 22, 2005\noutput: word_document\n---\n```\n输出路径同pdf;\n\n保持为markdown可以包含所有的绘制的图形（为 png 图片），code chunks，以及数学表达式（图片形式）等等\n通过 front-matter 来设置图片的保存路径以及输出路径。\n\n```\n---\nmarkdown:\n  image_dir: /assets\n  path: output.md\n  ignore_from_front_matter: true\n  absolute_image_path: false\n---\n```\nimage_dir 可选\n定义了哪里将保存你的图片。例如，/assets 意味着所有的图片将会被保存到项目目录下的 assets 文件夹内。如果 image_dir。如果 image_dir 没有被定义，那么插件设置中的 Image save folder path 将会被使用。默认为 /assets。\n\npath 可选\n定义了哪里输出你的 markdown 文件。如果 path 没有被定义，filename_.md 将会被使用。\n\nignore_from_front_matter 可选\n如果设置为 false，那么 markdown 将会被包含于导出的文件中的 front-matter 中。\n\nabsolute_image_path 可选\n是否使用绝对（相对于项目文件夹）图片路径。\n\n\n对于vscode 中编写markdown就介绍这么多，小伙伴有任何疑问都可以与我邮件或者微信qq交流\n\n#### vscode的一些快捷键\nCtrl+n： new 一个文件\nCtrl+b: 关闭左侧菜单\nctr+左右方向键：光标跳跃到下一个单词\nalt+上下方向键：上/下移一行\nctrl+d：选中一个单词\nctrl+x:删除一行\nctrl+1/2/3:分屏\nctrl+w：关闭当前窗口","source":"_posts/在vscode中编写markdown.md","raw":"---\ntitle: '在vscode中编写markdown '\ndate: 2019-04-12 11:50:38\ntags: tool\n---\n作者：muggle\n\n#### 为什么要markdown\n\n&nbsp;&nbsp;markdown语法学习成本低，而且非常方便排版，如果你经常写文章，那么你就很有必要掌握markdown了，而且在vscode中编写markdown也非常方便，只需掌握几个快捷键，安装几个插件就能极大的提高你的写作效率。\n\n#### 插件安装使用\n\n##### 使用设置相关\n\nctr+shift+x 输入markdown preview enhanced下载安装，\n安装好之后新建 .md文件就能愉快的写文章了，这里对markdown语法就不做介绍了，比较简单；\n说一下插件怎么使用\nctrl+shift+v 打开预览，按F1或者ctr+shift+p输入Markdown Preview Enhanced: Customize Css 可改预览样式；对于一些常用的代码段还可以在vsocde中设置代码段快捷键，一键生成代码或文字。\n<!--more-->\n\n附上自己常用的预览样式\n\n```js\n.markdown-preview.markdown-preview {\n  background-color: rgb(46, 45, 45);\n  color: rgb(204,120,50);\n  font-size: 16px;\n  font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;\n  h1{\n    font-size: 70px;\n    color: bisque;\n  }\n  h2{\n    font-size: 55px;\n    color: bisque;\n  }\n  h3{\n    font-size: 40px;\n    color: bisque;\n  }\n  h4{\n    font-size: 30px;\n    color: bisque;\n  }\n  h5{\n    font-size: 20px;\n    color: bisque;\n  }\n  h6{\n    font-size: 15px;\n    color: bisque;\n  }\n  code{\n    color: red;\n    \n  }\n  pre{\n    // color:oldlace;\n    \n  }\n  \n  blockquote{\n    color: skyblue;\n  }\n  .slides{\n    color: antiquewhite;\n  }\n}\n\n```\n\n##### 插件使用的一些语法\n\n具体使用细节可查看[markdown preview enhanced](https://www.bookstack.cn/read/mpe/zh-cn-customize-css.md),这里只是对常用功能做介绍\n\n###### toc\n\n在你的文档里输入\n> [TOC]\n\n就能产生一个目录\n\n###### 引入外部文件\n语法为：\n> @import \"你的文件\"\n\n可引入 md 图片 html等，文件的路径为绝对路径或相对路径或者网络路径\n\n###### 制作幻灯片\n幻灯片语法为：\n```js\n---\npresentation:\n  width: 800\n  height: 600\n---\n<!-- slide -->\n在这里编写你的幻灯片。。。\n\n```\n\n##### 导出为PDF Word 等\npdf需要在 markdown 文件中的 front-matter 里声明 pdf_document 的输出类型：\n```js\n---\ntitle: \"test\"\nauthor: test\ndate: March 22, 2020\noutput: pdf_document\n---\n```\n你可以通过 path 来定义文档的输出路径。例如：\n```js\n---\ntitle: \"Habits\"\noutput:\n  pdf_document:\n    path: /Exports/Habits.pdf\n---\n```\nword需要在 markdown 文件中的 front-matter 里声明 word_document 的输出类型：\n```\n---\ntitle: \"Habits\"\nauthor: John Doe\ndate: March 22, 2005\noutput: word_document\n---\n```\n输出路径同pdf;\n\n保持为markdown可以包含所有的绘制的图形（为 png 图片），code chunks，以及数学表达式（图片形式）等等\n通过 front-matter 来设置图片的保存路径以及输出路径。\n\n```\n---\nmarkdown:\n  image_dir: /assets\n  path: output.md\n  ignore_from_front_matter: true\n  absolute_image_path: false\n---\n```\nimage_dir 可选\n定义了哪里将保存你的图片。例如，/assets 意味着所有的图片将会被保存到项目目录下的 assets 文件夹内。如果 image_dir。如果 image_dir 没有被定义，那么插件设置中的 Image save folder path 将会被使用。默认为 /assets。\n\npath 可选\n定义了哪里输出你的 markdown 文件。如果 path 没有被定义，filename_.md 将会被使用。\n\nignore_from_front_matter 可选\n如果设置为 false，那么 markdown 将会被包含于导出的文件中的 front-matter 中。\n\nabsolute_image_path 可选\n是否使用绝对（相对于项目文件夹）图片路径。\n\n\n对于vscode 中编写markdown就介绍这么多，小伙伴有任何疑问都可以与我邮件或者微信qq交流\n\n#### vscode的一些快捷键\nCtrl+n： new 一个文件\nCtrl+b: 关闭左侧菜单\nctr+左右方向键：光标跳跃到下一个单词\nalt+上下方向键：上/下移一行\nctrl+d：选中一个单词\nctrl+x:删除一行\nctrl+1/2/3:分屏\nctrl+w：关闭当前窗口","slug":"在vscode中编写markdown","published":1,"updated":"2021-01-11T07:31:23.329Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh75004j00wiax362imc","content":"<p>作者：muggle</p>\n<h4 id=\"为什么要markdown\"><a href=\"#为什么要markdown\" class=\"headerlink\" title=\"为什么要markdown\"></a>为什么要markdown</h4><p>&nbsp;&nbsp;markdown语法学习成本低，而且非常方便排版，如果你经常写文章，那么你就很有必要掌握markdown了，而且在vscode中编写markdown也非常方便，只需掌握几个快捷键，安装几个插件就能极大的提高你的写作效率。</p>\n<h4 id=\"插件安装使用\"><a href=\"#插件安装使用\" class=\"headerlink\" title=\"插件安装使用\"></a>插件安装使用</h4><h5 id=\"使用设置相关\"><a href=\"#使用设置相关\" class=\"headerlink\" title=\"使用设置相关\"></a>使用设置相关</h5><p>ctr+shift+x 输入markdown preview enhanced下载安装，<br>安装好之后新建 .md文件就能愉快的写文章了，这里对markdown语法就不做介绍了，比较简单；<br>说一下插件怎么使用<br>ctrl+shift+v 打开预览，按F1或者ctr+shift+p输入Markdown Preview Enhanced: Customize Css 可改预览样式；对于一些常用的代码段还可以在vsocde中设置代码段快捷键，一键生成代码或文字。</p>\n<a id=\"more\"></a>\n\n<p>附上自己常用的预览样式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.markdown-preview.markdown-preview &#123;</span><br><span class=\"line\">  background-color: rgb(<span class=\"number\">46</span>, <span class=\"number\">45</span>, <span class=\"number\">45</span>);</span><br><span class=\"line\">  color: rgb(<span class=\"number\">204</span>,<span class=\"number\">120</span>,<span class=\"number\">50</span>);</span><br><span class=\"line\">  font-size: 16px;</span><br><span class=\"line\">  font-family: <span class=\"string\">&#x27;Franklin Gothic Medium&#x27;</span>, <span class=\"string\">&#x27;Arial Narrow&#x27;</span>, Arial, sans-serif;</span><br><span class=\"line\">  h1&#123;</span><br><span class=\"line\">    font-size: 70px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h2&#123;</span><br><span class=\"line\">    font-size: 55px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h3&#123;</span><br><span class=\"line\">    font-size: 40px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h4&#123;</span><br><span class=\"line\">    font-size: 30px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h5&#123;</span><br><span class=\"line\">    font-size: 20px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h6&#123;</span><br><span class=\"line\">    font-size: 15px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  code&#123;</span><br><span class=\"line\">    color: red;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pre&#123;</span><br><span class=\"line\">    <span class=\"comment\">// color:oldlace;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  blockquote&#123;</span><br><span class=\"line\">    color: skyblue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .slides&#123;</span><br><span class=\"line\">    color: antiquewhite;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"插件使用的一些语法\"><a href=\"#插件使用的一些语法\" class=\"headerlink\" title=\"插件使用的一些语法\"></a>插件使用的一些语法</h5><p>具体使用细节可查看<a href=\"https://www.bookstack.cn/read/mpe/zh-cn-customize-css.md\">markdown preview enhanced</a>,这里只是对常用功能做介绍</p>\n<h6 id=\"toc\"><a href=\"#toc\" class=\"headerlink\" title=\"toc\"></a>toc</h6><p>在你的文档里输入</p>\n<blockquote>\n<p>[TOC]</p>\n</blockquote>\n<p>就能产生一个目录</p>\n<h6 id=\"引入外部文件\"><a href=\"#引入外部文件\" class=\"headerlink\" title=\"引入外部文件\"></a>引入外部文件</h6><p>语法为：</p>\n<blockquote>\n<p>@import “你的文件”</p>\n</blockquote>\n<p>可引入 md 图片 html等，文件的路径为绝对路径或相对路径或者网络路径</p>\n<h6 id=\"制作幻灯片\"><a href=\"#制作幻灯片\" class=\"headerlink\" title=\"制作幻灯片\"></a>制作幻灯片</h6><p>幻灯片语法为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">presentation:</span><br><span class=\"line\">  width: <span class=\"number\">800</span></span><br><span class=\"line\">  height: <span class=\"number\">600</span></span><br><span class=\"line\">---</span><br><span class=\"line\">&lt;!-- slide --&gt;</span><br><span class=\"line\">在这里编写你的幻灯片。。。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"导出为PDF-Word-等\"><a href=\"#导出为PDF-Word-等\" class=\"headerlink\" title=\"导出为PDF Word 等\"></a>导出为PDF Word 等</h5><p>pdf需要在 markdown 文件中的 front-matter 里声明 pdf_document 的输出类型：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: <span class=\"string\">&quot;test&quot;</span></span><br><span class=\"line\">author: test</span><br><span class=\"line\">date: March <span class=\"number\">22</span>, <span class=\"number\">2020</span></span><br><span class=\"line\">output: pdf_document</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>你可以通过 path 来定义文档的输出路径。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: <span class=\"string\">&quot;Habits&quot;</span></span><br><span class=\"line\">output:</span><br><span class=\"line\">  pdf_document:</span><br><span class=\"line\">    path: <span class=\"regexp\">/Exports/</span>Habits.pdf</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>word需要在 markdown 文件中的 front-matter 里声明 word_document 的输出类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &quot;Habits&quot;</span><br><span class=\"line\">author: John Doe</span><br><span class=\"line\">date: March 22, 2005</span><br><span class=\"line\">output: word_document</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>输出路径同pdf;</p>\n<p>保持为markdown可以包含所有的绘制的图形（为 png 图片），code chunks，以及数学表达式（图片形式）等等<br>通过 front-matter 来设置图片的保存路径以及输出路径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">markdown:</span><br><span class=\"line\">  image_dir: &#x2F;assets</span><br><span class=\"line\">  path: output.md</span><br><span class=\"line\">  ignore_from_front_matter: true</span><br><span class=\"line\">  absolute_image_path: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>image_dir 可选<br>定义了哪里将保存你的图片。例如，/assets 意味着所有的图片将会被保存到项目目录下的 assets 文件夹内。如果 image_dir。如果 image_dir 没有被定义，那么插件设置中的 Image save folder path 将会被使用。默认为 /assets。</p>\n<p>path 可选<br>定义了哪里输出你的 markdown 文件。如果 path 没有被定义，filename_.md 将会被使用。</p>\n<p>ignore_from_front_matter 可选<br>如果设置为 false，那么 markdown 将会被包含于导出的文件中的 front-matter 中。</p>\n<p>absolute_image_path 可选<br>是否使用绝对（相对于项目文件夹）图片路径。</p>\n<p>对于vscode 中编写markdown就介绍这么多，小伙伴有任何疑问都可以与我邮件或者微信qq交流</p>\n<h4 id=\"vscode的一些快捷键\"><a href=\"#vscode的一些快捷键\" class=\"headerlink\" title=\"vscode的一些快捷键\"></a>vscode的一些快捷键</h4><p>Ctrl+n： new 一个文件<br>Ctrl+b: 关闭左侧菜单<br>ctr+左右方向键：光标跳跃到下一个单词<br>alt+上下方向键：上/下移一行<br>ctrl+d：选中一个单词<br>ctrl+x:删除一行<br>ctrl+1/2/3:分屏<br>ctrl+w：关闭当前窗口</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h4 id=\"为什么要markdown\"><a href=\"#为什么要markdown\" class=\"headerlink\" title=\"为什么要markdown\"></a>为什么要markdown</h4><p>&nbsp;&nbsp;markdown语法学习成本低，而且非常方便排版，如果你经常写文章，那么你就很有必要掌握markdown了，而且在vscode中编写markdown也非常方便，只需掌握几个快捷键，安装几个插件就能极大的提高你的写作效率。</p>\n<h4 id=\"插件安装使用\"><a href=\"#插件安装使用\" class=\"headerlink\" title=\"插件安装使用\"></a>插件安装使用</h4><h5 id=\"使用设置相关\"><a href=\"#使用设置相关\" class=\"headerlink\" title=\"使用设置相关\"></a>使用设置相关</h5><p>ctr+shift+x 输入markdown preview enhanced下载安装，<br>安装好之后新建 .md文件就能愉快的写文章了，这里对markdown语法就不做介绍了，比较简单；<br>说一下插件怎么使用<br>ctrl+shift+v 打开预览，按F1或者ctr+shift+p输入Markdown Preview Enhanced: Customize Css 可改预览样式；对于一些常用的代码段还可以在vsocde中设置代码段快捷键，一键生成代码或文字。</p>","more":"<p>附上自己常用的预览样式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.markdown-preview.markdown-preview &#123;</span><br><span class=\"line\">  background-color: rgb(<span class=\"number\">46</span>, <span class=\"number\">45</span>, <span class=\"number\">45</span>);</span><br><span class=\"line\">  color: rgb(<span class=\"number\">204</span>,<span class=\"number\">120</span>,<span class=\"number\">50</span>);</span><br><span class=\"line\">  font-size: 16px;</span><br><span class=\"line\">  font-family: <span class=\"string\">&#x27;Franklin Gothic Medium&#x27;</span>, <span class=\"string\">&#x27;Arial Narrow&#x27;</span>, Arial, sans-serif;</span><br><span class=\"line\">  h1&#123;</span><br><span class=\"line\">    font-size: 70px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h2&#123;</span><br><span class=\"line\">    font-size: 55px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h3&#123;</span><br><span class=\"line\">    font-size: 40px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h4&#123;</span><br><span class=\"line\">    font-size: 30px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h5&#123;</span><br><span class=\"line\">    font-size: 20px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  h6&#123;</span><br><span class=\"line\">    font-size: 15px;</span><br><span class=\"line\">    color: bisque;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  code&#123;</span><br><span class=\"line\">    color: red;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pre&#123;</span><br><span class=\"line\">    <span class=\"comment\">// color:oldlace;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  blockquote&#123;</span><br><span class=\"line\">    color: skyblue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  .slides&#123;</span><br><span class=\"line\">    color: antiquewhite;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"插件使用的一些语法\"><a href=\"#插件使用的一些语法\" class=\"headerlink\" title=\"插件使用的一些语法\"></a>插件使用的一些语法</h5><p>具体使用细节可查看<a href=\"https://www.bookstack.cn/read/mpe/zh-cn-customize-css.md\">markdown preview enhanced</a>,这里只是对常用功能做介绍</p>\n<h6 id=\"toc\"><a href=\"#toc\" class=\"headerlink\" title=\"toc\"></a>toc</h6><p>在你的文档里输入</p>\n<blockquote>\n<p>[TOC]</p>\n</blockquote>\n<p>就能产生一个目录</p>\n<h6 id=\"引入外部文件\"><a href=\"#引入外部文件\" class=\"headerlink\" title=\"引入外部文件\"></a>引入外部文件</h6><p>语法为：</p>\n<blockquote>\n<p>@import “你的文件”</p>\n</blockquote>\n<p>可引入 md 图片 html等，文件的路径为绝对路径或相对路径或者网络路径</p>\n<h6 id=\"制作幻灯片\"><a href=\"#制作幻灯片\" class=\"headerlink\" title=\"制作幻灯片\"></a>制作幻灯片</h6><p>幻灯片语法为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">presentation:</span><br><span class=\"line\">  width: <span class=\"number\">800</span></span><br><span class=\"line\">  height: <span class=\"number\">600</span></span><br><span class=\"line\">---</span><br><span class=\"line\">&lt;!-- slide --&gt;</span><br><span class=\"line\">在这里编写你的幻灯片。。。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"导出为PDF-Word-等\"><a href=\"#导出为PDF-Word-等\" class=\"headerlink\" title=\"导出为PDF Word 等\"></a>导出为PDF Word 等</h5><p>pdf需要在 markdown 文件中的 front-matter 里声明 pdf_document 的输出类型：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: <span class=\"string\">&quot;test&quot;</span></span><br><span class=\"line\">author: test</span><br><span class=\"line\">date: March <span class=\"number\">22</span>, <span class=\"number\">2020</span></span><br><span class=\"line\">output: pdf_document</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>你可以通过 path 来定义文档的输出路径。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: <span class=\"string\">&quot;Habits&quot;</span></span><br><span class=\"line\">output:</span><br><span class=\"line\">  pdf_document:</span><br><span class=\"line\">    path: <span class=\"regexp\">/Exports/</span>Habits.pdf</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>word需要在 markdown 文件中的 front-matter 里声明 word_document 的输出类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: &quot;Habits&quot;</span><br><span class=\"line\">author: John Doe</span><br><span class=\"line\">date: March 22, 2005</span><br><span class=\"line\">output: word_document</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>输出路径同pdf;</p>\n<p>保持为markdown可以包含所有的绘制的图形（为 png 图片），code chunks，以及数学表达式（图片形式）等等<br>通过 front-matter 来设置图片的保存路径以及输出路径。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">markdown:</span><br><span class=\"line\">  image_dir: &#x2F;assets</span><br><span class=\"line\">  path: output.md</span><br><span class=\"line\">  ignore_from_front_matter: true</span><br><span class=\"line\">  absolute_image_path: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>image_dir 可选<br>定义了哪里将保存你的图片。例如，/assets 意味着所有的图片将会被保存到项目目录下的 assets 文件夹内。如果 image_dir。如果 image_dir 没有被定义，那么插件设置中的 Image save folder path 将会被使用。默认为 /assets。</p>\n<p>path 可选<br>定义了哪里输出你的 markdown 文件。如果 path 没有被定义，filename_.md 将会被使用。</p>\n<p>ignore_from_front_matter 可选<br>如果设置为 false，那么 markdown 将会被包含于导出的文件中的 front-matter 中。</p>\n<p>absolute_image_path 可选<br>是否使用绝对（相对于项目文件夹）图片路径。</p>\n<p>对于vscode 中编写markdown就介绍这么多，小伙伴有任何疑问都可以与我邮件或者微信qq交流</p>\n<h4 id=\"vscode的一些快捷键\"><a href=\"#vscode的一些快捷键\" class=\"headerlink\" title=\"vscode的一些快捷键\"></a>vscode的一些快捷键</h4><p>Ctrl+n： new 一个文件<br>Ctrl+b: 关闭左侧菜单<br>ctr+左右方向键：光标跳跃到下一个单词<br>alt+上下方向键：上/下移一行<br>ctrl+d：选中一个单词<br>ctrl+x:删除一行<br>ctrl+1/2/3:分屏<br>ctrl+w：关闭当前窗口</p>"},{"title":"鸟瞰MYSQL","date":"2019-08-02T12:36:40.000Z","_content":"\n作者: muggle\n\n## 1 mysql 架构\nmysql分为server层和存储引擎\n\n### 1.1  server层\n- 连接器：管理连接权限验证\n- 查询缓存：命中缓存直接换回查询结果\n- 分析器：分析语法\n- 优化器：生成执行计划，选择索引\n- 执行器：操作索引返回结果\n\n<!--more-->\n\n### 1.2  存储引擎\n存储引擎负责数据的存储和提取；其架构是插件式的。innodb在mysql5.5.5版本开始成为mysql默认存储引擎。\n\n各存储引擎比对：\n\n-  InnoDB：支持事务，支持外键，InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据，不支持全文索引。\n- MyISAM：不支持事物，不支持外键，MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的，查询效率上MyISAM要高于InnnDB，因此做读写分离的时候一般选择用InnoDB做主机，MyISAM做从机\n- Memory：有比较大的缺陷使用场景很少；文件数据都存储在内存中，如果mysqld进程发生异常，重启或关闭机器这些数据都会消失。\n\n### 1.3 sql的执行过程\n\n第一步客户端连接上mysql数据库的连接器，连接器获取权限，维持管理连接；连接完成后如果你没有后续的指令这个连接就会处于空闲状态，如果太长时间不使用这个连接这个连接就会断开，这个空闲时长默认是8小时，由wait_timeout参数控制。\n\n第二步你往mysql数据库发送了一条sql，这个时候查询缓存开始工作，看看之前有没有执行过这个sql，如果有则直接返回缓存数据到客户端，只要对表执行过更新操作缓存都会失效，因此一些很少更新的数据表可考虑使用数据库缓存，对频繁更新的表使用缓存反而弊大于利。使用缓存的方法如以下sql，通过SQL_CACHE来指定：\n\n```sql\nselect  SQL_CACHE * from table where xxx=xxx\n```\n\n第三步当未命中缓存的时候，分析器开始工作；分析器判断你是select还是update还是insert，分析你的语法是否正确。\n\n第四步优化器根据你的表的索引和sql语句决定用哪个索引，决定join的顺序。\n\n第五步执行器执行sql，调用存储引擎的接口，扫描遍历表或者插入更新数据。\n\n## 2 mysql日志\n\n### 2.1 mysql日志介绍\n\nmysql有两个重要日志——redolog和binlog，redolog是独属于innodb的日志，binlog则是属于server层的日志。下面介绍这两个日志有什么用：当我们更新数据库数据的时候，这两个日志文件也会被更新，记录数据库更新操作。\n\nredolog又称作重做日志，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。它在数据库重启恢复的时候被使用，innodb利用这个日志恢复到数据库宕机前的状态，以此来保证数据的完整性。redolog是物理日志，记录的是某个表的数据做了哪些修改，redolog是固定大小的，也就是说后面的日志会覆盖前面的日志。\n\nbinlog又称作归档日志，它记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作。binlog是逻辑日志，记录的是某个表执行了哪些操作。binlog是追加形式的写入日志，后面的日志不会被前面的覆盖\n\n### 2.2  数据更新过程\n\n我们执行一个更新操作是这样的：读取对应的数据到内存—>更新数据—>写redolog日志—>redolog状态为prepare—>写binlog日志—>提交事务—>redolog状态为commit，数据正式写入日志文件。我们发现redolog的提交方式为“两段式提交”，这样做的目的是为了数据恢复的时候确保数据恢复的准确性，因为数据恢复是通过备份的binlog来完成的，所以要确保redolog要和binlog一致。\n\n## 3 mysql的mvcc\n\n事务隔离级别在此略过，相信大部分小伙伴都知道相关的知识了，在这里单单只介绍mysql实现事务隔离的原理——mvcc(多版本并发控制)。在学习mvcc之前我需要先介绍快照读和当前读。\n\n### 3.1 快照读和当前读\n\n快照读就是一个`select`语句，形如：\n\n```sql\nselect * from table\n```\n\n在`Repeatable read`事务隔离级别下，快照读的特点是获取当前数据库的快照数据，对于所有未commit的数据都不可见，快照读不会对数据上锁。\n\n当前读是对所读数据上悲观锁使其他当前读无法操作数据。当前读sql包括:\n\n```java\nselect ... lock in share mode\n\nselect ... for update\n\ninsert\n\nupdate\n\ndelete\n```\n\n其中后面三个sql都是给数据库上排他锁（X锁），而第一个sql是给数据库上共享锁（S锁）。X锁是一旦某个当前读到这个锁，其他当前读则没有对这个事务读写的权利，其他当前读会被阻塞住。而S锁是当一个当前读对某条数据上S锁，其他当前读可以对该数据也上S锁但不能上X锁，拿到S锁的当前读可以读数据不能改数据。（关于数据库悲观锁乐观锁并发章节会介绍）。\n\n### 3.2 mvcc原理\n\ninnodb实现快照读和当 前读悲观锁的技术就是mvcc。innodb在插入一条数据的时候会在后面跟上两个隐藏的列，这两个列，一个保存了这个行的创建时系统版本号，一个保存的是行的删除的系统版本号。每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。innodb更新一条数据是设置旧数据删除版本号，然后插入一条新的数据并设置创建版本号，然后删除旧的数据。那么怎么保证快照读是读取到未commit的数据呢，两个条件：\n\n- InnoDB只查找创建版本早于当前事务版本的数据行，即，行的系统版本号小于或等于事务的系统版本号，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。\n\n- 行的删除版本，要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。\n  只有符合上述两个条件的纪录，才能作为查询结果返回。\n\n而数据库锁也是通过比对版本号来决定是否阻塞某个事物。\n\n## 4 mysql 索引 \n\n### 4.1  索引介绍\n\n索引按数据结构分可分为哈希表，有序数组，搜索树，跳表：\n\n- 哈希表适用于只有等值查询的场景\n- 有序数组适用于有等值查询和范围查询的场景，但有序数组索引的更新代价很大，所以最好用于静态数据表\n- 搜索树的搜索效率稳定，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高\n- 跳表可以理解为优化的哈希索引\n\ninnodb使用了B+树索引模型，而且是多叉树。虽然二叉树是索引效率最高的，但是索引需要写入磁盘，如果使用二叉树磁盘io会变得很频繁。在innodb索引中分为主键索引（聚簇索引）和非主键索引（二级索引）。主键索引保存了该行数据的全部信息，二级索引保存了该行数据的主键；所以使用二级索引的时候会先查出主键值，然后回表查询出数据，而使用主键索引则不需要回表。\n\n对二级索引而言可使用覆盖索引来优化sql，看下面两条sql\n\n```sql\nselect * from table where key=1;\nselect id from table where key=1;\n```\n\nkey是一个二级索引，第一条sql是先查询出id，然后根据id回表查询出真正的数据。而第二条查询索引后直接返回数据不需要回表。第二条sql索引key覆盖了我们的查询需求，称作覆盖索引\n\n### 4.2 普通索引和唯一索引\n\ninnoDB是按数据页来读写数据的，当要读取一条数据的时候是先将本页数据全部读入内存，然后找到对应数据，而不是直接读取，每页数据的默认大小为16KB。\n\n当一个数据页需要更新的时候，如果内存中有该数据页就直接更新，如果没有该数据页则在不影响数据一致性的前提下将；更新操作先缓存到`change buffer`中，在下次查询需要访问这个数据页的时候再写入更新操作除了查询会将`change buffer` 写入磁盘，后台线程线程也会定期将`change buffer`写入到磁盘中。对于唯一索引来说所有的更新操作都要先判断这个操作是否会违反唯一性约束，因此唯一索引的更新无法使用`change buffer` 而普通索引可以，唯一索引更新比普通索引更新多一个唯一性校验的过程。\n\n### 4.3 联合索引  \n\n两个或更多个列上的索引被称作联合索引（复合索引）。联合索引可减少索引开销，以联合索引(a,b,c)为例，建立这样的索引相当于建立了索引a、ab、abc三个索引——Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分，而且当最左侧字段是常量引用时，索引就十分有效，这就是**最左前缀原则**。由最左前缀原则可知，组合索引是有顺序的，那么哪个索引放在前面就比较有讲究了。对于组合索引还有一个知识点——**索引下推**，假设有组合索引（a，b，c）有如下sql:\n\n```sql\nselet * from table where a=xxx and b=xxx\n```\n\n这个sql会进行两次筛选第一次查出`a=xxx`数据 再从`a=xxx`中查出 `b=xxx` 的数据。使用索引下推和不使用索引下推的区别在于不使用索引下推会先查出`a=xxx`数据的主键然后根据查询出的主键回表查询出全行数据，再在全行数据上查出 `b=xxx` 的数据；而索引下推的执行过程是先查出`a=xxx`数据的主键，然后在这些主键上二次查询 `b=xxx` 的主键，然后回表。\n\n索引下推的特点：\n\n- innodb引擎的表，索引下推只能用于二级索引\n- 索引下推一般可用于所查询字段不全是联合索引的字段，查询条件为多条件查询且查询条件子句字段全是联合索引。\n\n\n\n### 4.4 优化器与索引\n\n在 索引建立之后，一条语句可能会命中多个索引，这时，索引的选择，就会交由 优化器 来选择合适的索引。优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。那么优化器是怎么去确定索引的呢？优化器会优先选择扫描行数最少的索引，同时还会结合是否使用临时表、是否排序等因素进行综合判断。MySQL 在开始执行sql之前，并不知道满足这个条件的记录有多少条，而只能根据mysql的统计信息来估计。\n\n### 4.5 其他索引知识点\n\n有时候需要索引很长的字符列，这会让索引变得很大很慢还占内存。通常可以以开始的部分字符作为索引，这就是**前缀索引**。这样可以大大节约索引空间，从而提高索引效率，但这样也会降低索引的选择性。\n\n**脏页**对数据库的影响：\n\n当内存数据页和磁盘的数据不一致的时候我们称这个内存页为脏页，内存数据写入磁盘后数据一致，称为干净页。当要读入数据而数据库没有内存的时候，这个时候需要淘汰内存中的数据页——干净页可以直接淘汰掉，而脏页需要先刷入磁盘再淘汰。如果一个查询要淘汰的脏页太多会导致查询的时间变长。为了减少脏页对数据库性能影响，innodb会控制脏页的比例和脏页刷新时机。\n\n# 5 mysql语法分析及优化\n\n### 5.1 count(*)\n\n`count(*)`对innodb而言，它需要把数据从磁盘中读取出来然后累计计数；而MyISAM引擎把一个表的总行数存在了磁盘上，所以执行`count(*)`会直接返回这个数，如果有where条件则和innodb一样。\n那么如何优化`count(*)`？一个思路是使用缓存，但是需要注意双写一致的问题（双写一致性后文缓存章节会做介绍）。还可以专门设计一张表用以存储`count(*)`。\n\n对于count(主键id)来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server 层。server层拿到id后，判断是不可能为空的，就按行累加。 对于count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个 数字“1”进去，判断是不可能为空的，按行累加。 单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎 返回id会涉及到解析数据行，以及拷贝字段值的操作。 对于count(字段)来说： 如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加； 如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再 判断一下，不是null才累加。  而对于count(*)来说，并不会把全部字段取出来，而是专门做了优化，不取值，按行累加。所以排序效率：\n> count(*)=count(1)>count(id)>count(字段)\n\n\n### 5.2 order by\n\nMysql会给每个线程分配一块内存用于做排序处理，称为`sort_buffer`,一个包含排序的sql执行过程为：申请排序内存`sort_buffer`,然后一条条查询出整行数据，然后将需要的字段数据放入到排序内存中，染回对排序内存中的数据做一个快速排序，然后返回到客户端。当数据量过大，排序内存盛不下的时候就会利用磁盘临时文件来辅助排序。当我们排序内存盛不下数据的时候，mysql会使用`rowid`排序来优化。rowid排序相对于全字段排序，不会把所有字段都放入sort_buffer，所以在sort buffer中进行排序之后还得回表查询。在少数情况下，可以使用联合索引+索引覆盖的方式来优化order by。\n\n### 5.3 join\n在了解`join`之前我们应该先了解**驱动表**这个概念——当两表发生关联的时候就会有驱动表和被驱动表之分，驱动表也叫外表（R表），被驱动表也叫做内表（S表）。一般我们将小表当做驱动表（指定了联接条件时，满足查询条件的记录行数少的表为「驱动表」,未指定联接条件时，行数少的表为「驱动表」；MySQL 内部优化器也是这么做的）。\n\n假设有这样一句sql（xxx 为索引）:\n```sql\nselect * from table1 left join tablet2 on table1.xxx=table2.xxx \n```\n这条语句执行过程是先遍历表table1，然后根据从表table1中取出的每行数据中的xxx值，去表table2中查找满足条件的 记录。这个过程就跟我们写程序时的嵌套查询类似，并且能够用上被驱动表的索引，这种查询方式叫`NLJ`。当xxx不是索引的时候，再使用`NLJ`的话就会对table2做多次的全表扫描（每从table1取一条数据就全表扫描一次table2），扫描数暴涨。这个时候mysql会采用另外一个查询策略。Mysql会先把table1的数据读入到一个`join_buffer`的内存空间里面去，然后\n依次取出table2的每一行数据，跟`join_buffer`中的数据做对比，满足join条件的作为结果集的一部分返回。\n我们在使用`join`的时候,要遵循以下几点：\n- 小表驱动大表。\n- 被驱动表走索引的情况下（走`NLJ`查询方式）的时候才考虑用join\n\n\n### 5.4 sql的优化 \n1） 在mysql中，如果对字段做了函数计算，就用不上索引了\n如以下sql(data 为索引):\n```sql\nselect *  from tradelog where month(data)=1;\n```\n优化器对这样的sql会放弃走搜索树，因为它无法知道data的区间。\n\n2）隐式的类型转换会导致索引失效。\n如以下sql:\n```sql\nselect * from table where xxx=110717;\n```\n其中xxx为`varchar`型，在mysql中，字符串和数字做比较的话，将字符串转换成数字再进行比较，这里相当于使用了`CAST(xxx AS signed )` 导致无法走索引。\n\n3）索引列参与了计算不会走索引\n\n4）like %xxx 不会走索引，like xxx% 会走索引\n\n5）在where子句中使用or，在innodb中不会走索引，而MyISAM会。\n\n\n## 6执行计划和慢查询日志\n### 6.1 执行计划\n在查询sql之前加上`explain`可查看该条sql的执行计划,如：\n```sql\nEXPLAIN SELECT * FROM table\n```\n这条sql会返回这样一个表：\n\n| id   | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | extra |      |\n| ---- | ----------- | ----- | ---------- | ---- | ------------- | ---- | ------- | ---- | ---- | -------- | ----- | ---- |\n| 1    | simple      |       |            |      |               |      |         |      |      |          |       |      |\n这个表便是sql的执行计划，我们可以通过分析这个执行计划来知道我们sql的运行情况。现对各列进行解释：\n\n1）id：查询中执行select子句或操作表的顺序。\n\n2）select_type：查询中每个select子句的类型（简单 到复杂）包括：\n- SIMPLE：查询中不包含子查询或者UNION；\n- PRIMARY：查询中包含复杂的子部分；\n- SUBQUERY：在SELECT或WHERE列表中包含了子查询，该子查询被标记为SUBQUERY；\n- DERIVED：衍生，在FROM列表中包含的子查询被标记为DERIVED；\n- UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；\n- UNION  RESULT：从UNION表获取结果的SELECT被标记为UNION RESULT；\n\n\n3） type：表示MySQL在表中找到所需行的方式，又称“访问类型”，包括：\n- ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行；\n- index：Full Index Scan，index与ALL区别为index类型只遍历索引树；\n- range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between  <  >  等查询；\n- ref：非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找；\n- eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描；\n- onst 和 system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下， 使用system；\n- NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引。\n\n4）possible_keys： 指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。\n\n5）key：显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。\n\n6）key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。\n\n7）ref： 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。\n\n8）rows： 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。\n\n9）Extra：其他重要信息 包括：\n- Using index：该值表示相应的select操作中使用了覆盖索引 ；\n- Using where：MySQL将用where子句来过滤结果集；\n- Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询；\n- Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”。\n\n### 6.2 慢查询日志\nmysql支持慢查询日志功能——mysql会将查询时间过长的sql相关信息写入日志。这个查询时间阀值由参数`long_query_time`指定，`long_query_time`的默认值为10，运行10S以上的查询sql会被记录到慢查询日志中。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。\n\n可通过以下sql查看慢查询日志是否开启：\n```sql\nshow variables  like '%slow_query_log%';\n```\n通过以下sql开启慢查询：\n```sql\nset global slow_query_log=1;\n```\n使用sql修改慢查询日志设置只对当前数据库生效，如果MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf。\n\n通过以下sql查看修改慢查询的阈值：\n```sql\nshow variables like 'long_query_time%';\nset global long_query_time=4;\n```\n\n## 7主从备份\n\n### 7.1主从备份原理\n\n主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。通过这种手段我们可以做到读写分离，主库写数据，从库读数据，从而提高数据库的可用。\nMySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点。\n\n主节点 binary log dump 线程：\n当从节点连接主节点时，主节点会创建一个`log dump` 线程，用于发送`binlog`的内容。在读取`binlog`中的操作时，此线程会对主节点上的`binlog`加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。\n\n 从节点I/O线程:\n 用于从库将主库的`binlog`复制到本地的`relay log`中，首先，从库库会先启动一个工作线程，称为IO工作线程，负责和主库建立一个普通的客户端连接。如果该进程追赶上了主库，它将进入睡眠状态，直到主库有新的事件产生通知它，他才会被唤醒，将接收到的事件记录到`relay log`(中继日志)中。\n\n 从节点SQL线程:\n SQL线程负责读取`relay log`中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。\n\n ### 7.2 主从备份延迟\n主备延迟最直接的表现是，备库消费中继日志（`relay log`）的速度，比主库生产`binlog` 的速度要慢。可能导致的原因有：\n- 大事务，主库上必须等事务执行完成才会写入binlog，再传给备库，当一个事物用时很久的时候，在从库上会因为这个事物的执行产生延迟。\n- 从库压力大。\n\n主备延迟当然是不好的，那么有哪些办法尽量减小主备延迟呢？有下面几个办法：\n- 一主多从——多接几个从库，让这些从库来分担读的压力。这样方法适用于从库读压力大的时候。\n- 通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力\n\n### 7.3 主从备份配置\n主机：\n```shell\n\nvi /etc/my.cnf\n\n\n#主数据库端ID号\nserver_id = 1           \n #开启二进制日志                  \nlog-bin = mysql-bin    \n#需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可                  \nbinlog-do-db = db        \n#将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中                 \nlog-slave-updates                        \n#控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失) \nsync_binlog = 1                    \n#这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突\nauto_increment_offset = 1           \n#这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突\nauto_increment_increment = 1            \n#二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除  \nexpire_logs_days = 7                    \n#将函数复制到slave  \nlog_bin_trust_function_creators = 1       \n```\n\n登录mysql\n```sql\n#创建slave账号account，密码123456\nmysql>grant replication slave on *.* to 'account'@'10.10.20.116' identified by '123456';\n#更新数据库权限\nmysql>flush privileges;\n\n# 检查log-bin\nshow variables like ‘log_bin’\n\n#查看主服务器状态\nshow master status\\G;\n\n\n```\n\n从机：\n```shell\nvi /etc/my.cnf\n\n\nserver_id = 2\nlog-bin = mysql-bin\nlog-slave-updates\nsync_binlog = 0\n#log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作\ninnodb_flush_log_at_trx_commit = 0        \n#指定slave要复制哪个库\nreplicate-do-db = db         \n#MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据\nslave-net-timeout = 60                    \nlog_bin_trust_function_creators = 1\n\n```\n登录mysql\n```sql\n#执行同步命令，设置主服务器ip，同步账号密码，同步位置\nmysql>change master to master_host='10.10.20.111',master_user='account',master_password='123456',master_log_file='mysql-bin.000033',master_log_pos=337523;\n#开启同步功能\nmysql>start slave;\n#查看从服务器状态\nmysql>show slave status\\G;\n```\n\n\n## 8 分布式事务\n由于篇幅问题，这里不再对分布式事物的概念做普及，直接介绍两种分布式事务: XA 分布式事务和 TCC分布式事务。\n\n### 8.1 XA分布式事务\n\nXA是两阶段提交的强一致性事物。在MySQL 5.7.7版本中，Oracle 官方将MySQL XA 一直存在的一个“bug” 进行了修复，使得MySQL XA 的实现符合了分布式事务的标准。\n\nXA事务中的角色：\n- 资源管理器（resource manager）：用来管理系统资源，是通向事务资源的途径。数据库就是一种资源管理器。资源管理还应该具有管理事务提交或回滚的能力。\n- 事务管理器（transaction manager）：事务管理器是分布式事务的核心管理者。事务管理器与每个资源管理器（resource \nmanager）进行通信，协调并完成事务的处理。事务的各个分支由唯一命名进行标识。\n\nXA规范的基础是两阶段提交协议：\n\n在第一阶段，交易中间件请求所有相关数据库准备提交（预提交）各自的事务分支，以确认是否所有相关数据库都可以提交各自的事务分支。当某一数据库收到预提交后，如果可以提交属于自己的事务分支，则将自己在该事务分支中所做的操作固定记录下来，并给交易中间件一个同意提交的应答，此时数据库将不能再在该事务分支中加入任何操作，但此时数据库并没有真正提交该事务，数据库对共享资源的操作还未释放（处于锁定状态）。如果由于某种原因数据库无法提交属于自己的事务分支，它将回滚自己的所有操作，释放对共享资源上的锁，并返回给交易中间件失败应答。\n\n在第二阶段，交易中间件审查所有数据库返回的预提交结果，如所有数据库都可以提交，交易中间件将要求所有数据库做正式提交，这样该全局事务被提交。而如果有任一数据库预提交返回失败，交易中间件将要求所有其它数据库回滚其操作，这样该全局事务被回滚。\n\nmysql允许多个数据库实例参与一个全局的事务。MySQL XA 的命令集合如下：\n```sql\n-- 开启一个事务，并将事务置于ACTIVE状态，此后执行的SQL语句都将置于该是事务中。\n\nXA START xid\n-- 将事务置于IDLE状态，表示事务内的SQL操作完成。\nXA END xid\n\n-- 事务提交的准备动作，事务状态置于PREPARED状态。事务如果无法完成提交前的准备操作，该语句会执行失败。\nXA PREPARE xid\n\n-- 事务最终提交，完成持久化。\nXA COMMIT xid\n\n-- 事务回滚终止\nXA ROLLBACK xid\n\n-- 查看MySQL中存在的PREPARED状态的xa事务。\nXA RECOVER\n```\nMySQL 在XA事务中扮演的是参与者的角色，被事务协调器所支配。XA事务比普通本地事务多了一个`PREPARE`状态，普通事务是 begin-> commit 而分布式事务是 begin->PREPARE 等其他数据库事务都到PREPARE状态的时候再 PREPARE->commit。分布式事务sql示例：\n\n```sql\n xa start 'aaa';\n insert into table(xxx) values(xxx);\n xa end 'aaa';\n xa prepare 'aaa';\n xa commit 'aaa';\n```\nXA事务存在的问题：\n\n- 单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。\n- 同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞状态，直到提交完成才能释放资源。\n- 数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。\n\n\n### 8.2 TCC分布式事务\nTCC又被称作柔性事务，通过事务补偿机制来达到事务的最终一致性，它不是强一致性的事务。TCC将事务分为两个阶段，或者说是由两个事务组成的。相对于XA事务来说TCC的并发性更好，XA是全局性的事务，而TCC是由两个本地事务组成。\n\n假设我们购买一件商品，后台需要操作两张表——积分表加积分而库存表扣库存，这两张表存在于两个数据库中，使用TCC事务执行这一事务：\n\n1）TCC实现阶段一：Try\n在try阶段并不是直接减库存加积分，而是将相关数据改变为预备的状态。库存表先锁定一个库存，锁定的方式可以预留一个锁定字段，当这个字段为一的时候表示这个商品被锁定。积分表加一个数据，这个数据也是被锁定状态，锁定方式和库存表一样。其sql形如：\n```sql\nupdate stock set lock=1 where id=1;\ninsert into credits (lock,...) values (1,...)\n\n```\n这两条sql如果都执行成功则进入 Confirm阶段，如果执行不成功则进入Cancel阶段\n\n2）TCC实现阶段二：Confirm\n\n这一阶段正式减库存加积分订单状态改为已支付。执行sql将锁定的库存扣除，为累加积分累加，以及一些其他的逻辑。\n\n3）TCC实现阶段三：Cancel\n当try阶段执行不成功，就会执行这一阶段，这个阶段将锁定的库存还原，锁定的积分删除掉。退回到事务执行前的状态。\n\nTCC事务原理很简单，使用起来却不简单。首先TCC事务对系统侵入性很大，其次是让业务逻辑变得复杂。在实际使用中我们必须依赖TCC事务中间件才能让TCC事务得以实现。通常一个TCC事务实现大概是这样子的：某个服务向外暴露了一个服务，这个服务对外正常调用，其他服务并不能感知到TCC事务的存在，而其服务内部，分别实现了Try,Confirm,Cancel三个接口，注册到TCC中间件上去。当调用这个服务的时候，其事务操作由该服务和TCC中间件共同完成。\n\n而TCC事务中间件还要做好其他事情，比如确保Confirm或者Cancel执行成功，如果发现某个服务的Cancel或者Confirm一直没成功，会不停的重试调用他的Cancel或者Confirm逻辑，务必要他成功！即使在尝试多次后无法成功也能通知到系统需要人工排查异常。TCC事务还要考虑一些异常情况的处理，比如说订单服务突然挂了，然后再次重启，TCC分布式事务框架要能够保证之前没执行完的分布式事务继续执行。TCC分布式事务框架还需要做好日志的记录，保存下来分布式事务运行的各个阶段和状态，以便系统上线后能够排查异常，恢复数据。目前开源的TCC事务框架有：`Seata` `ByteTCC` `tcc-transaction` 等。","source":"_posts/intresting.md","raw":"---\ntitle: 鸟瞰MYSQL\ndate: 2019-08-02 20:36:40\ntags: mysql\n---\n\n作者: muggle\n\n## 1 mysql 架构\nmysql分为server层和存储引擎\n\n### 1.1  server层\n- 连接器：管理连接权限验证\n- 查询缓存：命中缓存直接换回查询结果\n- 分析器：分析语法\n- 优化器：生成执行计划，选择索引\n- 执行器：操作索引返回结果\n\n<!--more-->\n\n### 1.2  存储引擎\n存储引擎负责数据的存储和提取；其架构是插件式的。innodb在mysql5.5.5版本开始成为mysql默认存储引擎。\n\n各存储引擎比对：\n\n-  InnoDB：支持事务，支持外键，InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据，不支持全文索引。\n- MyISAM：不支持事物，不支持外键，MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的，查询效率上MyISAM要高于InnnDB，因此做读写分离的时候一般选择用InnoDB做主机，MyISAM做从机\n- Memory：有比较大的缺陷使用场景很少；文件数据都存储在内存中，如果mysqld进程发生异常，重启或关闭机器这些数据都会消失。\n\n### 1.3 sql的执行过程\n\n第一步客户端连接上mysql数据库的连接器，连接器获取权限，维持管理连接；连接完成后如果你没有后续的指令这个连接就会处于空闲状态，如果太长时间不使用这个连接这个连接就会断开，这个空闲时长默认是8小时，由wait_timeout参数控制。\n\n第二步你往mysql数据库发送了一条sql，这个时候查询缓存开始工作，看看之前有没有执行过这个sql，如果有则直接返回缓存数据到客户端，只要对表执行过更新操作缓存都会失效，因此一些很少更新的数据表可考虑使用数据库缓存，对频繁更新的表使用缓存反而弊大于利。使用缓存的方法如以下sql，通过SQL_CACHE来指定：\n\n```sql\nselect  SQL_CACHE * from table where xxx=xxx\n```\n\n第三步当未命中缓存的时候，分析器开始工作；分析器判断你是select还是update还是insert，分析你的语法是否正确。\n\n第四步优化器根据你的表的索引和sql语句决定用哪个索引，决定join的顺序。\n\n第五步执行器执行sql，调用存储引擎的接口，扫描遍历表或者插入更新数据。\n\n## 2 mysql日志\n\n### 2.1 mysql日志介绍\n\nmysql有两个重要日志——redolog和binlog，redolog是独属于innodb的日志，binlog则是属于server层的日志。下面介绍这两个日志有什么用：当我们更新数据库数据的时候，这两个日志文件也会被更新，记录数据库更新操作。\n\nredolog又称作重做日志，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。它在数据库重启恢复的时候被使用，innodb利用这个日志恢复到数据库宕机前的状态，以此来保证数据的完整性。redolog是物理日志，记录的是某个表的数据做了哪些修改，redolog是固定大小的，也就是说后面的日志会覆盖前面的日志。\n\nbinlog又称作归档日志，它记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作。binlog是逻辑日志，记录的是某个表执行了哪些操作。binlog是追加形式的写入日志，后面的日志不会被前面的覆盖\n\n### 2.2  数据更新过程\n\n我们执行一个更新操作是这样的：读取对应的数据到内存—>更新数据—>写redolog日志—>redolog状态为prepare—>写binlog日志—>提交事务—>redolog状态为commit，数据正式写入日志文件。我们发现redolog的提交方式为“两段式提交”，这样做的目的是为了数据恢复的时候确保数据恢复的准确性，因为数据恢复是通过备份的binlog来完成的，所以要确保redolog要和binlog一致。\n\n## 3 mysql的mvcc\n\n事务隔离级别在此略过，相信大部分小伙伴都知道相关的知识了，在这里单单只介绍mysql实现事务隔离的原理——mvcc(多版本并发控制)。在学习mvcc之前我需要先介绍快照读和当前读。\n\n### 3.1 快照读和当前读\n\n快照读就是一个`select`语句，形如：\n\n```sql\nselect * from table\n```\n\n在`Repeatable read`事务隔离级别下，快照读的特点是获取当前数据库的快照数据，对于所有未commit的数据都不可见，快照读不会对数据上锁。\n\n当前读是对所读数据上悲观锁使其他当前读无法操作数据。当前读sql包括:\n\n```java\nselect ... lock in share mode\n\nselect ... for update\n\ninsert\n\nupdate\n\ndelete\n```\n\n其中后面三个sql都是给数据库上排他锁（X锁），而第一个sql是给数据库上共享锁（S锁）。X锁是一旦某个当前读到这个锁，其他当前读则没有对这个事务读写的权利，其他当前读会被阻塞住。而S锁是当一个当前读对某条数据上S锁，其他当前读可以对该数据也上S锁但不能上X锁，拿到S锁的当前读可以读数据不能改数据。（关于数据库悲观锁乐观锁并发章节会介绍）。\n\n### 3.2 mvcc原理\n\ninnodb实现快照读和当 前读悲观锁的技术就是mvcc。innodb在插入一条数据的时候会在后面跟上两个隐藏的列，这两个列，一个保存了这个行的创建时系统版本号，一个保存的是行的删除的系统版本号。每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。innodb更新一条数据是设置旧数据删除版本号，然后插入一条新的数据并设置创建版本号，然后删除旧的数据。那么怎么保证快照读是读取到未commit的数据呢，两个条件：\n\n- InnoDB只查找创建版本早于当前事务版本的数据行，即，行的系统版本号小于或等于事务的系统版本号，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。\n\n- 行的删除版本，要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。\n  只有符合上述两个条件的纪录，才能作为查询结果返回。\n\n而数据库锁也是通过比对版本号来决定是否阻塞某个事物。\n\n## 4 mysql 索引 \n\n### 4.1  索引介绍\n\n索引按数据结构分可分为哈希表，有序数组，搜索树，跳表：\n\n- 哈希表适用于只有等值查询的场景\n- 有序数组适用于有等值查询和范围查询的场景，但有序数组索引的更新代价很大，所以最好用于静态数据表\n- 搜索树的搜索效率稳定，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高\n- 跳表可以理解为优化的哈希索引\n\ninnodb使用了B+树索引模型，而且是多叉树。虽然二叉树是索引效率最高的，但是索引需要写入磁盘，如果使用二叉树磁盘io会变得很频繁。在innodb索引中分为主键索引（聚簇索引）和非主键索引（二级索引）。主键索引保存了该行数据的全部信息，二级索引保存了该行数据的主键；所以使用二级索引的时候会先查出主键值，然后回表查询出数据，而使用主键索引则不需要回表。\n\n对二级索引而言可使用覆盖索引来优化sql，看下面两条sql\n\n```sql\nselect * from table where key=1;\nselect id from table where key=1;\n```\n\nkey是一个二级索引，第一条sql是先查询出id，然后根据id回表查询出真正的数据。而第二条查询索引后直接返回数据不需要回表。第二条sql索引key覆盖了我们的查询需求，称作覆盖索引\n\n### 4.2 普通索引和唯一索引\n\ninnoDB是按数据页来读写数据的，当要读取一条数据的时候是先将本页数据全部读入内存，然后找到对应数据，而不是直接读取，每页数据的默认大小为16KB。\n\n当一个数据页需要更新的时候，如果内存中有该数据页就直接更新，如果没有该数据页则在不影响数据一致性的前提下将；更新操作先缓存到`change buffer`中，在下次查询需要访问这个数据页的时候再写入更新操作除了查询会将`change buffer` 写入磁盘，后台线程线程也会定期将`change buffer`写入到磁盘中。对于唯一索引来说所有的更新操作都要先判断这个操作是否会违反唯一性约束，因此唯一索引的更新无法使用`change buffer` 而普通索引可以，唯一索引更新比普通索引更新多一个唯一性校验的过程。\n\n### 4.3 联合索引  \n\n两个或更多个列上的索引被称作联合索引（复合索引）。联合索引可减少索引开销，以联合索引(a,b,c)为例，建立这样的索引相当于建立了索引a、ab、abc三个索引——Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分，而且当最左侧字段是常量引用时，索引就十分有效，这就是**最左前缀原则**。由最左前缀原则可知，组合索引是有顺序的，那么哪个索引放在前面就比较有讲究了。对于组合索引还有一个知识点——**索引下推**，假设有组合索引（a，b，c）有如下sql:\n\n```sql\nselet * from table where a=xxx and b=xxx\n```\n\n这个sql会进行两次筛选第一次查出`a=xxx`数据 再从`a=xxx`中查出 `b=xxx` 的数据。使用索引下推和不使用索引下推的区别在于不使用索引下推会先查出`a=xxx`数据的主键然后根据查询出的主键回表查询出全行数据，再在全行数据上查出 `b=xxx` 的数据；而索引下推的执行过程是先查出`a=xxx`数据的主键，然后在这些主键上二次查询 `b=xxx` 的主键，然后回表。\n\n索引下推的特点：\n\n- innodb引擎的表，索引下推只能用于二级索引\n- 索引下推一般可用于所查询字段不全是联合索引的字段，查询条件为多条件查询且查询条件子句字段全是联合索引。\n\n\n\n### 4.4 优化器与索引\n\n在 索引建立之后，一条语句可能会命中多个索引，这时，索引的选择，就会交由 优化器 来选择合适的索引。优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。那么优化器是怎么去确定索引的呢？优化器会优先选择扫描行数最少的索引，同时还会结合是否使用临时表、是否排序等因素进行综合判断。MySQL 在开始执行sql之前，并不知道满足这个条件的记录有多少条，而只能根据mysql的统计信息来估计。\n\n### 4.5 其他索引知识点\n\n有时候需要索引很长的字符列，这会让索引变得很大很慢还占内存。通常可以以开始的部分字符作为索引，这就是**前缀索引**。这样可以大大节约索引空间，从而提高索引效率，但这样也会降低索引的选择性。\n\n**脏页**对数据库的影响：\n\n当内存数据页和磁盘的数据不一致的时候我们称这个内存页为脏页，内存数据写入磁盘后数据一致，称为干净页。当要读入数据而数据库没有内存的时候，这个时候需要淘汰内存中的数据页——干净页可以直接淘汰掉，而脏页需要先刷入磁盘再淘汰。如果一个查询要淘汰的脏页太多会导致查询的时间变长。为了减少脏页对数据库性能影响，innodb会控制脏页的比例和脏页刷新时机。\n\n# 5 mysql语法分析及优化\n\n### 5.1 count(*)\n\n`count(*)`对innodb而言，它需要把数据从磁盘中读取出来然后累计计数；而MyISAM引擎把一个表的总行数存在了磁盘上，所以执行`count(*)`会直接返回这个数，如果有where条件则和innodb一样。\n那么如何优化`count(*)`？一个思路是使用缓存，但是需要注意双写一致的问题（双写一致性后文缓存章节会做介绍）。还可以专门设计一张表用以存储`count(*)`。\n\n对于count(主键id)来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server 层。server层拿到id后，判断是不可能为空的，就按行累加。 对于count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个 数字“1”进去，判断是不可能为空的，按行累加。 单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎 返回id会涉及到解析数据行，以及拷贝字段值的操作。 对于count(字段)来说： 如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加； 如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再 判断一下，不是null才累加。  而对于count(*)来说，并不会把全部字段取出来，而是专门做了优化，不取值，按行累加。所以排序效率：\n> count(*)=count(1)>count(id)>count(字段)\n\n\n### 5.2 order by\n\nMysql会给每个线程分配一块内存用于做排序处理，称为`sort_buffer`,一个包含排序的sql执行过程为：申请排序内存`sort_buffer`,然后一条条查询出整行数据，然后将需要的字段数据放入到排序内存中，染回对排序内存中的数据做一个快速排序，然后返回到客户端。当数据量过大，排序内存盛不下的时候就会利用磁盘临时文件来辅助排序。当我们排序内存盛不下数据的时候，mysql会使用`rowid`排序来优化。rowid排序相对于全字段排序，不会把所有字段都放入sort_buffer，所以在sort buffer中进行排序之后还得回表查询。在少数情况下，可以使用联合索引+索引覆盖的方式来优化order by。\n\n### 5.3 join\n在了解`join`之前我们应该先了解**驱动表**这个概念——当两表发生关联的时候就会有驱动表和被驱动表之分，驱动表也叫外表（R表），被驱动表也叫做内表（S表）。一般我们将小表当做驱动表（指定了联接条件时，满足查询条件的记录行数少的表为「驱动表」,未指定联接条件时，行数少的表为「驱动表」；MySQL 内部优化器也是这么做的）。\n\n假设有这样一句sql（xxx 为索引）:\n```sql\nselect * from table1 left join tablet2 on table1.xxx=table2.xxx \n```\n这条语句执行过程是先遍历表table1，然后根据从表table1中取出的每行数据中的xxx值，去表table2中查找满足条件的 记录。这个过程就跟我们写程序时的嵌套查询类似，并且能够用上被驱动表的索引，这种查询方式叫`NLJ`。当xxx不是索引的时候，再使用`NLJ`的话就会对table2做多次的全表扫描（每从table1取一条数据就全表扫描一次table2），扫描数暴涨。这个时候mysql会采用另外一个查询策略。Mysql会先把table1的数据读入到一个`join_buffer`的内存空间里面去，然后\n依次取出table2的每一行数据，跟`join_buffer`中的数据做对比，满足join条件的作为结果集的一部分返回。\n我们在使用`join`的时候,要遵循以下几点：\n- 小表驱动大表。\n- 被驱动表走索引的情况下（走`NLJ`查询方式）的时候才考虑用join\n\n\n### 5.4 sql的优化 \n1） 在mysql中，如果对字段做了函数计算，就用不上索引了\n如以下sql(data 为索引):\n```sql\nselect *  from tradelog where month(data)=1;\n```\n优化器对这样的sql会放弃走搜索树，因为它无法知道data的区间。\n\n2）隐式的类型转换会导致索引失效。\n如以下sql:\n```sql\nselect * from table where xxx=110717;\n```\n其中xxx为`varchar`型，在mysql中，字符串和数字做比较的话，将字符串转换成数字再进行比较，这里相当于使用了`CAST(xxx AS signed )` 导致无法走索引。\n\n3）索引列参与了计算不会走索引\n\n4）like %xxx 不会走索引，like xxx% 会走索引\n\n5）在where子句中使用or，在innodb中不会走索引，而MyISAM会。\n\n\n## 6执行计划和慢查询日志\n### 6.1 执行计划\n在查询sql之前加上`explain`可查看该条sql的执行计划,如：\n```sql\nEXPLAIN SELECT * FROM table\n```\n这条sql会返回这样一个表：\n\n| id   | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | extra |      |\n| ---- | ----------- | ----- | ---------- | ---- | ------------- | ---- | ------- | ---- | ---- | -------- | ----- | ---- |\n| 1    | simple      |       |            |      |               |      |         |      |      |          |       |      |\n这个表便是sql的执行计划，我们可以通过分析这个执行计划来知道我们sql的运行情况。现对各列进行解释：\n\n1）id：查询中执行select子句或操作表的顺序。\n\n2）select_type：查询中每个select子句的类型（简单 到复杂）包括：\n- SIMPLE：查询中不包含子查询或者UNION；\n- PRIMARY：查询中包含复杂的子部分；\n- SUBQUERY：在SELECT或WHERE列表中包含了子查询，该子查询被标记为SUBQUERY；\n- DERIVED：衍生，在FROM列表中包含的子查询被标记为DERIVED；\n- UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；\n- UNION  RESULT：从UNION表获取结果的SELECT被标记为UNION RESULT；\n\n\n3） type：表示MySQL在表中找到所需行的方式，又称“访问类型”，包括：\n- ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行；\n- index：Full Index Scan，index与ALL区别为index类型只遍历索引树；\n- range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between  <  >  等查询；\n- ref：非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找；\n- eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描；\n- onst 和 system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下， 使用system；\n- NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引。\n\n4）possible_keys： 指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。\n\n5）key：显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。\n\n6）key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。\n\n7）ref： 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。\n\n8）rows： 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。\n\n9）Extra：其他重要信息 包括：\n- Using index：该值表示相应的select操作中使用了覆盖索引 ；\n- Using where：MySQL将用where子句来过滤结果集；\n- Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询；\n- Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”。\n\n### 6.2 慢查询日志\nmysql支持慢查询日志功能——mysql会将查询时间过长的sql相关信息写入日志。这个查询时间阀值由参数`long_query_time`指定，`long_query_time`的默认值为10，运行10S以上的查询sql会被记录到慢查询日志中。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。\n\n可通过以下sql查看慢查询日志是否开启：\n```sql\nshow variables  like '%slow_query_log%';\n```\n通过以下sql开启慢查询：\n```sql\nset global slow_query_log=1;\n```\n使用sql修改慢查询日志设置只对当前数据库生效，如果MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf。\n\n通过以下sql查看修改慢查询的阈值：\n```sql\nshow variables like 'long_query_time%';\nset global long_query_time=4;\n```\n\n## 7主从备份\n\n### 7.1主从备份原理\n\n主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。通过这种手段我们可以做到读写分离，主库写数据，从库读数据，从而提高数据库的可用。\nMySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点。\n\n主节点 binary log dump 线程：\n当从节点连接主节点时，主节点会创建一个`log dump` 线程，用于发送`binlog`的内容。在读取`binlog`中的操作时，此线程会对主节点上的`binlog`加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。\n\n 从节点I/O线程:\n 用于从库将主库的`binlog`复制到本地的`relay log`中，首先，从库库会先启动一个工作线程，称为IO工作线程，负责和主库建立一个普通的客户端连接。如果该进程追赶上了主库，它将进入睡眠状态，直到主库有新的事件产生通知它，他才会被唤醒，将接收到的事件记录到`relay log`(中继日志)中。\n\n 从节点SQL线程:\n SQL线程负责读取`relay log`中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。\n\n ### 7.2 主从备份延迟\n主备延迟最直接的表现是，备库消费中继日志（`relay log`）的速度，比主库生产`binlog` 的速度要慢。可能导致的原因有：\n- 大事务，主库上必须等事务执行完成才会写入binlog，再传给备库，当一个事物用时很久的时候，在从库上会因为这个事物的执行产生延迟。\n- 从库压力大。\n\n主备延迟当然是不好的，那么有哪些办法尽量减小主备延迟呢？有下面几个办法：\n- 一主多从——多接几个从库，让这些从库来分担读的压力。这样方法适用于从库读压力大的时候。\n- 通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力\n\n### 7.3 主从备份配置\n主机：\n```shell\n\nvi /etc/my.cnf\n\n\n#主数据库端ID号\nserver_id = 1           \n #开启二进制日志                  \nlog-bin = mysql-bin    \n#需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可                  \nbinlog-do-db = db        \n#将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中                 \nlog-slave-updates                        \n#控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失) \nsync_binlog = 1                    \n#这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突\nauto_increment_offset = 1           \n#这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突\nauto_increment_increment = 1            \n#二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除  \nexpire_logs_days = 7                    \n#将函数复制到slave  \nlog_bin_trust_function_creators = 1       \n```\n\n登录mysql\n```sql\n#创建slave账号account，密码123456\nmysql>grant replication slave on *.* to 'account'@'10.10.20.116' identified by '123456';\n#更新数据库权限\nmysql>flush privileges;\n\n# 检查log-bin\nshow variables like ‘log_bin’\n\n#查看主服务器状态\nshow master status\\G;\n\n\n```\n\n从机：\n```shell\nvi /etc/my.cnf\n\n\nserver_id = 2\nlog-bin = mysql-bin\nlog-slave-updates\nsync_binlog = 0\n#log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作\ninnodb_flush_log_at_trx_commit = 0        \n#指定slave要复制哪个库\nreplicate-do-db = db         \n#MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据\nslave-net-timeout = 60                    \nlog_bin_trust_function_creators = 1\n\n```\n登录mysql\n```sql\n#执行同步命令，设置主服务器ip，同步账号密码，同步位置\nmysql>change master to master_host='10.10.20.111',master_user='account',master_password='123456',master_log_file='mysql-bin.000033',master_log_pos=337523;\n#开启同步功能\nmysql>start slave;\n#查看从服务器状态\nmysql>show slave status\\G;\n```\n\n\n## 8 分布式事务\n由于篇幅问题，这里不再对分布式事物的概念做普及，直接介绍两种分布式事务: XA 分布式事务和 TCC分布式事务。\n\n### 8.1 XA分布式事务\n\nXA是两阶段提交的强一致性事物。在MySQL 5.7.7版本中，Oracle 官方将MySQL XA 一直存在的一个“bug” 进行了修复，使得MySQL XA 的实现符合了分布式事务的标准。\n\nXA事务中的角色：\n- 资源管理器（resource manager）：用来管理系统资源，是通向事务资源的途径。数据库就是一种资源管理器。资源管理还应该具有管理事务提交或回滚的能力。\n- 事务管理器（transaction manager）：事务管理器是分布式事务的核心管理者。事务管理器与每个资源管理器（resource \nmanager）进行通信，协调并完成事务的处理。事务的各个分支由唯一命名进行标识。\n\nXA规范的基础是两阶段提交协议：\n\n在第一阶段，交易中间件请求所有相关数据库准备提交（预提交）各自的事务分支，以确认是否所有相关数据库都可以提交各自的事务分支。当某一数据库收到预提交后，如果可以提交属于自己的事务分支，则将自己在该事务分支中所做的操作固定记录下来，并给交易中间件一个同意提交的应答，此时数据库将不能再在该事务分支中加入任何操作，但此时数据库并没有真正提交该事务，数据库对共享资源的操作还未释放（处于锁定状态）。如果由于某种原因数据库无法提交属于自己的事务分支，它将回滚自己的所有操作，释放对共享资源上的锁，并返回给交易中间件失败应答。\n\n在第二阶段，交易中间件审查所有数据库返回的预提交结果，如所有数据库都可以提交，交易中间件将要求所有数据库做正式提交，这样该全局事务被提交。而如果有任一数据库预提交返回失败，交易中间件将要求所有其它数据库回滚其操作，这样该全局事务被回滚。\n\nmysql允许多个数据库实例参与一个全局的事务。MySQL XA 的命令集合如下：\n```sql\n-- 开启一个事务，并将事务置于ACTIVE状态，此后执行的SQL语句都将置于该是事务中。\n\nXA START xid\n-- 将事务置于IDLE状态，表示事务内的SQL操作完成。\nXA END xid\n\n-- 事务提交的准备动作，事务状态置于PREPARED状态。事务如果无法完成提交前的准备操作，该语句会执行失败。\nXA PREPARE xid\n\n-- 事务最终提交，完成持久化。\nXA COMMIT xid\n\n-- 事务回滚终止\nXA ROLLBACK xid\n\n-- 查看MySQL中存在的PREPARED状态的xa事务。\nXA RECOVER\n```\nMySQL 在XA事务中扮演的是参与者的角色，被事务协调器所支配。XA事务比普通本地事务多了一个`PREPARE`状态，普通事务是 begin-> commit 而分布式事务是 begin->PREPARE 等其他数据库事务都到PREPARE状态的时候再 PREPARE->commit。分布式事务sql示例：\n\n```sql\n xa start 'aaa';\n insert into table(xxx) values(xxx);\n xa end 'aaa';\n xa prepare 'aaa';\n xa commit 'aaa';\n```\nXA事务存在的问题：\n\n- 单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。\n- 同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞状态，直到提交完成才能释放资源。\n- 数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。\n\n\n### 8.2 TCC分布式事务\nTCC又被称作柔性事务，通过事务补偿机制来达到事务的最终一致性，它不是强一致性的事务。TCC将事务分为两个阶段，或者说是由两个事务组成的。相对于XA事务来说TCC的并发性更好，XA是全局性的事务，而TCC是由两个本地事务组成。\n\n假设我们购买一件商品，后台需要操作两张表——积分表加积分而库存表扣库存，这两张表存在于两个数据库中，使用TCC事务执行这一事务：\n\n1）TCC实现阶段一：Try\n在try阶段并不是直接减库存加积分，而是将相关数据改变为预备的状态。库存表先锁定一个库存，锁定的方式可以预留一个锁定字段，当这个字段为一的时候表示这个商品被锁定。积分表加一个数据，这个数据也是被锁定状态，锁定方式和库存表一样。其sql形如：\n```sql\nupdate stock set lock=1 where id=1;\ninsert into credits (lock,...) values (1,...)\n\n```\n这两条sql如果都执行成功则进入 Confirm阶段，如果执行不成功则进入Cancel阶段\n\n2）TCC实现阶段二：Confirm\n\n这一阶段正式减库存加积分订单状态改为已支付。执行sql将锁定的库存扣除，为累加积分累加，以及一些其他的逻辑。\n\n3）TCC实现阶段三：Cancel\n当try阶段执行不成功，就会执行这一阶段，这个阶段将锁定的库存还原，锁定的积分删除掉。退回到事务执行前的状态。\n\nTCC事务原理很简单，使用起来却不简单。首先TCC事务对系统侵入性很大，其次是让业务逻辑变得复杂。在实际使用中我们必须依赖TCC事务中间件才能让TCC事务得以实现。通常一个TCC事务实现大概是这样子的：某个服务向外暴露了一个服务，这个服务对外正常调用，其他服务并不能感知到TCC事务的存在，而其服务内部，分别实现了Try,Confirm,Cancel三个接口，注册到TCC中间件上去。当调用这个服务的时候，其事务操作由该服务和TCC中间件共同完成。\n\n而TCC事务中间件还要做好其他事情，比如确保Confirm或者Cancel执行成功，如果发现某个服务的Cancel或者Confirm一直没成功，会不停的重试调用他的Cancel或者Confirm逻辑，务必要他成功！即使在尝试多次后无法成功也能通知到系统需要人工排查异常。TCC事务还要考虑一些异常情况的处理，比如说订单服务突然挂了，然后再次重启，TCC分布式事务框架要能够保证之前没执行完的分布式事务继续执行。TCC分布式事务框架还需要做好日志的记录，保存下来分布式事务运行的各个阶段和状态，以便系统上线后能够排查异常，恢复数据。目前开源的TCC事务框架有：`Seata` `ByteTCC` `tcc-transaction` 等。","slug":"intresting","published":1,"updated":"2021-01-11T07:31:23.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh75004l00wigt0o0mr0","content":"<p>作者: muggle</p>\n<h2 id=\"1-mysql-架构\"><a href=\"#1-mysql-架构\" class=\"headerlink\" title=\"1 mysql 架构\"></a>1 mysql 架构</h2><p>mysql分为server层和存储引擎</p>\n<h3 id=\"1-1-server层\"><a href=\"#1-1-server层\" class=\"headerlink\" title=\"1.1  server层\"></a>1.1  server层</h3><ul>\n<li>连接器：管理连接权限验证</li>\n<li>查询缓存：命中缓存直接换回查询结果</li>\n<li>分析器：分析语法</li>\n<li>优化器：生成执行计划，选择索引</li>\n<li>执行器：操作索引返回结果</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"1-2-存储引擎\"><a href=\"#1-2-存储引擎\" class=\"headerlink\" title=\"1.2  存储引擎\"></a>1.2  存储引擎</h3><p>存储引擎负责数据的存储和提取；其架构是插件式的。innodb在mysql5.5.5版本开始成为mysql默认存储引擎。</p>\n<p>各存储引擎比对：</p>\n<ul>\n<li>InnoDB：支持事务，支持外键，InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据，不支持全文索引。</li>\n<li>MyISAM：不支持事物，不支持外键，MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的，查询效率上MyISAM要高于InnnDB，因此做读写分离的时候一般选择用InnoDB做主机，MyISAM做从机</li>\n<li>Memory：有比较大的缺陷使用场景很少；文件数据都存储在内存中，如果mysqld进程发生异常，重启或关闭机器这些数据都会消失。</li>\n</ul>\n<h3 id=\"1-3-sql的执行过程\"><a href=\"#1-3-sql的执行过程\" class=\"headerlink\" title=\"1.3 sql的执行过程\"></a>1.3 sql的执行过程</h3><p>第一步客户端连接上mysql数据库的连接器，连接器获取权限，维持管理连接；连接完成后如果你没有后续的指令这个连接就会处于空闲状态，如果太长时间不使用这个连接这个连接就会断开，这个空闲时长默认是8小时，由wait_timeout参数控制。</p>\n<p>第二步你往mysql数据库发送了一条sql，这个时候查询缓存开始工作，看看之前有没有执行过这个sql，如果有则直接返回缓存数据到客户端，只要对表执行过更新操作缓存都会失效，因此一些很少更新的数据表可考虑使用数据库缓存，对频繁更新的表使用缓存反而弊大于利。使用缓存的方法如以下sql，通过SQL_CACHE来指定：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span>  SQL_CACHE <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> xxx<span class=\"operator\">=</span>xxx</span><br></pre></td></tr></table></figure>\n<p>第三步当未命中缓存的时候，分析器开始工作；分析器判断你是select还是update还是insert，分析你的语法是否正确。</p>\n<p>第四步优化器根据你的表的索引和sql语句决定用哪个索引，决定join的顺序。</p>\n<p>第五步执行器执行sql，调用存储引擎的接口，扫描遍历表或者插入更新数据。</p>\n<h2 id=\"2-mysql日志\"><a href=\"#2-mysql日志\" class=\"headerlink\" title=\"2 mysql日志\"></a>2 mysql日志</h2><h3 id=\"2-1-mysql日志介绍\"><a href=\"#2-1-mysql日志介绍\" class=\"headerlink\" title=\"2.1 mysql日志介绍\"></a>2.1 mysql日志介绍</h3><p>mysql有两个重要日志——redolog和binlog，redolog是独属于innodb的日志，binlog则是属于server层的日志。下面介绍这两个日志有什么用：当我们更新数据库数据的时候，这两个日志文件也会被更新，记录数据库更新操作。</p>\n<p>redolog又称作重做日志，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。它在数据库重启恢复的时候被使用，innodb利用这个日志恢复到数据库宕机前的状态，以此来保证数据的完整性。redolog是物理日志，记录的是某个表的数据做了哪些修改，redolog是固定大小的，也就是说后面的日志会覆盖前面的日志。</p>\n<p>binlog又称作归档日志，它记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作。binlog是逻辑日志，记录的是某个表执行了哪些操作。binlog是追加形式的写入日志，后面的日志不会被前面的覆盖</p>\n<h3 id=\"2-2-数据更新过程\"><a href=\"#2-2-数据更新过程\" class=\"headerlink\" title=\"2.2  数据更新过程\"></a>2.2  数据更新过程</h3><p>我们执行一个更新操作是这样的：读取对应的数据到内存—&gt;更新数据—&gt;写redolog日志—&gt;redolog状态为prepare—&gt;写binlog日志—&gt;提交事务—&gt;redolog状态为commit，数据正式写入日志文件。我们发现redolog的提交方式为“两段式提交”，这样做的目的是为了数据恢复的时候确保数据恢复的准确性，因为数据恢复是通过备份的binlog来完成的，所以要确保redolog要和binlog一致。</p>\n<h2 id=\"3-mysql的mvcc\"><a href=\"#3-mysql的mvcc\" class=\"headerlink\" title=\"3 mysql的mvcc\"></a>3 mysql的mvcc</h2><p>事务隔离级别在此略过，相信大部分小伙伴都知道相关的知识了，在这里单单只介绍mysql实现事务隔离的原理——mvcc(多版本并发控制)。在学习mvcc之前我需要先介绍快照读和当前读。</p>\n<h3 id=\"3-1-快照读和当前读\"><a href=\"#3-1-快照读和当前读\" class=\"headerlink\" title=\"3.1 快照读和当前读\"></a>3.1 快照读和当前读</h3><p>快照读就是一个<code>select</code>语句，形如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span></span><br></pre></td></tr></table></figure>\n<p>在<code>Repeatable read</code>事务隔离级别下，快照读的特点是获取当前数据库的快照数据，对于所有未commit的数据都不可见，快照读不会对数据上锁。</p>\n<p>当前读是对所读数据上悲观锁使其他当前读无法操作数据。当前读sql包括:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ... lock in share mode</span><br><span class=\"line\"></span><br><span class=\"line\">select ... <span class=\"keyword\">for</span> update</span><br><span class=\"line\"></span><br><span class=\"line\">insert</span><br><span class=\"line\"></span><br><span class=\"line\">update</span><br><span class=\"line\"></span><br><span class=\"line\">delete</span><br></pre></td></tr></table></figure>\n<p>其中后面三个sql都是给数据库上排他锁（X锁），而第一个sql是给数据库上共享锁（S锁）。X锁是一旦某个当前读到这个锁，其他当前读则没有对这个事务读写的权利，其他当前读会被阻塞住。而S锁是当一个当前读对某条数据上S锁，其他当前读可以对该数据也上S锁但不能上X锁，拿到S锁的当前读可以读数据不能改数据。（关于数据库悲观锁乐观锁并发章节会介绍）。</p>\n<h3 id=\"3-2-mvcc原理\"><a href=\"#3-2-mvcc原理\" class=\"headerlink\" title=\"3.2 mvcc原理\"></a>3.2 mvcc原理</h3><p>innodb实现快照读和当 前读悲观锁的技术就是mvcc。innodb在插入一条数据的时候会在后面跟上两个隐藏的列，这两个列，一个保存了这个行的创建时系统版本号，一个保存的是行的删除的系统版本号。每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。innodb更新一条数据是设置旧数据删除版本号，然后插入一条新的数据并设置创建版本号，然后删除旧的数据。那么怎么保证快照读是读取到未commit的数据呢，两个条件：</p>\n<ul>\n<li><p>InnoDB只查找创建版本早于当前事务版本的数据行，即，行的系统版本号小于或等于事务的系统版本号，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</p>\n</li>\n<li><p>行的删除版本，要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。<br>只有符合上述两个条件的纪录，才能作为查询结果返回。</p>\n</li>\n</ul>\n<p>而数据库锁也是通过比对版本号来决定是否阻塞某个事物。</p>\n<h2 id=\"4-mysql-索引\"><a href=\"#4-mysql-索引\" class=\"headerlink\" title=\"4 mysql 索引\"></a>4 mysql 索引</h2><h3 id=\"4-1-索引介绍\"><a href=\"#4-1-索引介绍\" class=\"headerlink\" title=\"4.1  索引介绍\"></a>4.1  索引介绍</h3><p>索引按数据结构分可分为哈希表，有序数组，搜索树，跳表：</p>\n<ul>\n<li>哈希表适用于只有等值查询的场景</li>\n<li>有序数组适用于有等值查询和范围查询的场景，但有序数组索引的更新代价很大，所以最好用于静态数据表</li>\n<li>搜索树的搜索效率稳定，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高</li>\n<li>跳表可以理解为优化的哈希索引</li>\n</ul>\n<p>innodb使用了B+树索引模型，而且是多叉树。虽然二叉树是索引效率最高的，但是索引需要写入磁盘，如果使用二叉树磁盘io会变得很频繁。在innodb索引中分为主键索引（聚簇索引）和非主键索引（二级索引）。主键索引保存了该行数据的全部信息，二级索引保存了该行数据的主键；所以使用二级索引的时候会先查出主键值，然后回表查询出数据，而使用主键索引则不需要回表。</p>\n<p>对二级索引而言可使用覆盖索引来优化sql，看下面两条sql</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> key<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> id <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> key<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>key是一个二级索引，第一条sql是先查询出id，然后根据id回表查询出真正的数据。而第二条查询索引后直接返回数据不需要回表。第二条sql索引key覆盖了我们的查询需求，称作覆盖索引</p>\n<h3 id=\"4-2-普通索引和唯一索引\"><a href=\"#4-2-普通索引和唯一索引\" class=\"headerlink\" title=\"4.2 普通索引和唯一索引\"></a>4.2 普通索引和唯一索引</h3><p>innoDB是按数据页来读写数据的，当要读取一条数据的时候是先将本页数据全部读入内存，然后找到对应数据，而不是直接读取，每页数据的默认大小为16KB。</p>\n<p>当一个数据页需要更新的时候，如果内存中有该数据页就直接更新，如果没有该数据页则在不影响数据一致性的前提下将；更新操作先缓存到<code>change buffer</code>中，在下次查询需要访问这个数据页的时候再写入更新操作除了查询会将<code>change buffer</code> 写入磁盘，后台线程线程也会定期将<code>change buffer</code>写入到磁盘中。对于唯一索引来说所有的更新操作都要先判断这个操作是否会违反唯一性约束，因此唯一索引的更新无法使用<code>change buffer</code> 而普通索引可以，唯一索引更新比普通索引更新多一个唯一性校验的过程。</p>\n<h3 id=\"4-3-联合索引\"><a href=\"#4-3-联合索引\" class=\"headerlink\" title=\"4.3 联合索引\"></a>4.3 联合索引</h3><p>两个或更多个列上的索引被称作联合索引（复合索引）。联合索引可减少索引开销，以联合索引(a,b,c)为例，建立这样的索引相当于建立了索引a、ab、abc三个索引——Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分，而且当最左侧字段是常量引用时，索引就十分有效，这就是<strong>最左前缀原则</strong>。由最左前缀原则可知，组合索引是有顺序的，那么哪个索引放在前面就比较有讲究了。对于组合索引还有一个知识点——<strong>索引下推</strong>，假设有组合索引（a，b，c）有如下sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selet <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> a<span class=\"operator\">=</span>xxx <span class=\"keyword\">and</span> b<span class=\"operator\">=</span>xxx</span><br></pre></td></tr></table></figure>\n<p>这个sql会进行两次筛选第一次查出<code>a=xxx</code>数据 再从<code>a=xxx</code>中查出 <code>b=xxx</code> 的数据。使用索引下推和不使用索引下推的区别在于不使用索引下推会先查出<code>a=xxx</code>数据的主键然后根据查询出的主键回表查询出全行数据，再在全行数据上查出 <code>b=xxx</code> 的数据；而索引下推的执行过程是先查出<code>a=xxx</code>数据的主键，然后在这些主键上二次查询 <code>b=xxx</code> 的主键，然后回表。</p>\n<p>索引下推的特点：</p>\n<ul>\n<li>innodb引擎的表，索引下推只能用于二级索引</li>\n<li>索引下推一般可用于所查询字段不全是联合索引的字段，查询条件为多条件查询且查询条件子句字段全是联合索引。</li>\n</ul>\n<h3 id=\"4-4-优化器与索引\"><a href=\"#4-4-优化器与索引\" class=\"headerlink\" title=\"4.4 优化器与索引\"></a>4.4 优化器与索引</h3><p>在 索引建立之后，一条语句可能会命中多个索引，这时，索引的选择，就会交由 优化器 来选择合适的索引。优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。那么优化器是怎么去确定索引的呢？优化器会优先选择扫描行数最少的索引，同时还会结合是否使用临时表、是否排序等因素进行综合判断。MySQL 在开始执行sql之前，并不知道满足这个条件的记录有多少条，而只能根据mysql的统计信息来估计。</p>\n<h3 id=\"4-5-其他索引知识点\"><a href=\"#4-5-其他索引知识点\" class=\"headerlink\" title=\"4.5 其他索引知识点\"></a>4.5 其他索引知识点</h3><p>有时候需要索引很长的字符列，这会让索引变得很大很慢还占内存。通常可以以开始的部分字符作为索引，这就是<strong>前缀索引</strong>。这样可以大大节约索引空间，从而提高索引效率，但这样也会降低索引的选择性。</p>\n<p><strong>脏页</strong>对数据库的影响：</p>\n<p>当内存数据页和磁盘的数据不一致的时候我们称这个内存页为脏页，内存数据写入磁盘后数据一致，称为干净页。当要读入数据而数据库没有内存的时候，这个时候需要淘汰内存中的数据页——干净页可以直接淘汰掉，而脏页需要先刷入磁盘再淘汰。如果一个查询要淘汰的脏页太多会导致查询的时间变长。为了减少脏页对数据库性能影响，innodb会控制脏页的比例和脏页刷新时机。</p>\n<h1 id=\"5-mysql语法分析及优化\"><a href=\"#5-mysql语法分析及优化\" class=\"headerlink\" title=\"5 mysql语法分析及优化\"></a>5 mysql语法分析及优化</h1><h3 id=\"5-1-count\"><a href=\"#5-1-count\" class=\"headerlink\" title=\"5.1 count(*)\"></a>5.1 count(*)</h3><p><code>count(*)</code>对innodb而言，它需要把数据从磁盘中读取出来然后累计计数；而MyISAM引擎把一个表的总行数存在了磁盘上，所以执行<code>count(*)</code>会直接返回这个数，如果有where条件则和innodb一样。<br>那么如何优化<code>count(*)</code>？一个思路是使用缓存，但是需要注意双写一致的问题（双写一致性后文缓存章节会做介绍）。还可以专门设计一张表用以存储<code>count(*)</code>。</p>\n<p>对于count(主键id)来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server 层。server层拿到id后，判断是不可能为空的，就按行累加。 对于count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个 数字“1”进去，判断是不可能为空的，按行累加。 单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎 返回id会涉及到解析数据行，以及拷贝字段值的操作。 对于count(字段)来说： 如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加； 如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再 判断一下，不是null才累加。  而对于count(*)来说，并不会把全部字段取出来，而是专门做了优化，不取值，按行累加。所以排序效率：</p>\n<blockquote>\n<p>count(*)=count(1)&gt;count(id)&gt;count(字段)</p>\n</blockquote>\n<h3 id=\"5-2-order-by\"><a href=\"#5-2-order-by\" class=\"headerlink\" title=\"5.2 order by\"></a>5.2 order by</h3><p>Mysql会给每个线程分配一块内存用于做排序处理，称为<code>sort_buffer</code>,一个包含排序的sql执行过程为：申请排序内存<code>sort_buffer</code>,然后一条条查询出整行数据，然后将需要的字段数据放入到排序内存中，染回对排序内存中的数据做一个快速排序，然后返回到客户端。当数据量过大，排序内存盛不下的时候就会利用磁盘临时文件来辅助排序。当我们排序内存盛不下数据的时候，mysql会使用<code>rowid</code>排序来优化。rowid排序相对于全字段排序，不会把所有字段都放入sort_buffer，所以在sort buffer中进行排序之后还得回表查询。在少数情况下，可以使用联合索引+索引覆盖的方式来优化order by。</p>\n<h3 id=\"5-3-join\"><a href=\"#5-3-join\" class=\"headerlink\" title=\"5.3 join\"></a>5.3 join</h3><p>在了解<code>join</code>之前我们应该先了解<strong>驱动表</strong>这个概念——当两表发生关联的时候就会有驱动表和被驱动表之分，驱动表也叫外表（R表），被驱动表也叫做内表（S表）。一般我们将小表当做驱动表（指定了联接条件时，满足查询条件的记录行数少的表为「驱动表」,未指定联接条件时，行数少的表为「驱动表」；MySQL 内部优化器也是这么做的）。</p>\n<p>假设有这样一句sql（xxx 为索引）:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> table1 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> tablet2 <span class=\"keyword\">on</span> table1.xxx<span class=\"operator\">=</span>table2.xxx </span><br></pre></td></tr></table></figure>\n<p>这条语句执行过程是先遍历表table1，然后根据从表table1中取出的每行数据中的xxx值，去表table2中查找满足条件的 记录。这个过程就跟我们写程序时的嵌套查询类似，并且能够用上被驱动表的索引，这种查询方式叫<code>NLJ</code>。当xxx不是索引的时候，再使用<code>NLJ</code>的话就会对table2做多次的全表扫描（每从table1取一条数据就全表扫描一次table2），扫描数暴涨。这个时候mysql会采用另外一个查询策略。Mysql会先把table1的数据读入到一个<code>join_buffer</code>的内存空间里面去，然后<br>依次取出table2的每一行数据，跟<code>join_buffer</code>中的数据做对比，满足join条件的作为结果集的一部分返回。<br>我们在使用<code>join</code>的时候,要遵循以下几点：</p>\n<ul>\n<li>小表驱动大表。</li>\n<li>被驱动表走索引的情况下（走<code>NLJ</code>查询方式）的时候才考虑用join</li>\n</ul>\n<h3 id=\"5-4-sql的优化\"><a href=\"#5-4-sql的优化\" class=\"headerlink\" title=\"5.4 sql的优化\"></a>5.4 sql的优化</h3><p>1） 在mysql中，如果对字段做了函数计算，就用不上索引了<br>如以下sql(data 为索引):</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span>  <span class=\"keyword\">from</span> tradelog <span class=\"keyword\">where</span> <span class=\"keyword\">month</span>(data)<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>优化器对这样的sql会放弃走搜索树，因为它无法知道data的区间。</p>\n<p>2）隐式的类型转换会导致索引失效。<br>如以下sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> xxx<span class=\"operator\">=</span><span class=\"number\">110717</span>;</span><br></pre></td></tr></table></figure>\n<p>其中xxx为<code>varchar</code>型，在mysql中，字符串和数字做比较的话，将字符串转换成数字再进行比较，这里相当于使用了<code>CAST(xxx AS signed )</code> 导致无法走索引。</p>\n<p>3）索引列参与了计算不会走索引</p>\n<p>4）like %xxx 不会走索引，like xxx% 会走索引</p>\n<p>5）在where子句中使用or，在innodb中不会走索引，而MyISAM会。</p>\n<h2 id=\"6执行计划和慢查询日志\"><a href=\"#6执行计划和慢查询日志\" class=\"headerlink\" title=\"6执行计划和慢查询日志\"></a>6执行计划和慢查询日志</h2><h3 id=\"6-1-执行计划\"><a href=\"#6-1-执行计划\" class=\"headerlink\" title=\"6.1 执行计划\"></a>6.1 执行计划</h3><p>在查询sql之前加上<code>explain</code>可查看该条sql的执行计划,如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span></span><br></pre></td></tr></table></figure>\n<p>这条sql会返回这样一个表：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>partitions</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_len</th>\n<th>ref</th>\n<th>rows</th>\n<th>filtered</th>\n<th>extra</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>simple</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>这个表便是sql的执行计划，我们可以通过分析这个执行计划来知道我们sql的运行情况。现对各列进行解释：</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>1）id：查询中执行select子句或操作表的顺序。</p>\n<p>2）select_type：查询中每个select子句的类型（简单 到复杂）包括：</p>\n<ul>\n<li>SIMPLE：查询中不包含子查询或者UNION；</li>\n<li>PRIMARY：查询中包含复杂的子部分；</li>\n<li>SUBQUERY：在SELECT或WHERE列表中包含了子查询，该子查询被标记为SUBQUERY；</li>\n<li>DERIVED：衍生，在FROM列表中包含的子查询被标记为DERIVED；</li>\n<li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；</li>\n<li>UNION  RESULT：从UNION表获取结果的SELECT被标记为UNION RESULT；</li>\n</ul>\n<p>3） type：表示MySQL在表中找到所需行的方式，又称“访问类型”，包括：</p>\n<ul>\n<li>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行；</li>\n<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树；</li>\n<li>range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between  &lt;  &gt;  等查询；</li>\n<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找；</li>\n<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描；</li>\n<li>onst 和 system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下， 使用system；</li>\n<li>NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引。</li>\n</ul>\n<p>4）possible_keys： 指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。</p>\n<p>5）key：显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>\n<p>6）key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。</p>\n<p>7）ref： 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p>\n<p>8）rows： 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p>\n<p>9）Extra：其他重要信息 包括：</p>\n<ul>\n<li>Using index：该值表示相应的select操作中使用了覆盖索引 ；</li>\n<li>Using where：MySQL将用where子句来过滤结果集；</li>\n<li>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询；</li>\n<li>Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”。</li>\n</ul>\n<h3 id=\"6-2-慢查询日志\"><a href=\"#6-2-慢查询日志\" class=\"headerlink\" title=\"6.2 慢查询日志\"></a>6.2 慢查询日志</h3><p>mysql支持慢查询日志功能——mysql会将查询时间过长的sql相关信息写入日志。这个查询时间阀值由参数<code>long_query_time</code>指定，<code>long_query_time</code>的默认值为10，运行10S以上的查询sql会被记录到慢查询日志中。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p>\n<p>可通过以下sql查看慢查询日志是否开启：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables  <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log%&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>通过以下sql开启慢查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>使用sql修改慢查询日志设置只对当前数据库生效，如果MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf。</p>\n<p>通过以下sql查看修改慢查询的阈值：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;long_query_time%&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7主从备份\"><a href=\"#7主从备份\" class=\"headerlink\" title=\"7主从备份\"></a>7主从备份</h2><h3 id=\"7-1主从备份原理\"><a href=\"#7-1主从备份原理\" class=\"headerlink\" title=\"7.1主从备份原理\"></a>7.1主从备份原理</h3><p>主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。通过这种手段我们可以做到读写分离，主库写数据，从库读数据，从而提高数据库的可用。<br>MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点。</p>\n<p>主节点 binary log dump 线程：<br>当从节点连接主节点时，主节点会创建一个<code>log dump</code> 线程，用于发送<code>binlog</code>的内容。在读取<code>binlog</code>中的操作时，此线程会对主节点上的<code>binlog</code>加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。</p>\n<p> 从节点I/O线程:<br> 用于从库将主库的<code>binlog</code>复制到本地的<code>relay log</code>中，首先，从库库会先启动一个工作线程，称为IO工作线程，负责和主库建立一个普通的客户端连接。如果该进程追赶上了主库，它将进入睡眠状态，直到主库有新的事件产生通知它，他才会被唤醒，将接收到的事件记录到<code>relay log</code>(中继日志)中。</p>\n<p> 从节点SQL线程:<br> SQL线程负责读取<code>relay log</code>中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</p>\n<h3 id=\"7-2-主从备份延迟\"><a href=\"#7-2-主从备份延迟\" class=\"headerlink\" title=\"7.2 主从备份延迟\"></a>7.2 主从备份延迟</h3><p>主备延迟最直接的表现是，备库消费中继日志（<code>relay log</code>）的速度，比主库生产<code>binlog</code> 的速度要慢。可能导致的原因有：</p>\n<ul>\n<li>大事务，主库上必须等事务执行完成才会写入binlog，再传给备库，当一个事物用时很久的时候，在从库上会因为这个事物的执行产生延迟。</li>\n<li>从库压力大。</li>\n</ul>\n<p>主备延迟当然是不好的，那么有哪些办法尽量减小主备延迟呢？有下面几个办法：</p>\n<ul>\n<li>一主多从——多接几个从库，让这些从库来分担读的压力。这样方法适用于从库读压力大的时候。</li>\n<li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力</li>\n</ul>\n<h3 id=\"7-3-主从备份配置\"><a href=\"#7-3-主从备份配置\" class=\"headerlink\" title=\"7.3 主从备份配置\"></a>7.3 主从备份配置</h3><p>主机：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">vi /etc/my.cnf</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">主数据库端ID号</span></span><br><span class=\"line\">server_id = 1           </span><br><span class=\"line\"><span class=\"meta\"> #</span><span class=\"bash\">开启二进制日志</span>                  </span><br><span class=\"line\">log-bin = mysql-bin    </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可</span>                  </span><br><span class=\"line\">binlog-do-db = db        </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中</span>                 </span><br><span class=\"line\">log-slave-updates                        </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失)</span> </span><br><span class=\"line\">sync_binlog = 1                    </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突</span></span><br><span class=\"line\">auto_increment_offset = 1           </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突</span></span><br><span class=\"line\">auto_increment_increment = 1            </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除</span>  </span><br><span class=\"line\">expire_logs_days = 7                    </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">将函数复制到slave</span>  </span><br><span class=\"line\">log_bin_trust_function_creators = 1       </span><br></pre></td></tr></table></figure>\n<p>登录mysql</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#创建slave账号account，密码<span class=\"number\">123456</span></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span><span class=\"keyword\">grant</span> replication slave <span class=\"keyword\">on</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">to</span> <span class=\"string\">&#x27;account&#x27;</span>@<span class=\"string\">&#x27;10.10.20.116&#x27;</span> identified <span class=\"keyword\">by</span> <span class=\"string\">&#x27;123456&#x27;</span>;</span><br><span class=\"line\">#更新数据库权限</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span>flush privileges;</span><br><span class=\"line\"></span><br><span class=\"line\"># 检查log<span class=\"operator\">-</span>bin</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> ‘log_bin’</span><br><span class=\"line\"></span><br><span class=\"line\">#查看主服务器状态</span><br><span class=\"line\"><span class=\"keyword\">show</span> master status\\G;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>从机：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/my.cnf</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">server_id = 2</span><br><span class=\"line\">log-bin = mysql-bin</span><br><span class=\"line\">log-slave-updates</span><br><span class=\"line\">sync_binlog = 0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"built_in\">log</span> buffer将每秒一次地写入<span class=\"built_in\">log</span> file中，并且<span class=\"built_in\">log</span> file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作</span></span><br><span class=\"line\">innodb_flush_log_at_trx_commit = 0        </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定slave要复制哪个库</span></span><br><span class=\"line\">replicate-do-db = db         </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据</span></span><br><span class=\"line\">slave-net-timeout = 60                    </span><br><span class=\"line\">log_bin_trust_function_creators = 1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>登录mysql</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#执行同步命令，设置主服务器ip，同步账号密码，同步位置</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span>change master <span class=\"keyword\">to</span> master_host<span class=\"operator\">=</span><span class=\"string\">&#x27;10.10.20.111&#x27;</span>,master_user<span class=\"operator\">=</span><span class=\"string\">&#x27;account&#x27;</span>,master_password<span class=\"operator\">=</span><span class=\"string\">&#x27;123456&#x27;</span>,master_log_file<span class=\"operator\">=</span><span class=\"string\">&#x27;mysql-bin.000033&#x27;</span>,master_log_pos<span class=\"operator\">=</span><span class=\"number\">337523</span>;</span><br><span class=\"line\">#开启同步功能</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span><span class=\"keyword\">start</span> slave;</span><br><span class=\"line\">#查看从服务器状态</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span><span class=\"keyword\">show</span> slave status\\G;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-分布式事务\"><a href=\"#8-分布式事务\" class=\"headerlink\" title=\"8 分布式事务\"></a>8 分布式事务</h2><p>由于篇幅问题，这里不再对分布式事物的概念做普及，直接介绍两种分布式事务: XA 分布式事务和 TCC分布式事务。</p>\n<h3 id=\"8-1-XA分布式事务\"><a href=\"#8-1-XA分布式事务\" class=\"headerlink\" title=\"8.1 XA分布式事务\"></a>8.1 XA分布式事务</h3><p>XA是两阶段提交的强一致性事物。在MySQL 5.7.7版本中，Oracle 官方将MySQL XA 一直存在的一个“bug” 进行了修复，使得MySQL XA 的实现符合了分布式事务的标准。</p>\n<p>XA事务中的角色：</p>\n<ul>\n<li>资源管理器（resource manager）：用来管理系统资源，是通向事务资源的途径。数据库就是一种资源管理器。资源管理还应该具有管理事务提交或回滚的能力。</li>\n<li>事务管理器（transaction manager）：事务管理器是分布式事务的核心管理者。事务管理器与每个资源管理器（resource<br>manager）进行通信，协调并完成事务的处理。事务的各个分支由唯一命名进行标识。</li>\n</ul>\n<p>XA规范的基础是两阶段提交协议：</p>\n<p>在第一阶段，交易中间件请求所有相关数据库准备提交（预提交）各自的事务分支，以确认是否所有相关数据库都可以提交各自的事务分支。当某一数据库收到预提交后，如果可以提交属于自己的事务分支，则将自己在该事务分支中所做的操作固定记录下来，并给交易中间件一个同意提交的应答，此时数据库将不能再在该事务分支中加入任何操作，但此时数据库并没有真正提交该事务，数据库对共享资源的操作还未释放（处于锁定状态）。如果由于某种原因数据库无法提交属于自己的事务分支，它将回滚自己的所有操作，释放对共享资源上的锁，并返回给交易中间件失败应答。</p>\n<p>在第二阶段，交易中间件审查所有数据库返回的预提交结果，如所有数据库都可以提交，交易中间件将要求所有数据库做正式提交，这样该全局事务被提交。而如果有任一数据库预提交返回失败，交易中间件将要求所有其它数据库回滚其操作，这样该全局事务被回滚。</p>\n<p>mysql允许多个数据库实例参与一个全局的事务。MySQL XA 的命令集合如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 开启一个事务，并将事务置于ACTIVE状态，此后执行的SQL语句都将置于该是事务中。</span></span><br><span class=\"line\"></span><br><span class=\"line\">XA <span class=\"keyword\">START</span> xid</span><br><span class=\"line\"><span class=\"comment\">-- 将事务置于IDLE状态，表示事务内的SQL操作完成。</span></span><br><span class=\"line\">XA <span class=\"keyword\">END</span> xid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务提交的准备动作，事务状态置于PREPARED状态。事务如果无法完成提交前的准备操作，该语句会执行失败。</span></span><br><span class=\"line\">XA <span class=\"keyword\">PREPARE</span> xid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务最终提交，完成持久化。</span></span><br><span class=\"line\">XA <span class=\"keyword\">COMMIT</span> xid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务回滚终止</span></span><br><span class=\"line\">XA <span class=\"keyword\">ROLLBACK</span> xid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看MySQL中存在的PREPARED状态的xa事务。</span></span><br><span class=\"line\">XA RECOVER</span><br></pre></td></tr></table></figure>\n<p>MySQL 在XA事务中扮演的是参与者的角色，被事务协调器所支配。XA事务比普通本地事务多了一个<code>PREPARE</code>状态，普通事务是 begin-&gt; commit 而分布式事务是 begin-&gt;PREPARE 等其他数据库事务都到PREPARE状态的时候再 PREPARE-&gt;commit。分布式事务sql示例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xa <span class=\"keyword\">start</span> <span class=\"string\">&#x27;aaa&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span>(xxx) <span class=\"keyword\">values</span>(xxx);</span><br><span class=\"line\">xa <span class=\"keyword\">end</span> <span class=\"string\">&#x27;aaa&#x27;</span>;</span><br><span class=\"line\">xa <span class=\"keyword\">prepare</span> <span class=\"string\">&#x27;aaa&#x27;</span>;</span><br><span class=\"line\">xa <span class=\"keyword\">commit</span> <span class=\"string\">&#x27;aaa&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>XA事务存在的问题：</p>\n<ul>\n<li>单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li>\n<li>同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞状态，直到提交完成才能释放资源。</li>\n<li>数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li>\n</ul>\n<h3 id=\"8-2-TCC分布式事务\"><a href=\"#8-2-TCC分布式事务\" class=\"headerlink\" title=\"8.2 TCC分布式事务\"></a>8.2 TCC分布式事务</h3><p>TCC又被称作柔性事务，通过事务补偿机制来达到事务的最终一致性，它不是强一致性的事务。TCC将事务分为两个阶段，或者说是由两个事务组成的。相对于XA事务来说TCC的并发性更好，XA是全局性的事务，而TCC是由两个本地事务组成。</p>\n<p>假设我们购买一件商品，后台需要操作两张表——积分表加积分而库存表扣库存，这两张表存在于两个数据库中，使用TCC事务执行这一事务：</p>\n<p>1）TCC实现阶段一：Try<br>在try阶段并不是直接减库存加积分，而是将相关数据改变为预备的状态。库存表先锁定一个库存，锁定的方式可以预留一个锁定字段，当这个字段为一的时候表示这个商品被锁定。积分表加一个数据，这个数据也是被锁定状态，锁定方式和库存表一样。其sql形如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> stock <span class=\"keyword\">set</span> lock<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> credits (lock,...) <span class=\"keyword\">values</span> (<span class=\"number\">1</span>,...)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这两条sql如果都执行成功则进入 Confirm阶段，如果执行不成功则进入Cancel阶段</p>\n<p>2）TCC实现阶段二：Confirm</p>\n<p>这一阶段正式减库存加积分订单状态改为已支付。执行sql将锁定的库存扣除，为累加积分累加，以及一些其他的逻辑。</p>\n<p>3）TCC实现阶段三：Cancel<br>当try阶段执行不成功，就会执行这一阶段，这个阶段将锁定的库存还原，锁定的积分删除掉。退回到事务执行前的状态。</p>\n<p>TCC事务原理很简单，使用起来却不简单。首先TCC事务对系统侵入性很大，其次是让业务逻辑变得复杂。在实际使用中我们必须依赖TCC事务中间件才能让TCC事务得以实现。通常一个TCC事务实现大概是这样子的：某个服务向外暴露了一个服务，这个服务对外正常调用，其他服务并不能感知到TCC事务的存在，而其服务内部，分别实现了Try,Confirm,Cancel三个接口，注册到TCC中间件上去。当调用这个服务的时候，其事务操作由该服务和TCC中间件共同完成。</p>\n<p>而TCC事务中间件还要做好其他事情，比如确保Confirm或者Cancel执行成功，如果发现某个服务的Cancel或者Confirm一直没成功，会不停的重试调用他的Cancel或者Confirm逻辑，务必要他成功！即使在尝试多次后无法成功也能通知到系统需要人工排查异常。TCC事务还要考虑一些异常情况的处理，比如说订单服务突然挂了，然后再次重启，TCC分布式事务框架要能够保证之前没执行完的分布式事务继续执行。TCC分布式事务框架还需要做好日志的记录，保存下来分布式事务运行的各个阶段和状态，以便系统上线后能够排查异常，恢复数据。目前开源的TCC事务框架有：<code>Seata</code> <code>ByteTCC</code> <code>tcc-transaction</code> 等。</p>\n","site":{"data":{}},"excerpt":"<p>作者: muggle</p>\n<h2 id=\"1-mysql-架构\"><a href=\"#1-mysql-架构\" class=\"headerlink\" title=\"1 mysql 架构\"></a>1 mysql 架构</h2><p>mysql分为server层和存储引擎</p>\n<h3 id=\"1-1-server层\"><a href=\"#1-1-server层\" class=\"headerlink\" title=\"1.1  server层\"></a>1.1  server层</h3><ul>\n<li>连接器：管理连接权限验证</li>\n<li>查询缓存：命中缓存直接换回查询结果</li>\n<li>分析器：分析语法</li>\n<li>优化器：生成执行计划，选择索引</li>\n<li>执行器：操作索引返回结果</li>\n</ul>","more":"<h3 id=\"1-2-存储引擎\"><a href=\"#1-2-存储引擎\" class=\"headerlink\" title=\"1.2  存储引擎\"></a>1.2  存储引擎</h3><p>存储引擎负责数据的存储和提取；其架构是插件式的。innodb在mysql5.5.5版本开始成为mysql默认存储引擎。</p>\n<p>各存储引擎比对：</p>\n<ul>\n<li>InnoDB：支持事务，支持外键，InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据，不支持全文索引。</li>\n<li>MyISAM：不支持事物，不支持外键，MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的，查询效率上MyISAM要高于InnnDB，因此做读写分离的时候一般选择用InnoDB做主机，MyISAM做从机</li>\n<li>Memory：有比较大的缺陷使用场景很少；文件数据都存储在内存中，如果mysqld进程发生异常，重启或关闭机器这些数据都会消失。</li>\n</ul>\n<h3 id=\"1-3-sql的执行过程\"><a href=\"#1-3-sql的执行过程\" class=\"headerlink\" title=\"1.3 sql的执行过程\"></a>1.3 sql的执行过程</h3><p>第一步客户端连接上mysql数据库的连接器，连接器获取权限，维持管理连接；连接完成后如果你没有后续的指令这个连接就会处于空闲状态，如果太长时间不使用这个连接这个连接就会断开，这个空闲时长默认是8小时，由wait_timeout参数控制。</p>\n<p>第二步你往mysql数据库发送了一条sql，这个时候查询缓存开始工作，看看之前有没有执行过这个sql，如果有则直接返回缓存数据到客户端，只要对表执行过更新操作缓存都会失效，因此一些很少更新的数据表可考虑使用数据库缓存，对频繁更新的表使用缓存反而弊大于利。使用缓存的方法如以下sql，通过SQL_CACHE来指定：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span>  SQL_CACHE <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> xxx<span class=\"operator\">=</span>xxx</span><br></pre></td></tr></table></figure>\n<p>第三步当未命中缓存的时候，分析器开始工作；分析器判断你是select还是update还是insert，分析你的语法是否正确。</p>\n<p>第四步优化器根据你的表的索引和sql语句决定用哪个索引，决定join的顺序。</p>\n<p>第五步执行器执行sql，调用存储引擎的接口，扫描遍历表或者插入更新数据。</p>\n<h2 id=\"2-mysql日志\"><a href=\"#2-mysql日志\" class=\"headerlink\" title=\"2 mysql日志\"></a>2 mysql日志</h2><h3 id=\"2-1-mysql日志介绍\"><a href=\"#2-1-mysql日志介绍\" class=\"headerlink\" title=\"2.1 mysql日志介绍\"></a>2.1 mysql日志介绍</h3><p>mysql有两个重要日志——redolog和binlog，redolog是独属于innodb的日志，binlog则是属于server层的日志。下面介绍这两个日志有什么用：当我们更新数据库数据的时候，这两个日志文件也会被更新，记录数据库更新操作。</p>\n<p>redolog又称作重做日志，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。它在数据库重启恢复的时候被使用，innodb利用这个日志恢复到数据库宕机前的状态，以此来保证数据的完整性。redolog是物理日志，记录的是某个表的数据做了哪些修改，redolog是固定大小的，也就是说后面的日志会覆盖前面的日志。</p>\n<p>binlog又称作归档日志，它记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作。binlog是逻辑日志，记录的是某个表执行了哪些操作。binlog是追加形式的写入日志，后面的日志不会被前面的覆盖</p>\n<h3 id=\"2-2-数据更新过程\"><a href=\"#2-2-数据更新过程\" class=\"headerlink\" title=\"2.2  数据更新过程\"></a>2.2  数据更新过程</h3><p>我们执行一个更新操作是这样的：读取对应的数据到内存—&gt;更新数据—&gt;写redolog日志—&gt;redolog状态为prepare—&gt;写binlog日志—&gt;提交事务—&gt;redolog状态为commit，数据正式写入日志文件。我们发现redolog的提交方式为“两段式提交”，这样做的目的是为了数据恢复的时候确保数据恢复的准确性，因为数据恢复是通过备份的binlog来完成的，所以要确保redolog要和binlog一致。</p>\n<h2 id=\"3-mysql的mvcc\"><a href=\"#3-mysql的mvcc\" class=\"headerlink\" title=\"3 mysql的mvcc\"></a>3 mysql的mvcc</h2><p>事务隔离级别在此略过，相信大部分小伙伴都知道相关的知识了，在这里单单只介绍mysql实现事务隔离的原理——mvcc(多版本并发控制)。在学习mvcc之前我需要先介绍快照读和当前读。</p>\n<h3 id=\"3-1-快照读和当前读\"><a href=\"#3-1-快照读和当前读\" class=\"headerlink\" title=\"3.1 快照读和当前读\"></a>3.1 快照读和当前读</h3><p>快照读就是一个<code>select</code>语句，形如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span></span><br></pre></td></tr></table></figure>\n<p>在<code>Repeatable read</code>事务隔离级别下，快照读的特点是获取当前数据库的快照数据，对于所有未commit的数据都不可见，快照读不会对数据上锁。</p>\n<p>当前读是对所读数据上悲观锁使其他当前读无法操作数据。当前读sql包括:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ... lock in share mode</span><br><span class=\"line\"></span><br><span class=\"line\">select ... <span class=\"keyword\">for</span> update</span><br><span class=\"line\"></span><br><span class=\"line\">insert</span><br><span class=\"line\"></span><br><span class=\"line\">update</span><br><span class=\"line\"></span><br><span class=\"line\">delete</span><br></pre></td></tr></table></figure>\n<p>其中后面三个sql都是给数据库上排他锁（X锁），而第一个sql是给数据库上共享锁（S锁）。X锁是一旦某个当前读到这个锁，其他当前读则没有对这个事务读写的权利，其他当前读会被阻塞住。而S锁是当一个当前读对某条数据上S锁，其他当前读可以对该数据也上S锁但不能上X锁，拿到S锁的当前读可以读数据不能改数据。（关于数据库悲观锁乐观锁并发章节会介绍）。</p>\n<h3 id=\"3-2-mvcc原理\"><a href=\"#3-2-mvcc原理\" class=\"headerlink\" title=\"3.2 mvcc原理\"></a>3.2 mvcc原理</h3><p>innodb实现快照读和当 前读悲观锁的技术就是mvcc。innodb在插入一条数据的时候会在后面跟上两个隐藏的列，这两个列，一个保存了这个行的创建时系统版本号，一个保存的是行的删除的系统版本号。每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。innodb更新一条数据是设置旧数据删除版本号，然后插入一条新的数据并设置创建版本号，然后删除旧的数据。那么怎么保证快照读是读取到未commit的数据呢，两个条件：</p>\n<ul>\n<li><p>InnoDB只查找创建版本早于当前事务版本的数据行，即，行的系统版本号小于或等于事务的系统版本号，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</p>\n</li>\n<li><p>行的删除版本，要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。<br>只有符合上述两个条件的纪录，才能作为查询结果返回。</p>\n</li>\n</ul>\n<p>而数据库锁也是通过比对版本号来决定是否阻塞某个事物。</p>\n<h2 id=\"4-mysql-索引\"><a href=\"#4-mysql-索引\" class=\"headerlink\" title=\"4 mysql 索引\"></a>4 mysql 索引</h2><h3 id=\"4-1-索引介绍\"><a href=\"#4-1-索引介绍\" class=\"headerlink\" title=\"4.1  索引介绍\"></a>4.1  索引介绍</h3><p>索引按数据结构分可分为哈希表，有序数组，搜索树，跳表：</p>\n<ul>\n<li>哈希表适用于只有等值查询的场景</li>\n<li>有序数组适用于有等值查询和范围查询的场景，但有序数组索引的更新代价很大，所以最好用于静态数据表</li>\n<li>搜索树的搜索效率稳定，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高</li>\n<li>跳表可以理解为优化的哈希索引</li>\n</ul>\n<p>innodb使用了B+树索引模型，而且是多叉树。虽然二叉树是索引效率最高的，但是索引需要写入磁盘，如果使用二叉树磁盘io会变得很频繁。在innodb索引中分为主键索引（聚簇索引）和非主键索引（二级索引）。主键索引保存了该行数据的全部信息，二级索引保存了该行数据的主键；所以使用二级索引的时候会先查出主键值，然后回表查询出数据，而使用主键索引则不需要回表。</p>\n<p>对二级索引而言可使用覆盖索引来优化sql，看下面两条sql</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> key<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> id <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> key<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>key是一个二级索引，第一条sql是先查询出id，然后根据id回表查询出真正的数据。而第二条查询索引后直接返回数据不需要回表。第二条sql索引key覆盖了我们的查询需求，称作覆盖索引</p>\n<h3 id=\"4-2-普通索引和唯一索引\"><a href=\"#4-2-普通索引和唯一索引\" class=\"headerlink\" title=\"4.2 普通索引和唯一索引\"></a>4.2 普通索引和唯一索引</h3><p>innoDB是按数据页来读写数据的，当要读取一条数据的时候是先将本页数据全部读入内存，然后找到对应数据，而不是直接读取，每页数据的默认大小为16KB。</p>\n<p>当一个数据页需要更新的时候，如果内存中有该数据页就直接更新，如果没有该数据页则在不影响数据一致性的前提下将；更新操作先缓存到<code>change buffer</code>中，在下次查询需要访问这个数据页的时候再写入更新操作除了查询会将<code>change buffer</code> 写入磁盘，后台线程线程也会定期将<code>change buffer</code>写入到磁盘中。对于唯一索引来说所有的更新操作都要先判断这个操作是否会违反唯一性约束，因此唯一索引的更新无法使用<code>change buffer</code> 而普通索引可以，唯一索引更新比普通索引更新多一个唯一性校验的过程。</p>\n<h3 id=\"4-3-联合索引\"><a href=\"#4-3-联合索引\" class=\"headerlink\" title=\"4.3 联合索引\"></a>4.3 联合索引</h3><p>两个或更多个列上的索引被称作联合索引（复合索引）。联合索引可减少索引开销，以联合索引(a,b,c)为例，建立这样的索引相当于建立了索引a、ab、abc三个索引——Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分，而且当最左侧字段是常量引用时，索引就十分有效，这就是<strong>最左前缀原则</strong>。由最左前缀原则可知，组合索引是有顺序的，那么哪个索引放在前面就比较有讲究了。对于组合索引还有一个知识点——<strong>索引下推</strong>，假设有组合索引（a，b，c）有如下sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selet <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> a<span class=\"operator\">=</span>xxx <span class=\"keyword\">and</span> b<span class=\"operator\">=</span>xxx</span><br></pre></td></tr></table></figure>\n<p>这个sql会进行两次筛选第一次查出<code>a=xxx</code>数据 再从<code>a=xxx</code>中查出 <code>b=xxx</code> 的数据。使用索引下推和不使用索引下推的区别在于不使用索引下推会先查出<code>a=xxx</code>数据的主键然后根据查询出的主键回表查询出全行数据，再在全行数据上查出 <code>b=xxx</code> 的数据；而索引下推的执行过程是先查出<code>a=xxx</code>数据的主键，然后在这些主键上二次查询 <code>b=xxx</code> 的主键，然后回表。</p>\n<p>索引下推的特点：</p>\n<ul>\n<li>innodb引擎的表，索引下推只能用于二级索引</li>\n<li>索引下推一般可用于所查询字段不全是联合索引的字段，查询条件为多条件查询且查询条件子句字段全是联合索引。</li>\n</ul>\n<h3 id=\"4-4-优化器与索引\"><a href=\"#4-4-优化器与索引\" class=\"headerlink\" title=\"4.4 优化器与索引\"></a>4.4 优化器与索引</h3><p>在 索引建立之后，一条语句可能会命中多个索引，这时，索引的选择，就会交由 优化器 来选择合适的索引。优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。那么优化器是怎么去确定索引的呢？优化器会优先选择扫描行数最少的索引，同时还会结合是否使用临时表、是否排序等因素进行综合判断。MySQL 在开始执行sql之前，并不知道满足这个条件的记录有多少条，而只能根据mysql的统计信息来估计。</p>\n<h3 id=\"4-5-其他索引知识点\"><a href=\"#4-5-其他索引知识点\" class=\"headerlink\" title=\"4.5 其他索引知识点\"></a>4.5 其他索引知识点</h3><p>有时候需要索引很长的字符列，这会让索引变得很大很慢还占内存。通常可以以开始的部分字符作为索引，这就是<strong>前缀索引</strong>。这样可以大大节约索引空间，从而提高索引效率，但这样也会降低索引的选择性。</p>\n<p><strong>脏页</strong>对数据库的影响：</p>\n<p>当内存数据页和磁盘的数据不一致的时候我们称这个内存页为脏页，内存数据写入磁盘后数据一致，称为干净页。当要读入数据而数据库没有内存的时候，这个时候需要淘汰内存中的数据页——干净页可以直接淘汰掉，而脏页需要先刷入磁盘再淘汰。如果一个查询要淘汰的脏页太多会导致查询的时间变长。为了减少脏页对数据库性能影响，innodb会控制脏页的比例和脏页刷新时机。</p>\n<h1 id=\"5-mysql语法分析及优化\"><a href=\"#5-mysql语法分析及优化\" class=\"headerlink\" title=\"5 mysql语法分析及优化\"></a>5 mysql语法分析及优化</h1><h3 id=\"5-1-count\"><a href=\"#5-1-count\" class=\"headerlink\" title=\"5.1 count(*)\"></a>5.1 count(*)</h3><p><code>count(*)</code>对innodb而言，它需要把数据从磁盘中读取出来然后累计计数；而MyISAM引擎把一个表的总行数存在了磁盘上，所以执行<code>count(*)</code>会直接返回这个数，如果有where条件则和innodb一样。<br>那么如何优化<code>count(*)</code>？一个思路是使用缓存，但是需要注意双写一致的问题（双写一致性后文缓存章节会做介绍）。还可以专门设计一张表用以存储<code>count(*)</code>。</p>\n<p>对于count(主键id)来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server 层。server层拿到id后，判断是不可能为空的，就按行累加。 对于count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个 数字“1”进去，判断是不可能为空的，按行累加。 单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键id)快。因为从引擎 返回id会涉及到解析数据行，以及拷贝字段值的操作。 对于count(字段)来说： 如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加； 如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再 判断一下，不是null才累加。  而对于count(*)来说，并不会把全部字段取出来，而是专门做了优化，不取值，按行累加。所以排序效率：</p>\n<blockquote>\n<p>count(*)=count(1)&gt;count(id)&gt;count(字段)</p>\n</blockquote>\n<h3 id=\"5-2-order-by\"><a href=\"#5-2-order-by\" class=\"headerlink\" title=\"5.2 order by\"></a>5.2 order by</h3><p>Mysql会给每个线程分配一块内存用于做排序处理，称为<code>sort_buffer</code>,一个包含排序的sql执行过程为：申请排序内存<code>sort_buffer</code>,然后一条条查询出整行数据，然后将需要的字段数据放入到排序内存中，染回对排序内存中的数据做一个快速排序，然后返回到客户端。当数据量过大，排序内存盛不下的时候就会利用磁盘临时文件来辅助排序。当我们排序内存盛不下数据的时候，mysql会使用<code>rowid</code>排序来优化。rowid排序相对于全字段排序，不会把所有字段都放入sort_buffer，所以在sort buffer中进行排序之后还得回表查询。在少数情况下，可以使用联合索引+索引覆盖的方式来优化order by。</p>\n<h3 id=\"5-3-join\"><a href=\"#5-3-join\" class=\"headerlink\" title=\"5.3 join\"></a>5.3 join</h3><p>在了解<code>join</code>之前我们应该先了解<strong>驱动表</strong>这个概念——当两表发生关联的时候就会有驱动表和被驱动表之分，驱动表也叫外表（R表），被驱动表也叫做内表（S表）。一般我们将小表当做驱动表（指定了联接条件时，满足查询条件的记录行数少的表为「驱动表」,未指定联接条件时，行数少的表为「驱动表」；MySQL 内部优化器也是这么做的）。</p>\n<p>假设有这样一句sql（xxx 为索引）:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> table1 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> tablet2 <span class=\"keyword\">on</span> table1.xxx<span class=\"operator\">=</span>table2.xxx </span><br></pre></td></tr></table></figure>\n<p>这条语句执行过程是先遍历表table1，然后根据从表table1中取出的每行数据中的xxx值，去表table2中查找满足条件的 记录。这个过程就跟我们写程序时的嵌套查询类似，并且能够用上被驱动表的索引，这种查询方式叫<code>NLJ</code>。当xxx不是索引的时候，再使用<code>NLJ</code>的话就会对table2做多次的全表扫描（每从table1取一条数据就全表扫描一次table2），扫描数暴涨。这个时候mysql会采用另外一个查询策略。Mysql会先把table1的数据读入到一个<code>join_buffer</code>的内存空间里面去，然后<br>依次取出table2的每一行数据，跟<code>join_buffer</code>中的数据做对比，满足join条件的作为结果集的一部分返回。<br>我们在使用<code>join</code>的时候,要遵循以下几点：</p>\n<ul>\n<li>小表驱动大表。</li>\n<li>被驱动表走索引的情况下（走<code>NLJ</code>查询方式）的时候才考虑用join</li>\n</ul>\n<h3 id=\"5-4-sql的优化\"><a href=\"#5-4-sql的优化\" class=\"headerlink\" title=\"5.4 sql的优化\"></a>5.4 sql的优化</h3><p>1） 在mysql中，如果对字段做了函数计算，就用不上索引了<br>如以下sql(data 为索引):</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span>  <span class=\"keyword\">from</span> tradelog <span class=\"keyword\">where</span> <span class=\"keyword\">month</span>(data)<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>优化器对这样的sql会放弃走搜索树，因为它无法知道data的区间。</p>\n<p>2）隐式的类型转换会导致索引失效。<br>如以下sql:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> xxx<span class=\"operator\">=</span><span class=\"number\">110717</span>;</span><br></pre></td></tr></table></figure>\n<p>其中xxx为<code>varchar</code>型，在mysql中，字符串和数字做比较的话，将字符串转换成数字再进行比较，这里相当于使用了<code>CAST(xxx AS signed )</code> 导致无法走索引。</p>\n<p>3）索引列参与了计算不会走索引</p>\n<p>4）like %xxx 不会走索引，like xxx% 会走索引</p>\n<p>5）在where子句中使用or，在innodb中不会走索引，而MyISAM会。</p>\n<h2 id=\"6执行计划和慢查询日志\"><a href=\"#6执行计划和慢查询日志\" class=\"headerlink\" title=\"6执行计划和慢查询日志\"></a>6执行计划和慢查询日志</h2><h3 id=\"6-1-执行计划\"><a href=\"#6-1-执行计划\" class=\"headerlink\" title=\"6.1 执行计划\"></a>6.1 执行计划</h3><p>在查询sql之前加上<code>explain</code>可查看该条sql的执行计划,如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPLAIN <span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span></span><br></pre></td></tr></table></figure>\n<p>这条sql会返回这样一个表：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>select_type</th>\n<th>table</th>\n<th>partitions</th>\n<th>type</th>\n<th>possible_keys</th>\n<th>key</th>\n<th>key_len</th>\n<th>ref</th>\n<th>rows</th>\n<th>filtered</th>\n<th>extra</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>simple</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>这个表便是sql的执行计划，我们可以通过分析这个执行计划来知道我们sql的运行情况。现对各列进行解释：</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>1）id：查询中执行select子句或操作表的顺序。</p>\n<p>2）select_type：查询中每个select子句的类型（简单 到复杂）包括：</p>\n<ul>\n<li>SIMPLE：查询中不包含子查询或者UNION；</li>\n<li>PRIMARY：查询中包含复杂的子部分；</li>\n<li>SUBQUERY：在SELECT或WHERE列表中包含了子查询，该子查询被标记为SUBQUERY；</li>\n<li>DERIVED：衍生，在FROM列表中包含的子查询被标记为DERIVED；</li>\n<li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；</li>\n<li>UNION  RESULT：从UNION表获取结果的SELECT被标记为UNION RESULT；</li>\n</ul>\n<p>3） type：表示MySQL在表中找到所需行的方式，又称“访问类型”，包括：</p>\n<ul>\n<li>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行；</li>\n<li>index：Full Index Scan，index与ALL区别为index类型只遍历索引树；</li>\n<li>range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between  &lt;  &gt;  等查询；</li>\n<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找；</li>\n<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描；</li>\n<li>onst 和 system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下， 使用system；</li>\n<li>NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引。</li>\n</ul>\n<p>4）possible_keys： 指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。</p>\n<p>5）key：显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>\n<p>6）key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。</p>\n<p>7）ref： 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p>\n<p>8）rows： 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</p>\n<p>9）Extra：其他重要信息 包括：</p>\n<ul>\n<li>Using index：该值表示相应的select操作中使用了覆盖索引 ；</li>\n<li>Using where：MySQL将用where子句来过滤结果集；</li>\n<li>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询；</li>\n<li>Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”。</li>\n</ul>\n<h3 id=\"6-2-慢查询日志\"><a href=\"#6-2-慢查询日志\" class=\"headerlink\" title=\"6.2 慢查询日志\"></a>6.2 慢查询日志</h3><p>mysql支持慢查询日志功能——mysql会将查询时间过长的sql相关信息写入日志。这个查询时间阀值由参数<code>long_query_time</code>指定，<code>long_query_time</code>的默认值为10，运行10S以上的查询sql会被记录到慢查询日志中。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p>\n<p>可通过以下sql查看慢查询日志是否开启：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables  <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%slow_query_log%&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>通过以下sql开启慢查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> slow_query_log<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>使用sql修改慢查询日志设置只对当前数据库生效，如果MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf。</p>\n<p>通过以下sql查看修改慢查询的阈值：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> <span class=\"string\">&#x27;long_query_time%&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> long_query_time<span class=\"operator\">=</span><span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7主从备份\"><a href=\"#7主从备份\" class=\"headerlink\" title=\"7主从备份\"></a>7主从备份</h2><h3 id=\"7-1主从备份原理\"><a href=\"#7-1主从备份原理\" class=\"headerlink\" title=\"7.1主从备份原理\"></a>7.1主从备份原理</h3><p>主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。通过这种手段我们可以做到读写分离，主库写数据，从库读数据，从而提高数据库的可用。<br>MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点。</p>\n<p>主节点 binary log dump 线程：<br>当从节点连接主节点时，主节点会创建一个<code>log dump</code> 线程，用于发送<code>binlog</code>的内容。在读取<code>binlog</code>中的操作时，此线程会对主节点上的<code>binlog</code>加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。</p>\n<p> 从节点I/O线程:<br> 用于从库将主库的<code>binlog</code>复制到本地的<code>relay log</code>中，首先，从库库会先启动一个工作线程，称为IO工作线程，负责和主库建立一个普通的客户端连接。如果该进程追赶上了主库，它将进入睡眠状态，直到主库有新的事件产生通知它，他才会被唤醒，将接收到的事件记录到<code>relay log</code>(中继日志)中。</p>\n<p> 从节点SQL线程:<br> SQL线程负责读取<code>relay log</code>中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</p>\n<h3 id=\"7-2-主从备份延迟\"><a href=\"#7-2-主从备份延迟\" class=\"headerlink\" title=\"7.2 主从备份延迟\"></a>7.2 主从备份延迟</h3><p>主备延迟最直接的表现是，备库消费中继日志（<code>relay log</code>）的速度，比主库生产<code>binlog</code> 的速度要慢。可能导致的原因有：</p>\n<ul>\n<li>大事务，主库上必须等事务执行完成才会写入binlog，再传给备库，当一个事物用时很久的时候，在从库上会因为这个事物的执行产生延迟。</li>\n<li>从库压力大。</li>\n</ul>\n<p>主备延迟当然是不好的，那么有哪些办法尽量减小主备延迟呢？有下面几个办法：</p>\n<ul>\n<li>一主多从——多接几个从库，让这些从库来分担读的压力。这样方法适用于从库读压力大的时候。</li>\n<li>通过binlog输出到外部系统，比如Hadoop这类系统，让外部系统提供统计类查询的能力</li>\n</ul>\n<h3 id=\"7-3-主从备份配置\"><a href=\"#7-3-主从备份配置\" class=\"headerlink\" title=\"7.3 主从备份配置\"></a>7.3 主从备份配置</h3><p>主机：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">vi /etc/my.cnf</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">主数据库端ID号</span></span><br><span class=\"line\">server_id = 1           </span><br><span class=\"line\"><span class=\"meta\"> #</span><span class=\"bash\">开启二进制日志</span>                  </span><br><span class=\"line\">log-bin = mysql-bin    </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可</span>                  </span><br><span class=\"line\">binlog-do-db = db        </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中</span>                 </span><br><span class=\"line\">log-slave-updates                        </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失)</span> </span><br><span class=\"line\">sync_binlog = 1                    </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突</span></span><br><span class=\"line\">auto_increment_offset = 1           </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突</span></span><br><span class=\"line\">auto_increment_increment = 1            </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除</span>  </span><br><span class=\"line\">expire_logs_days = 7                    </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">将函数复制到slave</span>  </span><br><span class=\"line\">log_bin_trust_function_creators = 1       </span><br></pre></td></tr></table></figure>\n<p>登录mysql</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#创建slave账号account，密码<span class=\"number\">123456</span></span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span><span class=\"keyword\">grant</span> replication slave <span class=\"keyword\">on</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">to</span> <span class=\"string\">&#x27;account&#x27;</span>@<span class=\"string\">&#x27;10.10.20.116&#x27;</span> identified <span class=\"keyword\">by</span> <span class=\"string\">&#x27;123456&#x27;</span>;</span><br><span class=\"line\">#更新数据库权限</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span>flush privileges;</span><br><span class=\"line\"></span><br><span class=\"line\"># 检查log<span class=\"operator\">-</span>bin</span><br><span class=\"line\"><span class=\"keyword\">show</span> variables <span class=\"keyword\">like</span> ‘log_bin’</span><br><span class=\"line\"></span><br><span class=\"line\">#查看主服务器状态</span><br><span class=\"line\"><span class=\"keyword\">show</span> master status\\G;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>从机：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/my.cnf</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">server_id = 2</span><br><span class=\"line\">log-bin = mysql-bin</span><br><span class=\"line\">log-slave-updates</span><br><span class=\"line\">sync_binlog = 0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"built_in\">log</span> buffer将每秒一次地写入<span class=\"built_in\">log</span> file中，并且<span class=\"built_in\">log</span> file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作</span></span><br><span class=\"line\">innodb_flush_log_at_trx_commit = 0        </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">指定slave要复制哪个库</span></span><br><span class=\"line\">replicate-do-db = db         </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据</span></span><br><span class=\"line\">slave-net-timeout = 60                    </span><br><span class=\"line\">log_bin_trust_function_creators = 1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>登录mysql</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#执行同步命令，设置主服务器ip，同步账号密码，同步位置</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span>change master <span class=\"keyword\">to</span> master_host<span class=\"operator\">=</span><span class=\"string\">&#x27;10.10.20.111&#x27;</span>,master_user<span class=\"operator\">=</span><span class=\"string\">&#x27;account&#x27;</span>,master_password<span class=\"operator\">=</span><span class=\"string\">&#x27;123456&#x27;</span>,master_log_file<span class=\"operator\">=</span><span class=\"string\">&#x27;mysql-bin.000033&#x27;</span>,master_log_pos<span class=\"operator\">=</span><span class=\"number\">337523</span>;</span><br><span class=\"line\">#开启同步功能</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span><span class=\"keyword\">start</span> slave;</span><br><span class=\"line\">#查看从服务器状态</span><br><span class=\"line\">mysql<span class=\"operator\">&gt;</span><span class=\"keyword\">show</span> slave status\\G;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-分布式事务\"><a href=\"#8-分布式事务\" class=\"headerlink\" title=\"8 分布式事务\"></a>8 分布式事务</h2><p>由于篇幅问题，这里不再对分布式事物的概念做普及，直接介绍两种分布式事务: XA 分布式事务和 TCC分布式事务。</p>\n<h3 id=\"8-1-XA分布式事务\"><a href=\"#8-1-XA分布式事务\" class=\"headerlink\" title=\"8.1 XA分布式事务\"></a>8.1 XA分布式事务</h3><p>XA是两阶段提交的强一致性事物。在MySQL 5.7.7版本中，Oracle 官方将MySQL XA 一直存在的一个“bug” 进行了修复，使得MySQL XA 的实现符合了分布式事务的标准。</p>\n<p>XA事务中的角色：</p>\n<ul>\n<li>资源管理器（resource manager）：用来管理系统资源，是通向事务资源的途径。数据库就是一种资源管理器。资源管理还应该具有管理事务提交或回滚的能力。</li>\n<li>事务管理器（transaction manager）：事务管理器是分布式事务的核心管理者。事务管理器与每个资源管理器（resource<br>manager）进行通信，协调并完成事务的处理。事务的各个分支由唯一命名进行标识。</li>\n</ul>\n<p>XA规范的基础是两阶段提交协议：</p>\n<p>在第一阶段，交易中间件请求所有相关数据库准备提交（预提交）各自的事务分支，以确认是否所有相关数据库都可以提交各自的事务分支。当某一数据库收到预提交后，如果可以提交属于自己的事务分支，则将自己在该事务分支中所做的操作固定记录下来，并给交易中间件一个同意提交的应答，此时数据库将不能再在该事务分支中加入任何操作，但此时数据库并没有真正提交该事务，数据库对共享资源的操作还未释放（处于锁定状态）。如果由于某种原因数据库无法提交属于自己的事务分支，它将回滚自己的所有操作，释放对共享资源上的锁，并返回给交易中间件失败应答。</p>\n<p>在第二阶段，交易中间件审查所有数据库返回的预提交结果，如所有数据库都可以提交，交易中间件将要求所有数据库做正式提交，这样该全局事务被提交。而如果有任一数据库预提交返回失败，交易中间件将要求所有其它数据库回滚其操作，这样该全局事务被回滚。</p>\n<p>mysql允许多个数据库实例参与一个全局的事务。MySQL XA 的命令集合如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 开启一个事务，并将事务置于ACTIVE状态，此后执行的SQL语句都将置于该是事务中。</span></span><br><span class=\"line\"></span><br><span class=\"line\">XA <span class=\"keyword\">START</span> xid</span><br><span class=\"line\"><span class=\"comment\">-- 将事务置于IDLE状态，表示事务内的SQL操作完成。</span></span><br><span class=\"line\">XA <span class=\"keyword\">END</span> xid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务提交的准备动作，事务状态置于PREPARED状态。事务如果无法完成提交前的准备操作，该语句会执行失败。</span></span><br><span class=\"line\">XA <span class=\"keyword\">PREPARE</span> xid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务最终提交，完成持久化。</span></span><br><span class=\"line\">XA <span class=\"keyword\">COMMIT</span> xid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 事务回滚终止</span></span><br><span class=\"line\">XA <span class=\"keyword\">ROLLBACK</span> xid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看MySQL中存在的PREPARED状态的xa事务。</span></span><br><span class=\"line\">XA RECOVER</span><br></pre></td></tr></table></figure>\n<p>MySQL 在XA事务中扮演的是参与者的角色，被事务协调器所支配。XA事务比普通本地事务多了一个<code>PREPARE</code>状态，普通事务是 begin-&gt; commit 而分布式事务是 begin-&gt;PREPARE 等其他数据库事务都到PREPARE状态的时候再 PREPARE-&gt;commit。分布式事务sql示例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xa <span class=\"keyword\">start</span> <span class=\"string\">&#x27;aaa&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span>(xxx) <span class=\"keyword\">values</span>(xxx);</span><br><span class=\"line\">xa <span class=\"keyword\">end</span> <span class=\"string\">&#x27;aaa&#x27;</span>;</span><br><span class=\"line\">xa <span class=\"keyword\">prepare</span> <span class=\"string\">&#x27;aaa&#x27;</span>;</span><br><span class=\"line\">xa <span class=\"keyword\">commit</span> <span class=\"string\">&#x27;aaa&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>XA事务存在的问题：</p>\n<ul>\n<li>单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li>\n<li>同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞状态，直到提交完成才能释放资源。</li>\n<li>数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li>\n</ul>\n<h3 id=\"8-2-TCC分布式事务\"><a href=\"#8-2-TCC分布式事务\" class=\"headerlink\" title=\"8.2 TCC分布式事务\"></a>8.2 TCC分布式事务</h3><p>TCC又被称作柔性事务，通过事务补偿机制来达到事务的最终一致性，它不是强一致性的事务。TCC将事务分为两个阶段，或者说是由两个事务组成的。相对于XA事务来说TCC的并发性更好，XA是全局性的事务，而TCC是由两个本地事务组成。</p>\n<p>假设我们购买一件商品，后台需要操作两张表——积分表加积分而库存表扣库存，这两张表存在于两个数据库中，使用TCC事务执行这一事务：</p>\n<p>1）TCC实现阶段一：Try<br>在try阶段并不是直接减库存加积分，而是将相关数据改变为预备的状态。库存表先锁定一个库存，锁定的方式可以预留一个锁定字段，当这个字段为一的时候表示这个商品被锁定。积分表加一个数据，这个数据也是被锁定状态，锁定方式和库存表一样。其sql形如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> stock <span class=\"keyword\">set</span> lock<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> credits (lock,...) <span class=\"keyword\">values</span> (<span class=\"number\">1</span>,...)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这两条sql如果都执行成功则进入 Confirm阶段，如果执行不成功则进入Cancel阶段</p>\n<p>2）TCC实现阶段二：Confirm</p>\n<p>这一阶段正式减库存加积分订单状态改为已支付。执行sql将锁定的库存扣除，为累加积分累加，以及一些其他的逻辑。</p>\n<p>3）TCC实现阶段三：Cancel<br>当try阶段执行不成功，就会执行这一阶段，这个阶段将锁定的库存还原，锁定的积分删除掉。退回到事务执行前的状态。</p>\n<p>TCC事务原理很简单，使用起来却不简单。首先TCC事务对系统侵入性很大，其次是让业务逻辑变得复杂。在实际使用中我们必须依赖TCC事务中间件才能让TCC事务得以实现。通常一个TCC事务实现大概是这样子的：某个服务向外暴露了一个服务，这个服务对外正常调用，其他服务并不能感知到TCC事务的存在，而其服务内部，分别实现了Try,Confirm,Cancel三个接口，注册到TCC中间件上去。当调用这个服务的时候，其事务操作由该服务和TCC中间件共同完成。</p>\n<p>而TCC事务中间件还要做好其他事情，比如确保Confirm或者Cancel执行成功，如果发现某个服务的Cancel或者Confirm一直没成功，会不停的重试调用他的Cancel或者Confirm逻辑，务必要他成功！即使在尝试多次后无法成功也能通知到系统需要人工排查异常。TCC事务还要考虑一些异常情况的处理，比如说订单服务突然挂了，然后再次重启，TCC分布式事务框架要能够保证之前没执行完的分布式事务继续执行。TCC分布式事务框架还需要做好日志的记录，保存下来分布式事务运行的各个阶段和状态，以便系统上线后能够排查异常，恢复数据。目前开源的TCC事务框架有：<code>Seata</code> <code>ByteTCC</code> <code>tcc-transaction</code> 等。</p>"},{"title":"redis笔记","date":"2019-05-06T01:53:26.000Z","_content":"\n## redis基础知识\n\n客户端与服务端的通讯协议是建立在TCP协议之上构建的；\n\nredis序列化协议 resp\n\n- 状态回复（status reply）的第一个字节是 `\"+\"`\n- 错误回复（error reply）的第一个字节是 `\"-\"`\n- 整数回复（integer reply）的第一个字节是 `\":\"`\n- 批量回复（bulk reply）的第一个字节是 `\"$\"`\n- 多条批量回复（multi bulk reply）的第一个字节是 `\"*\"`\n\n<!--more-->\n\n举例：\n\n```shell\nSET mykey myvalue\n*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\mykey\\r\\n$7\\r\\myvalue\\r\\n\n```\n\n指令表：\n\n[redis命令表](<http://redisdoc.com/>)\n\n- 字符串\n  - [SET](http://redisdoc.com/string/set.html)\n  - [SETNX](http://redisdoc.com/string/setnx.html)\n  - [SETEX](http://redisdoc.com/string/setex.html)\n  - [PSETEX](http://redisdoc.com/string/psetex.html)\n  - [GET](http://redisdoc.com/string/get.html)\n  - [GETSET](http://redisdoc.com/string/getset.html)\n  - [STRLEN](http://redisdoc.com/string/strlen.html)\n  - [APPEND](http://redisdoc.com/string/append.html)\n  - [SETRANGE](http://redisdoc.com/string/setrange.html)\n  - [GETRANGE](http://redisdoc.com/string/getrange.html)\n  - [INCR](http://redisdoc.com/string/incr.html)\n  - [INCRBY](http://redisdoc.com/string/incrby.html)\n  - [INCRBYFLOAT](http://redisdoc.com/string/incrbyfloat.html)\n  - [DECR](http://redisdoc.com/string/decr.html)\n  - [DECRBY](http://redisdoc.com/string/decrby.html)\n  - [MSET](http://redisdoc.com/string/mset.html)\n  - [MSETNX](http://redisdoc.com/string/msetnx.html)\n  - [MGET](http://redisdoc.com/string/mget.html)\n- 哈希表\n  - [HSET](http://redisdoc.com/hash/hset.html)\n  - [HSETNX](http://redisdoc.com/hash/hsetnx.html)\n  - [HGET](http://redisdoc.com/hash/hget.html)\n  - [HEXISTS](http://redisdoc.com/hash/hexists.html)\n  - [HDEL](http://redisdoc.com/hash/hdel.html)\n  - [HLEN](http://redisdoc.com/hash/hlen.html)\n  - [HSTRLEN](http://redisdoc.com/hash/hstrlen.html)\n  - [HINCRBY](http://redisdoc.com/hash/hincrby.html)\n  - [HINCRBYFLOAT](http://redisdoc.com/hash/hincrbyfloat.html)\n  - [HMSET](http://redisdoc.com/hash/hmset.html)\n  - [HMGET](http://redisdoc.com/hash/hmget.html)\n  - [HKEYS](http://redisdoc.com/hash/hkeys.html)\n  - [HVALS](http://redisdoc.com/hash/hvals.html)\n  - [HGETALL](http://redisdoc.com/hash/hgetall.html)\n  - [HSCAN](http://redisdoc.com/hash/hscan.html)\n- 列表\n  - [LPUSH](http://redisdoc.com/list/lpush.html)\n  - [LPUSHX](http://redisdoc.com/list/lpushx.html)\n  - [RPUSH](http://redisdoc.com/list/rpush.html)\n  - [RPUSHX](http://redisdoc.com/list/rpushx.html)\n  - [LPOP](http://redisdoc.com/list/lpop.html)\n  - [RPOP](http://redisdoc.com/list/rpop.html)\n  - [RPOPLPUSH](http://redisdoc.com/list/rpoplpush.html)\n  - [LREM](http://redisdoc.com/list/lrem.html)\n  - [LLEN](http://redisdoc.com/list/llen.html)\n  - [LINDEX](http://redisdoc.com/list/lindex.html)\n  - [LINSERT](http://redisdoc.com/list/linsert.html)\n  - [LSET](http://redisdoc.com/list/lset.html)\n  - [LRANGE](http://redisdoc.com/list/lrange.html)\n  - [LTRIM](http://redisdoc.com/list/ltrim.html)\n  - [BLPOP](http://redisdoc.com/list/blpop.html)\n  - [BRPOP](http://redisdoc.com/list/brpop.html)\n  - [BRPOPLPUSH](http://redisdoc.com/list/brpoplpush.html)\n- 集合\n  - [SADD](http://redisdoc.com/set/sadd.html)\n  - [SISMEMBER](http://redisdoc.com/set/sismember.html)\n  - [SPOP](http://redisdoc.com/set/spop.html)\n  - [SRANDMEMBER](http://redisdoc.com/set/srandmember.html)\n  - [SREM](http://redisdoc.com/set/srem.html)\n  - [SMOVE](http://redisdoc.com/set/smove.html)\n  - [SCARD](http://redisdoc.com/set/scard.html)\n  - [SMEMBERS](http://redisdoc.com/set/smembers.html)\n  - [SSCAN](http://redisdoc.com/set/sscan.html)\n  - [SINTER](http://redisdoc.com/set/sinter.html)\n  - [SINTERSTORE](http://redisdoc.com/set/sinterstore.html)\n  - [SUNION](http://redisdoc.com/set/sunion.html)\n  - [SUNIONSTORE](http://redisdoc.com/set/sunionstore.html)\n  - [SDIFF](http://redisdoc.com/set/sdiff.html)\n  - [SDIFFSTORE](http://redisdoc.com/set/sdiffstore.html)\n- 有序集合\n  - [ZADD](http://redisdoc.com/sorted_set/zadd.html)\n  - [ZSCORE](http://redisdoc.com/sorted_set/zscore.html)\n  - [ZINCRBY](http://redisdoc.com/sorted_set/zincrby.html)\n  - [ZCARD](http://redisdoc.com/sorted_set/zcard.html)\n  - [ZCOUNT](http://redisdoc.com/sorted_set/zcount.html)\n  - [ZRANGE](http://redisdoc.com/sorted_set/zrange.html)\n  - [ZREVRANGE](http://redisdoc.com/sorted_set/zrevrange.html)\n  - [ZRANGEBYSCORE](http://redisdoc.com/sorted_set/zrangebyscore.html)\n  - [ZREVRANGEBYSCORE](http://redisdoc.com/sorted_set/zrevrangebyscore.html)\n  - [ZRANK](http://redisdoc.com/sorted_set/zrank.html)\n  - [ZREVRANK](http://redisdoc.com/sorted_set/zrevrank.html)\n  - [ZREM](http://redisdoc.com/sorted_set/zrem.html)\n  - [ZREMRANGEBYRANK](http://redisdoc.com/sorted_set/zremrangebyrank.html)\n  - [ZREMRANGEBYSCORE](http://redisdoc.com/sorted_set/zremrangebyscore.html)\n  - [ZRANGEBYLEX](http://redisdoc.com/sorted_set/zrangebylex.html)\n  - [ZLEXCOUNT](http://redisdoc.com/sorted_set/zlexcount.html)\n  - [ZREMRANGEBYLEX](http://redisdoc.com/sorted_set/zremrangebylex.html)\n  - [ZSCAN](http://redisdoc.com/sorted_set/zscan.html)\n  - [ZUNIONSTORE](http://redisdoc.com/sorted_set/zunionstore.html)\n  - [ZINTERSTORE](http://redisdoc.com/sorted_set/zinterstore.html)\n- HyperLogLog\n  - [PFADD](http://redisdoc.com/hyperloglog/pfadd.html)\n  - [PFCOUNT](http://redisdoc.com/hyperloglog/pfcount.html)\n  - [PFMERGE](http://redisdoc.com/hyperloglog/pfmerge.html)\n- 地理位置\n  - [GEOADD](http://redisdoc.com/geo/geoadd.html)\n  - [GEOPOS](http://redisdoc.com/geo/geopos.html)\n  - [GEODIST](http://redisdoc.com/geo/geodist.html)\n  - [GEORADIUS](http://redisdoc.com/geo/georadius.html)\n  - [GEORADIUSBYMEMBER](http://redisdoc.com/geo/georadiusbymember.html)\n  - [GEOHASH](http://redisdoc.com/geo/geohash.html)\n- 位图\n  - [SETBIT](http://redisdoc.com/bitmap/setbit.html)\n  - [GETBIT](http://redisdoc.com/bitmap/getbit.html)\n  - [BITCOUNT](http://redisdoc.com/bitmap/bitcount.html)\n  - [BITPOS](http://redisdoc.com/bitmap/bitpos.html)\n  - [BITOP](http://redisdoc.com/bitmap/bitop.html)\n  - [BITFIELD](http://redisdoc.com/bitmap/bitfield.html)\n- 数据库\n  - [EXISTS](http://redisdoc.com/database/exists.html)\n  - [TYPE](http://redisdoc.com/database/type.html)\n  - [RENAME](http://redisdoc.com/database/rename.html)\n  - [RENAMENX](http://redisdoc.com/database/renamenx.html)\n  - [MOVE](http://redisdoc.com/database/move.html)\n  - [DEL](http://redisdoc.com/database/del.html)\n  - [RANDOMKEY](http://redisdoc.com/database/randomkey.html)\n  - [DBSIZE](http://redisdoc.com/database/dbsize.html)\n  - [KEYS](http://redisdoc.com/database/keys.html)\n  - [SCAN](http://redisdoc.com/database/scan.html)\n  - [SORT](http://redisdoc.com/database/sort.html)\n  - [FLUSHDB](http://redisdoc.com/database/flushdb.html)\n  - [FLUSHALL](http://redisdoc.com/database/flushall.html)\n  - [SELECT](http://redisdoc.com/database/select.html)\n  - [SWAPDB](http://redisdoc.com/database/swapdb.html)\n- 自动过期\n  - [EXPIRE](http://redisdoc.com/expire/expire.html)\n  - [EXPIREAT](http://redisdoc.com/expire/expireat.html)\n  - [TTL](http://redisdoc.com/expire/ttl.html)\n  - [PERSIST](http://redisdoc.com/expire/persist.html)\n  - [PEXPIRE](http://redisdoc.com/expire/pexpire.html)\n  - [PEXPIREAT](http://redisdoc.com/expire/pexpireat.html)\n  - [PTTL](http://redisdoc.com/expire/pttl.html)\n- 事务\n  - [MULTI](http://redisdoc.com/transaction/multi.html)\n  - [EXEC](http://redisdoc.com/transaction/exec.html)\n  - [DISCARD](http://redisdoc.com/transaction/discard.html)\n  - [WATCH](http://redisdoc.com/transaction/watch.html)\n  - [UNWATCH](http://redisdoc.com/transaction/unwatch.html)\n- Lua 脚本\n  - [EVAL](http://redisdoc.com/script/eval.html)\n  - [EVALSHA](http://redisdoc.com/script/evalsha.html)\n  - [SCRIPT_LOAD](http://redisdoc.com/script/script_load.html)\n  - [SCRIPT_EXISTS](http://redisdoc.com/script/script_exists.html)\n  - [SCRIPT_FLUSH](http://redisdoc.com/script/script_flush.html)\n  - [SCRIPT_KILL](http://redisdoc.com/script/script_kill.html)\n- 持久化\n  - [SAVE](http://redisdoc.com/persistence/save.html)\n  - [BGSAVE](http://redisdoc.com/persistence/bgsave.html)\n  - [BGREWRITEAOF](http://redisdoc.com/persistence/bgrewriteaof.html)\n  - [LASTSAVE](http://redisdoc.com/persistence/lastsave.html)\n- 发布与订阅\n  - [PUBLISH](http://redisdoc.com/pubsub/publish.html)\n  - [SUBSCRIBE](http://redisdoc.com/pubsub/subscribe.html)\n  - [PSUBSCRIBE](http://redisdoc.com/pubsub/psubscribe.html)\n  - [UNSUBSCRIBE](http://redisdoc.com/pubsub/unsubscribe.html)\n  - [PUNSUBSCRIBE](http://redisdoc.com/pubsub/punsubscribe.html)\n  - [PUBSUB](http://redisdoc.com/pubsub/pubsub.html)\n- 复制\n  - [SLAVEOF](http://redisdoc.com/replication/slaveof.html)\n  - [ROLE](http://redisdoc.com/replication/role.html)\n- 客户端与服务器\n  - [AUTH](http://redisdoc.com/client_and_server/auth.html)\n  - [QUIT](http://redisdoc.com/client_and_server/quit.html)\n  - [INFO](http://redisdoc.com/client_and_server/info.html)\n  - [SHUTDOWN](http://redisdoc.com/client_and_server/shutdown.html)\n  - [TIME](http://redisdoc.com/client_and_server/time.html)\n  - [CLIENT_GETNAME](http://redisdoc.com/client_and_server/client_getname.html)\n  - [CLIENT_KILL](http://redisdoc.com/client_and_server/client_kill.html)\n  - [CLIENT_LIST](http://redisdoc.com/client_and_server/client_list.html)\n  - [CLIENT_SETNAME](http://redisdoc.com/client_and_server/client_setname.html)\n- 配置选项\n  - [CONFIG_SET](http://redisdoc.com/configure/config_set.html)\n  - [CONFIG_GET](http://redisdoc.com/configure/config_get.html)\n  - [CONFIG_RESETSTAT](http://redisdoc.com/configure/config_resetstat.html)\n  - [CONFIG_REWRITE](http://redisdoc.com/configure/config_rewrite.html)\n- 调试\n  - [PING](http://redisdoc.com/debug/ping.html)\n  - [ECHO](http://redisdoc.com/debug/echo.html)\n  - [OBJECT](http://redisdoc.com/debug/object.html)\n  - [SLOWLOG](http://redisdoc.com/debug/slowlog.html)\n  - [MONITOR](http://redisdoc.com/debug/monitor.html)\n  - [DEBUG_OBJECT](http://redisdoc.com/debug/debug_object.html)\n  - [DEBUG_SEGFAULT](http://redisdoc.com/debug/debug_segfault.html)\n- 内部命令\n  - [MIGRATE](http://redisdoc.com/internal/migrate.html)\n  - [DUMP](http://redisdoc.com/internal/dump.html)\n  - [RESTORE](http://redisdoc.com/internal/restore.html)\n  - [SYNC](http://redisdoc.com/internal/sync.html)\n  - [PSYNC](http://redisdoc.com/internal/psync.html)\n- 功能文档\n  - [Redis 集群规范](http://redisdoc.com/topic/cluster-spec.html)\n  - [持久化（persistence）](http://redisdoc.com/topic/persistence.html)\n  - [发布与订阅（pub/sub）](http://redisdoc.com/topic/pubsub.html)\n  - [Sentinel](http://redisdoc.com/topic/sentinel.html)\n  - [集群教程](http://redisdoc.com/topic/cluster-tutorial.html)\n  - [键空间通知（keyspace notification）](http://redisdoc.com/topic/notification.html)\n  - [通信协议（protocol）](http://redisdoc.com/topic/protocol.html)\n  - [复制（Replication）](http://redisdoc.com/topic/replication.html)\n  - [事务（transaction）](http://redisdoc.com/topic/transaction.html)\n\nredis key集中过期问题，集中过期导致redis压力过大而卡顿\n\n采用一定范围内的随机过期时间\n\nRedis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型实际会严重影响整体吞吐量，CPU计算过程中，整个IO调度都是被阻塞住的。\n\n**redis分布式锁参考 本博客[多线程进阶篇](<https://muggle.javaboy.org/2019/04/23/thread-3/>)**\n\n## springboot 分布式session\n\n```java\n@Configuration  \n@EnableRedisHttpSession  \npublic class RedisSessionConfig {  \n}  \n```\n\n```xml\n<dependency>  \n        <groupId>org.springframework.boot</groupId>  \n        <artifactId>spring-boot-starter-redis</artifactId>  \n</dependency>  \n<dependency>  \n        <groupId>org.springframework.session</groupId>  \n        <artifactId>spring-session-data-redis</artifactId>  \n</dependency>\n```\n\n```properties\nspring.redis.host=localhost  \nspring.redis.port=6379  \n```\n\n**注意：springboot2.1有包冲突，本配置只适用于2.1以下**\n\n## mybatis的二级缓存\n\n二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。\n\nUserMapper有一个二级缓存区域（按namespace分），其它mapper也有自己的二级缓存区域（按namespace分）。每一个namespace的mapper都有一个二级缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。sql节点可配置userCache flushcache\n\n打开二级缓存总开关（springboot默认开启），在mapper中使用`<cache/>`打开二级缓存 在分布式系统中不能直接使用二级缓存\n\n`<cache />`的属性：\n\n- eviction：代表的是缓存收回策略，有一下策略：\n  1. LRU，  最近最少使用的，移除最长时间不用的对象。\n  2. FIFO，先进先出，按对象进入缓存的顺序来移除他们\n  3. SOFT， 软引用，移除基于垃圾回收器状态和软引用规则的对象。\n  4. WEAK，若引用，更积极的移除基于垃圾收集器状态和若引用规则的对象\n- flushInterval：刷新间隔时间，单位为毫秒，默认是当sql执行的时候才回去刷新。\n- size：引用数目，一个正整数，代表缓存最多可以存储多少对象，不宜设置过大，过大会造成内存溢出。\n- readOnly：只读，意味着缓存数据只能读取，不能修改，这样设置的好处是我们可以快速读取缓存，去诶但是我们没有办法修改缓存。默认值为false，不允许我们修改。\n\n\n\n## 分布式缓存\n\n分布式缓存策略\n\nmybatis整合ehcache实现分布式缓存、jetcache、spring cache\n\njetcache整合笔记：\n\n```xml\n        <dependency>\n            <groupId>com.alicp.jetcache</groupId>\n            <artifactId>jetcache-starter-redis</artifactId>\n            <version>2.4.4</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n        </dependency>\n```\n\n```java\n@SpringBootApplication\n@EnableMethodCache(basePackages = \"com.muggle.jetcahetest\")\n@EnableCreateCacheAnnotation\npublic class JetcaheTestApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(JetcaheTestApplication.class, args);\n    }\n\n}\n```\n\n```java\npublic interface Server {\n\n    @Cached(cacheType = CacheType.REMOTE)\n    int test (String message);\n}\n```\n\n```java\n@Service\npublic class ServerImpl implements Server {\n    @Override\n    public int test(String message) {\n        System.out.println(\">>>\");\n        return 666;\n    }\n}\n```\n\n更多文档参考[jetCache github 地址][]\n\n分布式缓存的应用\n\n合并批量更新，提高io\n\n缓存的粒度问题，缓存数据是全量还是部分\n\n### cache cloud 使用\n\n### 分布式缓存原理分析\n\n- 传统分布式算法：HASH算法或者取模算法\n- Consistent hashing一致性算法原理\n- Hash倾斜性\n- 虚拟节点\n- Consistent hashing命中率\n\nConsistent hashing 是一致性hash算法\n\n博客：[一致性哈希](<https://blog.csdn.net/qq_35956041/article/details/81026972>)\n\n哈希倾斜：缓存任务分配不均，采用虚拟节点避免\n\n缓存穿透：缓存未起作用\n\n缓存雪崩：缓存雪崩可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。\n\n缓存的算法\n\nFIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。\nLFU算法：Least Frequently Used，最不经常使用算法。\nLRU算法：Least Recently Used，近期最少使用算法。\n\nLRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的\n\n## redis运维（抄录自 https://mp.weixin.qq.com/s/TvIxovAi6XfR7RGigtHRtQ）\n\n### 快照持久化\n\nredis中的快照持久化默认是开启的，redis.conf中相关配置主要有如下几项：\n\n```properties\nsave 900 1\nsave 300 10\nsave 60 10000\nstop-writes-on-bgsave-error yes\nrdbcompression yes\ndbfilename dump.rdb\ndir ./\n```\n\n前面三个save相关的选项表示备份的频率，分别表示`900秒内至少一个键被更改则进行快照，300秒内至少10个键被更改则进行快照，60秒内至少10000个键被更改则进行快照，`stop-writes-on-bgsave-error表示在快照创建出错后，是否继续执行写命令，rdbcompression则表示是否对快照文件进行压缩，dbfilename表示生成的快照文件的名字，dir则表示生成的快照文件的位置，在redis中，快照持久化默认就是开启的。\n\n1.在redis运行过程中，我们可以向redis发送一条save命令来创建一个快照，save是一个阻塞命令，redis在接收到save命令之后，开始执行备份操作之后，在备份操作执行完毕之前，将不再处理其他请求，其他请求将被挂起，因此这个命令我们用的不多。save命令执行如下：\n\n```\n127.0.0.1:6379> SAVE\nOK\n```\n\n2.在redis运行过程中，我们也可以发送一条bgsave命令来创建一个快照，不同于save命令，bgsave命令会fork一个子进程，然后这个子进程负责执行将快照写入硬盘，而父进程则继续处理客户端发来的请求，这样就不会导致客户端命令阻塞了。如下：\n\n```\n127.0.0.1:6379> BGSAVE\nBackground saving started\n```\n\n3.如果我们在redis.conf中配置了如下选项：\n\n```\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n那么当条件满足时，比如900秒内有一个key被操作了，那么redis就会自动触发bgsava命令进行备份。我们可以根据实际需求在redis.conf中配置多个这种触发规则。\n\n4.还有一种情况也会触发save命令，那就是我们执行shutdown命令时，当我们用shutdown命令关闭redis时，此时也会执行一个save命令进行备份操作，并在备份操作完成后将服务器关闭。\n\n5.还有一种特殊情况也会触发bgsave命令，就是在主从备份的时候。当从机连接上主机后，会发送一条sync命令来开始一次复制操作，此时主机会开始一次bgsave操作，并在bgsave操作结束后向从机发送快照数据实现数据同步。\n\n### aof持久化\n\n与快照持久化不同，AOF持久化是将被执行的命令写到aof文件末尾，在恢复时只需要从头到尾执行一遍写命令即可恢复数据，AOF在redis中默认也是没有开启的，需要我们手动开启，开启方式如下：\n\n打开redis.conf配置文件，修改appendonly属性值为yes，如下：\n\n```\nappendonly yes\n```\n\n另外几个和AOF相关的属性如下：\n\n```\nappendfilename \"appendonly.aof\"\n# appendfsync always\nappendfsync everysec\n# appendfsync no\nno-appendfsync-on-rewrite no\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n```\n\n这几个属性的含义分别如下：\n\n1.appendfilename表示生成的AOF备份文件的文件名。\n2.appendfsync表示备份的时机，always表示每执行一个命令就备份一次，everysec表示每秒备份一次，no表示将备份时机交给操作系统。\n3.no-appendfsync-on-rewrite表示在对aof文件进行压缩时，是否执行同步操作。\n4.最后两行配置表示AOF文件的压缩时机，这个我们一会再细说。\n\n同时为了避免快照备份的影响，我们将快照备份关闭，关闭方式如下：\n\n```\nsave \"\"\n# save 900 1\n# save 300 10\n# save 60 10000\n```\n\n此时，当我们在redis中进行数据操作时，就会自动生成AOF的配置文件appendonly.aof\n\nAOF备份的几个关键点\n\n1.通过上面的介绍，小伙伴们了解到appendfsync的取值一共有三种，我们在项目中首选everysec，always选项会严重降低redis性能。\n2.使用everysec，最坏的情况下我们可能丢失1秒的数据。\n\nAOF文件的重写与压缩\n\nAOF备份有很多明显的优势，当然也有劣势，那就是文件大小。随着系统的运行，AOF的文件会越来越大，甚至把整个电脑的硬盘填满，AOF文件的重写与压缩机制可以在一定程度上缓解这个问题。\n当AOF的备份文件过大时，我们可以向redis发送一条bgrewriteaof命令进行文件重写，如下：\n\n```\n127.0.0.1:6379> BGREWRITEAOF\nBackground append only file rewriting started\n(0.71s)\n```\n\nbgrewriteaof的执行原理和我们上文说的bgsave的原理一致，这里我就不再赘述，因此bgsave执行过程中存在的问题在这里也一样存在。\n\nbgrewriteaof也可以自动执行，自动执行时间则依赖于auto-aof-rewrite-percentage和auto-aof-rewrite-min-size配置，auto-aof-rewrite-percentage 100表示当目前aof文件大小超过上一次重写时的aof文件大小的百分之多少时会再次进行重写，如果之前没有重写，则以启动时的aof文件大小为依据，同时还要求AOF文件的大小至少要大于64M(auto-aof-rewrite-min-size 64mb)。\n\n### redis主从复制\n\n6379是主机，即master，6380和6381是从机，即slave，那么如何配置这种实例关系呢，很简单，分别在6380和6381上执行如下命令：\n\n```\n127.0.0.1:6381> SLAVEOF 127.0.0.1 6379\nOK\n```\n\n这一步也可以通过在两个从机的redis.conf中添加如下配置来解决：\n\n```\nslaveof 127.0.0.1 6379\n```\n\n主从复制注意点\n\n1.如果主机已经运行了一段时间了，并且了已经存储了一些数据了，此时从机连上来，那么从机会将主机上所有的数据进行备份，而不是从连接的那个时间点开始备份。\n2.配置了主从复制之后，主机上可读可写，但是从机只能读取不能写入（可以通过修改redis.conf中 slave-read-only 的值让从机也可以执行写操作）。\n3.在整个主从结构运行过程中，如果主机不幸挂掉，重启之后，他依然是主机，主从复制操作也能够继续进行。\n\n复制原理\n\n每一个master都有一个replication ID，这是一个较大的伪随机字符串，标记了一个给定的数据集。每个master也持有一个偏移量，master将自己产生的复制流发送给slave时，发送多少个字节的数据，自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集时，它可以以此更新slave的状态。复制偏移量即使在没有一个slave连接到master时，也会自增，所以基本上每一对给定的Replication ID, offset都会标识一个master数据集的确切版本。当slave连接到master时，它们使用PSYNC命令来发送它们记录的旧的master replication ID和它们至今为止处理的偏移量。通过这种方式，master能够仅发送slave所需的增量部分。但是如果master的缓冲区中没有足够的命令积压缓冲记录，或者如果slave引用了不再知道的历史记录（replication ID），则会转而进行一个全量重同步：在这种情况下，slave会得到一个完整的数据集副本，从头开始(参考redis官网)。\n\n简单来说，就是以下几个步骤：\n\n```\n    1.slave启动成功连接到master后会发送一个sync命令。  \n    2.Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令。  \n    3.在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步。  \n    4.全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。  \n    5.增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。  \n    6.但是只要是重新连接master,一次完全同步（全量复制)将被自动执行。  \n```\n\n我们搭建的主从复制模式是下面这样的：\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnKsYW7dwk0aaRIrKcESa9ibiaq4WfV2TDDvyGMsfjVVZ3K8oKEYT6m7YfJQekNiayQ4PfknStVl21QQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  \n\n实际上，一主二仆的主从复制，我们可以搭建成下面这种结构：\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnKsYW7dwk0aaRIrKcESa9ibbMvoJzK9ycEft3gcMssde1knu6OlGzgBWlRFRNyZYFuIc3pBUIce7g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  \n\n哨兵模式，其实并不复杂，我们还是在我们前面的基础上来搭建哨兵模式。假设现在我的master是6379，两个从机分别是6380和6381，两个从机都是从6379上复制数据。先按照上文的步骤，我们配置好一主二仆，然后在redis目录下打开sentinel.conf文件，做如下配置：\n\n```\nsentinel monitor mymaster 127.0.0.1 6379 1\n```\n\n其中mymaster是给要监控的主机取的名字，随意取，后面是主机地址，最后面的2表示有多少个sentinel认为主机挂掉了，就进行切换（我这里只有一个，因此设置为1）。好了，配置完成后，输入如下命令启动哨兵：\n\n```java\nredis-sentinel sentinel.conf\n```\n\n6379挂掉之后，redis内部重新举行了选举，6380重新上位。此时，如果6379重启，也不再是扛把子了，只能屈身做一个slave了。\n\n### 集群搭建\n\nRedis集群架构如下图：\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYmokRcFGBAhCcEXKrK04yXHyTcYLtNXvWCZjjS5Vl9wWsg323VBBmboGhJ6Ovfia4Pqc2oLadKcqvg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  \n\nRedis集群运行原理如下：\n\n1.所有的Redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽\n2.节点的fail是通过集群中超过半数的节点检测失效时才生效\n3.客户端与Redis节点直连,不需要中间proxy层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可\n4.Redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster (簇)负责维护`node<->slot<->value`。Redis集群中内置了16384个哈希槽，当需要在Redis集群中放置一个key-value时，Redis先对key使用crc16算法算出一个结果，然后把结果对 16384 求余数，这样每个key都会对应一个编号在 0-16383 之间的哈希槽，Redis 会根据节点数量大致均等的将哈希槽映射到不同的节点\n\n\n\n","source":"_posts/redis-1.md","raw":"---\ntitle: redis笔记\ndate: 2019-05-06 09:53:26\ntags: redis\n---\n\n## redis基础知识\n\n客户端与服务端的通讯协议是建立在TCP协议之上构建的；\n\nredis序列化协议 resp\n\n- 状态回复（status reply）的第一个字节是 `\"+\"`\n- 错误回复（error reply）的第一个字节是 `\"-\"`\n- 整数回复（integer reply）的第一个字节是 `\":\"`\n- 批量回复（bulk reply）的第一个字节是 `\"$\"`\n- 多条批量回复（multi bulk reply）的第一个字节是 `\"*\"`\n\n<!--more-->\n\n举例：\n\n```shell\nSET mykey myvalue\n*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\mykey\\r\\n$7\\r\\myvalue\\r\\n\n```\n\n指令表：\n\n[redis命令表](<http://redisdoc.com/>)\n\n- 字符串\n  - [SET](http://redisdoc.com/string/set.html)\n  - [SETNX](http://redisdoc.com/string/setnx.html)\n  - [SETEX](http://redisdoc.com/string/setex.html)\n  - [PSETEX](http://redisdoc.com/string/psetex.html)\n  - [GET](http://redisdoc.com/string/get.html)\n  - [GETSET](http://redisdoc.com/string/getset.html)\n  - [STRLEN](http://redisdoc.com/string/strlen.html)\n  - [APPEND](http://redisdoc.com/string/append.html)\n  - [SETRANGE](http://redisdoc.com/string/setrange.html)\n  - [GETRANGE](http://redisdoc.com/string/getrange.html)\n  - [INCR](http://redisdoc.com/string/incr.html)\n  - [INCRBY](http://redisdoc.com/string/incrby.html)\n  - [INCRBYFLOAT](http://redisdoc.com/string/incrbyfloat.html)\n  - [DECR](http://redisdoc.com/string/decr.html)\n  - [DECRBY](http://redisdoc.com/string/decrby.html)\n  - [MSET](http://redisdoc.com/string/mset.html)\n  - [MSETNX](http://redisdoc.com/string/msetnx.html)\n  - [MGET](http://redisdoc.com/string/mget.html)\n- 哈希表\n  - [HSET](http://redisdoc.com/hash/hset.html)\n  - [HSETNX](http://redisdoc.com/hash/hsetnx.html)\n  - [HGET](http://redisdoc.com/hash/hget.html)\n  - [HEXISTS](http://redisdoc.com/hash/hexists.html)\n  - [HDEL](http://redisdoc.com/hash/hdel.html)\n  - [HLEN](http://redisdoc.com/hash/hlen.html)\n  - [HSTRLEN](http://redisdoc.com/hash/hstrlen.html)\n  - [HINCRBY](http://redisdoc.com/hash/hincrby.html)\n  - [HINCRBYFLOAT](http://redisdoc.com/hash/hincrbyfloat.html)\n  - [HMSET](http://redisdoc.com/hash/hmset.html)\n  - [HMGET](http://redisdoc.com/hash/hmget.html)\n  - [HKEYS](http://redisdoc.com/hash/hkeys.html)\n  - [HVALS](http://redisdoc.com/hash/hvals.html)\n  - [HGETALL](http://redisdoc.com/hash/hgetall.html)\n  - [HSCAN](http://redisdoc.com/hash/hscan.html)\n- 列表\n  - [LPUSH](http://redisdoc.com/list/lpush.html)\n  - [LPUSHX](http://redisdoc.com/list/lpushx.html)\n  - [RPUSH](http://redisdoc.com/list/rpush.html)\n  - [RPUSHX](http://redisdoc.com/list/rpushx.html)\n  - [LPOP](http://redisdoc.com/list/lpop.html)\n  - [RPOP](http://redisdoc.com/list/rpop.html)\n  - [RPOPLPUSH](http://redisdoc.com/list/rpoplpush.html)\n  - [LREM](http://redisdoc.com/list/lrem.html)\n  - [LLEN](http://redisdoc.com/list/llen.html)\n  - [LINDEX](http://redisdoc.com/list/lindex.html)\n  - [LINSERT](http://redisdoc.com/list/linsert.html)\n  - [LSET](http://redisdoc.com/list/lset.html)\n  - [LRANGE](http://redisdoc.com/list/lrange.html)\n  - [LTRIM](http://redisdoc.com/list/ltrim.html)\n  - [BLPOP](http://redisdoc.com/list/blpop.html)\n  - [BRPOP](http://redisdoc.com/list/brpop.html)\n  - [BRPOPLPUSH](http://redisdoc.com/list/brpoplpush.html)\n- 集合\n  - [SADD](http://redisdoc.com/set/sadd.html)\n  - [SISMEMBER](http://redisdoc.com/set/sismember.html)\n  - [SPOP](http://redisdoc.com/set/spop.html)\n  - [SRANDMEMBER](http://redisdoc.com/set/srandmember.html)\n  - [SREM](http://redisdoc.com/set/srem.html)\n  - [SMOVE](http://redisdoc.com/set/smove.html)\n  - [SCARD](http://redisdoc.com/set/scard.html)\n  - [SMEMBERS](http://redisdoc.com/set/smembers.html)\n  - [SSCAN](http://redisdoc.com/set/sscan.html)\n  - [SINTER](http://redisdoc.com/set/sinter.html)\n  - [SINTERSTORE](http://redisdoc.com/set/sinterstore.html)\n  - [SUNION](http://redisdoc.com/set/sunion.html)\n  - [SUNIONSTORE](http://redisdoc.com/set/sunionstore.html)\n  - [SDIFF](http://redisdoc.com/set/sdiff.html)\n  - [SDIFFSTORE](http://redisdoc.com/set/sdiffstore.html)\n- 有序集合\n  - [ZADD](http://redisdoc.com/sorted_set/zadd.html)\n  - [ZSCORE](http://redisdoc.com/sorted_set/zscore.html)\n  - [ZINCRBY](http://redisdoc.com/sorted_set/zincrby.html)\n  - [ZCARD](http://redisdoc.com/sorted_set/zcard.html)\n  - [ZCOUNT](http://redisdoc.com/sorted_set/zcount.html)\n  - [ZRANGE](http://redisdoc.com/sorted_set/zrange.html)\n  - [ZREVRANGE](http://redisdoc.com/sorted_set/zrevrange.html)\n  - [ZRANGEBYSCORE](http://redisdoc.com/sorted_set/zrangebyscore.html)\n  - [ZREVRANGEBYSCORE](http://redisdoc.com/sorted_set/zrevrangebyscore.html)\n  - [ZRANK](http://redisdoc.com/sorted_set/zrank.html)\n  - [ZREVRANK](http://redisdoc.com/sorted_set/zrevrank.html)\n  - [ZREM](http://redisdoc.com/sorted_set/zrem.html)\n  - [ZREMRANGEBYRANK](http://redisdoc.com/sorted_set/zremrangebyrank.html)\n  - [ZREMRANGEBYSCORE](http://redisdoc.com/sorted_set/zremrangebyscore.html)\n  - [ZRANGEBYLEX](http://redisdoc.com/sorted_set/zrangebylex.html)\n  - [ZLEXCOUNT](http://redisdoc.com/sorted_set/zlexcount.html)\n  - [ZREMRANGEBYLEX](http://redisdoc.com/sorted_set/zremrangebylex.html)\n  - [ZSCAN](http://redisdoc.com/sorted_set/zscan.html)\n  - [ZUNIONSTORE](http://redisdoc.com/sorted_set/zunionstore.html)\n  - [ZINTERSTORE](http://redisdoc.com/sorted_set/zinterstore.html)\n- HyperLogLog\n  - [PFADD](http://redisdoc.com/hyperloglog/pfadd.html)\n  - [PFCOUNT](http://redisdoc.com/hyperloglog/pfcount.html)\n  - [PFMERGE](http://redisdoc.com/hyperloglog/pfmerge.html)\n- 地理位置\n  - [GEOADD](http://redisdoc.com/geo/geoadd.html)\n  - [GEOPOS](http://redisdoc.com/geo/geopos.html)\n  - [GEODIST](http://redisdoc.com/geo/geodist.html)\n  - [GEORADIUS](http://redisdoc.com/geo/georadius.html)\n  - [GEORADIUSBYMEMBER](http://redisdoc.com/geo/georadiusbymember.html)\n  - [GEOHASH](http://redisdoc.com/geo/geohash.html)\n- 位图\n  - [SETBIT](http://redisdoc.com/bitmap/setbit.html)\n  - [GETBIT](http://redisdoc.com/bitmap/getbit.html)\n  - [BITCOUNT](http://redisdoc.com/bitmap/bitcount.html)\n  - [BITPOS](http://redisdoc.com/bitmap/bitpos.html)\n  - [BITOP](http://redisdoc.com/bitmap/bitop.html)\n  - [BITFIELD](http://redisdoc.com/bitmap/bitfield.html)\n- 数据库\n  - [EXISTS](http://redisdoc.com/database/exists.html)\n  - [TYPE](http://redisdoc.com/database/type.html)\n  - [RENAME](http://redisdoc.com/database/rename.html)\n  - [RENAMENX](http://redisdoc.com/database/renamenx.html)\n  - [MOVE](http://redisdoc.com/database/move.html)\n  - [DEL](http://redisdoc.com/database/del.html)\n  - [RANDOMKEY](http://redisdoc.com/database/randomkey.html)\n  - [DBSIZE](http://redisdoc.com/database/dbsize.html)\n  - [KEYS](http://redisdoc.com/database/keys.html)\n  - [SCAN](http://redisdoc.com/database/scan.html)\n  - [SORT](http://redisdoc.com/database/sort.html)\n  - [FLUSHDB](http://redisdoc.com/database/flushdb.html)\n  - [FLUSHALL](http://redisdoc.com/database/flushall.html)\n  - [SELECT](http://redisdoc.com/database/select.html)\n  - [SWAPDB](http://redisdoc.com/database/swapdb.html)\n- 自动过期\n  - [EXPIRE](http://redisdoc.com/expire/expire.html)\n  - [EXPIREAT](http://redisdoc.com/expire/expireat.html)\n  - [TTL](http://redisdoc.com/expire/ttl.html)\n  - [PERSIST](http://redisdoc.com/expire/persist.html)\n  - [PEXPIRE](http://redisdoc.com/expire/pexpire.html)\n  - [PEXPIREAT](http://redisdoc.com/expire/pexpireat.html)\n  - [PTTL](http://redisdoc.com/expire/pttl.html)\n- 事务\n  - [MULTI](http://redisdoc.com/transaction/multi.html)\n  - [EXEC](http://redisdoc.com/transaction/exec.html)\n  - [DISCARD](http://redisdoc.com/transaction/discard.html)\n  - [WATCH](http://redisdoc.com/transaction/watch.html)\n  - [UNWATCH](http://redisdoc.com/transaction/unwatch.html)\n- Lua 脚本\n  - [EVAL](http://redisdoc.com/script/eval.html)\n  - [EVALSHA](http://redisdoc.com/script/evalsha.html)\n  - [SCRIPT_LOAD](http://redisdoc.com/script/script_load.html)\n  - [SCRIPT_EXISTS](http://redisdoc.com/script/script_exists.html)\n  - [SCRIPT_FLUSH](http://redisdoc.com/script/script_flush.html)\n  - [SCRIPT_KILL](http://redisdoc.com/script/script_kill.html)\n- 持久化\n  - [SAVE](http://redisdoc.com/persistence/save.html)\n  - [BGSAVE](http://redisdoc.com/persistence/bgsave.html)\n  - [BGREWRITEAOF](http://redisdoc.com/persistence/bgrewriteaof.html)\n  - [LASTSAVE](http://redisdoc.com/persistence/lastsave.html)\n- 发布与订阅\n  - [PUBLISH](http://redisdoc.com/pubsub/publish.html)\n  - [SUBSCRIBE](http://redisdoc.com/pubsub/subscribe.html)\n  - [PSUBSCRIBE](http://redisdoc.com/pubsub/psubscribe.html)\n  - [UNSUBSCRIBE](http://redisdoc.com/pubsub/unsubscribe.html)\n  - [PUNSUBSCRIBE](http://redisdoc.com/pubsub/punsubscribe.html)\n  - [PUBSUB](http://redisdoc.com/pubsub/pubsub.html)\n- 复制\n  - [SLAVEOF](http://redisdoc.com/replication/slaveof.html)\n  - [ROLE](http://redisdoc.com/replication/role.html)\n- 客户端与服务器\n  - [AUTH](http://redisdoc.com/client_and_server/auth.html)\n  - [QUIT](http://redisdoc.com/client_and_server/quit.html)\n  - [INFO](http://redisdoc.com/client_and_server/info.html)\n  - [SHUTDOWN](http://redisdoc.com/client_and_server/shutdown.html)\n  - [TIME](http://redisdoc.com/client_and_server/time.html)\n  - [CLIENT_GETNAME](http://redisdoc.com/client_and_server/client_getname.html)\n  - [CLIENT_KILL](http://redisdoc.com/client_and_server/client_kill.html)\n  - [CLIENT_LIST](http://redisdoc.com/client_and_server/client_list.html)\n  - [CLIENT_SETNAME](http://redisdoc.com/client_and_server/client_setname.html)\n- 配置选项\n  - [CONFIG_SET](http://redisdoc.com/configure/config_set.html)\n  - [CONFIG_GET](http://redisdoc.com/configure/config_get.html)\n  - [CONFIG_RESETSTAT](http://redisdoc.com/configure/config_resetstat.html)\n  - [CONFIG_REWRITE](http://redisdoc.com/configure/config_rewrite.html)\n- 调试\n  - [PING](http://redisdoc.com/debug/ping.html)\n  - [ECHO](http://redisdoc.com/debug/echo.html)\n  - [OBJECT](http://redisdoc.com/debug/object.html)\n  - [SLOWLOG](http://redisdoc.com/debug/slowlog.html)\n  - [MONITOR](http://redisdoc.com/debug/monitor.html)\n  - [DEBUG_OBJECT](http://redisdoc.com/debug/debug_object.html)\n  - [DEBUG_SEGFAULT](http://redisdoc.com/debug/debug_segfault.html)\n- 内部命令\n  - [MIGRATE](http://redisdoc.com/internal/migrate.html)\n  - [DUMP](http://redisdoc.com/internal/dump.html)\n  - [RESTORE](http://redisdoc.com/internal/restore.html)\n  - [SYNC](http://redisdoc.com/internal/sync.html)\n  - [PSYNC](http://redisdoc.com/internal/psync.html)\n- 功能文档\n  - [Redis 集群规范](http://redisdoc.com/topic/cluster-spec.html)\n  - [持久化（persistence）](http://redisdoc.com/topic/persistence.html)\n  - [发布与订阅（pub/sub）](http://redisdoc.com/topic/pubsub.html)\n  - [Sentinel](http://redisdoc.com/topic/sentinel.html)\n  - [集群教程](http://redisdoc.com/topic/cluster-tutorial.html)\n  - [键空间通知（keyspace notification）](http://redisdoc.com/topic/notification.html)\n  - [通信协议（protocol）](http://redisdoc.com/topic/protocol.html)\n  - [复制（Replication）](http://redisdoc.com/topic/replication.html)\n  - [事务（transaction）](http://redisdoc.com/topic/transaction.html)\n\nredis key集中过期问题，集中过期导致redis压力过大而卡顿\n\n采用一定范围内的随机过期时间\n\nRedis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型实际会严重影响整体吞吐量，CPU计算过程中，整个IO调度都是被阻塞住的。\n\n**redis分布式锁参考 本博客[多线程进阶篇](<https://muggle.javaboy.org/2019/04/23/thread-3/>)**\n\n## springboot 分布式session\n\n```java\n@Configuration  \n@EnableRedisHttpSession  \npublic class RedisSessionConfig {  \n}  \n```\n\n```xml\n<dependency>  \n        <groupId>org.springframework.boot</groupId>  \n        <artifactId>spring-boot-starter-redis</artifactId>  \n</dependency>  \n<dependency>  \n        <groupId>org.springframework.session</groupId>  \n        <artifactId>spring-session-data-redis</artifactId>  \n</dependency>\n```\n\n```properties\nspring.redis.host=localhost  \nspring.redis.port=6379  \n```\n\n**注意：springboot2.1有包冲突，本配置只适用于2.1以下**\n\n## mybatis的二级缓存\n\n二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。\n\nUserMapper有一个二级缓存区域（按namespace分），其它mapper也有自己的二级缓存区域（按namespace分）。每一个namespace的mapper都有一个二级缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。sql节点可配置userCache flushcache\n\n打开二级缓存总开关（springboot默认开启），在mapper中使用`<cache/>`打开二级缓存 在分布式系统中不能直接使用二级缓存\n\n`<cache />`的属性：\n\n- eviction：代表的是缓存收回策略，有一下策略：\n  1. LRU，  最近最少使用的，移除最长时间不用的对象。\n  2. FIFO，先进先出，按对象进入缓存的顺序来移除他们\n  3. SOFT， 软引用，移除基于垃圾回收器状态和软引用规则的对象。\n  4. WEAK，若引用，更积极的移除基于垃圾收集器状态和若引用规则的对象\n- flushInterval：刷新间隔时间，单位为毫秒，默认是当sql执行的时候才回去刷新。\n- size：引用数目，一个正整数，代表缓存最多可以存储多少对象，不宜设置过大，过大会造成内存溢出。\n- readOnly：只读，意味着缓存数据只能读取，不能修改，这样设置的好处是我们可以快速读取缓存，去诶但是我们没有办法修改缓存。默认值为false，不允许我们修改。\n\n\n\n## 分布式缓存\n\n分布式缓存策略\n\nmybatis整合ehcache实现分布式缓存、jetcache、spring cache\n\njetcache整合笔记：\n\n```xml\n        <dependency>\n            <groupId>com.alicp.jetcache</groupId>\n            <artifactId>jetcache-starter-redis</artifactId>\n            <version>2.4.4</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-redis</artifactId>\n        </dependency>\n```\n\n```java\n@SpringBootApplication\n@EnableMethodCache(basePackages = \"com.muggle.jetcahetest\")\n@EnableCreateCacheAnnotation\npublic class JetcaheTestApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(JetcaheTestApplication.class, args);\n    }\n\n}\n```\n\n```java\npublic interface Server {\n\n    @Cached(cacheType = CacheType.REMOTE)\n    int test (String message);\n}\n```\n\n```java\n@Service\npublic class ServerImpl implements Server {\n    @Override\n    public int test(String message) {\n        System.out.println(\">>>\");\n        return 666;\n    }\n}\n```\n\n更多文档参考[jetCache github 地址][]\n\n分布式缓存的应用\n\n合并批量更新，提高io\n\n缓存的粒度问题，缓存数据是全量还是部分\n\n### cache cloud 使用\n\n### 分布式缓存原理分析\n\n- 传统分布式算法：HASH算法或者取模算法\n- Consistent hashing一致性算法原理\n- Hash倾斜性\n- 虚拟节点\n- Consistent hashing命中率\n\nConsistent hashing 是一致性hash算法\n\n博客：[一致性哈希](<https://blog.csdn.net/qq_35956041/article/details/81026972>)\n\n哈希倾斜：缓存任务分配不均，采用虚拟节点避免\n\n缓存穿透：缓存未起作用\n\n缓存雪崩：缓存雪崩可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。\n\n缓存的算法\n\nFIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。\nLFU算法：Least Frequently Used，最不经常使用算法。\nLRU算法：Least Recently Used，近期最少使用算法。\n\nLRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的\n\n## redis运维（抄录自 https://mp.weixin.qq.com/s/TvIxovAi6XfR7RGigtHRtQ）\n\n### 快照持久化\n\nredis中的快照持久化默认是开启的，redis.conf中相关配置主要有如下几项：\n\n```properties\nsave 900 1\nsave 300 10\nsave 60 10000\nstop-writes-on-bgsave-error yes\nrdbcompression yes\ndbfilename dump.rdb\ndir ./\n```\n\n前面三个save相关的选项表示备份的频率，分别表示`900秒内至少一个键被更改则进行快照，300秒内至少10个键被更改则进行快照，60秒内至少10000个键被更改则进行快照，`stop-writes-on-bgsave-error表示在快照创建出错后，是否继续执行写命令，rdbcompression则表示是否对快照文件进行压缩，dbfilename表示生成的快照文件的名字，dir则表示生成的快照文件的位置，在redis中，快照持久化默认就是开启的。\n\n1.在redis运行过程中，我们可以向redis发送一条save命令来创建一个快照，save是一个阻塞命令，redis在接收到save命令之后，开始执行备份操作之后，在备份操作执行完毕之前，将不再处理其他请求，其他请求将被挂起，因此这个命令我们用的不多。save命令执行如下：\n\n```\n127.0.0.1:6379> SAVE\nOK\n```\n\n2.在redis运行过程中，我们也可以发送一条bgsave命令来创建一个快照，不同于save命令，bgsave命令会fork一个子进程，然后这个子进程负责执行将快照写入硬盘，而父进程则继续处理客户端发来的请求，这样就不会导致客户端命令阻塞了。如下：\n\n```\n127.0.0.1:6379> BGSAVE\nBackground saving started\n```\n\n3.如果我们在redis.conf中配置了如下选项：\n\n```\nsave 900 1\nsave 300 10\nsave 60 10000\n```\n\n那么当条件满足时，比如900秒内有一个key被操作了，那么redis就会自动触发bgsava命令进行备份。我们可以根据实际需求在redis.conf中配置多个这种触发规则。\n\n4.还有一种情况也会触发save命令，那就是我们执行shutdown命令时，当我们用shutdown命令关闭redis时，此时也会执行一个save命令进行备份操作，并在备份操作完成后将服务器关闭。\n\n5.还有一种特殊情况也会触发bgsave命令，就是在主从备份的时候。当从机连接上主机后，会发送一条sync命令来开始一次复制操作，此时主机会开始一次bgsave操作，并在bgsave操作结束后向从机发送快照数据实现数据同步。\n\n### aof持久化\n\n与快照持久化不同，AOF持久化是将被执行的命令写到aof文件末尾，在恢复时只需要从头到尾执行一遍写命令即可恢复数据，AOF在redis中默认也是没有开启的，需要我们手动开启，开启方式如下：\n\n打开redis.conf配置文件，修改appendonly属性值为yes，如下：\n\n```\nappendonly yes\n```\n\n另外几个和AOF相关的属性如下：\n\n```\nappendfilename \"appendonly.aof\"\n# appendfsync always\nappendfsync everysec\n# appendfsync no\nno-appendfsync-on-rewrite no\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n```\n\n这几个属性的含义分别如下：\n\n1.appendfilename表示生成的AOF备份文件的文件名。\n2.appendfsync表示备份的时机，always表示每执行一个命令就备份一次，everysec表示每秒备份一次，no表示将备份时机交给操作系统。\n3.no-appendfsync-on-rewrite表示在对aof文件进行压缩时，是否执行同步操作。\n4.最后两行配置表示AOF文件的压缩时机，这个我们一会再细说。\n\n同时为了避免快照备份的影响，我们将快照备份关闭，关闭方式如下：\n\n```\nsave \"\"\n# save 900 1\n# save 300 10\n# save 60 10000\n```\n\n此时，当我们在redis中进行数据操作时，就会自动生成AOF的配置文件appendonly.aof\n\nAOF备份的几个关键点\n\n1.通过上面的介绍，小伙伴们了解到appendfsync的取值一共有三种，我们在项目中首选everysec，always选项会严重降低redis性能。\n2.使用everysec，最坏的情况下我们可能丢失1秒的数据。\n\nAOF文件的重写与压缩\n\nAOF备份有很多明显的优势，当然也有劣势，那就是文件大小。随着系统的运行，AOF的文件会越来越大，甚至把整个电脑的硬盘填满，AOF文件的重写与压缩机制可以在一定程度上缓解这个问题。\n当AOF的备份文件过大时，我们可以向redis发送一条bgrewriteaof命令进行文件重写，如下：\n\n```\n127.0.0.1:6379> BGREWRITEAOF\nBackground append only file rewriting started\n(0.71s)\n```\n\nbgrewriteaof的执行原理和我们上文说的bgsave的原理一致，这里我就不再赘述，因此bgsave执行过程中存在的问题在这里也一样存在。\n\nbgrewriteaof也可以自动执行，自动执行时间则依赖于auto-aof-rewrite-percentage和auto-aof-rewrite-min-size配置，auto-aof-rewrite-percentage 100表示当目前aof文件大小超过上一次重写时的aof文件大小的百分之多少时会再次进行重写，如果之前没有重写，则以启动时的aof文件大小为依据，同时还要求AOF文件的大小至少要大于64M(auto-aof-rewrite-min-size 64mb)。\n\n### redis主从复制\n\n6379是主机，即master，6380和6381是从机，即slave，那么如何配置这种实例关系呢，很简单，分别在6380和6381上执行如下命令：\n\n```\n127.0.0.1:6381> SLAVEOF 127.0.0.1 6379\nOK\n```\n\n这一步也可以通过在两个从机的redis.conf中添加如下配置来解决：\n\n```\nslaveof 127.0.0.1 6379\n```\n\n主从复制注意点\n\n1.如果主机已经运行了一段时间了，并且了已经存储了一些数据了，此时从机连上来，那么从机会将主机上所有的数据进行备份，而不是从连接的那个时间点开始备份。\n2.配置了主从复制之后，主机上可读可写，但是从机只能读取不能写入（可以通过修改redis.conf中 slave-read-only 的值让从机也可以执行写操作）。\n3.在整个主从结构运行过程中，如果主机不幸挂掉，重启之后，他依然是主机，主从复制操作也能够继续进行。\n\n复制原理\n\n每一个master都有一个replication ID，这是一个较大的伪随机字符串，标记了一个给定的数据集。每个master也持有一个偏移量，master将自己产生的复制流发送给slave时，发送多少个字节的数据，自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集时，它可以以此更新slave的状态。复制偏移量即使在没有一个slave连接到master时，也会自增，所以基本上每一对给定的Replication ID, offset都会标识一个master数据集的确切版本。当slave连接到master时，它们使用PSYNC命令来发送它们记录的旧的master replication ID和它们至今为止处理的偏移量。通过这种方式，master能够仅发送slave所需的增量部分。但是如果master的缓冲区中没有足够的命令积压缓冲记录，或者如果slave引用了不再知道的历史记录（replication ID），则会转而进行一个全量重同步：在这种情况下，slave会得到一个完整的数据集副本，从头开始(参考redis官网)。\n\n简单来说，就是以下几个步骤：\n\n```\n    1.slave启动成功连接到master后会发送一个sync命令。  \n    2.Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令。  \n    3.在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步。  \n    4.全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。  \n    5.增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。  \n    6.但是只要是重新连接master,一次完全同步（全量复制)将被自动执行。  \n```\n\n我们搭建的主从复制模式是下面这样的：\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnKsYW7dwk0aaRIrKcESa9ibiaq4WfV2TDDvyGMsfjVVZ3K8oKEYT6m7YfJQekNiayQ4PfknStVl21QQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  \n\n实际上，一主二仆的主从复制，我们可以搭建成下面这种结构：\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnKsYW7dwk0aaRIrKcESa9ibbMvoJzK9ycEft3gcMssde1knu6OlGzgBWlRFRNyZYFuIc3pBUIce7g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  \n\n哨兵模式，其实并不复杂，我们还是在我们前面的基础上来搭建哨兵模式。假设现在我的master是6379，两个从机分别是6380和6381，两个从机都是从6379上复制数据。先按照上文的步骤，我们配置好一主二仆，然后在redis目录下打开sentinel.conf文件，做如下配置：\n\n```\nsentinel monitor mymaster 127.0.0.1 6379 1\n```\n\n其中mymaster是给要监控的主机取的名字，随意取，后面是主机地址，最后面的2表示有多少个sentinel认为主机挂掉了，就进行切换（我这里只有一个，因此设置为1）。好了，配置完成后，输入如下命令启动哨兵：\n\n```java\nredis-sentinel sentinel.conf\n```\n\n6379挂掉之后，redis内部重新举行了选举，6380重新上位。此时，如果6379重启，也不再是扛把子了，只能屈身做一个slave了。\n\n### 集群搭建\n\nRedis集群架构如下图：\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYmokRcFGBAhCcEXKrK04yXHyTcYLtNXvWCZjjS5Vl9wWsg323VBBmboGhJ6Ovfia4Pqc2oLadKcqvg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)  \n\nRedis集群运行原理如下：\n\n1.所有的Redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽\n2.节点的fail是通过集群中超过半数的节点检测失效时才生效\n3.客户端与Redis节点直连,不需要中间proxy层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可\n4.Redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster (簇)负责维护`node<->slot<->value`。Redis集群中内置了16384个哈希槽，当需要在Redis集群中放置一个key-value时，Redis先对key使用crc16算法算出一个结果，然后把结果对 16384 求余数，这样每个key都会对应一个编号在 0-16383 之间的哈希槽，Redis 会根据节点数量大致均等的将哈希槽映射到不同的节点\n\n\n\n","slug":"redis-1","published":1,"updated":"2021-01-11T07:31:23.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh78004p00wido8o1vx0","content":"<h2 id=\"redis基础知识\"><a href=\"#redis基础知识\" class=\"headerlink\" title=\"redis基础知识\"></a>redis基础知识</h2><p>客户端与服务端的通讯协议是建立在TCP协议之上构建的；</p>\n<p>redis序列化协议 resp</p>\n<ul>\n<li>状态回复（status reply）的第一个字节是 <code>&quot;+&quot;</code></li>\n<li>错误回复（error reply）的第一个字节是 <code>&quot;-&quot;</code></li>\n<li>整数回复（integer reply）的第一个字节是 <code>&quot;:&quot;</code></li>\n<li>批量回复（bulk reply）的第一个字节是 <code>&quot;$&quot;</code></li>\n<li>多条批量回复（multi bulk reply）的第一个字节是 <code>&quot;*&quot;</code></li>\n</ul>\n<a id=\"more\"></a>\n\n<p>举例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET mykey myvalue</span><br><span class=\"line\">*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\mykey\\r\\n$7\\r\\myvalue\\r\\n</span><br></pre></td></tr></table></figure>\n<p>指令表：</p>\n<p><a href=\"http://redisdoc.com/\">redis命令表</a></p>\n<ul>\n<li>字符串<ul>\n<li><a href=\"http://redisdoc.com/string/set.html\">SET</a></li>\n<li><a href=\"http://redisdoc.com/string/setnx.html\">SETNX</a></li>\n<li><a href=\"http://redisdoc.com/string/setex.html\">SETEX</a></li>\n<li><a href=\"http://redisdoc.com/string/psetex.html\">PSETEX</a></li>\n<li><a href=\"http://redisdoc.com/string/get.html\">GET</a></li>\n<li><a href=\"http://redisdoc.com/string/getset.html\">GETSET</a></li>\n<li><a href=\"http://redisdoc.com/string/strlen.html\">STRLEN</a></li>\n<li><a href=\"http://redisdoc.com/string/append.html\">APPEND</a></li>\n<li><a href=\"http://redisdoc.com/string/setrange.html\">SETRANGE</a></li>\n<li><a href=\"http://redisdoc.com/string/getrange.html\">GETRANGE</a></li>\n<li><a href=\"http://redisdoc.com/string/incr.html\">INCR</a></li>\n<li><a href=\"http://redisdoc.com/string/incrby.html\">INCRBY</a></li>\n<li><a href=\"http://redisdoc.com/string/incrbyfloat.html\">INCRBYFLOAT</a></li>\n<li><a href=\"http://redisdoc.com/string/decr.html\">DECR</a></li>\n<li><a href=\"http://redisdoc.com/string/decrby.html\">DECRBY</a></li>\n<li><a href=\"http://redisdoc.com/string/mset.html\">MSET</a></li>\n<li><a href=\"http://redisdoc.com/string/msetnx.html\">MSETNX</a></li>\n<li><a href=\"http://redisdoc.com/string/mget.html\">MGET</a></li>\n</ul>\n</li>\n<li>哈希表<ul>\n<li><a href=\"http://redisdoc.com/hash/hset.html\">HSET</a></li>\n<li><a href=\"http://redisdoc.com/hash/hsetnx.html\">HSETNX</a></li>\n<li><a href=\"http://redisdoc.com/hash/hget.html\">HGET</a></li>\n<li><a href=\"http://redisdoc.com/hash/hexists.html\">HEXISTS</a></li>\n<li><a href=\"http://redisdoc.com/hash/hdel.html\">HDEL</a></li>\n<li><a href=\"http://redisdoc.com/hash/hlen.html\">HLEN</a></li>\n<li><a href=\"http://redisdoc.com/hash/hstrlen.html\">HSTRLEN</a></li>\n<li><a href=\"http://redisdoc.com/hash/hincrby.html\">HINCRBY</a></li>\n<li><a href=\"http://redisdoc.com/hash/hincrbyfloat.html\">HINCRBYFLOAT</a></li>\n<li><a href=\"http://redisdoc.com/hash/hmset.html\">HMSET</a></li>\n<li><a href=\"http://redisdoc.com/hash/hmget.html\">HMGET</a></li>\n<li><a href=\"http://redisdoc.com/hash/hkeys.html\">HKEYS</a></li>\n<li><a href=\"http://redisdoc.com/hash/hvals.html\">HVALS</a></li>\n<li><a href=\"http://redisdoc.com/hash/hgetall.html\">HGETALL</a></li>\n<li><a href=\"http://redisdoc.com/hash/hscan.html\">HSCAN</a></li>\n</ul>\n</li>\n<li>列表<ul>\n<li><a href=\"http://redisdoc.com/list/lpush.html\">LPUSH</a></li>\n<li><a href=\"http://redisdoc.com/list/lpushx.html\">LPUSHX</a></li>\n<li><a href=\"http://redisdoc.com/list/rpush.html\">RPUSH</a></li>\n<li><a href=\"http://redisdoc.com/list/rpushx.html\">RPUSHX</a></li>\n<li><a href=\"http://redisdoc.com/list/lpop.html\">LPOP</a></li>\n<li><a href=\"http://redisdoc.com/list/rpop.html\">RPOP</a></li>\n<li><a href=\"http://redisdoc.com/list/rpoplpush.html\">RPOPLPUSH</a></li>\n<li><a href=\"http://redisdoc.com/list/lrem.html\">LREM</a></li>\n<li><a href=\"http://redisdoc.com/list/llen.html\">LLEN</a></li>\n<li><a href=\"http://redisdoc.com/list/lindex.html\">LINDEX</a></li>\n<li><a href=\"http://redisdoc.com/list/linsert.html\">LINSERT</a></li>\n<li><a href=\"http://redisdoc.com/list/lset.html\">LSET</a></li>\n<li><a href=\"http://redisdoc.com/list/lrange.html\">LRANGE</a></li>\n<li><a href=\"http://redisdoc.com/list/ltrim.html\">LTRIM</a></li>\n<li><a href=\"http://redisdoc.com/list/blpop.html\">BLPOP</a></li>\n<li><a href=\"http://redisdoc.com/list/brpop.html\">BRPOP</a></li>\n<li><a href=\"http://redisdoc.com/list/brpoplpush.html\">BRPOPLPUSH</a></li>\n</ul>\n</li>\n<li>集合<ul>\n<li><a href=\"http://redisdoc.com/set/sadd.html\">SADD</a></li>\n<li><a href=\"http://redisdoc.com/set/sismember.html\">SISMEMBER</a></li>\n<li><a href=\"http://redisdoc.com/set/spop.html\">SPOP</a></li>\n<li><a href=\"http://redisdoc.com/set/srandmember.html\">SRANDMEMBER</a></li>\n<li><a href=\"http://redisdoc.com/set/srem.html\">SREM</a></li>\n<li><a href=\"http://redisdoc.com/set/smove.html\">SMOVE</a></li>\n<li><a href=\"http://redisdoc.com/set/scard.html\">SCARD</a></li>\n<li><a href=\"http://redisdoc.com/set/smembers.html\">SMEMBERS</a></li>\n<li><a href=\"http://redisdoc.com/set/sscan.html\">SSCAN</a></li>\n<li><a href=\"http://redisdoc.com/set/sinter.html\">SINTER</a></li>\n<li><a href=\"http://redisdoc.com/set/sinterstore.html\">SINTERSTORE</a></li>\n<li><a href=\"http://redisdoc.com/set/sunion.html\">SUNION</a></li>\n<li><a href=\"http://redisdoc.com/set/sunionstore.html\">SUNIONSTORE</a></li>\n<li><a href=\"http://redisdoc.com/set/sdiff.html\">SDIFF</a></li>\n<li><a href=\"http://redisdoc.com/set/sdiffstore.html\">SDIFFSTORE</a></li>\n</ul>\n</li>\n<li>有序集合<ul>\n<li><a href=\"http://redisdoc.com/sorted_set/zadd.html\">ZADD</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zscore.html\">ZSCORE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zincrby.html\">ZINCRBY</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zcard.html\">ZCARD</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zcount.html\">ZCOUNT</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrange.html\">ZRANGE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrevrange.html\">ZREVRANGE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrangebyscore.html\">ZRANGEBYSCORE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrevrangebyscore.html\">ZREVRANGEBYSCORE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrank.html\">ZRANK</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrevrank.html\">ZREVRANK</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrem.html\">ZREM</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zremrangebyrank.html\">ZREMRANGEBYRANK</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zremrangebyscore.html\">ZREMRANGEBYSCORE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrangebylex.html\">ZRANGEBYLEX</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zlexcount.html\">ZLEXCOUNT</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zremrangebylex.html\">ZREMRANGEBYLEX</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zscan.html\">ZSCAN</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zunionstore.html\">ZUNIONSTORE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zinterstore.html\">ZINTERSTORE</a></li>\n</ul>\n</li>\n<li>HyperLogLog<ul>\n<li><a href=\"http://redisdoc.com/hyperloglog/pfadd.html\">PFADD</a></li>\n<li><a href=\"http://redisdoc.com/hyperloglog/pfcount.html\">PFCOUNT</a></li>\n<li><a href=\"http://redisdoc.com/hyperloglog/pfmerge.html\">PFMERGE</a></li>\n</ul>\n</li>\n<li>地理位置<ul>\n<li><a href=\"http://redisdoc.com/geo/geoadd.html\">GEOADD</a></li>\n<li><a href=\"http://redisdoc.com/geo/geopos.html\">GEOPOS</a></li>\n<li><a href=\"http://redisdoc.com/geo/geodist.html\">GEODIST</a></li>\n<li><a href=\"http://redisdoc.com/geo/georadius.html\">GEORADIUS</a></li>\n<li><a href=\"http://redisdoc.com/geo/georadiusbymember.html\">GEORADIUSBYMEMBER</a></li>\n<li><a href=\"http://redisdoc.com/geo/geohash.html\">GEOHASH</a></li>\n</ul>\n</li>\n<li>位图<ul>\n<li><a href=\"http://redisdoc.com/bitmap/setbit.html\">SETBIT</a></li>\n<li><a href=\"http://redisdoc.com/bitmap/getbit.html\">GETBIT</a></li>\n<li><a href=\"http://redisdoc.com/bitmap/bitcount.html\">BITCOUNT</a></li>\n<li><a href=\"http://redisdoc.com/bitmap/bitpos.html\">BITPOS</a></li>\n<li><a href=\"http://redisdoc.com/bitmap/bitop.html\">BITOP</a></li>\n<li><a href=\"http://redisdoc.com/bitmap/bitfield.html\">BITFIELD</a></li>\n</ul>\n</li>\n<li>数据库<ul>\n<li><a href=\"http://redisdoc.com/database/exists.html\">EXISTS</a></li>\n<li><a href=\"http://redisdoc.com/database/type.html\">TYPE</a></li>\n<li><a href=\"http://redisdoc.com/database/rename.html\">RENAME</a></li>\n<li><a href=\"http://redisdoc.com/database/renamenx.html\">RENAMENX</a></li>\n<li><a href=\"http://redisdoc.com/database/move.html\">MOVE</a></li>\n<li><a href=\"http://redisdoc.com/database/del.html\">DEL</a></li>\n<li><a href=\"http://redisdoc.com/database/randomkey.html\">RANDOMKEY</a></li>\n<li><a href=\"http://redisdoc.com/database/dbsize.html\">DBSIZE</a></li>\n<li><a href=\"http://redisdoc.com/database/keys.html\">KEYS</a></li>\n<li><a href=\"http://redisdoc.com/database/scan.html\">SCAN</a></li>\n<li><a href=\"http://redisdoc.com/database/sort.html\">SORT</a></li>\n<li><a href=\"http://redisdoc.com/database/flushdb.html\">FLUSHDB</a></li>\n<li><a href=\"http://redisdoc.com/database/flushall.html\">FLUSHALL</a></li>\n<li><a href=\"http://redisdoc.com/database/select.html\">SELECT</a></li>\n<li><a href=\"http://redisdoc.com/database/swapdb.html\">SWAPDB</a></li>\n</ul>\n</li>\n<li>自动过期<ul>\n<li><a href=\"http://redisdoc.com/expire/expire.html\">EXPIRE</a></li>\n<li><a href=\"http://redisdoc.com/expire/expireat.html\">EXPIREAT</a></li>\n<li><a href=\"http://redisdoc.com/expire/ttl.html\">TTL</a></li>\n<li><a href=\"http://redisdoc.com/expire/persist.html\">PERSIST</a></li>\n<li><a href=\"http://redisdoc.com/expire/pexpire.html\">PEXPIRE</a></li>\n<li><a href=\"http://redisdoc.com/expire/pexpireat.html\">PEXPIREAT</a></li>\n<li><a href=\"http://redisdoc.com/expire/pttl.html\">PTTL</a></li>\n</ul>\n</li>\n<li>事务<ul>\n<li><a href=\"http://redisdoc.com/transaction/multi.html\">MULTI</a></li>\n<li><a href=\"http://redisdoc.com/transaction/exec.html\">EXEC</a></li>\n<li><a href=\"http://redisdoc.com/transaction/discard.html\">DISCARD</a></li>\n<li><a href=\"http://redisdoc.com/transaction/watch.html\">WATCH</a></li>\n<li><a href=\"http://redisdoc.com/transaction/unwatch.html\">UNWATCH</a></li>\n</ul>\n</li>\n<li>Lua 脚本<ul>\n<li><a href=\"http://redisdoc.com/script/eval.html\">EVAL</a></li>\n<li><a href=\"http://redisdoc.com/script/evalsha.html\">EVALSHA</a></li>\n<li><a href=\"http://redisdoc.com/script/script_load.html\">SCRIPT_LOAD</a></li>\n<li><a href=\"http://redisdoc.com/script/script_exists.html\">SCRIPT_EXISTS</a></li>\n<li><a href=\"http://redisdoc.com/script/script_flush.html\">SCRIPT_FLUSH</a></li>\n<li><a href=\"http://redisdoc.com/script/script_kill.html\">SCRIPT_KILL</a></li>\n</ul>\n</li>\n<li>持久化<ul>\n<li><a href=\"http://redisdoc.com/persistence/save.html\">SAVE</a></li>\n<li><a href=\"http://redisdoc.com/persistence/bgsave.html\">BGSAVE</a></li>\n<li><a href=\"http://redisdoc.com/persistence/bgrewriteaof.html\">BGREWRITEAOF</a></li>\n<li><a href=\"http://redisdoc.com/persistence/lastsave.html\">LASTSAVE</a></li>\n</ul>\n</li>\n<li>发布与订阅<ul>\n<li><a href=\"http://redisdoc.com/pubsub/publish.html\">PUBLISH</a></li>\n<li><a href=\"http://redisdoc.com/pubsub/subscribe.html\">SUBSCRIBE</a></li>\n<li><a href=\"http://redisdoc.com/pubsub/psubscribe.html\">PSUBSCRIBE</a></li>\n<li><a href=\"http://redisdoc.com/pubsub/unsubscribe.html\">UNSUBSCRIBE</a></li>\n<li><a href=\"http://redisdoc.com/pubsub/punsubscribe.html\">PUNSUBSCRIBE</a></li>\n<li><a href=\"http://redisdoc.com/pubsub/pubsub.html\">PUBSUB</a></li>\n</ul>\n</li>\n<li>复制<ul>\n<li><a href=\"http://redisdoc.com/replication/slaveof.html\">SLAVEOF</a></li>\n<li><a href=\"http://redisdoc.com/replication/role.html\">ROLE</a></li>\n</ul>\n</li>\n<li>客户端与服务器<ul>\n<li><a href=\"http://redisdoc.com/client_and_server/auth.html\">AUTH</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/quit.html\">QUIT</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/info.html\">INFO</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/shutdown.html\">SHUTDOWN</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/time.html\">TIME</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/client_getname.html\">CLIENT_GETNAME</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/client_kill.html\">CLIENT_KILL</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/client_list.html\">CLIENT_LIST</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/client_setname.html\">CLIENT_SETNAME</a></li>\n</ul>\n</li>\n<li>配置选项<ul>\n<li><a href=\"http://redisdoc.com/configure/config_set.html\">CONFIG_SET</a></li>\n<li><a href=\"http://redisdoc.com/configure/config_get.html\">CONFIG_GET</a></li>\n<li><a href=\"http://redisdoc.com/configure/config_resetstat.html\">CONFIG_RESETSTAT</a></li>\n<li><a href=\"http://redisdoc.com/configure/config_rewrite.html\">CONFIG_REWRITE</a></li>\n</ul>\n</li>\n<li>调试<ul>\n<li><a href=\"http://redisdoc.com/debug/ping.html\">PING</a></li>\n<li><a href=\"http://redisdoc.com/debug/echo.html\">ECHO</a></li>\n<li><a href=\"http://redisdoc.com/debug/object.html\">OBJECT</a></li>\n<li><a href=\"http://redisdoc.com/debug/slowlog.html\">SLOWLOG</a></li>\n<li><a href=\"http://redisdoc.com/debug/monitor.html\">MONITOR</a></li>\n<li><a href=\"http://redisdoc.com/debug/debug_object.html\">DEBUG_OBJECT</a></li>\n<li><a href=\"http://redisdoc.com/debug/debug_segfault.html\">DEBUG_SEGFAULT</a></li>\n</ul>\n</li>\n<li>内部命令<ul>\n<li><a href=\"http://redisdoc.com/internal/migrate.html\">MIGRATE</a></li>\n<li><a href=\"http://redisdoc.com/internal/dump.html\">DUMP</a></li>\n<li><a href=\"http://redisdoc.com/internal/restore.html\">RESTORE</a></li>\n<li><a href=\"http://redisdoc.com/internal/sync.html\">SYNC</a></li>\n<li><a href=\"http://redisdoc.com/internal/psync.html\">PSYNC</a></li>\n</ul>\n</li>\n<li>功能文档<ul>\n<li><a href=\"http://redisdoc.com/topic/cluster-spec.html\">Redis 集群规范</a></li>\n<li><a href=\"http://redisdoc.com/topic/persistence.html\">持久化（persistence）</a></li>\n<li><a href=\"http://redisdoc.com/topic/pubsub.html\">发布与订阅（pub/sub）</a></li>\n<li><a href=\"http://redisdoc.com/topic/sentinel.html\">Sentinel</a></li>\n<li><a href=\"http://redisdoc.com/topic/cluster-tutorial.html\">集群教程</a></li>\n<li><a href=\"http://redisdoc.com/topic/notification.html\">键空间通知（keyspace notification）</a></li>\n<li><a href=\"http://redisdoc.com/topic/protocol.html\">通信协议（protocol）</a></li>\n<li><a href=\"http://redisdoc.com/topic/replication.html\">复制（Replication）</a></li>\n<li><a href=\"http://redisdoc.com/topic/transaction.html\">事务（transaction）</a></li>\n</ul>\n</li>\n</ul>\n<p>redis key集中过期问题，集中过期导致redis压力过大而卡顿</p>\n<p>采用一定范围内的随机过期时间</p>\n<p>Redis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型实际会严重影响整体吞吐量，CPU计算过程中，整个IO调度都是被阻塞住的。</p>\n<p><strong>redis分布式锁参考 本博客<a href=\"https://muggle.javaboy.org/2019/04/23/thread-3/\">多线程进阶篇</a></strong></p>\n<h2 id=\"springboot-分布式session\"><a href=\"#springboot-分布式session\" class=\"headerlink\" title=\"springboot 分布式session\"></a>springboot 分布式session</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>  </span><br><span class=\"line\"><span class=\"meta\">@EnableRedisHttpSession</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisSessionConfig</span> </span>&#123;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.session<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-session-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.redis.host</span>=<span class=\"string\">localhost  </span></span><br><span class=\"line\"><span class=\"meta\">spring.redis.port</span>=<span class=\"string\">6379  </span></span><br></pre></td></tr></table></figure>\n<p><strong>注意：springboot2.1有包冲突，本配置只适用于2.1以下</strong></p>\n<h2 id=\"mybatis的二级缓存\"><a href=\"#mybatis的二级缓存\" class=\"headerlink\" title=\"mybatis的二级缓存\"></a>mybatis的二级缓存</h2><p>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p>\n<p>UserMapper有一个二级缓存区域（按namespace分），其它mapper也有自己的二级缓存区域（按namespace分）。每一个namespace的mapper都有一个二级缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。sql节点可配置userCache flushcache</p>\n<p>打开二级缓存总开关（springboot默认开启），在mapper中使用<code>&lt;cache/&gt;</code>打开二级缓存 在分布式系统中不能直接使用二级缓存</p>\n<p><code>&lt;cache /&gt;</code>的属性：</p>\n<ul>\n<li>eviction：代表的是缓存收回策略，有一下策略：<ol>\n<li>LRU，  最近最少使用的，移除最长时间不用的对象。</li>\n<li>FIFO，先进先出，按对象进入缓存的顺序来移除他们</li>\n<li>SOFT， 软引用，移除基于垃圾回收器状态和软引用规则的对象。</li>\n<li>WEAK，若引用，更积极的移除基于垃圾收集器状态和若引用规则的对象</li>\n</ol>\n</li>\n<li>flushInterval：刷新间隔时间，单位为毫秒，默认是当sql执行的时候才回去刷新。</li>\n<li>size：引用数目，一个正整数，代表缓存最多可以存储多少对象，不宜设置过大，过大会造成内存溢出。</li>\n<li>readOnly：只读，意味着缓存数据只能读取，不能修改，这样设置的好处是我们可以快速读取缓存，去诶但是我们没有办法修改缓存。默认值为false，不允许我们修改。</li>\n</ul>\n<h2 id=\"分布式缓存\"><a href=\"#分布式缓存\" class=\"headerlink\" title=\"分布式缓存\"></a>分布式缓存</h2><p>分布式缓存策略</p>\n<p>mybatis整合ehcache实现分布式缓存、jetcache、spring cache</p>\n<p>jetcache整合笔记：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alicp.jetcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jetcache-starter-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.4.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableMethodCache(basePackages = &quot;com.muggle.jetcahetest&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCreateCacheAnnotation</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JetcaheTestApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(JetcaheTestApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Cached(cacheType = CacheType.REMOTE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test</span> <span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">666</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多文档参考[jetCache github 地址][]</p>\n<p>分布式缓存的应用</p>\n<p>合并批量更新，提高io</p>\n<p>缓存的粒度问题，缓存数据是全量还是部分</p>\n<h3 id=\"cache-cloud-使用\"><a href=\"#cache-cloud-使用\" class=\"headerlink\" title=\"cache cloud 使用\"></a>cache cloud 使用</h3><h3 id=\"分布式缓存原理分析\"><a href=\"#分布式缓存原理分析\" class=\"headerlink\" title=\"分布式缓存原理分析\"></a>分布式缓存原理分析</h3><ul>\n<li>传统分布式算法：HASH算法或者取模算法</li>\n<li>Consistent hashing一致性算法原理</li>\n<li>Hash倾斜性</li>\n<li>虚拟节点</li>\n<li>Consistent hashing命中率</li>\n</ul>\n<p>Consistent hashing 是一致性hash算法</p>\n<p>博客：<a href=\"https://blog.csdn.net/qq_35956041/article/details/81026972\">一致性哈希</a></p>\n<p>哈希倾斜：缓存任务分配不均，采用虚拟节点避免</p>\n<p>缓存穿透：缓存未起作用</p>\n<p>缓存雪崩：缓存雪崩可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。</p>\n<p>缓存的算法</p>\n<p>FIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。<br>LFU算法：Least Frequently Used，最不经常使用算法。<br>LRU算法：Least Recently Used，近期最少使用算法。</p>\n<p>LRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的</p>\n<h2 id=\"redis运维（抄录自-https-mp-weixin-qq-com-s-TvIxovAi6XfR7RGigtHRtQ）\"><a href=\"#redis运维（抄录自-https-mp-weixin-qq-com-s-TvIxovAi6XfR7RGigtHRtQ）\" class=\"headerlink\" title=\"redis运维（抄录自 https://mp.weixin.qq.com/s/TvIxovAi6XfR7RGigtHRtQ）\"></a>redis运维（抄录自 <a href=\"https://mp.weixin.qq.com/s/TvIxovAi6XfR7RGigtHRtQ）\">https://mp.weixin.qq.com/s/TvIxovAi6XfR7RGigtHRtQ）</a></h2><h3 id=\"快照持久化\"><a href=\"#快照持久化\" class=\"headerlink\" title=\"快照持久化\"></a>快照持久化</h3><p>redis中的快照持久化默认是开启的，redis.conf中相关配置主要有如下几项：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">save</span> <span class=\"string\">900 1</span></span><br><span class=\"line\"><span class=\"attr\">save</span> <span class=\"string\">300 10</span></span><br><span class=\"line\"><span class=\"attr\">save</span> <span class=\"string\">60 10000</span></span><br><span class=\"line\"><span class=\"meta\">stop-writes-on-bgsave-error</span> <span class=\"string\">yes</span></span><br><span class=\"line\"><span class=\"attr\">rdbcompression</span> <span class=\"string\">yes</span></span><br><span class=\"line\"><span class=\"attr\">dbfilename</span> <span class=\"string\">dump.rdb</span></span><br><span class=\"line\"><span class=\"attr\">dir</span> <span class=\"string\">./</span></span><br></pre></td></tr></table></figure>\n<p>前面三个save相关的选项表示备份的频率，分别表示<code>900秒内至少一个键被更改则进行快照，300秒内至少10个键被更改则进行快照，60秒内至少10000个键被更改则进行快照，</code>stop-writes-on-bgsave-error表示在快照创建出错后，是否继续执行写命令，rdbcompression则表示是否对快照文件进行压缩，dbfilename表示生成的快照文件的名字，dir则表示生成的快照文件的位置，在redis中，快照持久化默认就是开启的。</p>\n<p>1.在redis运行过程中，我们可以向redis发送一条save命令来创建一个快照，save是一个阻塞命令，redis在接收到save命令之后，开始执行备份操作之后，在备份操作执行完毕之前，将不再处理其他请求，其他请求将被挂起，因此这个命令我们用的不多。save命令执行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SAVE</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>2.在redis运行过程中，我们也可以发送一条bgsave命令来创建一个快照，不同于save命令，bgsave命令会fork一个子进程，然后这个子进程负责执行将快照写入硬盘，而父进程则继续处理客户端发来的请求，这样就不会导致客户端命令阻塞了。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; BGSAVE</span><br><span class=\"line\">Background saving started</span><br></pre></td></tr></table></figure>\n<p>3.如果我们在redis.conf中配置了如下选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save 900 1</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n<p>那么当条件满足时，比如900秒内有一个key被操作了，那么redis就会自动触发bgsava命令进行备份。我们可以根据实际需求在redis.conf中配置多个这种触发规则。</p>\n<p>4.还有一种情况也会触发save命令，那就是我们执行shutdown命令时，当我们用shutdown命令关闭redis时，此时也会执行一个save命令进行备份操作，并在备份操作完成后将服务器关闭。</p>\n<p>5.还有一种特殊情况也会触发bgsave命令，就是在主从备份的时候。当从机连接上主机后，会发送一条sync命令来开始一次复制操作，此时主机会开始一次bgsave操作，并在bgsave操作结束后向从机发送快照数据实现数据同步。</p>\n<h3 id=\"aof持久化\"><a href=\"#aof持久化\" class=\"headerlink\" title=\"aof持久化\"></a>aof持久化</h3><p>与快照持久化不同，AOF持久化是将被执行的命令写到aof文件末尾，在恢复时只需要从头到尾执行一遍写命令即可恢复数据，AOF在redis中默认也是没有开启的，需要我们手动开启，开启方式如下：</p>\n<p>打开redis.conf配置文件，修改appendonly属性值为yes，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendonly yes</span><br></pre></td></tr></table></figure>\n<p>另外几个和AOF相关的属性如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendfilename &quot;appendonly.aof&quot;</span><br><span class=\"line\"># appendfsync always</span><br><span class=\"line\">appendfsync everysec</span><br><span class=\"line\"># appendfsync no</span><br><span class=\"line\">no-appendfsync-on-rewrite no</span><br><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>\n<p>这几个属性的含义分别如下：</p>\n<p>1.appendfilename表示生成的AOF备份文件的文件名。<br>2.appendfsync表示备份的时机，always表示每执行一个命令就备份一次，everysec表示每秒备份一次，no表示将备份时机交给操作系统。<br>3.no-appendfsync-on-rewrite表示在对aof文件进行压缩时，是否执行同步操作。<br>4.最后两行配置表示AOF文件的压缩时机，这个我们一会再细说。</p>\n<p>同时为了避免快照备份的影响，我们将快照备份关闭，关闭方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save &quot;&quot;</span><br><span class=\"line\"># save 900 1</span><br><span class=\"line\"># save 300 10</span><br><span class=\"line\"># save 60 10000</span><br></pre></td></tr></table></figure>\n<p>此时，当我们在redis中进行数据操作时，就会自动生成AOF的配置文件appendonly.aof</p>\n<p>AOF备份的几个关键点</p>\n<p>1.通过上面的介绍，小伙伴们了解到appendfsync的取值一共有三种，我们在项目中首选everysec，always选项会严重降低redis性能。<br>2.使用everysec，最坏的情况下我们可能丢失1秒的数据。</p>\n<p>AOF文件的重写与压缩</p>\n<p>AOF备份有很多明显的优势，当然也有劣势，那就是文件大小。随着系统的运行，AOF的文件会越来越大，甚至把整个电脑的硬盘填满，AOF文件的重写与压缩机制可以在一定程度上缓解这个问题。<br>当AOF的备份文件过大时，我们可以向redis发送一条bgrewriteaof命令进行文件重写，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; BGREWRITEAOF</span><br><span class=\"line\">Background append only file rewriting started</span><br><span class=\"line\">(0.71s)</span><br></pre></td></tr></table></figure>\n<p>bgrewriteaof的执行原理和我们上文说的bgsave的原理一致，这里我就不再赘述，因此bgsave执行过程中存在的问题在这里也一样存在。</p>\n<p>bgrewriteaof也可以自动执行，自动执行时间则依赖于auto-aof-rewrite-percentage和auto-aof-rewrite-min-size配置，auto-aof-rewrite-percentage 100表示当目前aof文件大小超过上一次重写时的aof文件大小的百分之多少时会再次进行重写，如果之前没有重写，则以启动时的aof文件大小为依据，同时还要求AOF文件的大小至少要大于64M(auto-aof-rewrite-min-size 64mb)。</p>\n<h3 id=\"redis主从复制\"><a href=\"#redis主从复制\" class=\"headerlink\" title=\"redis主从复制\"></a>redis主从复制</h3><p>6379是主机，即master，6380和6381是从机，即slave，那么如何配置这种实例关系呢，很简单，分别在6380和6381上执行如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6379</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>这一步也可以通过在两个从机的redis.conf中添加如下配置来解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>\n<p>主从复制注意点</p>\n<p>1.如果主机已经运行了一段时间了，并且了已经存储了一些数据了，此时从机连上来，那么从机会将主机上所有的数据进行备份，而不是从连接的那个时间点开始备份。<br>2.配置了主从复制之后，主机上可读可写，但是从机只能读取不能写入（可以通过修改redis.conf中 slave-read-only 的值让从机也可以执行写操作）。<br>3.在整个主从结构运行过程中，如果主机不幸挂掉，重启之后，他依然是主机，主从复制操作也能够继续进行。</p>\n<p>复制原理</p>\n<p>每一个master都有一个replication ID，这是一个较大的伪随机字符串，标记了一个给定的数据集。每个master也持有一个偏移量，master将自己产生的复制流发送给slave时，发送多少个字节的数据，自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集时，它可以以此更新slave的状态。复制偏移量即使在没有一个slave连接到master时，也会自增，所以基本上每一对给定的Replication ID, offset都会标识一个master数据集的确切版本。当slave连接到master时，它们使用PSYNC命令来发送它们记录的旧的master replication ID和它们至今为止处理的偏移量。通过这种方式，master能够仅发送slave所需的增量部分。但是如果master的缓冲区中没有足够的命令积压缓冲记录，或者如果slave引用了不再知道的历史记录（replication ID），则会转而进行一个全量重同步：在这种情况下，slave会得到一个完整的数据集副本，从头开始(参考redis官网)。</p>\n<p>简单来说，就是以下几个步骤：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.slave启动成功连接到master后会发送一个sync命令。  </span><br><span class=\"line\">2.Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令。  </span><br><span class=\"line\">3.在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步。  </span><br><span class=\"line\">4.全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。  </span><br><span class=\"line\">5.增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。  </span><br><span class=\"line\">6.但是只要是重新连接master,一次完全同步（全量复制)将被自动执行。  </span><br></pre></td></tr></table></figure>\n<p>我们搭建的主从复制模式是下面这样的：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnKsYW7dwk0aaRIrKcESa9ibiaq4WfV2TDDvyGMsfjVVZ3K8oKEYT6m7YfJQekNiayQ4PfknStVl21QQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\">  </p>\n<p>实际上，一主二仆的主从复制，我们可以搭建成下面这种结构：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnKsYW7dwk0aaRIrKcESa9ibbMvoJzK9ycEft3gcMssde1knu6OlGzgBWlRFRNyZYFuIc3pBUIce7g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\">  </p>\n<p>哨兵模式，其实并不复杂，我们还是在我们前面的基础上来搭建哨兵模式。假设现在我的master是6379，两个从机分别是6380和6381，两个从机都是从6379上复制数据。先按照上文的步骤，我们配置好一主二仆，然后在redis目录下打开sentinel.conf文件，做如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>\n<p>其中mymaster是给要监控的主机取的名字，随意取，后面是主机地址，最后面的2表示有多少个sentinel认为主机挂掉了，就进行切换（我这里只有一个，因此设置为1）。好了，配置完成后，输入如下命令启动哨兵：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure>\n<p>6379挂掉之后，redis内部重新举行了选举，6380重新上位。此时，如果6379重启，也不再是扛把子了，只能屈身做一个slave了。</p>\n<h3 id=\"集群搭建\"><a href=\"#集群搭建\" class=\"headerlink\" title=\"集群搭建\"></a>集群搭建</h3><p>Redis集群架构如下图：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYmokRcFGBAhCcEXKrK04yXHyTcYLtNXvWCZjjS5Vl9wWsg323VBBmboGhJ6Ovfia4Pqc2oLadKcqvg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\">  </p>\n<p>Redis集群运行原理如下：</p>\n<p>1.所有的Redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽<br>2.节点的fail是通过集群中超过半数的节点检测失效时才生效<br>3.客户端与Redis节点直连,不需要中间proxy层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可<br>4.Redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster (簇)负责维护<code>node&lt;-&gt;slot&lt;-&gt;value</code>。Redis集群中内置了16384个哈希槽，当需要在Redis集群中放置一个key-value时，Redis先对key使用crc16算法算出一个结果，然后把结果对 16384 求余数，这样每个key都会对应一个编号在 0-16383 之间的哈希槽，Redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"redis基础知识\"><a href=\"#redis基础知识\" class=\"headerlink\" title=\"redis基础知识\"></a>redis基础知识</h2><p>客户端与服务端的通讯协议是建立在TCP协议之上构建的；</p>\n<p>redis序列化协议 resp</p>\n<ul>\n<li>状态回复（status reply）的第一个字节是 <code>&quot;+&quot;</code></li>\n<li>错误回复（error reply）的第一个字节是 <code>&quot;-&quot;</code></li>\n<li>整数回复（integer reply）的第一个字节是 <code>&quot;:&quot;</code></li>\n<li>批量回复（bulk reply）的第一个字节是 <code>&quot;$&quot;</code></li>\n<li>多条批量回复（multi bulk reply）的第一个字节是 <code>&quot;*&quot;</code></li>\n</ul>","more":"<p>举例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET mykey myvalue</span><br><span class=\"line\">*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\mykey\\r\\n$7\\r\\myvalue\\r\\n</span><br></pre></td></tr></table></figure>\n<p>指令表：</p>\n<p><a href=\"http://redisdoc.com/\">redis命令表</a></p>\n<ul>\n<li>字符串<ul>\n<li><a href=\"http://redisdoc.com/string/set.html\">SET</a></li>\n<li><a href=\"http://redisdoc.com/string/setnx.html\">SETNX</a></li>\n<li><a href=\"http://redisdoc.com/string/setex.html\">SETEX</a></li>\n<li><a href=\"http://redisdoc.com/string/psetex.html\">PSETEX</a></li>\n<li><a href=\"http://redisdoc.com/string/get.html\">GET</a></li>\n<li><a href=\"http://redisdoc.com/string/getset.html\">GETSET</a></li>\n<li><a href=\"http://redisdoc.com/string/strlen.html\">STRLEN</a></li>\n<li><a href=\"http://redisdoc.com/string/append.html\">APPEND</a></li>\n<li><a href=\"http://redisdoc.com/string/setrange.html\">SETRANGE</a></li>\n<li><a href=\"http://redisdoc.com/string/getrange.html\">GETRANGE</a></li>\n<li><a href=\"http://redisdoc.com/string/incr.html\">INCR</a></li>\n<li><a href=\"http://redisdoc.com/string/incrby.html\">INCRBY</a></li>\n<li><a href=\"http://redisdoc.com/string/incrbyfloat.html\">INCRBYFLOAT</a></li>\n<li><a href=\"http://redisdoc.com/string/decr.html\">DECR</a></li>\n<li><a href=\"http://redisdoc.com/string/decrby.html\">DECRBY</a></li>\n<li><a href=\"http://redisdoc.com/string/mset.html\">MSET</a></li>\n<li><a href=\"http://redisdoc.com/string/msetnx.html\">MSETNX</a></li>\n<li><a href=\"http://redisdoc.com/string/mget.html\">MGET</a></li>\n</ul>\n</li>\n<li>哈希表<ul>\n<li><a href=\"http://redisdoc.com/hash/hset.html\">HSET</a></li>\n<li><a href=\"http://redisdoc.com/hash/hsetnx.html\">HSETNX</a></li>\n<li><a href=\"http://redisdoc.com/hash/hget.html\">HGET</a></li>\n<li><a href=\"http://redisdoc.com/hash/hexists.html\">HEXISTS</a></li>\n<li><a href=\"http://redisdoc.com/hash/hdel.html\">HDEL</a></li>\n<li><a href=\"http://redisdoc.com/hash/hlen.html\">HLEN</a></li>\n<li><a href=\"http://redisdoc.com/hash/hstrlen.html\">HSTRLEN</a></li>\n<li><a href=\"http://redisdoc.com/hash/hincrby.html\">HINCRBY</a></li>\n<li><a href=\"http://redisdoc.com/hash/hincrbyfloat.html\">HINCRBYFLOAT</a></li>\n<li><a href=\"http://redisdoc.com/hash/hmset.html\">HMSET</a></li>\n<li><a href=\"http://redisdoc.com/hash/hmget.html\">HMGET</a></li>\n<li><a href=\"http://redisdoc.com/hash/hkeys.html\">HKEYS</a></li>\n<li><a href=\"http://redisdoc.com/hash/hvals.html\">HVALS</a></li>\n<li><a href=\"http://redisdoc.com/hash/hgetall.html\">HGETALL</a></li>\n<li><a href=\"http://redisdoc.com/hash/hscan.html\">HSCAN</a></li>\n</ul>\n</li>\n<li>列表<ul>\n<li><a href=\"http://redisdoc.com/list/lpush.html\">LPUSH</a></li>\n<li><a href=\"http://redisdoc.com/list/lpushx.html\">LPUSHX</a></li>\n<li><a href=\"http://redisdoc.com/list/rpush.html\">RPUSH</a></li>\n<li><a href=\"http://redisdoc.com/list/rpushx.html\">RPUSHX</a></li>\n<li><a href=\"http://redisdoc.com/list/lpop.html\">LPOP</a></li>\n<li><a href=\"http://redisdoc.com/list/rpop.html\">RPOP</a></li>\n<li><a href=\"http://redisdoc.com/list/rpoplpush.html\">RPOPLPUSH</a></li>\n<li><a href=\"http://redisdoc.com/list/lrem.html\">LREM</a></li>\n<li><a href=\"http://redisdoc.com/list/llen.html\">LLEN</a></li>\n<li><a href=\"http://redisdoc.com/list/lindex.html\">LINDEX</a></li>\n<li><a href=\"http://redisdoc.com/list/linsert.html\">LINSERT</a></li>\n<li><a href=\"http://redisdoc.com/list/lset.html\">LSET</a></li>\n<li><a href=\"http://redisdoc.com/list/lrange.html\">LRANGE</a></li>\n<li><a href=\"http://redisdoc.com/list/ltrim.html\">LTRIM</a></li>\n<li><a href=\"http://redisdoc.com/list/blpop.html\">BLPOP</a></li>\n<li><a href=\"http://redisdoc.com/list/brpop.html\">BRPOP</a></li>\n<li><a href=\"http://redisdoc.com/list/brpoplpush.html\">BRPOPLPUSH</a></li>\n</ul>\n</li>\n<li>集合<ul>\n<li><a href=\"http://redisdoc.com/set/sadd.html\">SADD</a></li>\n<li><a href=\"http://redisdoc.com/set/sismember.html\">SISMEMBER</a></li>\n<li><a href=\"http://redisdoc.com/set/spop.html\">SPOP</a></li>\n<li><a href=\"http://redisdoc.com/set/srandmember.html\">SRANDMEMBER</a></li>\n<li><a href=\"http://redisdoc.com/set/srem.html\">SREM</a></li>\n<li><a href=\"http://redisdoc.com/set/smove.html\">SMOVE</a></li>\n<li><a href=\"http://redisdoc.com/set/scard.html\">SCARD</a></li>\n<li><a href=\"http://redisdoc.com/set/smembers.html\">SMEMBERS</a></li>\n<li><a href=\"http://redisdoc.com/set/sscan.html\">SSCAN</a></li>\n<li><a href=\"http://redisdoc.com/set/sinter.html\">SINTER</a></li>\n<li><a href=\"http://redisdoc.com/set/sinterstore.html\">SINTERSTORE</a></li>\n<li><a href=\"http://redisdoc.com/set/sunion.html\">SUNION</a></li>\n<li><a href=\"http://redisdoc.com/set/sunionstore.html\">SUNIONSTORE</a></li>\n<li><a href=\"http://redisdoc.com/set/sdiff.html\">SDIFF</a></li>\n<li><a href=\"http://redisdoc.com/set/sdiffstore.html\">SDIFFSTORE</a></li>\n</ul>\n</li>\n<li>有序集合<ul>\n<li><a href=\"http://redisdoc.com/sorted_set/zadd.html\">ZADD</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zscore.html\">ZSCORE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zincrby.html\">ZINCRBY</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zcard.html\">ZCARD</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zcount.html\">ZCOUNT</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrange.html\">ZRANGE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrevrange.html\">ZREVRANGE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrangebyscore.html\">ZRANGEBYSCORE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrevrangebyscore.html\">ZREVRANGEBYSCORE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrank.html\">ZRANK</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrevrank.html\">ZREVRANK</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrem.html\">ZREM</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zremrangebyrank.html\">ZREMRANGEBYRANK</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zremrangebyscore.html\">ZREMRANGEBYSCORE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zrangebylex.html\">ZRANGEBYLEX</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zlexcount.html\">ZLEXCOUNT</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zremrangebylex.html\">ZREMRANGEBYLEX</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zscan.html\">ZSCAN</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zunionstore.html\">ZUNIONSTORE</a></li>\n<li><a href=\"http://redisdoc.com/sorted_set/zinterstore.html\">ZINTERSTORE</a></li>\n</ul>\n</li>\n<li>HyperLogLog<ul>\n<li><a href=\"http://redisdoc.com/hyperloglog/pfadd.html\">PFADD</a></li>\n<li><a href=\"http://redisdoc.com/hyperloglog/pfcount.html\">PFCOUNT</a></li>\n<li><a href=\"http://redisdoc.com/hyperloglog/pfmerge.html\">PFMERGE</a></li>\n</ul>\n</li>\n<li>地理位置<ul>\n<li><a href=\"http://redisdoc.com/geo/geoadd.html\">GEOADD</a></li>\n<li><a href=\"http://redisdoc.com/geo/geopos.html\">GEOPOS</a></li>\n<li><a href=\"http://redisdoc.com/geo/geodist.html\">GEODIST</a></li>\n<li><a href=\"http://redisdoc.com/geo/georadius.html\">GEORADIUS</a></li>\n<li><a href=\"http://redisdoc.com/geo/georadiusbymember.html\">GEORADIUSBYMEMBER</a></li>\n<li><a href=\"http://redisdoc.com/geo/geohash.html\">GEOHASH</a></li>\n</ul>\n</li>\n<li>位图<ul>\n<li><a href=\"http://redisdoc.com/bitmap/setbit.html\">SETBIT</a></li>\n<li><a href=\"http://redisdoc.com/bitmap/getbit.html\">GETBIT</a></li>\n<li><a href=\"http://redisdoc.com/bitmap/bitcount.html\">BITCOUNT</a></li>\n<li><a href=\"http://redisdoc.com/bitmap/bitpos.html\">BITPOS</a></li>\n<li><a href=\"http://redisdoc.com/bitmap/bitop.html\">BITOP</a></li>\n<li><a href=\"http://redisdoc.com/bitmap/bitfield.html\">BITFIELD</a></li>\n</ul>\n</li>\n<li>数据库<ul>\n<li><a href=\"http://redisdoc.com/database/exists.html\">EXISTS</a></li>\n<li><a href=\"http://redisdoc.com/database/type.html\">TYPE</a></li>\n<li><a href=\"http://redisdoc.com/database/rename.html\">RENAME</a></li>\n<li><a href=\"http://redisdoc.com/database/renamenx.html\">RENAMENX</a></li>\n<li><a href=\"http://redisdoc.com/database/move.html\">MOVE</a></li>\n<li><a href=\"http://redisdoc.com/database/del.html\">DEL</a></li>\n<li><a href=\"http://redisdoc.com/database/randomkey.html\">RANDOMKEY</a></li>\n<li><a href=\"http://redisdoc.com/database/dbsize.html\">DBSIZE</a></li>\n<li><a href=\"http://redisdoc.com/database/keys.html\">KEYS</a></li>\n<li><a href=\"http://redisdoc.com/database/scan.html\">SCAN</a></li>\n<li><a href=\"http://redisdoc.com/database/sort.html\">SORT</a></li>\n<li><a href=\"http://redisdoc.com/database/flushdb.html\">FLUSHDB</a></li>\n<li><a href=\"http://redisdoc.com/database/flushall.html\">FLUSHALL</a></li>\n<li><a href=\"http://redisdoc.com/database/select.html\">SELECT</a></li>\n<li><a href=\"http://redisdoc.com/database/swapdb.html\">SWAPDB</a></li>\n</ul>\n</li>\n<li>自动过期<ul>\n<li><a href=\"http://redisdoc.com/expire/expire.html\">EXPIRE</a></li>\n<li><a href=\"http://redisdoc.com/expire/expireat.html\">EXPIREAT</a></li>\n<li><a href=\"http://redisdoc.com/expire/ttl.html\">TTL</a></li>\n<li><a href=\"http://redisdoc.com/expire/persist.html\">PERSIST</a></li>\n<li><a href=\"http://redisdoc.com/expire/pexpire.html\">PEXPIRE</a></li>\n<li><a href=\"http://redisdoc.com/expire/pexpireat.html\">PEXPIREAT</a></li>\n<li><a href=\"http://redisdoc.com/expire/pttl.html\">PTTL</a></li>\n</ul>\n</li>\n<li>事务<ul>\n<li><a href=\"http://redisdoc.com/transaction/multi.html\">MULTI</a></li>\n<li><a href=\"http://redisdoc.com/transaction/exec.html\">EXEC</a></li>\n<li><a href=\"http://redisdoc.com/transaction/discard.html\">DISCARD</a></li>\n<li><a href=\"http://redisdoc.com/transaction/watch.html\">WATCH</a></li>\n<li><a href=\"http://redisdoc.com/transaction/unwatch.html\">UNWATCH</a></li>\n</ul>\n</li>\n<li>Lua 脚本<ul>\n<li><a href=\"http://redisdoc.com/script/eval.html\">EVAL</a></li>\n<li><a href=\"http://redisdoc.com/script/evalsha.html\">EVALSHA</a></li>\n<li><a href=\"http://redisdoc.com/script/script_load.html\">SCRIPT_LOAD</a></li>\n<li><a href=\"http://redisdoc.com/script/script_exists.html\">SCRIPT_EXISTS</a></li>\n<li><a href=\"http://redisdoc.com/script/script_flush.html\">SCRIPT_FLUSH</a></li>\n<li><a href=\"http://redisdoc.com/script/script_kill.html\">SCRIPT_KILL</a></li>\n</ul>\n</li>\n<li>持久化<ul>\n<li><a href=\"http://redisdoc.com/persistence/save.html\">SAVE</a></li>\n<li><a href=\"http://redisdoc.com/persistence/bgsave.html\">BGSAVE</a></li>\n<li><a href=\"http://redisdoc.com/persistence/bgrewriteaof.html\">BGREWRITEAOF</a></li>\n<li><a href=\"http://redisdoc.com/persistence/lastsave.html\">LASTSAVE</a></li>\n</ul>\n</li>\n<li>发布与订阅<ul>\n<li><a href=\"http://redisdoc.com/pubsub/publish.html\">PUBLISH</a></li>\n<li><a href=\"http://redisdoc.com/pubsub/subscribe.html\">SUBSCRIBE</a></li>\n<li><a href=\"http://redisdoc.com/pubsub/psubscribe.html\">PSUBSCRIBE</a></li>\n<li><a href=\"http://redisdoc.com/pubsub/unsubscribe.html\">UNSUBSCRIBE</a></li>\n<li><a href=\"http://redisdoc.com/pubsub/punsubscribe.html\">PUNSUBSCRIBE</a></li>\n<li><a href=\"http://redisdoc.com/pubsub/pubsub.html\">PUBSUB</a></li>\n</ul>\n</li>\n<li>复制<ul>\n<li><a href=\"http://redisdoc.com/replication/slaveof.html\">SLAVEOF</a></li>\n<li><a href=\"http://redisdoc.com/replication/role.html\">ROLE</a></li>\n</ul>\n</li>\n<li>客户端与服务器<ul>\n<li><a href=\"http://redisdoc.com/client_and_server/auth.html\">AUTH</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/quit.html\">QUIT</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/info.html\">INFO</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/shutdown.html\">SHUTDOWN</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/time.html\">TIME</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/client_getname.html\">CLIENT_GETNAME</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/client_kill.html\">CLIENT_KILL</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/client_list.html\">CLIENT_LIST</a></li>\n<li><a href=\"http://redisdoc.com/client_and_server/client_setname.html\">CLIENT_SETNAME</a></li>\n</ul>\n</li>\n<li>配置选项<ul>\n<li><a href=\"http://redisdoc.com/configure/config_set.html\">CONFIG_SET</a></li>\n<li><a href=\"http://redisdoc.com/configure/config_get.html\">CONFIG_GET</a></li>\n<li><a href=\"http://redisdoc.com/configure/config_resetstat.html\">CONFIG_RESETSTAT</a></li>\n<li><a href=\"http://redisdoc.com/configure/config_rewrite.html\">CONFIG_REWRITE</a></li>\n</ul>\n</li>\n<li>调试<ul>\n<li><a href=\"http://redisdoc.com/debug/ping.html\">PING</a></li>\n<li><a href=\"http://redisdoc.com/debug/echo.html\">ECHO</a></li>\n<li><a href=\"http://redisdoc.com/debug/object.html\">OBJECT</a></li>\n<li><a href=\"http://redisdoc.com/debug/slowlog.html\">SLOWLOG</a></li>\n<li><a href=\"http://redisdoc.com/debug/monitor.html\">MONITOR</a></li>\n<li><a href=\"http://redisdoc.com/debug/debug_object.html\">DEBUG_OBJECT</a></li>\n<li><a href=\"http://redisdoc.com/debug/debug_segfault.html\">DEBUG_SEGFAULT</a></li>\n</ul>\n</li>\n<li>内部命令<ul>\n<li><a href=\"http://redisdoc.com/internal/migrate.html\">MIGRATE</a></li>\n<li><a href=\"http://redisdoc.com/internal/dump.html\">DUMP</a></li>\n<li><a href=\"http://redisdoc.com/internal/restore.html\">RESTORE</a></li>\n<li><a href=\"http://redisdoc.com/internal/sync.html\">SYNC</a></li>\n<li><a href=\"http://redisdoc.com/internal/psync.html\">PSYNC</a></li>\n</ul>\n</li>\n<li>功能文档<ul>\n<li><a href=\"http://redisdoc.com/topic/cluster-spec.html\">Redis 集群规范</a></li>\n<li><a href=\"http://redisdoc.com/topic/persistence.html\">持久化（persistence）</a></li>\n<li><a href=\"http://redisdoc.com/topic/pubsub.html\">发布与订阅（pub/sub）</a></li>\n<li><a href=\"http://redisdoc.com/topic/sentinel.html\">Sentinel</a></li>\n<li><a href=\"http://redisdoc.com/topic/cluster-tutorial.html\">集群教程</a></li>\n<li><a href=\"http://redisdoc.com/topic/notification.html\">键空间通知（keyspace notification）</a></li>\n<li><a href=\"http://redisdoc.com/topic/protocol.html\">通信协议（protocol）</a></li>\n<li><a href=\"http://redisdoc.com/topic/replication.html\">复制（Replication）</a></li>\n<li><a href=\"http://redisdoc.com/topic/transaction.html\">事务（transaction）</a></li>\n</ul>\n</li>\n</ul>\n<p>redis key集中过期问题，集中过期导致redis压力过大而卡顿</p>\n<p>采用一定范围内的随机过期时间</p>\n<p>Redis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型实际会严重影响整体吞吐量，CPU计算过程中，整个IO调度都是被阻塞住的。</p>\n<p><strong>redis分布式锁参考 本博客<a href=\"https://muggle.javaboy.org/2019/04/23/thread-3/\">多线程进阶篇</a></strong></p>\n<h2 id=\"springboot-分布式session\"><a href=\"#springboot-分布式session\" class=\"headerlink\" title=\"springboot 分布式session\"></a>springboot 分布式session</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span>  </span><br><span class=\"line\"><span class=\"meta\">@EnableRedisHttpSession</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisSessionConfig</span> </span>&#123;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.session<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-session-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.redis.host</span>=<span class=\"string\">localhost  </span></span><br><span class=\"line\"><span class=\"meta\">spring.redis.port</span>=<span class=\"string\">6379  </span></span><br></pre></td></tr></table></figure>\n<p><strong>注意：springboot2.1有包冲突，本配置只适用于2.1以下</strong></p>\n<h2 id=\"mybatis的二级缓存\"><a href=\"#mybatis的二级缓存\" class=\"headerlink\" title=\"mybatis的二级缓存\"></a>mybatis的二级缓存</h2><p>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p>\n<p>UserMapper有一个二级缓存区域（按namespace分），其它mapper也有自己的二级缓存区域（按namespace分）。每一个namespace的mapper都有一个二级缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。sql节点可配置userCache flushcache</p>\n<p>打开二级缓存总开关（springboot默认开启），在mapper中使用<code>&lt;cache/&gt;</code>打开二级缓存 在分布式系统中不能直接使用二级缓存</p>\n<p><code>&lt;cache /&gt;</code>的属性：</p>\n<ul>\n<li>eviction：代表的是缓存收回策略，有一下策略：<ol>\n<li>LRU，  最近最少使用的，移除最长时间不用的对象。</li>\n<li>FIFO，先进先出，按对象进入缓存的顺序来移除他们</li>\n<li>SOFT， 软引用，移除基于垃圾回收器状态和软引用规则的对象。</li>\n<li>WEAK，若引用，更积极的移除基于垃圾收集器状态和若引用规则的对象</li>\n</ol>\n</li>\n<li>flushInterval：刷新间隔时间，单位为毫秒，默认是当sql执行的时候才回去刷新。</li>\n<li>size：引用数目，一个正整数，代表缓存最多可以存储多少对象，不宜设置过大，过大会造成内存溢出。</li>\n<li>readOnly：只读，意味着缓存数据只能读取，不能修改，这样设置的好处是我们可以快速读取缓存，去诶但是我们没有办法修改缓存。默认值为false，不允许我们修改。</li>\n</ul>\n<h2 id=\"分布式缓存\"><a href=\"#分布式缓存\" class=\"headerlink\" title=\"分布式缓存\"></a>分布式缓存</h2><p>分布式缓存策略</p>\n<p>mybatis整合ehcache实现分布式缓存、jetcache、spring cache</p>\n<p>jetcache整合笔记：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alicp.jetcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jetcache-starter-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.4.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableMethodCache(basePackages = &quot;com.muggle.jetcahetest&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCreateCacheAnnotation</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JetcaheTestApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(JetcaheTestApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Cached(cacheType = CacheType.REMOTE)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">test</span> <span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">test</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">666</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多文档参考[jetCache github 地址][]</p>\n<p>分布式缓存的应用</p>\n<p>合并批量更新，提高io</p>\n<p>缓存的粒度问题，缓存数据是全量还是部分</p>\n<h3 id=\"cache-cloud-使用\"><a href=\"#cache-cloud-使用\" class=\"headerlink\" title=\"cache cloud 使用\"></a>cache cloud 使用</h3><h3 id=\"分布式缓存原理分析\"><a href=\"#分布式缓存原理分析\" class=\"headerlink\" title=\"分布式缓存原理分析\"></a>分布式缓存原理分析</h3><ul>\n<li>传统分布式算法：HASH算法或者取模算法</li>\n<li>Consistent hashing一致性算法原理</li>\n<li>Hash倾斜性</li>\n<li>虚拟节点</li>\n<li>Consistent hashing命中率</li>\n</ul>\n<p>Consistent hashing 是一致性hash算法</p>\n<p>博客：<a href=\"https://blog.csdn.net/qq_35956041/article/details/81026972\">一致性哈希</a></p>\n<p>哈希倾斜：缓存任务分配不均，采用虚拟节点避免</p>\n<p>缓存穿透：缓存未起作用</p>\n<p>缓存雪崩：缓存雪崩可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。</p>\n<p>缓存的算法</p>\n<p>FIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。<br>LFU算法：Least Frequently Used，最不经常使用算法。<br>LRU算法：Least Recently Used，近期最少使用算法。</p>\n<p>LRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的</p>\n<h2 id=\"redis运维（抄录自-https-mp-weixin-qq-com-s-TvIxovAi6XfR7RGigtHRtQ）\"><a href=\"#redis运维（抄录自-https-mp-weixin-qq-com-s-TvIxovAi6XfR7RGigtHRtQ）\" class=\"headerlink\" title=\"redis运维（抄录自 https://mp.weixin.qq.com/s/TvIxovAi6XfR7RGigtHRtQ）\"></a>redis运维（抄录自 <a href=\"https://mp.weixin.qq.com/s/TvIxovAi6XfR7RGigtHRtQ）\">https://mp.weixin.qq.com/s/TvIxovAi6XfR7RGigtHRtQ）</a></h2><h3 id=\"快照持久化\"><a href=\"#快照持久化\" class=\"headerlink\" title=\"快照持久化\"></a>快照持久化</h3><p>redis中的快照持久化默认是开启的，redis.conf中相关配置主要有如下几项：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">save</span> <span class=\"string\">900 1</span></span><br><span class=\"line\"><span class=\"attr\">save</span> <span class=\"string\">300 10</span></span><br><span class=\"line\"><span class=\"attr\">save</span> <span class=\"string\">60 10000</span></span><br><span class=\"line\"><span class=\"meta\">stop-writes-on-bgsave-error</span> <span class=\"string\">yes</span></span><br><span class=\"line\"><span class=\"attr\">rdbcompression</span> <span class=\"string\">yes</span></span><br><span class=\"line\"><span class=\"attr\">dbfilename</span> <span class=\"string\">dump.rdb</span></span><br><span class=\"line\"><span class=\"attr\">dir</span> <span class=\"string\">./</span></span><br></pre></td></tr></table></figure>\n<p>前面三个save相关的选项表示备份的频率，分别表示<code>900秒内至少一个键被更改则进行快照，300秒内至少10个键被更改则进行快照，60秒内至少10000个键被更改则进行快照，</code>stop-writes-on-bgsave-error表示在快照创建出错后，是否继续执行写命令，rdbcompression则表示是否对快照文件进行压缩，dbfilename表示生成的快照文件的名字，dir则表示生成的快照文件的位置，在redis中，快照持久化默认就是开启的。</p>\n<p>1.在redis运行过程中，我们可以向redis发送一条save命令来创建一个快照，save是一个阻塞命令，redis在接收到save命令之后，开始执行备份操作之后，在备份操作执行完毕之前，将不再处理其他请求，其他请求将被挂起，因此这个命令我们用的不多。save命令执行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; SAVE</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>2.在redis运行过程中，我们也可以发送一条bgsave命令来创建一个快照，不同于save命令，bgsave命令会fork一个子进程，然后这个子进程负责执行将快照写入硬盘，而父进程则继续处理客户端发来的请求，这样就不会导致客户端命令阻塞了。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; BGSAVE</span><br><span class=\"line\">Background saving started</span><br></pre></td></tr></table></figure>\n<p>3.如果我们在redis.conf中配置了如下选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save 900 1</span><br><span class=\"line\">save 300 10</span><br><span class=\"line\">save 60 10000</span><br></pre></td></tr></table></figure>\n<p>那么当条件满足时，比如900秒内有一个key被操作了，那么redis就会自动触发bgsava命令进行备份。我们可以根据实际需求在redis.conf中配置多个这种触发规则。</p>\n<p>4.还有一种情况也会触发save命令，那就是我们执行shutdown命令时，当我们用shutdown命令关闭redis时，此时也会执行一个save命令进行备份操作，并在备份操作完成后将服务器关闭。</p>\n<p>5.还有一种特殊情况也会触发bgsave命令，就是在主从备份的时候。当从机连接上主机后，会发送一条sync命令来开始一次复制操作，此时主机会开始一次bgsave操作，并在bgsave操作结束后向从机发送快照数据实现数据同步。</p>\n<h3 id=\"aof持久化\"><a href=\"#aof持久化\" class=\"headerlink\" title=\"aof持久化\"></a>aof持久化</h3><p>与快照持久化不同，AOF持久化是将被执行的命令写到aof文件末尾，在恢复时只需要从头到尾执行一遍写命令即可恢复数据，AOF在redis中默认也是没有开启的，需要我们手动开启，开启方式如下：</p>\n<p>打开redis.conf配置文件，修改appendonly属性值为yes，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendonly yes</span><br></pre></td></tr></table></figure>\n<p>另外几个和AOF相关的属性如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appendfilename &quot;appendonly.aof&quot;</span><br><span class=\"line\"># appendfsync always</span><br><span class=\"line\">appendfsync everysec</span><br><span class=\"line\"># appendfsync no</span><br><span class=\"line\">no-appendfsync-on-rewrite no</span><br><span class=\"line\">auto-aof-rewrite-percentage 100</span><br><span class=\"line\">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>\n<p>这几个属性的含义分别如下：</p>\n<p>1.appendfilename表示生成的AOF备份文件的文件名。<br>2.appendfsync表示备份的时机，always表示每执行一个命令就备份一次，everysec表示每秒备份一次，no表示将备份时机交给操作系统。<br>3.no-appendfsync-on-rewrite表示在对aof文件进行压缩时，是否执行同步操作。<br>4.最后两行配置表示AOF文件的压缩时机，这个我们一会再细说。</p>\n<p>同时为了避免快照备份的影响，我们将快照备份关闭，关闭方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save &quot;&quot;</span><br><span class=\"line\"># save 900 1</span><br><span class=\"line\"># save 300 10</span><br><span class=\"line\"># save 60 10000</span><br></pre></td></tr></table></figure>\n<p>此时，当我们在redis中进行数据操作时，就会自动生成AOF的配置文件appendonly.aof</p>\n<p>AOF备份的几个关键点</p>\n<p>1.通过上面的介绍，小伙伴们了解到appendfsync的取值一共有三种，我们在项目中首选everysec，always选项会严重降低redis性能。<br>2.使用everysec，最坏的情况下我们可能丢失1秒的数据。</p>\n<p>AOF文件的重写与压缩</p>\n<p>AOF备份有很多明显的优势，当然也有劣势，那就是文件大小。随着系统的运行，AOF的文件会越来越大，甚至把整个电脑的硬盘填满，AOF文件的重写与压缩机制可以在一定程度上缓解这个问题。<br>当AOF的备份文件过大时，我们可以向redis发送一条bgrewriteaof命令进行文件重写，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; BGREWRITEAOF</span><br><span class=\"line\">Background append only file rewriting started</span><br><span class=\"line\">(0.71s)</span><br></pre></td></tr></table></figure>\n<p>bgrewriteaof的执行原理和我们上文说的bgsave的原理一致，这里我就不再赘述，因此bgsave执行过程中存在的问题在这里也一样存在。</p>\n<p>bgrewriteaof也可以自动执行，自动执行时间则依赖于auto-aof-rewrite-percentage和auto-aof-rewrite-min-size配置，auto-aof-rewrite-percentage 100表示当目前aof文件大小超过上一次重写时的aof文件大小的百分之多少时会再次进行重写，如果之前没有重写，则以启动时的aof文件大小为依据，同时还要求AOF文件的大小至少要大于64M(auto-aof-rewrite-min-size 64mb)。</p>\n<h3 id=\"redis主从复制\"><a href=\"#redis主从复制\" class=\"headerlink\" title=\"redis主从复制\"></a>redis主从复制</h3><p>6379是主机，即master，6380和6381是从机，即slave，那么如何配置这种实例关系呢，很简单，分别在6380和6381上执行如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6379</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>这一步也可以通过在两个从机的redis.conf中添加如下配置来解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>\n<p>主从复制注意点</p>\n<p>1.如果主机已经运行了一段时间了，并且了已经存储了一些数据了，此时从机连上来，那么从机会将主机上所有的数据进行备份，而不是从连接的那个时间点开始备份。<br>2.配置了主从复制之后，主机上可读可写，但是从机只能读取不能写入（可以通过修改redis.conf中 slave-read-only 的值让从机也可以执行写操作）。<br>3.在整个主从结构运行过程中，如果主机不幸挂掉，重启之后，他依然是主机，主从复制操作也能够继续进行。</p>\n<p>复制原理</p>\n<p>每一个master都有一个replication ID，这是一个较大的伪随机字符串，标记了一个给定的数据集。每个master也持有一个偏移量，master将自己产生的复制流发送给slave时，发送多少个字节的数据，自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集时，它可以以此更新slave的状态。复制偏移量即使在没有一个slave连接到master时，也会自增，所以基本上每一对给定的Replication ID, offset都会标识一个master数据集的确切版本。当slave连接到master时，它们使用PSYNC命令来发送它们记录的旧的master replication ID和它们至今为止处理的偏移量。通过这种方式，master能够仅发送slave所需的增量部分。但是如果master的缓冲区中没有足够的命令积压缓冲记录，或者如果slave引用了不再知道的历史记录（replication ID），则会转而进行一个全量重同步：在这种情况下，slave会得到一个完整的数据集副本，从头开始(参考redis官网)。</p>\n<p>简单来说，就是以下几个步骤：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.slave启动成功连接到master后会发送一个sync命令。  </span><br><span class=\"line\">2.Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令。  </span><br><span class=\"line\">3.在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步。  </span><br><span class=\"line\">4.全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。  </span><br><span class=\"line\">5.增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。  </span><br><span class=\"line\">6.但是只要是重新连接master,一次完全同步（全量复制)将被自动执行。  </span><br></pre></td></tr></table></figure>\n<p>我们搭建的主从复制模式是下面这样的：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnKsYW7dwk0aaRIrKcESa9ibiaq4WfV2TDDvyGMsfjVVZ3K8oKEYT6m7YfJQekNiayQ4PfknStVl21QQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\">  </p>\n<p>实际上，一主二仆的主从复制，我们可以搭建成下面这种结构：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnKsYW7dwk0aaRIrKcESa9ibbMvoJzK9ycEft3gcMssde1knu6OlGzgBWlRFRNyZYFuIc3pBUIce7g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\">  </p>\n<p>哨兵模式，其实并不复杂，我们还是在我们前面的基础上来搭建哨兵模式。假设现在我的master是6379，两个从机分别是6380和6381，两个从机都是从6379上复制数据。先按照上文的步骤，我们配置好一主二仆，然后在redis目录下打开sentinel.conf文件，做如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>\n<p>其中mymaster是给要监控的主机取的名字，随意取，后面是主机地址，最后面的2表示有多少个sentinel认为主机挂掉了，就进行切换（我这里只有一个，因此设置为1）。好了，配置完成后，输入如下命令启动哨兵：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure>\n<p>6379挂掉之后，redis内部重新举行了选举，6380重新上位。此时，如果6379重启，也不再是扛把子了，只能屈身做一个slave了。</p>\n<h3 id=\"集群搭建\"><a href=\"#集群搭建\" class=\"headerlink\" title=\"集群搭建\"></a>集群搭建</h3><p>Redis集群架构如下图：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYmokRcFGBAhCcEXKrK04yXHyTcYLtNXvWCZjjS5Vl9wWsg323VBBmboGhJ6Ovfia4Pqc2oLadKcqvg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\">  </p>\n<p>Redis集群运行原理如下：</p>\n<p>1.所有的Redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽<br>2.节点的fail是通过集群中超过半数的节点检测失效时才生效<br>3.客户端与Redis节点直连,不需要中间proxy层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可<br>4.Redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster (簇)负责维护<code>node&lt;-&gt;slot&lt;-&gt;value</code>。Redis集群中内置了16384个哈希槽，当需要在Redis集群中放置一个key-value时，Redis先对key使用crc16算法算出一个结果，然后把结果对 16384 求余数，这样每个key都会对应一个编号在 0-16383 之间的哈希槽，Redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</p>"},{"title":"springSecurity深度解析第二版","date":"2019-04-20T04:44:15.000Z","_content":"作者：muggle\n# 前言\n\n由于第一版排版实在太过糟糕，而且很多细节没交代清楚，所以决定写第二版；这一版争取将排版设计得清晰明了一点，以方便读者阅读。\n\n# security原理分析\n\n## springSecurity过滤器链\n\nspringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明\n\n> 1. WebAsyncManagerIntegrationFilter：将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。\n>\n> 2. SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除\n>    例如在Session中维护一个用户的安全信息就是这个过滤器处理的。\n>\n> 3. HeaderWriterFilter：用于将头信息加入响应中\n> 4. CsrfFilter：用于处理跨站请求伪造\n> 5. LogoutFilter：用于处理退出登录\n> 6. UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。\n> 7. DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。\n> 8. BasicAuthenticationFilter：检测和处理http basic认证\n> 9. RequestCacheAwareFilter：用来处理请求的缓存\n> 10. SecurityContextHolderAwareRequestFilter：主要是包装请求对象request\n> 11. AnonymousAuthenticationFilter：检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication\n> 12. SessionManagementFilter：管理session的过滤器\n> 13. ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常\n> 14. FilterSecurityInterceptor：可以看做过滤器链的出口\n> 15. RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。\n\n## springSecurity 流程图\n\n上一版是通过debug的方法告诉读者springSecurity的一个执行过程，发现反而把问题搞复杂了，这一版我决定画一个流程图来说明其执行过程，只要把springSecurity的执行过程弄明白了，这个框架就会变得很简单\n\n<!--more-->\n\n![security.png](https://upload-images.jianshu.io/upload_images/13612520-e6bfb247ef6edf01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n\n## 流程说明\n\n1. 客户端发起一个请求，进入security过滤器链；\n\n2. 当到LogoutFilter的时候判断是否是登出路径，如果是登出路径则到logoutHandler，如果登出成功则到logoutSuccessHandler登出成功处理，如果登出失败则由ExceptionTranslationFilter；如果不是登出路径则直接进入下一个过滤器；\n\n3. 当到UsernamePasswordAuthenticationFilter的时候判断是否为登陆路径，如果是，则进入该过滤器进行登陆操作，如果登陆失败则到AuthenticationFailureHandler登陆失败处理器处理，如果登陆成功则到AuthenticationSuccessHandler登陆成功处理器处理 ；如果不是登陆请求则不进入该过滤器\n\n4. 当到FilterSecurityInterceptor的时候会拿到urI，根据uri去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到controller层否则到AccessDeniedHandler鉴权失败处理器处理\n\n   \n\n# security配置\n\n在`WebSecurityConfigurerAdapter`这个类里面可以完成上述流程图的所有配置\n\n\n\n## 配置类伪代码\n\n```java\n **/\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailService).passwordEncoder(new BCryptPasswordEncoder());\n    }\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n\n        web.ignoring().antMatchers(\"/resources/**/*.html\", \"/resources/**/*.js\");\n    }\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\")\n               .anyRequest().authenticated().accessDecisionManager(accessDecisionManager())\n               .and().logout().logoutSuccessHandler(new MyLogoutSuccessHandler())\n               .and().csrf().disable();\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n        http.exceptionHandling().accessDeniedHandler(new MyAccessDeniedHandler());\n        http.addFilterAfter(new MyFittler(), LogoutFilter.class);\n    }\n}\n\n```\n\n## 配置类说明\n\n###  configure(AuthenticationManagerBuilder auth) 说明\n\nAuthenticationManager的建造器，配置AuthenticationManagerBuilder 会让security自动构建一个AuthenticationManager（该类的功能参考流程图）；如果想要使用该功能你需要配置一个UserDetailService和passwordEncoder。userDetailsService用于在认证器中根据用户传过来的用户名查找一个用户，passwordEncoder用于密码的加密与比对，我们存储用户密码的时候用passwordEncoder.encode()加密存储，在认证器里会调用passwordEncoder.matches()方法进行密码比对。\n\n如果重写了该方法，security会启用DaoAuthenticationProvider这个认证器，该认证就是先调用UserDetailsService.loadUserByUsername然后使用passwordEncoder.matches()进行密码比对，如果认证成功成功则返回一个Authentication对象\n\n### configure(WebSecurity web)说明\n\n这个配置方法用于配置静态资源的处理方式，可使用ant匹配规则\n\n### configure(HttpSecurity http) 说明\n\n这个配置方法是最关键的方法，也是最复杂的方法。我们慢慢掰开来说\n\n```java\nhttp.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n```\n\n这是配置登陆相关的操作从方法名可知，配置了登录页请求路径，密码属性名，用户名属性名，和登陆请求路径，permitAll()代表任意用户可访问\n\n```java\nhttp.authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().accessDecisionManager(accessDecisionManager());\n```\n\n以上配置是权限相关的配置，配置了一个“/test” url该有什么权限才能访问，anyRequest()表示所有请求，authenticated()表示已登录用户，accessDecisionManager（）表示绑定在url上的鉴权管理器\n\n为了对比，现在贴出另一个权限配置清单\n\n```\nhttp.authorizeRequests().antMatchers(\"/tets_a/**\",\"/test_b/**\").hasRole(\"test\").antMatchers(\"/a/**\",\"/b/**\").authenticated().accessDecisionManager(accessDecisionManager())\n```\n\n我们可以看到权限配置的自由度很高，鉴权管理器可以绑定到任意url上；而且可以硬编码各种url权限;\n\n```java\nhttp.logout().logoutUrl(\"/logout\").logoutSuccessHandler(new MyLogoutSuccessHandler())\n```\n\n登出相关配置，这里配置了登出url和登出成功处理器\n\n```java\nhttp.exceptionHandling().accessDeniedHandler(new MyAccessDeniedHandler());\n```\n\n上面代码是配置鉴权失败的处理器\n\n```java\nhttp.addFilterAfter(new MyFittler(), LogoutFilter.class);\nhttp.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n```\n\n上面代码展示如何在过滤器链中插入自己的过滤器，addFilterBefore加在对应的过滤器之前addFilterAfter之后，addFilterAt加在过滤器同一位置，事实上框架原有的Filter在启动HttpSecurity配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用addFilterAt方法插入的Filter，会在这个位置上的原有Filter之前执行。\n\n注：关于HttpSecurity使用的是链式编程，其中http.xxxx.and.yyyyy这种写法和http.xxxx;http.yyyy写法意义一样。\n\n### 自定义authenticationManager和accessDecisionManager\n\n重写authenticationManagerBean()方法，并构造一个authenticationManager\n\n```java\n@Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        ProviderManager authenticationManager = new ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));\n        return authenticationManager;\n    }\n```\n\n我这里给authenticationManager配置了两个认证器，执行过程参考流程图\n\n定义构造AccessDecisionManager的方法并在配置类中调用，配置参考 configure(HttpSecurity http) 说明\n\n```java\npublic AccessDecisionManager accessDecisionManager(){\n        List<AccessDecisionVoter<? extends Object>> decisionVoters\n                = Arrays.asList(\n                new MyExpressionVoter(),\n                new WebExpressionVoter(),\n                new RoleVoter(),\n                new AuthenticatedVoter());\n        return new UnanimousBased(decisionVoters);\n\n    }\n```\n\n投票管理器会收集投票器投票结果做统计，最终结果大于等于0代表通过；每个投票器会返回三个结果：-1（反对），0（通过），1（赞成）。\n\n# security 权限用户系统说明\n\n## UserDetails\n\nsecurity中的用户接口，我们自定义用户类要实现该接口，各个属性的含义自行百度\n\n## GrantedAuthority\n\nsecurity中的用户权限接口，自定义权限需要实现该接口\n\n```java\n@Data\npublic class MyGrantedAuthority implements GrantedAuthority {\n    private String authority;\n}\n```\n\nauthority权限字段，需要注意的是在config中配置的权限会被加上ROLE_前缀，比如我们的配置authorizeRequests().antMatchers(\"/test\").hasRole(\"test\")，配置了一个“test”权限但我们存储的权限字段（authority）应该是“ROLE_test”\n\n## UserDetailsService\n\nsecurity用户service，自定义用户服务类需要实现该接口\n\n```java\n@Service\npublic class MyUserDetailService implements UserDetailsService {\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n      return.....\n    }\n}\n```\n\nloadUserByUsername的作用在上文中已经说明；\n\n## SecurityContextHolder\n\n用户在完成登陆后security会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成SecurityContext ，而实际存储的类是SecurityContextHolderStrategy ，默认的SecurityContextHolderStrategy 实现类是ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。\n\n手动填充SecurityContextHolder示例：\n\n```java\nUsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(\"test\",\"test\",list);\nSecurityContextHolder.getContext().setAuthentication(token);\n```\n\n对于token鉴权的系统\n\n我们就可以验证token后手动填充SecurityContextHolder，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空SecurityContextHolder。\n\n# security扩展说明\n\n可扩展的有\n\n- 鉴权失败处理器：security鉴权失败默认跳转登陆页面，我们可以\n- 验证器\n- 登陆成功处理器\n- 投票器\n- 自定义token处理过滤器\n- 登出成功处理器\n- 登陆失败处理器\n- 自定义UsernamePasswordAuthenticationFilter\n\n## 鉴权失败处理器\n\nsecurity鉴权失败默认跳转登陆页面，我们可以实现AccessDeniedHandler接口，重写handle()方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中\n\n## 验证器\n\n实现AuthenticationProvider接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点\n\n## 登陆成功处理器\n\n在security中验证成功默认跳转到上一次请求页面或者路径为\"/\"的页面，我们同样可以自定义：继承SimpleUrlAuthenticationSuccessHandler这个类或者实现AuthenticationSuccessHandler接口。我这里建议采用继承的方式；SimpleUrlAuthenticationSuccessHandler是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。\n\n## 投票器\n\n投票器可继承WebExpressionVoter或者实现AccessDecisionVoter<FilterInvocation>接口；WebExpressionVoter是security默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考 配置类说明章节；\n\n注意：投票器vote方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。\n\n## 自定义token处理过滤器\n\n自定义token处理器继承自可OncePerRequestFilter或者GenericFilterBean或者Filter都可以，在这个处理器里面需要完成的逻辑是：获取请求里的token，验证token是否合法然后填充SecurityContextHolder，虽然说过滤器只要添加在投票器之前就可以；但我这里还是建议添加在http.addFilterAfter(new MyFittler(), LogoutFilter.class);\n\n## 登出成功处理器\n\n实现LogoutSuccessHandler接口，添加到配置的方式参考 配置类说明章节\n\n## 登陆失败处理器\n\n登陆失败默认跳转到登陆页，我们同样可以自定义。继承SimpleUrlAuthenticationFailureHandler 或者实现AuthenticationFailureHandler；建议采用继承。\n\n## 自定义UsernamePasswordAuthenticationFilter\n\n我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们security的灵活性（比如添加验证验证码是否正确的功能），所以我这里是建议自定义UsernamePasswordAuthenticationFilter；\n\n我们直接继承UsernamePasswordAuthenticationFilter，然后在配置类中初始化这个过滤器，给这个过滤器添加登陆失败处理器，登陆成功处理器，登陆管理器，登陆请求url\n\n这里配置略微复杂，贴一下代码清单\n\n初始化过滤器：\n\n```java\nMyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());\n        return myUsernamePasswordAuthenticationFilte;\n    }\n```\n\n添加到配置：\n\n```java\nhttp.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n```\n\n# 代码清单\n\n下面贴出适配于 前后端分离和token验证的伪代码清单\n\n## 登陆页请求处理\n\n```java\n@Controller\npublic class LoginController {\n    /** \n    * @Description: 登陆页面的请求 \n    * @Param:  \n    * @return:  \n    */ \n    @GetMapping(\"/login_page\")\n    public String loginPage(){\n        return \"loginPage.html\";\n    }\n}\n```\n\n## 鉴权失败处理器\n\n```java\npublic class MyAccessDeniedHandler implements AccessDeniedHandler {\n    @Override\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        PrintWriter writer = response.getWriter();\n        writer.write(\"{\\\"code\\\":\\\"403\\\",\\\"msg\\\":\\\"没有权限\\\"}\");\n        writer.close();\n    }\n}\n```\n\n## 验证器\n\n```java\npublic class MyAuthenticationProvider  implements AuthenticationProvider {\n    private UserDetailsService userDetailsService;\n    private BCryptPasswordEncoder bCryptPasswordEncoder;\n\n    public MyAuthenticationProvider(UserDetailsService userDetailsService, BCryptPasswordEncoder bCryptPasswordEncoder) {\n        this.userDetailsService = userDetailsService;\n        this.bCryptPasswordEncoder = bCryptPasswordEncoder;\n    }\n\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n//       这里写验证逻辑\n        return null;\n    }\n\n    @Override\n    public boolean supports(Class<?> aClass) {\n        return true;\n    }\n}\n```\n\n## 验证成功处理器\n\n```java\nublic class MyAuthenticationSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        //随便写点啥\n    }\n}\n```\n\n## 投票器\n\n```java\n/**\n * @program: security-test\n * @description: 鉴权投票器\n * @author: muggle\n * @create: 2019-04-11\n **/\n\npublic class MyExpressionVoter extends WebExpressionVoter {\n    @Override\n    public int vote(Authentication authentication, FilterInvocation fi, Collection<ConfigAttribute> attributes) {\n//        这里写鉴权逻辑\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\");\n        return 1 ;\n    }\n}\n```\n\n## 自定义token处理过滤器\n\n```java\n/**\n * @program: security-about\n * @description:填充一个token\n * @author: muggle\n * @create: 2019-04-20\n **/\n\npublic class MyFittler extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        String token1 = request.getHeader(\"token\");\n        if (token1==null){\n\n        }\n\n        ArrayList<GrantedAuthority> list = new ArrayList<>();\n        GrantedAuthority grantedAuthority = new GrantedAuthority() {\n            @Override\n            public String getAuthority() {\n                return \"test\";\n            }\n        };\n        list.add(grantedAuthority);\n        UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(\"test\",\"test\",list);\n        SecurityContextHolder.getContext().setAuthentication(token);\n        filterChain.doFilter(request, response);\n    }\n}\n```\n\n## 登出成功处理器\n\n```java\npublic class MyLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        final PrintWriter writer = response.getWriter();\n\n        writer.write(\"{\\\"code\\\":\\\"200\\\",\\\"msg\\\":\\\"登出成功\\\"}\");\n        writer.close();\n    }\n}\n```\n\n## 登陆失败处理器\n\n```java\npublic class MyUrlAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        final PrintWriter writer = response.getWriter();\n        if(exception.getMessage().equals(\"坏的凭证\")){\n            writer.write(\"{\\\"code\\\":\\\"401\\\",\\\"msg\\\":\\\"登录失败,用户名或者密码有误\\\"}\");\n            writer.close();\n        }else {\n            writer.write(\"{\\\"code\\\":\\\"401\\\",\\\"msg\\\":\\\"登录失败,\"+exception.getMessage()+\"\\\"}\");\n            writer.close();\n        }\n\n    }\n}\n```\n\n## 自定义UsernamePasswordAuthenticationFilter\n\n```java\n/**\n * @program: security-test\n * @description: 用户登陆逻辑过滤器\n * @author: muggle\n * @create: 2019-04-11\n **/\n\npublic class MyUsernamePasswordAuthenticationFilte extends UsernamePasswordAuthenticationFilter {\n    private RedisService redisService;\n    private boolean postOnly = true;\n\n    public MyUsernamePasswordAuthenticationFilte(RedisService redisService){\n        this.redisService=redisService;\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n     \n        //你可以在这里做验证码校验，校验不通过抛出AuthenticationException()即可\n            super.attemptAuthentication(request,response);\n    }\n}\n```\n\n## 配置\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Autowired\n    RedisService redisService;\n    @Autowired\n    MyUserDetailService userDetailService;\n  \n    @Override\n    public void configure(WebSecurity web) throws Exception {\n\n        web.ignoring().antMatchers(\"/resources/**/*.html\", \"/resources/**/*.js\",\n                \"/resources/**/*.css\", \"/resources/**/*.txt\",\n                \"/resources/**/*.png\", \"/**/*.bmp\", \"/**/*.gif\", \"/**/*.png\", \"/**/*.jpg\", \"/**/*.ico\");\n//        super.configure(web);\n    }\n\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n//        配置登录页等 permitAll表示任何权限都能访问\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\")\n//               任何请求都被accessDecisionManager() 的鉴权器管理\n               .anyRequest().authenticated().accessDecisionManager(accessDecisionManager())\n//               登出配置\n               .and().logout().logoutUrl(\"/logout\").logoutSuccessHandler(new MyLogoutSuccessHandler())\n//               关闭csrf\n               .and().csrf().disable();\n       http.authorizeRequests().antMatchers(\"/tets_a/**\",\"/test_b/**\").hasRole(\"test\").antMatchers(\"/a/**\",\"/b/**\").authenticated().accessDecisionManager(accessDecisionManager())\n//      加自定义过滤器\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n//        配置鉴权失败的处理器\n        http.exceptionHandling().accessDeniedHandler(new MyAccessDeniedHandler());\n        http.addFilterAfter(new MyFittler(), LogoutFilter.class);\n\n    }\n\n\n    MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());\n        return myUsernamePasswordAuthenticationFilte;\n    }\n    MyAuthenticationProvider getMyAuthenticationProvider(){\n        MyAuthenticationProvider myAuthenticationProvider = new MyAuthenticationProvider(userDetailService,new BCryptPasswordEncoder());\n        return myAuthenticationProvider;\n    }\n    DaoAuthenticationProvider daoAuthenticationProvider(){\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(new BCryptPasswordEncoder());\n        daoAuthenticationProvider.setUserDetailsService(userDetailService);\n        return daoAuthenticationProvider;\n    }\n    protected AuthenticationManager getAuthenticationManager()  {\n        ProviderManager authenticationManager = new ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));\n        return authenticationManager;\n    }\n\n    public AccessDecisionManager accessDecisionManager(){\n        List<AccessDecisionVoter<? extends Object>> decisionVoters\n                = Arrays.asList(\n                new MyExpressionVoter(),\n                new WebExpressionVoter(),\n                new RoleVoter(),\n                new AuthenticatedVoter());\n        return new UnanimousBased(decisionVoters);\n\n    }\n}\n```\n\n# 总结\n\n对于security的扩展配置关键在于`configure(HttpSecurity http)`方法；扩展认证方式可以自定义`authenticationManager`并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义`accessDecisionManager`然后添加自己的投票器并绑定到对应的url（url 匹配方式为ant）上，投票器`vote(Authentication authentication, FilterInvocation fi, Collection<ConfigAttribute> attributes)`方法返回值为三种：-1 0 1，分别表示反对弃权赞成；\n\n对于token认证的校验方式，可以暴露一个获取的接口，或者重写`UsernamePasswordAuthenticationFilter`过滤器和扩展登陆成功处理器来获取token，然后在`LogoutFilter`之后添加一个自定义过滤器，用于校验和填充SecurityContextHolder\n\nsecurity的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回json,那么就需要重写各个处理器了。\n\n##  勘误\n\n2018/6/23: 在和别人讲解security的时候发现漏了一个处理器，401用户未登陆处理器，其默认是跳转到登陆页；现贴出其写法和配置方法，使其返回\n\n\n\n```java\n/**\n * @program: poseidon\n * @description: 未登录处理\n * @author: muggle\n * @create: 2018-12-31\n **/\npublic class PoseidonLoginUrlAuthenticationEntryPoint extends LoginUrlAuthenticationEntryPoint {\n    public PoseidonLoginUrlAuthenticationEntryPoint(String loginFormUrl) {\n        super(loginFormUrl);\n    }\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        final PrintWriter writer = response.getWriter();\n        writer.write(\"{\\\"code\\\":\\\"401\\\",\\\"msg\\\":\\\"用户未登录\\\"}\");\n        writer.close();\n    }\n}\n```\n\n在config 方法中加上\n\n```java\nhttp.exceptionHandling().authenticationEntryPoint( new PoseidonLoginUrlAuthenticationEntryPoint(\"/login\")).accessDeniedHandler(new PoseidonAccessDeniedHandler());\n```\n\n具体细节可参看我的poseidon项目和sofia脚手架。","source":"_posts/springSecurity2.md","raw":"---\ntitle: springSecurity深度解析第二版\ndate: 2019-04-20 12:44:15\ntags: security\n---\n作者：muggle\n# 前言\n\n由于第一版排版实在太过糟糕，而且很多细节没交代清楚，所以决定写第二版；这一版争取将排版设计得清晰明了一点，以方便读者阅读。\n\n# security原理分析\n\n## springSecurity过滤器链\n\nspringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明\n\n> 1. WebAsyncManagerIntegrationFilter：将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。\n>\n> 2. SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除\n>    例如在Session中维护一个用户的安全信息就是这个过滤器处理的。\n>\n> 3. HeaderWriterFilter：用于将头信息加入响应中\n> 4. CsrfFilter：用于处理跨站请求伪造\n> 5. LogoutFilter：用于处理退出登录\n> 6. UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。\n> 7. DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。\n> 8. BasicAuthenticationFilter：检测和处理http basic认证\n> 9. RequestCacheAwareFilter：用来处理请求的缓存\n> 10. SecurityContextHolderAwareRequestFilter：主要是包装请求对象request\n> 11. AnonymousAuthenticationFilter：检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication\n> 12. SessionManagementFilter：管理session的过滤器\n> 13. ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常\n> 14. FilterSecurityInterceptor：可以看做过滤器链的出口\n> 15. RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。\n\n## springSecurity 流程图\n\n上一版是通过debug的方法告诉读者springSecurity的一个执行过程，发现反而把问题搞复杂了，这一版我决定画一个流程图来说明其执行过程，只要把springSecurity的执行过程弄明白了，这个框架就会变得很简单\n\n<!--more-->\n\n![security.png](https://upload-images.jianshu.io/upload_images/13612520-e6bfb247ef6edf01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n\n## 流程说明\n\n1. 客户端发起一个请求，进入security过滤器链；\n\n2. 当到LogoutFilter的时候判断是否是登出路径，如果是登出路径则到logoutHandler，如果登出成功则到logoutSuccessHandler登出成功处理，如果登出失败则由ExceptionTranslationFilter；如果不是登出路径则直接进入下一个过滤器；\n\n3. 当到UsernamePasswordAuthenticationFilter的时候判断是否为登陆路径，如果是，则进入该过滤器进行登陆操作，如果登陆失败则到AuthenticationFailureHandler登陆失败处理器处理，如果登陆成功则到AuthenticationSuccessHandler登陆成功处理器处理 ；如果不是登陆请求则不进入该过滤器\n\n4. 当到FilterSecurityInterceptor的时候会拿到urI，根据uri去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到controller层否则到AccessDeniedHandler鉴权失败处理器处理\n\n   \n\n# security配置\n\n在`WebSecurityConfigurerAdapter`这个类里面可以完成上述流程图的所有配置\n\n\n\n## 配置类伪代码\n\n```java\n **/\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailService).passwordEncoder(new BCryptPasswordEncoder());\n    }\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n\n        web.ignoring().antMatchers(\"/resources/**/*.html\", \"/resources/**/*.js\");\n    }\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\")\n               .anyRequest().authenticated().accessDecisionManager(accessDecisionManager())\n               .and().logout().logoutSuccessHandler(new MyLogoutSuccessHandler())\n               .and().csrf().disable();\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n        http.exceptionHandling().accessDeniedHandler(new MyAccessDeniedHandler());\n        http.addFilterAfter(new MyFittler(), LogoutFilter.class);\n    }\n}\n\n```\n\n## 配置类说明\n\n###  configure(AuthenticationManagerBuilder auth) 说明\n\nAuthenticationManager的建造器，配置AuthenticationManagerBuilder 会让security自动构建一个AuthenticationManager（该类的功能参考流程图）；如果想要使用该功能你需要配置一个UserDetailService和passwordEncoder。userDetailsService用于在认证器中根据用户传过来的用户名查找一个用户，passwordEncoder用于密码的加密与比对，我们存储用户密码的时候用passwordEncoder.encode()加密存储，在认证器里会调用passwordEncoder.matches()方法进行密码比对。\n\n如果重写了该方法，security会启用DaoAuthenticationProvider这个认证器，该认证就是先调用UserDetailsService.loadUserByUsername然后使用passwordEncoder.matches()进行密码比对，如果认证成功成功则返回一个Authentication对象\n\n### configure(WebSecurity web)说明\n\n这个配置方法用于配置静态资源的处理方式，可使用ant匹配规则\n\n### configure(HttpSecurity http) 说明\n\n这个配置方法是最关键的方法，也是最复杂的方法。我们慢慢掰开来说\n\n```java\nhttp.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n```\n\n这是配置登陆相关的操作从方法名可知，配置了登录页请求路径，密码属性名，用户名属性名，和登陆请求路径，permitAll()代表任意用户可访问\n\n```java\nhttp.authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().accessDecisionManager(accessDecisionManager());\n```\n\n以上配置是权限相关的配置，配置了一个“/test” url该有什么权限才能访问，anyRequest()表示所有请求，authenticated()表示已登录用户，accessDecisionManager（）表示绑定在url上的鉴权管理器\n\n为了对比，现在贴出另一个权限配置清单\n\n```\nhttp.authorizeRequests().antMatchers(\"/tets_a/**\",\"/test_b/**\").hasRole(\"test\").antMatchers(\"/a/**\",\"/b/**\").authenticated().accessDecisionManager(accessDecisionManager())\n```\n\n我们可以看到权限配置的自由度很高，鉴权管理器可以绑定到任意url上；而且可以硬编码各种url权限;\n\n```java\nhttp.logout().logoutUrl(\"/logout\").logoutSuccessHandler(new MyLogoutSuccessHandler())\n```\n\n登出相关配置，这里配置了登出url和登出成功处理器\n\n```java\nhttp.exceptionHandling().accessDeniedHandler(new MyAccessDeniedHandler());\n```\n\n上面代码是配置鉴权失败的处理器\n\n```java\nhttp.addFilterAfter(new MyFittler(), LogoutFilter.class);\nhttp.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n```\n\n上面代码展示如何在过滤器链中插入自己的过滤器，addFilterBefore加在对应的过滤器之前addFilterAfter之后，addFilterAt加在过滤器同一位置，事实上框架原有的Filter在启动HttpSecurity配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用addFilterAt方法插入的Filter，会在这个位置上的原有Filter之前执行。\n\n注：关于HttpSecurity使用的是链式编程，其中http.xxxx.and.yyyyy这种写法和http.xxxx;http.yyyy写法意义一样。\n\n### 自定义authenticationManager和accessDecisionManager\n\n重写authenticationManagerBean()方法，并构造一个authenticationManager\n\n```java\n@Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        ProviderManager authenticationManager = new ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));\n        return authenticationManager;\n    }\n```\n\n我这里给authenticationManager配置了两个认证器，执行过程参考流程图\n\n定义构造AccessDecisionManager的方法并在配置类中调用，配置参考 configure(HttpSecurity http) 说明\n\n```java\npublic AccessDecisionManager accessDecisionManager(){\n        List<AccessDecisionVoter<? extends Object>> decisionVoters\n                = Arrays.asList(\n                new MyExpressionVoter(),\n                new WebExpressionVoter(),\n                new RoleVoter(),\n                new AuthenticatedVoter());\n        return new UnanimousBased(decisionVoters);\n\n    }\n```\n\n投票管理器会收集投票器投票结果做统计，最终结果大于等于0代表通过；每个投票器会返回三个结果：-1（反对），0（通过），1（赞成）。\n\n# security 权限用户系统说明\n\n## UserDetails\n\nsecurity中的用户接口，我们自定义用户类要实现该接口，各个属性的含义自行百度\n\n## GrantedAuthority\n\nsecurity中的用户权限接口，自定义权限需要实现该接口\n\n```java\n@Data\npublic class MyGrantedAuthority implements GrantedAuthority {\n    private String authority;\n}\n```\n\nauthority权限字段，需要注意的是在config中配置的权限会被加上ROLE_前缀，比如我们的配置authorizeRequests().antMatchers(\"/test\").hasRole(\"test\")，配置了一个“test”权限但我们存储的权限字段（authority）应该是“ROLE_test”\n\n## UserDetailsService\n\nsecurity用户service，自定义用户服务类需要实现该接口\n\n```java\n@Service\npublic class MyUserDetailService implements UserDetailsService {\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n      return.....\n    }\n}\n```\n\nloadUserByUsername的作用在上文中已经说明；\n\n## SecurityContextHolder\n\n用户在完成登陆后security会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成SecurityContext ，而实际存储的类是SecurityContextHolderStrategy ，默认的SecurityContextHolderStrategy 实现类是ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。\n\n手动填充SecurityContextHolder示例：\n\n```java\nUsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(\"test\",\"test\",list);\nSecurityContextHolder.getContext().setAuthentication(token);\n```\n\n对于token鉴权的系统\n\n我们就可以验证token后手动填充SecurityContextHolder，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空SecurityContextHolder。\n\n# security扩展说明\n\n可扩展的有\n\n- 鉴权失败处理器：security鉴权失败默认跳转登陆页面，我们可以\n- 验证器\n- 登陆成功处理器\n- 投票器\n- 自定义token处理过滤器\n- 登出成功处理器\n- 登陆失败处理器\n- 自定义UsernamePasswordAuthenticationFilter\n\n## 鉴权失败处理器\n\nsecurity鉴权失败默认跳转登陆页面，我们可以实现AccessDeniedHandler接口，重写handle()方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中\n\n## 验证器\n\n实现AuthenticationProvider接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点\n\n## 登陆成功处理器\n\n在security中验证成功默认跳转到上一次请求页面或者路径为\"/\"的页面，我们同样可以自定义：继承SimpleUrlAuthenticationSuccessHandler这个类或者实现AuthenticationSuccessHandler接口。我这里建议采用继承的方式；SimpleUrlAuthenticationSuccessHandler是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。\n\n## 投票器\n\n投票器可继承WebExpressionVoter或者实现AccessDecisionVoter<FilterInvocation>接口；WebExpressionVoter是security默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考 配置类说明章节；\n\n注意：投票器vote方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。\n\n## 自定义token处理过滤器\n\n自定义token处理器继承自可OncePerRequestFilter或者GenericFilterBean或者Filter都可以，在这个处理器里面需要完成的逻辑是：获取请求里的token，验证token是否合法然后填充SecurityContextHolder，虽然说过滤器只要添加在投票器之前就可以；但我这里还是建议添加在http.addFilterAfter(new MyFittler(), LogoutFilter.class);\n\n## 登出成功处理器\n\n实现LogoutSuccessHandler接口，添加到配置的方式参考 配置类说明章节\n\n## 登陆失败处理器\n\n登陆失败默认跳转到登陆页，我们同样可以自定义。继承SimpleUrlAuthenticationFailureHandler 或者实现AuthenticationFailureHandler；建议采用继承。\n\n## 自定义UsernamePasswordAuthenticationFilter\n\n我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们security的灵活性（比如添加验证验证码是否正确的功能），所以我这里是建议自定义UsernamePasswordAuthenticationFilter；\n\n我们直接继承UsernamePasswordAuthenticationFilter，然后在配置类中初始化这个过滤器，给这个过滤器添加登陆失败处理器，登陆成功处理器，登陆管理器，登陆请求url\n\n这里配置略微复杂，贴一下代码清单\n\n初始化过滤器：\n\n```java\nMyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());\n        return myUsernamePasswordAuthenticationFilte;\n    }\n```\n\n添加到配置：\n\n```java\nhttp.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n```\n\n# 代码清单\n\n下面贴出适配于 前后端分离和token验证的伪代码清单\n\n## 登陆页请求处理\n\n```java\n@Controller\npublic class LoginController {\n    /** \n    * @Description: 登陆页面的请求 \n    * @Param:  \n    * @return:  \n    */ \n    @GetMapping(\"/login_page\")\n    public String loginPage(){\n        return \"loginPage.html\";\n    }\n}\n```\n\n## 鉴权失败处理器\n\n```java\npublic class MyAccessDeniedHandler implements AccessDeniedHandler {\n    @Override\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        PrintWriter writer = response.getWriter();\n        writer.write(\"{\\\"code\\\":\\\"403\\\",\\\"msg\\\":\\\"没有权限\\\"}\");\n        writer.close();\n    }\n}\n```\n\n## 验证器\n\n```java\npublic class MyAuthenticationProvider  implements AuthenticationProvider {\n    private UserDetailsService userDetailsService;\n    private BCryptPasswordEncoder bCryptPasswordEncoder;\n\n    public MyAuthenticationProvider(UserDetailsService userDetailsService, BCryptPasswordEncoder bCryptPasswordEncoder) {\n        this.userDetailsService = userDetailsService;\n        this.bCryptPasswordEncoder = bCryptPasswordEncoder;\n    }\n\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n//       这里写验证逻辑\n        return null;\n    }\n\n    @Override\n    public boolean supports(Class<?> aClass) {\n        return true;\n    }\n}\n```\n\n## 验证成功处理器\n\n```java\nublic class MyAuthenticationSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        //随便写点啥\n    }\n}\n```\n\n## 投票器\n\n```java\n/**\n * @program: security-test\n * @description: 鉴权投票器\n * @author: muggle\n * @create: 2019-04-11\n **/\n\npublic class MyExpressionVoter extends WebExpressionVoter {\n    @Override\n    public int vote(Authentication authentication, FilterInvocation fi, Collection<ConfigAttribute> attributes) {\n//        这里写鉴权逻辑\n        System.out.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\");\n        return 1 ;\n    }\n}\n```\n\n## 自定义token处理过滤器\n\n```java\n/**\n * @program: security-about\n * @description:填充一个token\n * @author: muggle\n * @create: 2019-04-20\n **/\n\npublic class MyFittler extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        String token1 = request.getHeader(\"token\");\n        if (token1==null){\n\n        }\n\n        ArrayList<GrantedAuthority> list = new ArrayList<>();\n        GrantedAuthority grantedAuthority = new GrantedAuthority() {\n            @Override\n            public String getAuthority() {\n                return \"test\";\n            }\n        };\n        list.add(grantedAuthority);\n        UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(\"test\",\"test\",list);\n        SecurityContextHolder.getContext().setAuthentication(token);\n        filterChain.doFilter(request, response);\n    }\n}\n```\n\n## 登出成功处理器\n\n```java\npublic class MyLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        final PrintWriter writer = response.getWriter();\n\n        writer.write(\"{\\\"code\\\":\\\"200\\\",\\\"msg\\\":\\\"登出成功\\\"}\");\n        writer.close();\n    }\n}\n```\n\n## 登陆失败处理器\n\n```java\npublic class MyUrlAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        final PrintWriter writer = response.getWriter();\n        if(exception.getMessage().equals(\"坏的凭证\")){\n            writer.write(\"{\\\"code\\\":\\\"401\\\",\\\"msg\\\":\\\"登录失败,用户名或者密码有误\\\"}\");\n            writer.close();\n        }else {\n            writer.write(\"{\\\"code\\\":\\\"401\\\",\\\"msg\\\":\\\"登录失败,\"+exception.getMessage()+\"\\\"}\");\n            writer.close();\n        }\n\n    }\n}\n```\n\n## 自定义UsernamePasswordAuthenticationFilter\n\n```java\n/**\n * @program: security-test\n * @description: 用户登陆逻辑过滤器\n * @author: muggle\n * @create: 2019-04-11\n **/\n\npublic class MyUsernamePasswordAuthenticationFilte extends UsernamePasswordAuthenticationFilter {\n    private RedisService redisService;\n    private boolean postOnly = true;\n\n    public MyUsernamePasswordAuthenticationFilte(RedisService redisService){\n        this.redisService=redisService;\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n     \n        //你可以在这里做验证码校验，校验不通过抛出AuthenticationException()即可\n            super.attemptAuthentication(request,response);\n    }\n}\n```\n\n## 配置\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Autowired\n    RedisService redisService;\n    @Autowired\n    MyUserDetailService userDetailService;\n  \n    @Override\n    public void configure(WebSecurity web) throws Exception {\n\n        web.ignoring().antMatchers(\"/resources/**/*.html\", \"/resources/**/*.js\",\n                \"/resources/**/*.css\", \"/resources/**/*.txt\",\n                \"/resources/**/*.png\", \"/**/*.bmp\", \"/**/*.gif\", \"/**/*.png\", \"/**/*.jpg\", \"/**/*.ico\");\n//        super.configure(web);\n    }\n\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n//        配置登录页等 permitAll表示任何权限都能访问\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\")\n//               任何请求都被accessDecisionManager() 的鉴权器管理\n               .anyRequest().authenticated().accessDecisionManager(accessDecisionManager())\n//               登出配置\n               .and().logout().logoutUrl(\"/logout\").logoutSuccessHandler(new MyLogoutSuccessHandler())\n//               关闭csrf\n               .and().csrf().disable();\n       http.authorizeRequests().antMatchers(\"/tets_a/**\",\"/test_b/**\").hasRole(\"test\").antMatchers(\"/a/**\",\"/b/**\").authenticated().accessDecisionManager(accessDecisionManager())\n//      加自定义过滤器\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n//        配置鉴权失败的处理器\n        http.exceptionHandling().accessDeniedHandler(new MyAccessDeniedHandler());\n        http.addFilterAfter(new MyFittler(), LogoutFilter.class);\n\n    }\n\n\n    MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());\n        return myUsernamePasswordAuthenticationFilte;\n    }\n    MyAuthenticationProvider getMyAuthenticationProvider(){\n        MyAuthenticationProvider myAuthenticationProvider = new MyAuthenticationProvider(userDetailService,new BCryptPasswordEncoder());\n        return myAuthenticationProvider;\n    }\n    DaoAuthenticationProvider daoAuthenticationProvider(){\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(new BCryptPasswordEncoder());\n        daoAuthenticationProvider.setUserDetailsService(userDetailService);\n        return daoAuthenticationProvider;\n    }\n    protected AuthenticationManager getAuthenticationManager()  {\n        ProviderManager authenticationManager = new ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));\n        return authenticationManager;\n    }\n\n    public AccessDecisionManager accessDecisionManager(){\n        List<AccessDecisionVoter<? extends Object>> decisionVoters\n                = Arrays.asList(\n                new MyExpressionVoter(),\n                new WebExpressionVoter(),\n                new RoleVoter(),\n                new AuthenticatedVoter());\n        return new UnanimousBased(decisionVoters);\n\n    }\n}\n```\n\n# 总结\n\n对于security的扩展配置关键在于`configure(HttpSecurity http)`方法；扩展认证方式可以自定义`authenticationManager`并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义`accessDecisionManager`然后添加自己的投票器并绑定到对应的url（url 匹配方式为ant）上，投票器`vote(Authentication authentication, FilterInvocation fi, Collection<ConfigAttribute> attributes)`方法返回值为三种：-1 0 1，分别表示反对弃权赞成；\n\n对于token认证的校验方式，可以暴露一个获取的接口，或者重写`UsernamePasswordAuthenticationFilter`过滤器和扩展登陆成功处理器来获取token，然后在`LogoutFilter`之后添加一个自定义过滤器，用于校验和填充SecurityContextHolder\n\nsecurity的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回json,那么就需要重写各个处理器了。\n\n##  勘误\n\n2018/6/23: 在和别人讲解security的时候发现漏了一个处理器，401用户未登陆处理器，其默认是跳转到登陆页；现贴出其写法和配置方法，使其返回\n\n\n\n```java\n/**\n * @program: poseidon\n * @description: 未登录处理\n * @author: muggle\n * @create: 2018-12-31\n **/\npublic class PoseidonLoginUrlAuthenticationEntryPoint extends LoginUrlAuthenticationEntryPoint {\n    public PoseidonLoginUrlAuthenticationEntryPoint(String loginFormUrl) {\n        super(loginFormUrl);\n    }\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        final PrintWriter writer = response.getWriter();\n        writer.write(\"{\\\"code\\\":\\\"401\\\",\\\"msg\\\":\\\"用户未登录\\\"}\");\n        writer.close();\n    }\n}\n```\n\n在config 方法中加上\n\n```java\nhttp.exceptionHandling().authenticationEntryPoint( new PoseidonLoginUrlAuthenticationEntryPoint(\"/login\")).accessDeniedHandler(new PoseidonAccessDeniedHandler());\n```\n\n具体细节可参看我的poseidon项目和sofia脚手架。","slug":"springSecurity2","published":1,"updated":"2021-01-11T07:31:23.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh78004q00wi3xnbefg6","content":"<p>作者：muggle</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>由于第一版排版实在太过糟糕，而且很多细节没交代清楚，所以决定写第二版；这一版争取将排版设计得清晰明了一点，以方便读者阅读。</p>\n<h1 id=\"security原理分析\"><a href=\"#security原理分析\" class=\"headerlink\" title=\"security原理分析\"></a>security原理分析</h1><h2 id=\"springSecurity过滤器链\"><a href=\"#springSecurity过滤器链\" class=\"headerlink\" title=\"springSecurity过滤器链\"></a>springSecurity过滤器链</h2><p>springSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明</p>\n<blockquote>\n<ol>\n<li><p>WebAsyncManagerIntegrationFilter：将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。</p>\n</li>\n<li><p>SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除<br>例如在Session中维护一个用户的安全信息就是这个过滤器处理的。</p>\n</li>\n<li><p>HeaderWriterFilter：用于将头信息加入响应中</p>\n</li>\n<li><p>CsrfFilter：用于处理跨站请求伪造</p>\n</li>\n<li><p>LogoutFilter：用于处理退出登录</p>\n</li>\n<li><p>UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。</p>\n</li>\n<li><p>DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</p>\n</li>\n<li><p>BasicAuthenticationFilter：检测和处理http basic认证</p>\n</li>\n<li><p>RequestCacheAwareFilter：用来处理请求的缓存</p>\n</li>\n<li><p>SecurityContextHolderAwareRequestFilter：主要是包装请求对象request</p>\n</li>\n<li><p>AnonymousAuthenticationFilter：检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication</p>\n</li>\n<li><p>SessionManagementFilter：管理session的过滤器</p>\n</li>\n<li><p>ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常</p>\n</li>\n<li><p>FilterSecurityInterceptor：可以看做过滤器链的出口</p>\n</li>\n<li><p>RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"springSecurity-流程图\"><a href=\"#springSecurity-流程图\" class=\"headerlink\" title=\"springSecurity 流程图\"></a>springSecurity 流程图</h2><p>上一版是通过debug的方法告诉读者springSecurity的一个执行过程，发现反而把问题搞复杂了，这一版我决定画一个流程图来说明其执行过程，只要把springSecurity的执行过程弄明白了，这个框架就会变得很简单</p>\n<a id=\"more\"></a>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-e6bfb247ef6edf01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp\" alt=\"security.png\"></p>\n<h2 id=\"流程说明\"><a href=\"#流程说明\" class=\"headerlink\" title=\"流程说明\"></a>流程说明</h2><ol>\n<li><p>客户端发起一个请求，进入security过滤器链；</p>\n</li>\n<li><p>当到LogoutFilter的时候判断是否是登出路径，如果是登出路径则到logoutHandler，如果登出成功则到logoutSuccessHandler登出成功处理，如果登出失败则由ExceptionTranslationFilter；如果不是登出路径则直接进入下一个过滤器；</p>\n</li>\n<li><p>当到UsernamePasswordAuthenticationFilter的时候判断是否为登陆路径，如果是，则进入该过滤器进行登陆操作，如果登陆失败则到AuthenticationFailureHandler登陆失败处理器处理，如果登陆成功则到AuthenticationSuccessHandler登陆成功处理器处理 ；如果不是登陆请求则不进入该过滤器</p>\n</li>\n<li><p>当到FilterSecurityInterceptor的时候会拿到urI，根据uri去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到controller层否则到AccessDeniedHandler鉴权失败处理器处理</p>\n</li>\n</ol>\n<h1 id=\"security配置\"><a href=\"#security配置\" class=\"headerlink\" title=\"security配置\"></a>security配置</h1><p>在<code>WebSecurityConfigurerAdapter</code>这个类里面可以完成上述流程图的所有配置</p>\n<h2 id=\"配置类伪代码\"><a href=\"#配置类伪代码\" class=\"headerlink\" title=\"配置类伪代码\"></a>配置类伪代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> **/</span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthenticationManagerBuilder auth)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        auth.userDetailsService(userDetailService).passwordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        web.ignoring().antMatchers(<span class=\"string\">&quot;/resources/**/*.html&quot;</span>, <span class=\"string\">&quot;/resources/**/*.js&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">               .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>)</span><br><span class=\"line\">               .anyRequest().authenticated().accessDecisionManager(accessDecisionManager())</span><br><span class=\"line\">               .and().logout().logoutSuccessHandler(<span class=\"keyword\">new</span> MyLogoutSuccessHandler())</span><br><span class=\"line\">               .and().csrf().disable();</span><br><span class=\"line\">        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\">        http.exceptionHandling().accessDeniedHandler(<span class=\"keyword\">new</span> MyAccessDeniedHandler());</span><br><span class=\"line\">        http.addFilterAfter(<span class=\"keyword\">new</span> MyFittler(), LogoutFilter.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置类说明\"><a href=\"#配置类说明\" class=\"headerlink\" title=\"配置类说明\"></a>配置类说明</h2><h3 id=\"configure-AuthenticationManagerBuilder-auth-说明\"><a href=\"#configure-AuthenticationManagerBuilder-auth-说明\" class=\"headerlink\" title=\"configure(AuthenticationManagerBuilder auth) 说明\"></a>configure(AuthenticationManagerBuilder auth) 说明</h3><p>AuthenticationManager的建造器，配置AuthenticationManagerBuilder 会让security自动构建一个AuthenticationManager（该类的功能参考流程图）；如果想要使用该功能你需要配置一个UserDetailService和passwordEncoder。userDetailsService用于在认证器中根据用户传过来的用户名查找一个用户，passwordEncoder用于密码的加密与比对，我们存储用户密码的时候用passwordEncoder.encode()加密存储，在认证器里会调用passwordEncoder.matches()方法进行密码比对。</p>\n<p>如果重写了该方法，security会启用DaoAuthenticationProvider这个认证器，该认证就是先调用UserDetailsService.loadUserByUsername然后使用passwordEncoder.matches()进行密码比对，如果认证成功成功则返回一个Authentication对象</p>\n<h3 id=\"configure-WebSecurity-web-说明\"><a href=\"#configure-WebSecurity-web-说明\" class=\"headerlink\" title=\"configure(WebSecurity web)说明\"></a>configure(WebSecurity web)说明</h3><p>这个配置方法用于配置静态资源的处理方式，可使用ant匹配规则</p>\n<h3 id=\"configure-HttpSecurity-http-说明\"><a href=\"#configure-HttpSecurity-http-说明\" class=\"headerlink\" title=\"configure(HttpSecurity http) 说明\"></a>configure(HttpSecurity http) 说明</h3><p>这个配置方法是最关键的方法，也是最复杂的方法。我们慢慢掰开来说</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure>\n<p>这是配置登陆相关的操作从方法名可知，配置了登录页请求路径，密码属性名，用户名属性名，和登陆请求路径，permitAll()代表任意用户可访问</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().accessDecisionManager(accessDecisionManager());</span><br></pre></td></tr></table></figure>\n<p>以上配置是权限相关的配置，配置了一个“/test” url该有什么权限才能访问，anyRequest()表示所有请求，authenticated()表示已登录用户，accessDecisionManager（）表示绑定在url上的鉴权管理器</p>\n<p>为了对比，现在贴出另一个权限配置清单</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.authorizeRequests().antMatchers(&quot;&#x2F;tets_a&#x2F;**&quot;,&quot;&#x2F;test_b&#x2F;**&quot;).hasRole(&quot;test&quot;).antMatchers(&quot;&#x2F;a&#x2F;**&quot;,&quot;&#x2F;b&#x2F;**&quot;).authenticated().accessDecisionManager(accessDecisionManager())</span><br></pre></td></tr></table></figure>\n<p>我们可以看到权限配置的自由度很高，鉴权管理器可以绑定到任意url上；而且可以硬编码各种url权限;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.logout().logoutUrl(<span class=\"string\">&quot;/logout&quot;</span>).logoutSuccessHandler(<span class=\"keyword\">new</span> MyLogoutSuccessHandler())</span><br></pre></td></tr></table></figure>\n<p>登出相关配置，这里配置了登出url和登出成功处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.exceptionHandling().accessDeniedHandler(<span class=\"keyword\">new</span> MyAccessDeniedHandler());</span><br></pre></td></tr></table></figure>\n<p>上面代码是配置鉴权失败的处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.addFilterAfter(<span class=\"keyword\">new</span> MyFittler(), LogoutFilter.class);</span><br><span class=\"line\">http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>\n<p>上面代码展示如何在过滤器链中插入自己的过滤器，addFilterBefore加在对应的过滤器之前addFilterAfter之后，addFilterAt加在过滤器同一位置，事实上框架原有的Filter在启动HttpSecurity配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用addFilterAt方法插入的Filter，会在这个位置上的原有Filter之前执行。</p>\n<p>注：关于HttpSecurity使用的是链式编程，其中http.xxxx.and.yyyyy这种写法和http.xxxx;http.yyyy写法意义一样。</p>\n<h3 id=\"自定义authenticationManager和accessDecisionManager\"><a href=\"#自定义authenticationManager和accessDecisionManager\" class=\"headerlink\" title=\"自定义authenticationManager和accessDecisionManager\"></a>自定义authenticationManager和accessDecisionManager</h3><p>重写authenticationManagerBean()方法，并构造一个authenticationManager</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AuthenticationManager <span class=\"title\">authenticationManagerBean</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ProviderManager authenticationManager = <span class=\"keyword\">new</span> ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationManager;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我这里给authenticationManager配置了两个认证器，执行过程参考流程图</p>\n<p>定义构造AccessDecisionManager的方法并在配置类中调用，配置参考 configure(HttpSecurity http) 说明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AccessDecisionManager <span class=\"title\">accessDecisionManager</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters</span><br><span class=\"line\">                = Arrays.asList(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MyExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> WebExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> RoleVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> AuthenticatedVoter());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UnanimousBased(decisionVoters);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>投票管理器会收集投票器投票结果做统计，最终结果大于等于0代表通过；每个投票器会返回三个结果：-1（反对），0（通过），1（赞成）。</p>\n<h1 id=\"security-权限用户系统说明\"><a href=\"#security-权限用户系统说明\" class=\"headerlink\" title=\"security 权限用户系统说明\"></a>security 权限用户系统说明</h1><h2 id=\"UserDetails\"><a href=\"#UserDetails\" class=\"headerlink\" title=\"UserDetails\"></a>UserDetails</h2><p>security中的用户接口，我们自定义用户类要实现该接口，各个属性的含义自行百度</p>\n<h2 id=\"GrantedAuthority\"><a href=\"#GrantedAuthority\" class=\"headerlink\" title=\"GrantedAuthority\"></a>GrantedAuthority</h2><p>security中的用户权限接口，自定义权限需要实现该接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyGrantedAuthority</span> <span class=\"keyword\">implements</span> <span class=\"title\">GrantedAuthority</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String authority;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>authority权限字段，需要注意的是在config中配置的权限会被加上ROLE_前缀，比如我们的配置authorizeRequests().antMatchers(“/test”).hasRole(“test”)，配置了一个“test”权限但我们存储的权限字段（authority）应该是“ROLE_test”</p>\n<h2 id=\"UserDetailsService\"><a href=\"#UserDetailsService\" class=\"headerlink\" title=\"UserDetailsService\"></a>UserDetailsService</h2><p>security用户service，自定义用户服务类需要实现该接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUserDetailService</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDetailsService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserDetails <span class=\"title\">loadUserByUsername</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class=\"line\">      return.....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>loadUserByUsername的作用在上文中已经说明；</p>\n<h2 id=\"SecurityContextHolder\"><a href=\"#SecurityContextHolder\" class=\"headerlink\" title=\"SecurityContextHolder\"></a>SecurityContextHolder</h2><p>用户在完成登陆后security会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成SecurityContext ，而实际存储的类是SecurityContextHolderStrategy ，默认的SecurityContextHolderStrategy 实现类是ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。</p>\n<p>手动填充SecurityContextHolder示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UsernamePasswordAuthenticationToken token = <span class=\"keyword\">new</span> UsernamePasswordAuthenticationToken(<span class=\"string\">&quot;test&quot;</span>,<span class=\"string\">&quot;test&quot;</span>,list);</span><br><span class=\"line\">SecurityContextHolder.getContext().setAuthentication(token);</span><br></pre></td></tr></table></figure>\n<p>对于token鉴权的系统</p>\n<p>我们就可以验证token后手动填充SecurityContextHolder，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空SecurityContextHolder。</p>\n<h1 id=\"security扩展说明\"><a href=\"#security扩展说明\" class=\"headerlink\" title=\"security扩展说明\"></a>security扩展说明</h1><p>可扩展的有</p>\n<ul>\n<li>鉴权失败处理器：security鉴权失败默认跳转登陆页面，我们可以</li>\n<li>验证器</li>\n<li>登陆成功处理器</li>\n<li>投票器</li>\n<li>自定义token处理过滤器</li>\n<li>登出成功处理器</li>\n<li>登陆失败处理器</li>\n<li>自定义UsernamePasswordAuthenticationFilter</li>\n</ul>\n<h2 id=\"鉴权失败处理器\"><a href=\"#鉴权失败处理器\" class=\"headerlink\" title=\"鉴权失败处理器\"></a>鉴权失败处理器</h2><p>security鉴权失败默认跳转登陆页面，我们可以实现AccessDeniedHandler接口，重写handle()方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中</p>\n<h2 id=\"验证器\"><a href=\"#验证器\" class=\"headerlink\" title=\"验证器\"></a>验证器</h2><p>实现AuthenticationProvider接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点</p>\n<h2 id=\"登陆成功处理器\"><a href=\"#登陆成功处理器\" class=\"headerlink\" title=\"登陆成功处理器\"></a>登陆成功处理器</h2><p>在security中验证成功默认跳转到上一次请求页面或者路径为”/“的页面，我们同样可以自定义：继承SimpleUrlAuthenticationSuccessHandler这个类或者实现AuthenticationSuccessHandler接口。我这里建议采用继承的方式；SimpleUrlAuthenticationSuccessHandler是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。</p>\n<h2 id=\"投票器\"><a href=\"#投票器\" class=\"headerlink\" title=\"投票器\"></a>投票器</h2><p>投票器可继承WebExpressionVoter或者实现AccessDecisionVoter<FilterInvocation>接口；WebExpressionVoter是security默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考 配置类说明章节；</p>\n<p>注意：投票器vote方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。</p>\n<h2 id=\"自定义token处理过滤器\"><a href=\"#自定义token处理过滤器\" class=\"headerlink\" title=\"自定义token处理过滤器\"></a>自定义token处理过滤器</h2><p>自定义token处理器继承自可OncePerRequestFilter或者GenericFilterBean或者Filter都可以，在这个处理器里面需要完成的逻辑是：获取请求里的token，验证token是否合法然后填充SecurityContextHolder，虽然说过滤器只要添加在投票器之前就可以；但我这里还是建议添加在http.addFilterAfter(new MyFittler(), LogoutFilter.class);</p>\n<h2 id=\"登出成功处理器\"><a href=\"#登出成功处理器\" class=\"headerlink\" title=\"登出成功处理器\"></a>登出成功处理器</h2><p>实现LogoutSuccessHandler接口，添加到配置的方式参考 配置类说明章节</p>\n<h2 id=\"登陆失败处理器\"><a href=\"#登陆失败处理器\" class=\"headerlink\" title=\"登陆失败处理器\"></a>登陆失败处理器</h2><p>登陆失败默认跳转到登陆页，我们同样可以自定义。继承SimpleUrlAuthenticationFailureHandler 或者实现AuthenticationFailureHandler；建议采用继承。</p>\n<h2 id=\"自定义UsernamePasswordAuthenticationFilter\"><a href=\"#自定义UsernamePasswordAuthenticationFilter\" class=\"headerlink\" title=\"自定义UsernamePasswordAuthenticationFilter\"></a>自定义UsernamePasswordAuthenticationFilter</h2><p>我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们security的灵活性（比如添加验证验证码是否正确的功能），所以我这里是建议自定义UsernamePasswordAuthenticationFilter；</p>\n<p>我们直接继承UsernamePasswordAuthenticationFilter，然后在配置类中初始化这个过滤器，给这个过滤器添加登陆失败处理器，登陆成功处理器，登陆管理器，登陆请求url</p>\n<p>这里配置略微复杂，贴一下代码清单</p>\n<p>初始化过滤器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>添加到配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>\n<h1 id=\"代码清单\"><a href=\"#代码清单\" class=\"headerlink\" title=\"代码清单\"></a>代码清单</h1><p>下面贴出适配于 前后端分离和token验证的伪代码清单</p>\n<h2 id=\"登陆页请求处理\"><a href=\"#登陆页请求处理\" class=\"headerlink\" title=\"登陆页请求处理\"></a>登陆页请求处理</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@Description</span>: 登陆页面的请求 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@Param</span>:  </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span>:  </span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/login_page&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">loginPage</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;loginPage.html&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"鉴权失败处理器-1\"><a href=\"#鉴权失败处理器-1\" class=\"headerlink\" title=\"鉴权失败处理器\"></a>鉴权失败处理器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAccessDeniedHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessDeniedHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse response, AccessDeniedException e)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;403\\&quot;,\\&quot;msg\\&quot;:\\&quot;没有权限\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"验证器-1\"><a href=\"#验证器-1\" class=\"headerlink\" title=\"验证器\"></a>验证器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAuthenticationProvider</span>  <span class=\"keyword\">implements</span> <span class=\"title\">AuthenticationProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDetailsService userDetailsService;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyAuthenticationProvider</span><span class=\"params\">(UserDetailsService userDetailsService, BCryptPasswordEncoder bCryptPasswordEncoder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userDetailsService = userDetailsService;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bCryptPasswordEncoder = bCryptPasswordEncoder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Authentication <span class=\"title\">authenticate</span><span class=\"params\">(Authentication authentication)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//       这里写验证逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"验证成功处理器\"><a href=\"#验证成功处理器\" class=\"headerlink\" title=\"验证成功处理器\"></a>验证成功处理器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ublic <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAuthenticationSuccessHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleUrlAuthenticationSuccessHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthenticationSuccess</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//随便写点啥</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"投票器-1\"><a href=\"#投票器-1\" class=\"headerlink\" title=\"投票器\"></a>投票器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>: security-test</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 鉴权投票器</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-04-11</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExpressionVoter</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebExpressionVoter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">vote</span><span class=\"params\">(Authentication authentication, FilterInvocation fi, Collection&lt;ConfigAttribute&gt; attributes)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        这里写鉴权逻辑</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义token处理过滤器-1\"><a href=\"#自定义token处理过滤器-1\" class=\"headerlink\" title=\"自定义token处理过滤器\"></a>自定义token处理过滤器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>: security-about</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>:填充一个token</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-04-20</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFittler</span> <span class=\"keyword\">extends</span> <span class=\"title\">OncePerRequestFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilterInternal</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        String token1 = request.getHeader(<span class=\"string\">&quot;token&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token1==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;GrantedAuthority&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        GrantedAuthority grantedAuthority = <span class=\"keyword\">new</span> GrantedAuthority() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAuthority</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;test&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        list.add(grantedAuthority);</span><br><span class=\"line\">        UsernamePasswordAuthenticationToken token = <span class=\"keyword\">new</span> UsernamePasswordAuthenticationToken(<span class=\"string\">&quot;test&quot;</span>,<span class=\"string\">&quot;test&quot;</span>,list);</span><br><span class=\"line\">        SecurityContextHolder.getContext().setAuthentication(token);</span><br><span class=\"line\">        filterChain.doFilter(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"登出成功处理器-1\"><a href=\"#登出成功处理器-1\" class=\"headerlink\" title=\"登出成功处理器\"></a>登出成功处理器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLogoutSuccessHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">LogoutSuccessHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLogoutSuccess</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse response, Authentication authentication)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\"></span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;200\\&quot;,\\&quot;msg\\&quot;:\\&quot;登出成功\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"登陆失败处理器-1\"><a href=\"#登陆失败处理器-1\" class=\"headerlink\" title=\"登陆失败处理器\"></a>登陆失败处理器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUrlAuthenticationFailureHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleUrlAuthenticationFailureHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthenticationFailure</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(exception.getMessage().equals(<span class=\"string\">&quot;坏的凭证&quot;</span>))&#123;</span><br><span class=\"line\">            writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;401\\&quot;,\\&quot;msg\\&quot;:\\&quot;登录失败,用户名或者密码有误\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">            writer.close();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;401\\&quot;,\\&quot;msg\\&quot;:\\&quot;登录失败,&quot;</span>+exception.getMessage()+<span class=\"string\">&quot;\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">            writer.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义UsernamePasswordAuthenticationFilter-1\"><a href=\"#自定义UsernamePasswordAuthenticationFilter-1\" class=\"headerlink\" title=\"自定义UsernamePasswordAuthenticationFilter\"></a>自定义UsernamePasswordAuthenticationFilter</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>: security-test</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 用户登陆逻辑过滤器</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-04-11</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUsernamePasswordAuthenticationFilte</span> <span class=\"keyword\">extends</span> <span class=\"title\">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisService redisService;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> postOnly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyUsernamePasswordAuthenticationFilte</span><span class=\"params\">(RedisService redisService)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.redisService=redisService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Authentication <span class=\"title\">attemptAuthentication</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">        <span class=\"comment\">//你可以在这里做验证码校验，校验不通过抛出AuthenticationException()即可</span></span><br><span class=\"line\">            <span class=\"keyword\">super</span>.attemptAuthentication(request,response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisService redisService;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    MyUserDetailService userDetailService;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        web.ignoring().antMatchers(<span class=\"string\">&quot;/resources/**/*.html&quot;</span>, <span class=\"string\">&quot;/resources/**/*.js&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.css&quot;</span>, <span class=\"string\">&quot;/resources/**/*.txt&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.bmp&quot;</span>, <span class=\"string\">&quot;/**/*.gif&quot;</span>, <span class=\"string\">&quot;/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.jpg&quot;</span>, <span class=\"string\">&quot;/**/*.ico&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        super.configure(web);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        配置登录页等 permitAll表示任何权限都能访问</span></span><br><span class=\"line\">       http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">               .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//               任何请求都被accessDecisionManager() 的鉴权器管理</span></span><br><span class=\"line\">               .anyRequest().authenticated().accessDecisionManager(accessDecisionManager())</span><br><span class=\"line\"><span class=\"comment\">//               登出配置</span></span><br><span class=\"line\">               .and().logout().logoutUrl(<span class=\"string\">&quot;/logout&quot;</span>).logoutSuccessHandler(<span class=\"keyword\">new</span> MyLogoutSuccessHandler())</span><br><span class=\"line\"><span class=\"comment\">//               关闭csrf</span></span><br><span class=\"line\">               .and().csrf().disable();</span><br><span class=\"line\">       http.authorizeRequests().antMatchers(<span class=\"string\">&quot;/tets_a/**&quot;</span>,<span class=\"string\">&quot;/test_b/**&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).antMatchers(<span class=\"string\">&quot;/a/**&quot;</span>,<span class=\"string\">&quot;/b/**&quot;</span>).authenticated().accessDecisionManager(accessDecisionManager())</span><br><span class=\"line\"><span class=\"comment\">//      加自定义过滤器</span></span><br><span class=\"line\">        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\"><span class=\"comment\">//        配置鉴权失败的处理器</span></span><br><span class=\"line\">        http.exceptionHandling().accessDeniedHandler(<span class=\"keyword\">new</span> MyAccessDeniedHandler());</span><br><span class=\"line\">        http.addFilterAfter(<span class=\"keyword\">new</span> MyFittler(), LogoutFilter.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">MyAuthenticationProvider <span class=\"title\">getMyAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MyAuthenticationProvider myAuthenticationProvider = <span class=\"keyword\">new</span> MyAuthenticationProvider(userDetailService,<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myAuthenticationProvider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">DaoAuthenticationProvider <span class=\"title\">daoAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        DaoAuthenticationProvider daoAuthenticationProvider = <span class=\"keyword\">new</span> DaoAuthenticationProvider();</span><br><span class=\"line\">        daoAuthenticationProvider.setPasswordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">        daoAuthenticationProvider.setUserDetailsService(userDetailService);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> daoAuthenticationProvider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationManager <span class=\"title\">getAuthenticationManager</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">        ProviderManager authenticationManager = <span class=\"keyword\">new</span> ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AccessDecisionManager <span class=\"title\">accessDecisionManager</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters</span><br><span class=\"line\">                = Arrays.asList(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MyExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> WebExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> RoleVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> AuthenticatedVoter());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UnanimousBased(decisionVoters);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>对于security的扩展配置关键在于<code>configure(HttpSecurity http)</code>方法；扩展认证方式可以自定义<code>authenticationManager</code>并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义<code>accessDecisionManager</code>然后添加自己的投票器并绑定到对应的url（url 匹配方式为ant）上，投票器<code>vote(Authentication authentication, FilterInvocation fi, Collection&lt;ConfigAttribute&gt; attributes)</code>方法返回值为三种：-1 0 1，分别表示反对弃权赞成；</p>\n<p>对于token认证的校验方式，可以暴露一个获取的接口，或者重写<code>UsernamePasswordAuthenticationFilter</code>过滤器和扩展登陆成功处理器来获取token，然后在<code>LogoutFilter</code>之后添加一个自定义过滤器，用于校验和填充SecurityContextHolder</p>\n<p>security的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回json,那么就需要重写各个处理器了。</p>\n<h2 id=\"勘误\"><a href=\"#勘误\" class=\"headerlink\" title=\"勘误\"></a>勘误</h2><p>2018/6/23: 在和别人讲解security的时候发现漏了一个处理器，401用户未登陆处理器，其默认是跳转到登陆页；现贴出其写法和配置方法，使其返回</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>: poseidon</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 未登录处理</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2018-12-31</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoseidonLoginUrlAuthenticationEntryPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">LoginUrlAuthenticationEntryPoint</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PoseidonLoginUrlAuthenticationEntryPoint</span><span class=\"params\">(String loginFormUrl)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(loginFormUrl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commence</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;401\\&quot;,\\&quot;msg\\&quot;:\\&quot;用户未登录\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在config 方法中加上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.exceptionHandling().authenticationEntryPoint( <span class=\"keyword\">new</span> PoseidonLoginUrlAuthenticationEntryPoint(<span class=\"string\">&quot;/login&quot;</span>)).accessDeniedHandler(<span class=\"keyword\">new</span> PoseidonAccessDeniedHandler());</span><br></pre></td></tr></table></figure>\n<p>具体细节可参看我的poseidon项目和sofia脚手架。</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>由于第一版排版实在太过糟糕，而且很多细节没交代清楚，所以决定写第二版；这一版争取将排版设计得清晰明了一点，以方便读者阅读。</p>\n<h1 id=\"security原理分析\"><a href=\"#security原理分析\" class=\"headerlink\" title=\"security原理分析\"></a>security原理分析</h1><h2 id=\"springSecurity过滤器链\"><a href=\"#springSecurity过滤器链\" class=\"headerlink\" title=\"springSecurity过滤器链\"></a>springSecurity过滤器链</h2><p>springSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的各个进行说明</p>\n<blockquote>\n<ol>\n<li><p>WebAsyncManagerIntegrationFilter：将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。</p>\n</li>\n<li><p>SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除<br>例如在Session中维护一个用户的安全信息就是这个过滤器处理的。</p>\n</li>\n<li><p>HeaderWriterFilter：用于将头信息加入响应中</p>\n</li>\n<li><p>CsrfFilter：用于处理跨站请求伪造</p>\n</li>\n<li><p>LogoutFilter：用于处理退出登录</p>\n</li>\n<li><p>UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。</p>\n</li>\n<li><p>DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</p>\n</li>\n<li><p>BasicAuthenticationFilter：检测和处理http basic认证</p>\n</li>\n<li><p>RequestCacheAwareFilter：用来处理请求的缓存</p>\n</li>\n<li><p>SecurityContextHolderAwareRequestFilter：主要是包装请求对象request</p>\n</li>\n<li><p>AnonymousAuthenticationFilter：检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication</p>\n</li>\n<li><p>SessionManagementFilter：管理session的过滤器</p>\n</li>\n<li><p>ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常</p>\n</li>\n<li><p>FilterSecurityInterceptor：可以看做过滤器链的出口</p>\n</li>\n<li><p>RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"springSecurity-流程图\"><a href=\"#springSecurity-流程图\" class=\"headerlink\" title=\"springSecurity 流程图\"></a>springSecurity 流程图</h2><p>上一版是通过debug的方法告诉读者springSecurity的一个执行过程，发现反而把问题搞复杂了，这一版我决定画一个流程图来说明其执行过程，只要把springSecurity的执行过程弄明白了，这个框架就会变得很简单</p>","more":"<p><img src=\"https://upload-images.jianshu.io/upload_images/13612520-e6bfb247ef6edf01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp\" alt=\"security.png\"></p>\n<h2 id=\"流程说明\"><a href=\"#流程说明\" class=\"headerlink\" title=\"流程说明\"></a>流程说明</h2><ol>\n<li><p>客户端发起一个请求，进入security过滤器链；</p>\n</li>\n<li><p>当到LogoutFilter的时候判断是否是登出路径，如果是登出路径则到logoutHandler，如果登出成功则到logoutSuccessHandler登出成功处理，如果登出失败则由ExceptionTranslationFilter；如果不是登出路径则直接进入下一个过滤器；</p>\n</li>\n<li><p>当到UsernamePasswordAuthenticationFilter的时候判断是否为登陆路径，如果是，则进入该过滤器进行登陆操作，如果登陆失败则到AuthenticationFailureHandler登陆失败处理器处理，如果登陆成功则到AuthenticationSuccessHandler登陆成功处理器处理 ；如果不是登陆请求则不进入该过滤器</p>\n</li>\n<li><p>当到FilterSecurityInterceptor的时候会拿到urI，根据uri去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到controller层否则到AccessDeniedHandler鉴权失败处理器处理</p>\n</li>\n</ol>\n<h1 id=\"security配置\"><a href=\"#security配置\" class=\"headerlink\" title=\"security配置\"></a>security配置</h1><p>在<code>WebSecurityConfigurerAdapter</code>这个类里面可以完成上述流程图的所有配置</p>\n<h2 id=\"配置类伪代码\"><a href=\"#配置类伪代码\" class=\"headerlink\" title=\"配置类伪代码\"></a>配置类伪代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> **/</span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthenticationManagerBuilder auth)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        auth.userDetailsService(userDetailService).passwordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        web.ignoring().antMatchers(<span class=\"string\">&quot;/resources/**/*.html&quot;</span>, <span class=\"string\">&quot;/resources/**/*.js&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">               .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>)</span><br><span class=\"line\">               .anyRequest().authenticated().accessDecisionManager(accessDecisionManager())</span><br><span class=\"line\">               .and().logout().logoutSuccessHandler(<span class=\"keyword\">new</span> MyLogoutSuccessHandler())</span><br><span class=\"line\">               .and().csrf().disable();</span><br><span class=\"line\">        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\">        http.exceptionHandling().accessDeniedHandler(<span class=\"keyword\">new</span> MyAccessDeniedHandler());</span><br><span class=\"line\">        http.addFilterAfter(<span class=\"keyword\">new</span> MyFittler(), LogoutFilter.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置类说明\"><a href=\"#配置类说明\" class=\"headerlink\" title=\"配置类说明\"></a>配置类说明</h2><h3 id=\"configure-AuthenticationManagerBuilder-auth-说明\"><a href=\"#configure-AuthenticationManagerBuilder-auth-说明\" class=\"headerlink\" title=\"configure(AuthenticationManagerBuilder auth) 说明\"></a>configure(AuthenticationManagerBuilder auth) 说明</h3><p>AuthenticationManager的建造器，配置AuthenticationManagerBuilder 会让security自动构建一个AuthenticationManager（该类的功能参考流程图）；如果想要使用该功能你需要配置一个UserDetailService和passwordEncoder。userDetailsService用于在认证器中根据用户传过来的用户名查找一个用户，passwordEncoder用于密码的加密与比对，我们存储用户密码的时候用passwordEncoder.encode()加密存储，在认证器里会调用passwordEncoder.matches()方法进行密码比对。</p>\n<p>如果重写了该方法，security会启用DaoAuthenticationProvider这个认证器，该认证就是先调用UserDetailsService.loadUserByUsername然后使用passwordEncoder.matches()进行密码比对，如果认证成功成功则返回一个Authentication对象</p>\n<h3 id=\"configure-WebSecurity-web-说明\"><a href=\"#configure-WebSecurity-web-说明\" class=\"headerlink\" title=\"configure(WebSecurity web)说明\"></a>configure(WebSecurity web)说明</h3><p>这个配置方法用于配置静态资源的处理方式，可使用ant匹配规则</p>\n<h3 id=\"configure-HttpSecurity-http-说明\"><a href=\"#configure-HttpSecurity-http-说明\" class=\"headerlink\" title=\"configure(HttpSecurity http) 说明\"></a>configure(HttpSecurity http) 说明</h3><p>这个配置方法是最关键的方法，也是最复杂的方法。我们慢慢掰开来说</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure>\n<p>这是配置登陆相关的操作从方法名可知，配置了登录页请求路径，密码属性名，用户名属性名，和登陆请求路径，permitAll()代表任意用户可访问</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().accessDecisionManager(accessDecisionManager());</span><br></pre></td></tr></table></figure>\n<p>以上配置是权限相关的配置，配置了一个“/test” url该有什么权限才能访问，anyRequest()表示所有请求，authenticated()表示已登录用户，accessDecisionManager（）表示绑定在url上的鉴权管理器</p>\n<p>为了对比，现在贴出另一个权限配置清单</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.authorizeRequests().antMatchers(&quot;&#x2F;tets_a&#x2F;**&quot;,&quot;&#x2F;test_b&#x2F;**&quot;).hasRole(&quot;test&quot;).antMatchers(&quot;&#x2F;a&#x2F;**&quot;,&quot;&#x2F;b&#x2F;**&quot;).authenticated().accessDecisionManager(accessDecisionManager())</span><br></pre></td></tr></table></figure>\n<p>我们可以看到权限配置的自由度很高，鉴权管理器可以绑定到任意url上；而且可以硬编码各种url权限;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.logout().logoutUrl(<span class=\"string\">&quot;/logout&quot;</span>).logoutSuccessHandler(<span class=\"keyword\">new</span> MyLogoutSuccessHandler())</span><br></pre></td></tr></table></figure>\n<p>登出相关配置，这里配置了登出url和登出成功处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.exceptionHandling().accessDeniedHandler(<span class=\"keyword\">new</span> MyAccessDeniedHandler());</span><br></pre></td></tr></table></figure>\n<p>上面代码是配置鉴权失败的处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.addFilterAfter(<span class=\"keyword\">new</span> MyFittler(), LogoutFilter.class);</span><br><span class=\"line\">http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>\n<p>上面代码展示如何在过滤器链中插入自己的过滤器，addFilterBefore加在对应的过滤器之前addFilterAfter之后，addFilterAt加在过滤器同一位置，事实上框架原有的Filter在启动HttpSecurity配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用addFilterAt方法插入的Filter，会在这个位置上的原有Filter之前执行。</p>\n<p>注：关于HttpSecurity使用的是链式编程，其中http.xxxx.and.yyyyy这种写法和http.xxxx;http.yyyy写法意义一样。</p>\n<h3 id=\"自定义authenticationManager和accessDecisionManager\"><a href=\"#自定义authenticationManager和accessDecisionManager\" class=\"headerlink\" title=\"自定义authenticationManager和accessDecisionManager\"></a>自定义authenticationManager和accessDecisionManager</h3><p>重写authenticationManagerBean()方法，并构造一个authenticationManager</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AuthenticationManager <span class=\"title\">authenticationManagerBean</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ProviderManager authenticationManager = <span class=\"keyword\">new</span> ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationManager;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我这里给authenticationManager配置了两个认证器，执行过程参考流程图</p>\n<p>定义构造AccessDecisionManager的方法并在配置类中调用，配置参考 configure(HttpSecurity http) 说明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AccessDecisionManager <span class=\"title\">accessDecisionManager</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters</span><br><span class=\"line\">                = Arrays.asList(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MyExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> WebExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> RoleVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> AuthenticatedVoter());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UnanimousBased(decisionVoters);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>投票管理器会收集投票器投票结果做统计，最终结果大于等于0代表通过；每个投票器会返回三个结果：-1（反对），0（通过），1（赞成）。</p>\n<h1 id=\"security-权限用户系统说明\"><a href=\"#security-权限用户系统说明\" class=\"headerlink\" title=\"security 权限用户系统说明\"></a>security 权限用户系统说明</h1><h2 id=\"UserDetails\"><a href=\"#UserDetails\" class=\"headerlink\" title=\"UserDetails\"></a>UserDetails</h2><p>security中的用户接口，我们自定义用户类要实现该接口，各个属性的含义自行百度</p>\n<h2 id=\"GrantedAuthority\"><a href=\"#GrantedAuthority\" class=\"headerlink\" title=\"GrantedAuthority\"></a>GrantedAuthority</h2><p>security中的用户权限接口，自定义权限需要实现该接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyGrantedAuthority</span> <span class=\"keyword\">implements</span> <span class=\"title\">GrantedAuthority</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String authority;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>authority权限字段，需要注意的是在config中配置的权限会被加上ROLE_前缀，比如我们的配置authorizeRequests().antMatchers(“/test”).hasRole(“test”)，配置了一个“test”权限但我们存储的权限字段（authority）应该是“ROLE_test”</p>\n<h2 id=\"UserDetailsService\"><a href=\"#UserDetailsService\" class=\"headerlink\" title=\"UserDetailsService\"></a>UserDetailsService</h2><p>security用户service，自定义用户服务类需要实现该接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUserDetailService</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDetailsService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserDetails <span class=\"title\">loadUserByUsername</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class=\"line\">      return.....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>loadUserByUsername的作用在上文中已经说明；</p>\n<h2 id=\"SecurityContextHolder\"><a href=\"#SecurityContextHolder\" class=\"headerlink\" title=\"SecurityContextHolder\"></a>SecurityContextHolder</h2><p>用户在完成登陆后security会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成SecurityContext ，而实际存储的类是SecurityContextHolderStrategy ，默认的SecurityContextHolderStrategy 实现类是ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。</p>\n<p>手动填充SecurityContextHolder示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UsernamePasswordAuthenticationToken token = <span class=\"keyword\">new</span> UsernamePasswordAuthenticationToken(<span class=\"string\">&quot;test&quot;</span>,<span class=\"string\">&quot;test&quot;</span>,list);</span><br><span class=\"line\">SecurityContextHolder.getContext().setAuthentication(token);</span><br></pre></td></tr></table></figure>\n<p>对于token鉴权的系统</p>\n<p>我们就可以验证token后手动填充SecurityContextHolder，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空SecurityContextHolder。</p>\n<h1 id=\"security扩展说明\"><a href=\"#security扩展说明\" class=\"headerlink\" title=\"security扩展说明\"></a>security扩展说明</h1><p>可扩展的有</p>\n<ul>\n<li>鉴权失败处理器：security鉴权失败默认跳转登陆页面，我们可以</li>\n<li>验证器</li>\n<li>登陆成功处理器</li>\n<li>投票器</li>\n<li>自定义token处理过滤器</li>\n<li>登出成功处理器</li>\n<li>登陆失败处理器</li>\n<li>自定义UsernamePasswordAuthenticationFilter</li>\n</ul>\n<h2 id=\"鉴权失败处理器\"><a href=\"#鉴权失败处理器\" class=\"headerlink\" title=\"鉴权失败处理器\"></a>鉴权失败处理器</h2><p>security鉴权失败默认跳转登陆页面，我们可以实现AccessDeniedHandler接口，重写handle()方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中</p>\n<h2 id=\"验证器\"><a href=\"#验证器\" class=\"headerlink\" title=\"验证器\"></a>验证器</h2><p>实现AuthenticationProvider接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点</p>\n<h2 id=\"登陆成功处理器\"><a href=\"#登陆成功处理器\" class=\"headerlink\" title=\"登陆成功处理器\"></a>登陆成功处理器</h2><p>在security中验证成功默认跳转到上一次请求页面或者路径为”/“的页面，我们同样可以自定义：继承SimpleUrlAuthenticationSuccessHandler这个类或者实现AuthenticationSuccessHandler接口。我这里建议采用继承的方式；SimpleUrlAuthenticationSuccessHandler是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。</p>\n<h2 id=\"投票器\"><a href=\"#投票器\" class=\"headerlink\" title=\"投票器\"></a>投票器</h2><p>投票器可继承WebExpressionVoter或者实现AccessDecisionVoter<FilterInvocation>接口；WebExpressionVoter是security默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考 配置类说明章节；</p>\n<p>注意：投票器vote方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。</p>\n<h2 id=\"自定义token处理过滤器\"><a href=\"#自定义token处理过滤器\" class=\"headerlink\" title=\"自定义token处理过滤器\"></a>自定义token处理过滤器</h2><p>自定义token处理器继承自可OncePerRequestFilter或者GenericFilterBean或者Filter都可以，在这个处理器里面需要完成的逻辑是：获取请求里的token，验证token是否合法然后填充SecurityContextHolder，虽然说过滤器只要添加在投票器之前就可以；但我这里还是建议添加在http.addFilterAfter(new MyFittler(), LogoutFilter.class);</p>\n<h2 id=\"登出成功处理器\"><a href=\"#登出成功处理器\" class=\"headerlink\" title=\"登出成功处理器\"></a>登出成功处理器</h2><p>实现LogoutSuccessHandler接口，添加到配置的方式参考 配置类说明章节</p>\n<h2 id=\"登陆失败处理器\"><a href=\"#登陆失败处理器\" class=\"headerlink\" title=\"登陆失败处理器\"></a>登陆失败处理器</h2><p>登陆失败默认跳转到登陆页，我们同样可以自定义。继承SimpleUrlAuthenticationFailureHandler 或者实现AuthenticationFailureHandler；建议采用继承。</p>\n<h2 id=\"自定义UsernamePasswordAuthenticationFilter\"><a href=\"#自定义UsernamePasswordAuthenticationFilter\" class=\"headerlink\" title=\"自定义UsernamePasswordAuthenticationFilter\"></a>自定义UsernamePasswordAuthenticationFilter</h2><p>我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们security的灵活性（比如添加验证验证码是否正确的功能），所以我这里是建议自定义UsernamePasswordAuthenticationFilter；</p>\n<p>我们直接继承UsernamePasswordAuthenticationFilter，然后在配置类中初始化这个过滤器，给这个过滤器添加登陆失败处理器，登陆成功处理器，登陆管理器，登陆请求url</p>\n<p>这里配置略微复杂，贴一下代码清单</p>\n<p>初始化过滤器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>添加到配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>\n<h1 id=\"代码清单\"><a href=\"#代码清单\" class=\"headerlink\" title=\"代码清单\"></a>代码清单</h1><p>下面贴出适配于 前后端分离和token验证的伪代码清单</p>\n<h2 id=\"登陆页请求处理\"><a href=\"#登陆页请求处理\" class=\"headerlink\" title=\"登陆页请求处理\"></a>登陆页请求处理</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@Description</span>: 登陆页面的请求 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@Param</span>:  </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span>:  </span></span><br><span class=\"line\"><span class=\"comment\">    */</span> </span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/login_page&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">loginPage</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;loginPage.html&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"鉴权失败处理器-1\"><a href=\"#鉴权失败处理器-1\" class=\"headerlink\" title=\"鉴权失败处理器\"></a>鉴权失败处理器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAccessDeniedHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessDeniedHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse response, AccessDeniedException e)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;403\\&quot;,\\&quot;msg\\&quot;:\\&quot;没有权限\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"验证器-1\"><a href=\"#验证器-1\" class=\"headerlink\" title=\"验证器\"></a>验证器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAuthenticationProvider</span>  <span class=\"keyword\">implements</span> <span class=\"title\">AuthenticationProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDetailsService userDetailsService;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyAuthenticationProvider</span><span class=\"params\">(UserDetailsService userDetailsService, BCryptPasswordEncoder bCryptPasswordEncoder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userDetailsService = userDetailsService;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bCryptPasswordEncoder = bCryptPasswordEncoder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Authentication <span class=\"title\">authenticate</span><span class=\"params\">(Authentication authentication)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//       这里写验证逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"验证成功处理器\"><a href=\"#验证成功处理器\" class=\"headerlink\" title=\"验证成功处理器\"></a>验证成功处理器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ublic <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAuthenticationSuccessHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleUrlAuthenticationSuccessHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthenticationSuccess</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//随便写点啥</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"投票器-1\"><a href=\"#投票器-1\" class=\"headerlink\" title=\"投票器\"></a>投票器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>: security-test</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 鉴权投票器</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-04-11</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExpressionVoter</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebExpressionVoter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">vote</span><span class=\"params\">(Authentication authentication, FilterInvocation fi, Collection&lt;ConfigAttribute&gt; attributes)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        这里写鉴权逻辑</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义token处理过滤器-1\"><a href=\"#自定义token处理过滤器-1\" class=\"headerlink\" title=\"自定义token处理过滤器\"></a>自定义token处理过滤器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>: security-about</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>:填充一个token</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-04-20</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFittler</span> <span class=\"keyword\">extends</span> <span class=\"title\">OncePerRequestFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilterInternal</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        String token1 = request.getHeader(<span class=\"string\">&quot;token&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token1==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;GrantedAuthority&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        GrantedAuthority grantedAuthority = <span class=\"keyword\">new</span> GrantedAuthority() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAuthority</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;test&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        list.add(grantedAuthority);</span><br><span class=\"line\">        UsernamePasswordAuthenticationToken token = <span class=\"keyword\">new</span> UsernamePasswordAuthenticationToken(<span class=\"string\">&quot;test&quot;</span>,<span class=\"string\">&quot;test&quot;</span>,list);</span><br><span class=\"line\">        SecurityContextHolder.getContext().setAuthentication(token);</span><br><span class=\"line\">        filterChain.doFilter(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"登出成功处理器-1\"><a href=\"#登出成功处理器-1\" class=\"headerlink\" title=\"登出成功处理器\"></a>登出成功处理器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLogoutSuccessHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">LogoutSuccessHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLogoutSuccess</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse response, Authentication authentication)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\"></span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;200\\&quot;,\\&quot;msg\\&quot;:\\&quot;登出成功\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"登陆失败处理器-1\"><a href=\"#登陆失败处理器-1\" class=\"headerlink\" title=\"登陆失败处理器\"></a>登陆失败处理器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUrlAuthenticationFailureHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleUrlAuthenticationFailureHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthenticationFailure</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(exception.getMessage().equals(<span class=\"string\">&quot;坏的凭证&quot;</span>))&#123;</span><br><span class=\"line\">            writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;401\\&quot;,\\&quot;msg\\&quot;:\\&quot;登录失败,用户名或者密码有误\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">            writer.close();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;401\\&quot;,\\&quot;msg\\&quot;:\\&quot;登录失败,&quot;</span>+exception.getMessage()+<span class=\"string\">&quot;\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">            writer.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"自定义UsernamePasswordAuthenticationFilter-1\"><a href=\"#自定义UsernamePasswordAuthenticationFilter-1\" class=\"headerlink\" title=\"自定义UsernamePasswordAuthenticationFilter\"></a>自定义UsernamePasswordAuthenticationFilter</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>: security-test</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 用户登陆逻辑过滤器</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-04-11</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUsernamePasswordAuthenticationFilte</span> <span class=\"keyword\">extends</span> <span class=\"title\">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisService redisService;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> postOnly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyUsernamePasswordAuthenticationFilte</span><span class=\"params\">(RedisService redisService)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.redisService=redisService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Authentication <span class=\"title\">attemptAuthentication</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">        <span class=\"comment\">//你可以在这里做验证码校验，校验不通过抛出AuthenticationException()即可</span></span><br><span class=\"line\">            <span class=\"keyword\">super</span>.attemptAuthentication(request,response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisService redisService;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    MyUserDetailService userDetailService;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        web.ignoring().antMatchers(<span class=\"string\">&quot;/resources/**/*.html&quot;</span>, <span class=\"string\">&quot;/resources/**/*.js&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.css&quot;</span>, <span class=\"string\">&quot;/resources/**/*.txt&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.bmp&quot;</span>, <span class=\"string\">&quot;/**/*.gif&quot;</span>, <span class=\"string\">&quot;/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.jpg&quot;</span>, <span class=\"string\">&quot;/**/*.ico&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        super.configure(web);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        配置登录页等 permitAll表示任何权限都能访问</span></span><br><span class=\"line\">       http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">               .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//               任何请求都被accessDecisionManager() 的鉴权器管理</span></span><br><span class=\"line\">               .anyRequest().authenticated().accessDecisionManager(accessDecisionManager())</span><br><span class=\"line\"><span class=\"comment\">//               登出配置</span></span><br><span class=\"line\">               .and().logout().logoutUrl(<span class=\"string\">&quot;/logout&quot;</span>).logoutSuccessHandler(<span class=\"keyword\">new</span> MyLogoutSuccessHandler())</span><br><span class=\"line\"><span class=\"comment\">//               关闭csrf</span></span><br><span class=\"line\">               .and().csrf().disable();</span><br><span class=\"line\">       http.authorizeRequests().antMatchers(<span class=\"string\">&quot;/tets_a/**&quot;</span>,<span class=\"string\">&quot;/test_b/**&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).antMatchers(<span class=\"string\">&quot;/a/**&quot;</span>,<span class=\"string\">&quot;/b/**&quot;</span>).authenticated().accessDecisionManager(accessDecisionManager())</span><br><span class=\"line\"><span class=\"comment\">//      加自定义过滤器</span></span><br><span class=\"line\">        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\"><span class=\"comment\">//        配置鉴权失败的处理器</span></span><br><span class=\"line\">        http.exceptionHandling().accessDeniedHandler(<span class=\"keyword\">new</span> MyAccessDeniedHandler());</span><br><span class=\"line\">        http.addFilterAfter(<span class=\"keyword\">new</span> MyFittler(), LogoutFilter.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">MyAuthenticationProvider <span class=\"title\">getMyAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MyAuthenticationProvider myAuthenticationProvider = <span class=\"keyword\">new</span> MyAuthenticationProvider(userDetailService,<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myAuthenticationProvider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">DaoAuthenticationProvider <span class=\"title\">daoAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        DaoAuthenticationProvider daoAuthenticationProvider = <span class=\"keyword\">new</span> DaoAuthenticationProvider();</span><br><span class=\"line\">        daoAuthenticationProvider.setPasswordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">        daoAuthenticationProvider.setUserDetailsService(userDetailService);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> daoAuthenticationProvider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationManager <span class=\"title\">getAuthenticationManager</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">        ProviderManager authenticationManager = <span class=\"keyword\">new</span> ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AccessDecisionManager <span class=\"title\">accessDecisionManager</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters</span><br><span class=\"line\">                = Arrays.asList(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MyExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> WebExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> RoleVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> AuthenticatedVoter());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UnanimousBased(decisionVoters);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>对于security的扩展配置关键在于<code>configure(HttpSecurity http)</code>方法；扩展认证方式可以自定义<code>authenticationManager</code>并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义<code>accessDecisionManager</code>然后添加自己的投票器并绑定到对应的url（url 匹配方式为ant）上，投票器<code>vote(Authentication authentication, FilterInvocation fi, Collection&lt;ConfigAttribute&gt; attributes)</code>方法返回值为三种：-1 0 1，分别表示反对弃权赞成；</p>\n<p>对于token认证的校验方式，可以暴露一个获取的接口，或者重写<code>UsernamePasswordAuthenticationFilter</code>过滤器和扩展登陆成功处理器来获取token，然后在<code>LogoutFilter</code>之后添加一个自定义过滤器，用于校验和填充SecurityContextHolder</p>\n<p>security的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回json,那么就需要重写各个处理器了。</p>\n<h2 id=\"勘误\"><a href=\"#勘误\" class=\"headerlink\" title=\"勘误\"></a>勘误</h2><p>2018/6/23: 在和别人讲解security的时候发现漏了一个处理器，401用户未登陆处理器，其默认是跳转到登陆页；现贴出其写法和配置方法，使其返回</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>: poseidon</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 未登录处理</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2018-12-31</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PoseidonLoginUrlAuthenticationEntryPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">LoginUrlAuthenticationEntryPoint</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PoseidonLoginUrlAuthenticationEntryPoint</span><span class=\"params\">(String loginFormUrl)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(loginFormUrl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commence</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;401\\&quot;,\\&quot;msg\\&quot;:\\&quot;用户未登录\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在config 方法中加上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.exceptionHandling().authenticationEntryPoint( <span class=\"keyword\">new</span> PoseidonLoginUrlAuthenticationEntryPoint(<span class=\"string\">&quot;/login&quot;</span>)).accessDeniedHandler(<span class=\"keyword\">new</span> PoseidonAccessDeniedHandler());</span><br></pre></td></tr></table></figure>\n<p>具体细节可参看我的poseidon项目和sofia脚手架。</p>"},{"title":" springSecurity深度解析","date":"2019-04-11T13:27:31.000Z","_content":"作者：muggle\n\n#### 从一个基础的springsecurity开始，进行代码跟踪分析其原理\n\nspringsecurity是一个典型的责任链模式；我们先新建一个springboot项目，进行最基本的springsecurity配置，然后debug;我这里使用的开发工具是idea.建议大家也使用idea来进行日常开发。好了话不多说，开始：\n\n第一步\n\n新建springboot项目 maven依赖：\n```xml\n<dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.security</groupId>\n            <artifactId>spring-security-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n```\n\n启动项目，控制台上会输出这样一段字符串：\n```java\n2019-04-11 09:47:40.388  INFO 16716 --- [           main] .s.s.UserDetailsServiceAutoConfiguration :\n\nUsing generated security password: a6d55bc6-49fb-4241-a5ae-527e5e644731\n\n```\n\n<!--more-->\n现在我们访问 http://localhost:8080 会自动跳转到 http://localhost:8080/login，并弹出一个登陆页面，用户名输user,密码输上面的字符串： a6d55bc6-49fb-4241-a5ae-527e5e644731，每次字符串都是随机的，要留意你的控制台打印的字符串，登陆成功了，现在我们开始debug,看看一次登陆和一次登陆后访问一次不登陆访问这三种情况security都做了哪些事情。\n\n先写一个接口：\n```java\n\n@RestController\npublic class TestController {\n    @GetMapping(\"test\")\n    public String test(){\n        return \"hi 你好啊\";\n    }\n}\n```\nspringsecurity 执行过程是走一条过滤器链，所以我们要先明白，有哪些过滤器，并在过滤器上打上断点追踪，下面贴出各个过滤器名称及作用：\n\n>1、WebAsyncManagerIntegrationFilter\n将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。\n2、SecurityContextPersistenceFilter\n在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除\n例如在Session中维护一个用户的安全信息就是这个过滤器处理的。\n3、HeaderWriterFilter\n用于将头信息加入响应中\n4、CsrfFilter\n用于处理跨站请求伪造\n5、LogoutFilter\n用于处理退出登录\n6、UsernamePasswordAuthenticationFilter\n用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。\n从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。\n7、DefaultLoginPageGeneratingFilter\n如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。\n8、BasicAuthenticationFilter\n处理请求头信息，DigestAuthenticationFilter\n9、RequestCacheAwareFilter\n用来处理请求的缓存\n10、SecurityContextHolderAwareRequestFilter\n11、AnonymousAuthenticationFilter\n12、SessionManagementFilter\n13、ExceptionTranslationFilter\n处理 AccessDeniedException 和 AuthenticationException 异常\n14、FilterSecurityInterceptor\nAbstractInterceptUrlConfigurer.createFilterSecurityInterceptor\n15、RememberMeAuthenticationFilter的作用是, 当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统.\n\n先不管那么多，ctr+alt+shift+t（或者按两下shift） 输入类名找到类，打断点，开始debug\n\n#### springsecurity 的默认登陆url是/login:我们访问一下来捋一捋：\n其代码顺序是：\n`WebAsyncManagerIntegrationFilter`  -> `SecurityContextPersistenceFilter` -> `HeaderWriterFilter` -> `CsrfFilter` -> `LogoutFilter` -> `DefaultLoginPageGeneratingFilter`\n\n然后浏览器会返回一个登陆页面：\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-d6e336c80cbf30c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 说明：\n这其实是发起了一个请求登陆页面的请求，请求首先进入`WebAsyncManagerIntegrationFilter` 这个过滤器做了什么我们不必去关系，它下一个过滤器`SecurityContextPersistenceFilter` 通过request的attribute来上了一次请求锁，并且对SecurityContextHolder进行了管理；而SecurityContextHolder是对用户信息进行管理的一套系统，分为三大类\n\n1. SecurityContextHolder 对用户信息增删改查的操作\n 2. SecurityContext 将用户名，权限等封装成该对象\n 3. SecurityContextHolderStrategy 用于存储 SecurityContext\n\n默认的SecurityContextHolderStrategy 实现类是ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。\n下一个过滤器`HeaderWriterFilter`请求和响应封装了一下，用于`CsrfFilter`鉴别csrf攻击 `LogoutFilter`判断是不是登出操作，如果是则不执行下面的过滤器，而执行登出的相关操作，DefaultLoginPageGeneratingFilter生成登录页\n\n我们先输入正确的代码登陆一次\n\n通过跟踪代码发现其执行顺序是：\n`WebAsyncManagerIntegrationFilter` -> `SecurityContextPersistenceFilter` -> `HeaderWriterFilter`->`CsrfFilter`-> `LogoutFilter`->`UsernamePasswordAuthenticationFilter`->`WebAsyncManagerIntegrationFilter`->`SecurityContextPersistenceFilter`->`HeaderWriterFilter`->`CsrfFilter`->`LogoutFilter`->`DefaultLoginPageGeneratingFilter`->`BasicAuthenticationFilter`->`RequestCacheAwareFilter`->`SecurityContextHolderAwareRequestFilter`->`AnonymousAuthenticationFilter`->`SessionManagementFilter`->`ExceptionTranslationFilter`->`FilterSecurityInterceptor`->`SecurityContextPersistenceFilter`->`LogoutFilter`->`DefaultLoginPageGeneratingFilter`->`RequestCacheAwareFilter`->`SecurityContextHolderAwareRequestFilter`->`AnonymousAuthenticationFilter`->`SessionManagementFilter`->`ExceptionTranslationFilter`->`FilterSecurityInterceptor`\n\n这一次之所以过滤器链跑这么长是因为，这里可以认为发起了三次请求，第一次请求是登陆，登陆成功后转发到 url 为“/”的接口，而我没有这个接口，发生了重定向到“/error” 而“/error”页面是springboot请求失败的错误页面返回机制。\n`WebAsyncManagerIntegrationFilter` -> `SecurityContextPersistenceFilter` -> `HeaderWriterFilter`->`CsrfFilter`-> `LogoutFilter`->`UsernamePasswordAuthenticationFilter` 这一过程登陆请求。\n\n`WebAsyncManagerIntegrationFilter`->`SecurityContextPersistenceFilter`->`HeaderWriterFilter`->`CsrfFilter`->`LogoutFilter`->`DefaultLoginPageGeneratingFilter`->`BasicAuthenticationFilter`->`RequestCacheAwareFilter`->`SecurityContextHolderAwareRequestFilter`->`AnonymousAuthenticationFilter`->`SessionManagementFilter`->`ExceptionTranslationFilter`->`FilterSecurityInterceptor`\n这是转发到“/”的过程\n\n`SecurityContextPersistenceFilter`->`LogoutFilter`->`DefaultLoginPageGeneratingFilter`->`RequestCacheAwareFilter`->`SecurityContextHolderAwareRequestFilter`->`AnonymousAuthenticationFilter`->`SessionManagementFilter`->`ExceptionTranslationFilter`->`FilterSecurityInterceptor`\n这是重定向到error的过程\n\n接下来访问一下我们的/test接口\n看看执行顺序：\n`WebAsyncManagerIntegrationFilter`->`SecurityContextPersistenceFilter`->`HeaderWriterFilter`->`CsrfFilter`->`LogoutFilter`->`DefaultLoginPageGeneratingFilter`->`BasicAuthenticationFilter`->`RequestCacheAwareFilter`->`SecurityContextHolderAwareRequestFilter`->`AnonymousAuthenticationFilter`->`SessionManagementFilter`->`ExceptionTranslationFilter`->`FilterSecurityInterceptor`\n#### 说明：\nBasicAuthenticationFilter就是看你请求头里面有没有basic开头的东西，有的话做一些处理，对我们来说没啥用，不必去关心，RequestCacheAwareFilter对请求和响应做了额外处理 SecurityContextHolderAwareRequestFilter 也是对请求做了一些额外处理，我们同样不去关心它。AnonymousAuthenticationFilter过滤器是当securitycontext为null时填充一个匿名权限，这里被执行的原因因为security未配置完全，后面进一步配置了之后再回来详解。ExceptionTranslationFilter是对鉴权或者登陆异常的处理过滤器，FilterSecurityInterceptor可以看做是过滤器链的出口：\n```java\n public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        FilterInvocation fi = new FilterInvocation(request, response, chain);\n        this.invoke(fi);\n    }\n```\n这个fi就是请求的url值。\n\n现在我们完善一下security配置，让它复杂一点\n实现 GrantedAuthority：\n```java\n@Data\npublic class MyGrantedAuthority implements GrantedAuthority {\n    private String authority;\n}\n```\n实现UserDetails\n```java\n@Data\n@Accessors(chain = true)\npublic class MyUserDetail implements UserDetails {\n\n    private List<MyGrantedAuthority> authorities;\n\n    private String password;\n\n    private String username;\n\n    private boolean accountNonExpired;\n\n    private boolean accountNonLocked;\n\n    private boolean credentialsNonExpired;\n\n    private boolean enabled;\n\n}\n\n```\n\n实现UserDetailsService\n```java\n@Service\npublic class MyUserDetailService implements UserDetailsService {\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        List<MyGrantedAuthority> authorities = new ArrayList<>();\n        MyGrantedAuthority myGrantedAuthority = new MyGrantedAuthority();\n        myGrantedAuthority.setAuthority(\"ROLE_test\");\n        BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();\n        String test = bCryptPasswordEncoder.encode(\"test\");\n        authorities.add(myGrantedAuthority);\n        return new MyUserDetail().setAuthorities(authorities).setAccountNonExpired(true)\n                .setAccountNonLocked(true).setCredentialsNonExpired(true).setEnabled(true)\n                .setPassword(test).setUsername(\"test\");\n    }\n}\n```\n\n重写security适配器WebSecurityConfigurerAdapter：\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Autowired\n    MyUserDetailService userDetailService;\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailService).passwordEncoder(new BCryptPasswordEncoder());\n    }\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n\n        web.ignoring().antMatchers(\"/resources/**/*.html\", \"/resources/**/*.js\",\n                \"/resources/**/*.css\", \"/resources/**/*.txt\",\n                \"/resources/**/*.png\", \"/**/*.bmp\", \"/**/*.gif\", \"/**/*.png\", \"/**/*.jpg\", \"/**/*.ico\");\n//        super.configure(web);\n    }\n\n   @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().and().csrf().disable();\n    }\n\n}\n```\n这里比开始又要复杂一点了，我先对相关操作进行说明一下：\n先从SecurityConfig说起\n\n重写了三个config方法\n1.第一个config涉及到的问题比较深——security的认证鉴权系统；\n先说认证的过程，当过滤器跑到usernamepasswordFilter的时候就开始做认证了\n#### security认证原理\n认证的工作是交给AuthenticationManager去做，AuthenticationManager下有多个认证器 AuthenticationProvider\n只要其中一个AuthenticationProvider通过认证就算登陆成功，而且在认证器中抛出异常，无法终止认证流程只是算该认证器未通过。\n第一个config就算配置了一个AuthenticationManagerBuilder 这个类会生成一个 AuthenticationManager和DaoAuthenticationProvider认证器，认证调用userdetailservice 的loadUserByUsername方法来和你传入的username passworde做比较，password 是通过BCryptPasswordEncoder来做编码后比较的，这样做是为了提高安全性。\n\n2.第二个config是对静态资源的放行；\n\n3.第三个config 配置了登录页请求路径，登陆认证路径，用户名密码属性，和一个test权限，注意一点：我在config配的是hasRole(\"test\")，我设置的权限是  myGrantedAuthority.setAuthority(\"ROLE_test\");为什么这样弄后面会说。\n接下来完善一下，边边角角，写个登陆的HTML,一个登陆页面请求接口:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form method=\"post\" action=\"/sign_in\">\n    用户名：<input type=\"text\" name=\"username\" value=\"test\"><br>\n    密码：<input type=\"text\" name=\"password\" value=\"test\"><br>\n    <input type=\"text\" name=\"verification\"><br>\n    <input type=\"submit\" name=\"test\">\n</form>\n</body>\n</html>\n```\n\n```java\n@Controller\npublic class LoginController {\n    @GetMapping(\"/login_page\")\n    public String loginPage(){\n        return \"loginPage.html\";\n    }\n}\n\n```\n启动项目，访问localhost:8080/test\n跳转到了/login_page\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-40e8574ede6fdade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n点登陆，debug看看有什么不同 新增的断点DaoAuthenticationProvider和MyUserDetailService\n前面执行顺序还是一样，到SecurityContextHolderAwareRequestFilter的时候我们注意一下\n```java\npublic class SecurityContextHolderAwareRequestFilter extends GenericFilterBean {\n    private String rolePrefix = \"ROLE_\";\n\n```\n我们权限设置的前缀就是从这来的 到后面讲投票器的时候再细说。\n到UsernamePasswordAuthenticationFilter这个过滤器后 下一步到了DaoAuthenticationProvider验证器，验证器执行的是其父类AbstractUserDetailsAuthenticationProvider的authenticate（）方法同时我们看到MyUserDetailService的loadUserByUsername被调用，最后，认证结束转发到访问前路径/test 重新走过滤器。流程和一开始的简单配置一样，走到FilterSecurityInterceptor的时候进入WebExpressionVoter了投票器；\n#### security的投票器：\n当过滤器链走到尽头（FilterSecurityInterceptor）下一步就是鉴权了，鉴权功能会交给AccessDecisionManager去处理，而AccessDecisionManager下又有多个投票器，其中WebExpressionVoter是security的一个默认投票器，我们来分析一下这个类：\n其有个这样的方法\n```java\n public int vote(Authentication authentication, FilterInvocation fi, Collection<ConfigAttribute> attributes)\n```\n返回int类型，1表示赞成，0表示弃权，-1表示反对。当所有投票器的vote执行结束，如果最终结果小于0表示不通过，\n方法的参数说明：\n1. FilterInvocation  可获得请求的相关信息，比如请求方式（get post）url 等\n2.authentication 是从securitycontext中拿出来的用户信息\n3.Collection<ConfigAttribute> 是可以访问该路径的权限集合。也就是前面SecurityContextHolderAwareRequestFilter 查找出来的权限，对于在WebSecurityConfigurerAdapter config方法中的hasRole(\"test\")权限规则并不是直接取权限 test,而是加了前缀rolePrefix（“ROLE_”），这个前缀也是可配置的配置方式：[https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#appendix-faq-role-prefix](https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#appendix-faq-role-prefix)\n\n\n一些基本的知识点交代的差不多了，现在，我进行下一步\n#### security魔改\n需求：我希望后端能做验证码校验，没通过校验的直接登录失败；\n实现方式：security给我们提供了在各个过滤器上追加过滤器的方法，我们在UsernamePasswordAuthenticationFilter追加一个过滤器\n```java\n\npublic class MyUsernamePasswordAuthenticationFilte extends UsernamePasswordAuthenticationFilter {\n    private RedisService redisService;\n    private boolean postOnly = true;\n\n    public MyUsernamePasswordAuthenticationFilte(RedisService redisService){\n        this.redisService=redisService;\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n        redisService.getcCode(request);\n        return super.attemptAuthentication(request,response);\n    }\n}\n\n```\n这里redisService 就是你要弄的验证逻辑，其他代码还是从父类那复制过来，不去动它。\n为什么要继承UsernamePasswordAuthenticationFilter 而不是继承AbstractAuthenticationProcessingFilter，这样做的好处是可以少写代码少踩坑。\n然后修改config\n```java\n @Autowired\n RedisService redisService;\n\n @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().and().csrf().disable();\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n    }\n\n\n    MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        return myUsernamePasswordAuthenticationFilte;\n    }\n```\n我在加两个处理器，当我登陆成功或者失败，由我自己弄；\n登陆成功处理器\n```java\npublic class MyAuthenticationSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n\n        response.setContentType(\"application/json;charset=UTF-8\");\n        final PrintWriter writer = response.getWriter();\n        writer.write(\"{\\\"code\\\":\\\"200\\\",\\\"msg\\\":\\\"登录成功\\\"}\");\n        writer.close();\n    }\n}\n\n```\n登陆失败的处理器\n```java\npublic class MyUrlAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        final PrintWriter writer = response.getWriter();\n        if(exception.getMessage().equals(\"坏的凭证\")){\n            writer.write(\"{\\\"code\\\":\\\"401\\\",\\\"msg\\\":\\\"登录失败,用户名或者密码有误\\\"}\");\n            writer.close();\n        }else {\n            writer.write(\"{\\\"code\\\":\\\"401\\\",\\\"msg\\\":\\\"登录失败,\"+exception.getMessage()+\"\\\"}\");\n            writer.close();\n        }\n\n    }\n}\n\n```\n\n#### 说明：\n为什么要继承SimpleUrlAuthenticationFailureHandler和SimpleUrlAuthenticationSuccessHandler 而不是实现AuthenticationFailureHandler，还是那句话，为了少写代码少踩坑，我这里是返回json字符串，你也可以弄成重定向啥的，也比较容易。\nconfig再改一下：\n```java\n MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        return myUsernamePasswordAuthenticationFilte;\n    }\n```\n这里要注意 myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\"); 因为 http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);并不是替换掉UsernamePasswordAuthenticationFilter，而是和你自己添加的过滤器同时存在，security会根据url判断该走哪个过滤器，如果loginProcessingUrl还是“/login”的话走的是UsernamePasswordAuthenticationFilter，这里要留意一下。\n\n\n现在再加需求，我不仅需要普通登录方式，我想其他登录方式；\n实现方式：加多个认证器，每个认证器对应一种登录方式\n```java\npublic class MyAuthenticationProvider  implements AuthenticationProvider {\n    private UserDetailsService userDetailsService;\n    private BCryptPasswordEncoder bCryptPasswordEncoder;\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n//       这里写验证逻辑\n        return null;\n    }\n\n    @Override\n    public boolean supports(Class<?> aClass) {\n        return false;\n    }\n}\n\n```\n在改SecurityConfig\n```java\n @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().and().csrf().disable();\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n    }\n\n\n    MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());\n        return myUsernamePasswordAuthenticationFilte;\n    }\n    MyAuthenticationProvider getMyAuthenticationProvider(){\n        MyAuthenticationProvider myAuthenticationProvider = new MyAuthenticationProvider(userDetailService,new BCryptPasswordEncoder());\n        return myAuthenticationProvider;\n    }\n    DaoAuthenticationProvider daoAuthenticationProvider(){\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(new BCryptPasswordEncoder());\n        daoAuthenticationProvider.setUserDetailsService(userDetailService);\n        return daoAuthenticationProvider;\n    }\n    protected AuthenticationManager getAuthenticationManager()  {\n        ProviderManager authenticationManager = new ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));\n        return authenticationManager;\n    }\n```\n我再加需求：\n根据不同的客服端做不同的鉴权策略；\n实现方式：加投票器；\n```java\npublic class MyExpressionVoter extends WebExpressionVoter {\n    @Override\n    public int vote(Authentication authentication, FilterInvocation fi, Collection<ConfigAttribute> attributes) {\n//        这里写鉴权逻辑\n        return 0;\n    }\n}\n\n```\n\n再次改动config\n```java\n @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().accessDecisionManager(accessDecisionManager()).and().csrf().disable();\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n    }\n\n\n    MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());\n        return myUsernamePasswordAuthenticationFilte;\n    }\n    MyAuthenticationProvider getMyAuthenticationProvider(){\n        MyAuthenticationProvider myAuthenticationProvider = new MyAuthenticationProvider(userDetailService,new BCryptPasswordEncoder());\n        return myAuthenticationProvider;\n    }\n    DaoAuthenticationProvider daoAuthenticationProvider(){\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(new BCryptPasswordEncoder());\n        daoAuthenticationProvider.setUserDetailsService(userDetailService);\n        return daoAuthenticationProvider;\n    }\n    protected AuthenticationManager getAuthenticationManager()  {\n        ProviderManager authenticationManager = new ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));\n        return authenticationManager;\n    }\n\n    public AccessDecisionManager accessDecisionManager(){\n        List<AccessDecisionVoter<? extends Object>> decisionVoters\n                = Arrays.asList(\n                new MyExpressionVoter(),\n                new WebExpressionVoter(),\n                new RoleVoter(),\n                new AuthenticatedVoter());\n        return new UnanimousBased(decisionVoters);\n    }\n```\n在加两个鉴权失败处理器\n```java\npublic class MyAccessDeniedHandler implements AccessDeniedHandler {\n    @Override\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        PrintWriter writer = response.getWriter();\n        writer.write(\"{\\\"code\\\":\\\"403\\\",\\\"msg\\\":\\\"没有权限\\\"}\");\n        writer.close();\n    }\n}\n\n```\n再加一个登出处理器\n\n```java\n\npublic class MyLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        final PrintWriter writer = response.getWriter();\n\n        writer.write(\"{\\\"code\\\":\\\"200\\\",\\\"msg\\\":\\\"登出成功\\\"}\");\n        writer.close();\n    }\n}\n\n```\n最后修改SecurityConfig，最终模样为\n```java\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Autowired\n    RedisService redisService;\n    @Autowired\n    MyUserDetailService userDetailService;\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailService).passwordEncoder(new BCryptPasswordEncoder());\n    }\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n\n        web.ignoring().antMatchers(\"/resources/**/*.html\", \"/resources/**/*.js\",\n                \"/resources/**/*.css\", \"/resources/**/*.txt\",\n                \"/resources/**/*.png\", \"/**/*.bmp\", \"/**/*.gif\", \"/**/*.png\", \"/**/*.jpg\", \"/**/*.ico\");\n//        super.configure(web);\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().accessDecisionManager(accessDecisionManager())\n               .and().logout().logoutSuccessHandler(new MyLogoutSuccessHandler())\n               .and().csrf().disable();\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n        http.exceptionHandling().accessDeniedHandler(new MyAccessDeniedHandler());\n    }\n\n\n    MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());\n        return myUsernamePasswordAuthenticationFilte;\n    }\n    MyAuthenticationProvider getMyAuthenticationProvider(){\n        MyAuthenticationProvider myAuthenticationProvider = new MyAuthenticationProvider(userDetailService,new BCryptPasswordEncoder());\n        return myAuthenticationProvider;\n    }\n    DaoAuthenticationProvider daoAuthenticationProvider(){\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(new BCryptPasswordEncoder());\n        daoAuthenticationProvider.setUserDetailsService(userDetailService);\n        return daoAuthenticationProvider;\n    }\n    protected AuthenticationManager getAuthenticationManager()  {\n        ProviderManager authenticationManager = new ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));\n        return authenticationManager;\n    }\n\n    public AccessDecisionManager accessDecisionManager(){\n        List<AccessDecisionVoter<? extends Object>> decisionVoters\n                = Arrays.asList(\n                new MyExpressionVoter(),\n                new WebExpressionVoter(),\n                new RoleVoter(),\n                new AuthenticatedVoter());\n        return new UnanimousBased(decisionVoters);\n\n    }\n}\n```\n\n你可能想要用jwtToken 做token鉴权的方式；\n也好做，我这里提一下思路，鉴权都是在投票器里面，那我们在投票器之前填充好securitycontext就成，然后实现一个自己的投票器；填充securitycontext随便找个过滤器http.addFilterAfter() 然后在过滤器里面填充好就行，至于拿token的接口，在config里用.permitAll()放行就行了，比上面的改法还简单，我就不写了。\n\n#### 题外话\n\n具体的代码可以参考我的项目[poseindon](https://github.com/muggle0/poseidon/wiki)，这种security改动方式我经过生产实践的，不会有问题。另外篇幅有点长 感谢大佬的阅读。\n","source":"_posts/springSecurity深度解析.md","raw":"---\ntitle: ' springSecurity深度解析'\ndate: 2019-04-11 21:27:31\ntags: security\n---\n作者：muggle\n\n#### 从一个基础的springsecurity开始，进行代码跟踪分析其原理\n\nspringsecurity是一个典型的责任链模式；我们先新建一个springboot项目，进行最基本的springsecurity配置，然后debug;我这里使用的开发工具是idea.建议大家也使用idea来进行日常开发。好了话不多说，开始：\n\n第一步\n\n新建springboot项目 maven依赖：\n```xml\n<dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.security</groupId>\n            <artifactId>spring-security-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n```\n\n启动项目，控制台上会输出这样一段字符串：\n```java\n2019-04-11 09:47:40.388  INFO 16716 --- [           main] .s.s.UserDetailsServiceAutoConfiguration :\n\nUsing generated security password: a6d55bc6-49fb-4241-a5ae-527e5e644731\n\n```\n\n<!--more-->\n现在我们访问 http://localhost:8080 会自动跳转到 http://localhost:8080/login，并弹出一个登陆页面，用户名输user,密码输上面的字符串： a6d55bc6-49fb-4241-a5ae-527e5e644731，每次字符串都是随机的，要留意你的控制台打印的字符串，登陆成功了，现在我们开始debug,看看一次登陆和一次登陆后访问一次不登陆访问这三种情况security都做了哪些事情。\n\n先写一个接口：\n```java\n\n@RestController\npublic class TestController {\n    @GetMapping(\"test\")\n    public String test(){\n        return \"hi 你好啊\";\n    }\n}\n```\nspringsecurity 执行过程是走一条过滤器链，所以我们要先明白，有哪些过滤器，并在过滤器上打上断点追踪，下面贴出各个过滤器名称及作用：\n\n>1、WebAsyncManagerIntegrationFilter\n将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。\n2、SecurityContextPersistenceFilter\n在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除\n例如在Session中维护一个用户的安全信息就是这个过滤器处理的。\n3、HeaderWriterFilter\n用于将头信息加入响应中\n4、CsrfFilter\n用于处理跨站请求伪造\n5、LogoutFilter\n用于处理退出登录\n6、UsernamePasswordAuthenticationFilter\n用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。\n从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。\n7、DefaultLoginPageGeneratingFilter\n如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。\n8、BasicAuthenticationFilter\n处理请求头信息，DigestAuthenticationFilter\n9、RequestCacheAwareFilter\n用来处理请求的缓存\n10、SecurityContextHolderAwareRequestFilter\n11、AnonymousAuthenticationFilter\n12、SessionManagementFilter\n13、ExceptionTranslationFilter\n处理 AccessDeniedException 和 AuthenticationException 异常\n14、FilterSecurityInterceptor\nAbstractInterceptUrlConfigurer.createFilterSecurityInterceptor\n15、RememberMeAuthenticationFilter的作用是, 当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统.\n\n先不管那么多，ctr+alt+shift+t（或者按两下shift） 输入类名找到类，打断点，开始debug\n\n#### springsecurity 的默认登陆url是/login:我们访问一下来捋一捋：\n其代码顺序是：\n`WebAsyncManagerIntegrationFilter`  -> `SecurityContextPersistenceFilter` -> `HeaderWriterFilter` -> `CsrfFilter` -> `LogoutFilter` -> `DefaultLoginPageGeneratingFilter`\n\n然后浏览器会返回一个登陆页面：\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-d6e336c80cbf30c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 说明：\n这其实是发起了一个请求登陆页面的请求，请求首先进入`WebAsyncManagerIntegrationFilter` 这个过滤器做了什么我们不必去关系，它下一个过滤器`SecurityContextPersistenceFilter` 通过request的attribute来上了一次请求锁，并且对SecurityContextHolder进行了管理；而SecurityContextHolder是对用户信息进行管理的一套系统，分为三大类\n\n1. SecurityContextHolder 对用户信息增删改查的操作\n 2. SecurityContext 将用户名，权限等封装成该对象\n 3. SecurityContextHolderStrategy 用于存储 SecurityContext\n\n默认的SecurityContextHolderStrategy 实现类是ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。\n下一个过滤器`HeaderWriterFilter`请求和响应封装了一下，用于`CsrfFilter`鉴别csrf攻击 `LogoutFilter`判断是不是登出操作，如果是则不执行下面的过滤器，而执行登出的相关操作，DefaultLoginPageGeneratingFilter生成登录页\n\n我们先输入正确的代码登陆一次\n\n通过跟踪代码发现其执行顺序是：\n`WebAsyncManagerIntegrationFilter` -> `SecurityContextPersistenceFilter` -> `HeaderWriterFilter`->`CsrfFilter`-> `LogoutFilter`->`UsernamePasswordAuthenticationFilter`->`WebAsyncManagerIntegrationFilter`->`SecurityContextPersistenceFilter`->`HeaderWriterFilter`->`CsrfFilter`->`LogoutFilter`->`DefaultLoginPageGeneratingFilter`->`BasicAuthenticationFilter`->`RequestCacheAwareFilter`->`SecurityContextHolderAwareRequestFilter`->`AnonymousAuthenticationFilter`->`SessionManagementFilter`->`ExceptionTranslationFilter`->`FilterSecurityInterceptor`->`SecurityContextPersistenceFilter`->`LogoutFilter`->`DefaultLoginPageGeneratingFilter`->`RequestCacheAwareFilter`->`SecurityContextHolderAwareRequestFilter`->`AnonymousAuthenticationFilter`->`SessionManagementFilter`->`ExceptionTranslationFilter`->`FilterSecurityInterceptor`\n\n这一次之所以过滤器链跑这么长是因为，这里可以认为发起了三次请求，第一次请求是登陆，登陆成功后转发到 url 为“/”的接口，而我没有这个接口，发生了重定向到“/error” 而“/error”页面是springboot请求失败的错误页面返回机制。\n`WebAsyncManagerIntegrationFilter` -> `SecurityContextPersistenceFilter` -> `HeaderWriterFilter`->`CsrfFilter`-> `LogoutFilter`->`UsernamePasswordAuthenticationFilter` 这一过程登陆请求。\n\n`WebAsyncManagerIntegrationFilter`->`SecurityContextPersistenceFilter`->`HeaderWriterFilter`->`CsrfFilter`->`LogoutFilter`->`DefaultLoginPageGeneratingFilter`->`BasicAuthenticationFilter`->`RequestCacheAwareFilter`->`SecurityContextHolderAwareRequestFilter`->`AnonymousAuthenticationFilter`->`SessionManagementFilter`->`ExceptionTranslationFilter`->`FilterSecurityInterceptor`\n这是转发到“/”的过程\n\n`SecurityContextPersistenceFilter`->`LogoutFilter`->`DefaultLoginPageGeneratingFilter`->`RequestCacheAwareFilter`->`SecurityContextHolderAwareRequestFilter`->`AnonymousAuthenticationFilter`->`SessionManagementFilter`->`ExceptionTranslationFilter`->`FilterSecurityInterceptor`\n这是重定向到error的过程\n\n接下来访问一下我们的/test接口\n看看执行顺序：\n`WebAsyncManagerIntegrationFilter`->`SecurityContextPersistenceFilter`->`HeaderWriterFilter`->`CsrfFilter`->`LogoutFilter`->`DefaultLoginPageGeneratingFilter`->`BasicAuthenticationFilter`->`RequestCacheAwareFilter`->`SecurityContextHolderAwareRequestFilter`->`AnonymousAuthenticationFilter`->`SessionManagementFilter`->`ExceptionTranslationFilter`->`FilterSecurityInterceptor`\n#### 说明：\nBasicAuthenticationFilter就是看你请求头里面有没有basic开头的东西，有的话做一些处理，对我们来说没啥用，不必去关心，RequestCacheAwareFilter对请求和响应做了额外处理 SecurityContextHolderAwareRequestFilter 也是对请求做了一些额外处理，我们同样不去关心它。AnonymousAuthenticationFilter过滤器是当securitycontext为null时填充一个匿名权限，这里被执行的原因因为security未配置完全，后面进一步配置了之后再回来详解。ExceptionTranslationFilter是对鉴权或者登陆异常的处理过滤器，FilterSecurityInterceptor可以看做是过滤器链的出口：\n```java\n public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        FilterInvocation fi = new FilterInvocation(request, response, chain);\n        this.invoke(fi);\n    }\n```\n这个fi就是请求的url值。\n\n现在我们完善一下security配置，让它复杂一点\n实现 GrantedAuthority：\n```java\n@Data\npublic class MyGrantedAuthority implements GrantedAuthority {\n    private String authority;\n}\n```\n实现UserDetails\n```java\n@Data\n@Accessors(chain = true)\npublic class MyUserDetail implements UserDetails {\n\n    private List<MyGrantedAuthority> authorities;\n\n    private String password;\n\n    private String username;\n\n    private boolean accountNonExpired;\n\n    private boolean accountNonLocked;\n\n    private boolean credentialsNonExpired;\n\n    private boolean enabled;\n\n}\n\n```\n\n实现UserDetailsService\n```java\n@Service\npublic class MyUserDetailService implements UserDetailsService {\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        List<MyGrantedAuthority> authorities = new ArrayList<>();\n        MyGrantedAuthority myGrantedAuthority = new MyGrantedAuthority();\n        myGrantedAuthority.setAuthority(\"ROLE_test\");\n        BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();\n        String test = bCryptPasswordEncoder.encode(\"test\");\n        authorities.add(myGrantedAuthority);\n        return new MyUserDetail().setAuthorities(authorities).setAccountNonExpired(true)\n                .setAccountNonLocked(true).setCredentialsNonExpired(true).setEnabled(true)\n                .setPassword(test).setUsername(\"test\");\n    }\n}\n```\n\n重写security适配器WebSecurityConfigurerAdapter：\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Autowired\n    MyUserDetailService userDetailService;\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailService).passwordEncoder(new BCryptPasswordEncoder());\n    }\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n\n        web.ignoring().antMatchers(\"/resources/**/*.html\", \"/resources/**/*.js\",\n                \"/resources/**/*.css\", \"/resources/**/*.txt\",\n                \"/resources/**/*.png\", \"/**/*.bmp\", \"/**/*.gif\", \"/**/*.png\", \"/**/*.jpg\", \"/**/*.ico\");\n//        super.configure(web);\n    }\n\n   @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().and().csrf().disable();\n    }\n\n}\n```\n这里比开始又要复杂一点了，我先对相关操作进行说明一下：\n先从SecurityConfig说起\n\n重写了三个config方法\n1.第一个config涉及到的问题比较深——security的认证鉴权系统；\n先说认证的过程，当过滤器跑到usernamepasswordFilter的时候就开始做认证了\n#### security认证原理\n认证的工作是交给AuthenticationManager去做，AuthenticationManager下有多个认证器 AuthenticationProvider\n只要其中一个AuthenticationProvider通过认证就算登陆成功，而且在认证器中抛出异常，无法终止认证流程只是算该认证器未通过。\n第一个config就算配置了一个AuthenticationManagerBuilder 这个类会生成一个 AuthenticationManager和DaoAuthenticationProvider认证器，认证调用userdetailservice 的loadUserByUsername方法来和你传入的username passworde做比较，password 是通过BCryptPasswordEncoder来做编码后比较的，这样做是为了提高安全性。\n\n2.第二个config是对静态资源的放行；\n\n3.第三个config 配置了登录页请求路径，登陆认证路径，用户名密码属性，和一个test权限，注意一点：我在config配的是hasRole(\"test\")，我设置的权限是  myGrantedAuthority.setAuthority(\"ROLE_test\");为什么这样弄后面会说。\n接下来完善一下，边边角角，写个登陆的HTML,一个登陆页面请求接口:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form method=\"post\" action=\"/sign_in\">\n    用户名：<input type=\"text\" name=\"username\" value=\"test\"><br>\n    密码：<input type=\"text\" name=\"password\" value=\"test\"><br>\n    <input type=\"text\" name=\"verification\"><br>\n    <input type=\"submit\" name=\"test\">\n</form>\n</body>\n</html>\n```\n\n```java\n@Controller\npublic class LoginController {\n    @GetMapping(\"/login_page\")\n    public String loginPage(){\n        return \"loginPage.html\";\n    }\n}\n\n```\n启动项目，访问localhost:8080/test\n跳转到了/login_page\n![image.png](https://upload-images.jianshu.io/upload_images/13612520-40e8574ede6fdade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n点登陆，debug看看有什么不同 新增的断点DaoAuthenticationProvider和MyUserDetailService\n前面执行顺序还是一样，到SecurityContextHolderAwareRequestFilter的时候我们注意一下\n```java\npublic class SecurityContextHolderAwareRequestFilter extends GenericFilterBean {\n    private String rolePrefix = \"ROLE_\";\n\n```\n我们权限设置的前缀就是从这来的 到后面讲投票器的时候再细说。\n到UsernamePasswordAuthenticationFilter这个过滤器后 下一步到了DaoAuthenticationProvider验证器，验证器执行的是其父类AbstractUserDetailsAuthenticationProvider的authenticate（）方法同时我们看到MyUserDetailService的loadUserByUsername被调用，最后，认证结束转发到访问前路径/test 重新走过滤器。流程和一开始的简单配置一样，走到FilterSecurityInterceptor的时候进入WebExpressionVoter了投票器；\n#### security的投票器：\n当过滤器链走到尽头（FilterSecurityInterceptor）下一步就是鉴权了，鉴权功能会交给AccessDecisionManager去处理，而AccessDecisionManager下又有多个投票器，其中WebExpressionVoter是security的一个默认投票器，我们来分析一下这个类：\n其有个这样的方法\n```java\n public int vote(Authentication authentication, FilterInvocation fi, Collection<ConfigAttribute> attributes)\n```\n返回int类型，1表示赞成，0表示弃权，-1表示反对。当所有投票器的vote执行结束，如果最终结果小于0表示不通过，\n方法的参数说明：\n1. FilterInvocation  可获得请求的相关信息，比如请求方式（get post）url 等\n2.authentication 是从securitycontext中拿出来的用户信息\n3.Collection<ConfigAttribute> 是可以访问该路径的权限集合。也就是前面SecurityContextHolderAwareRequestFilter 查找出来的权限，对于在WebSecurityConfigurerAdapter config方法中的hasRole(\"test\")权限规则并不是直接取权限 test,而是加了前缀rolePrefix（“ROLE_”），这个前缀也是可配置的配置方式：[https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#appendix-faq-role-prefix](https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#appendix-faq-role-prefix)\n\n\n一些基本的知识点交代的差不多了，现在，我进行下一步\n#### security魔改\n需求：我希望后端能做验证码校验，没通过校验的直接登录失败；\n实现方式：security给我们提供了在各个过滤器上追加过滤器的方法，我们在UsernamePasswordAuthenticationFilter追加一个过滤器\n```java\n\npublic class MyUsernamePasswordAuthenticationFilte extends UsernamePasswordAuthenticationFilter {\n    private RedisService redisService;\n    private boolean postOnly = true;\n\n    public MyUsernamePasswordAuthenticationFilte(RedisService redisService){\n        this.redisService=redisService;\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n        redisService.getcCode(request);\n        return super.attemptAuthentication(request,response);\n    }\n}\n\n```\n这里redisService 就是你要弄的验证逻辑，其他代码还是从父类那复制过来，不去动它。\n为什么要继承UsernamePasswordAuthenticationFilter 而不是继承AbstractAuthenticationProcessingFilter，这样做的好处是可以少写代码少踩坑。\n然后修改config\n```java\n @Autowired\n RedisService redisService;\n\n @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().and().csrf().disable();\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n    }\n\n\n    MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        return myUsernamePasswordAuthenticationFilte;\n    }\n```\n我在加两个处理器，当我登陆成功或者失败，由我自己弄；\n登陆成功处理器\n```java\npublic class MyAuthenticationSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n\n        response.setContentType(\"application/json;charset=UTF-8\");\n        final PrintWriter writer = response.getWriter();\n        writer.write(\"{\\\"code\\\":\\\"200\\\",\\\"msg\\\":\\\"登录成功\\\"}\");\n        writer.close();\n    }\n}\n\n```\n登陆失败的处理器\n```java\npublic class MyUrlAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        final PrintWriter writer = response.getWriter();\n        if(exception.getMessage().equals(\"坏的凭证\")){\n            writer.write(\"{\\\"code\\\":\\\"401\\\",\\\"msg\\\":\\\"登录失败,用户名或者密码有误\\\"}\");\n            writer.close();\n        }else {\n            writer.write(\"{\\\"code\\\":\\\"401\\\",\\\"msg\\\":\\\"登录失败,\"+exception.getMessage()+\"\\\"}\");\n            writer.close();\n        }\n\n    }\n}\n\n```\n\n#### 说明：\n为什么要继承SimpleUrlAuthenticationFailureHandler和SimpleUrlAuthenticationSuccessHandler 而不是实现AuthenticationFailureHandler，还是那句话，为了少写代码少踩坑，我这里是返回json字符串，你也可以弄成重定向啥的，也比较容易。\nconfig再改一下：\n```java\n MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        return myUsernamePasswordAuthenticationFilte;\n    }\n```\n这里要注意 myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\"); 因为 http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);并不是替换掉UsernamePasswordAuthenticationFilter，而是和你自己添加的过滤器同时存在，security会根据url判断该走哪个过滤器，如果loginProcessingUrl还是“/login”的话走的是UsernamePasswordAuthenticationFilter，这里要留意一下。\n\n\n现在再加需求，我不仅需要普通登录方式，我想其他登录方式；\n实现方式：加多个认证器，每个认证器对应一种登录方式\n```java\npublic class MyAuthenticationProvider  implements AuthenticationProvider {\n    private UserDetailsService userDetailsService;\n    private BCryptPasswordEncoder bCryptPasswordEncoder;\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n//       这里写验证逻辑\n        return null;\n    }\n\n    @Override\n    public boolean supports(Class<?> aClass) {\n        return false;\n    }\n}\n\n```\n在改SecurityConfig\n```java\n @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().and().csrf().disable();\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n    }\n\n\n    MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());\n        return myUsernamePasswordAuthenticationFilte;\n    }\n    MyAuthenticationProvider getMyAuthenticationProvider(){\n        MyAuthenticationProvider myAuthenticationProvider = new MyAuthenticationProvider(userDetailService,new BCryptPasswordEncoder());\n        return myAuthenticationProvider;\n    }\n    DaoAuthenticationProvider daoAuthenticationProvider(){\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(new BCryptPasswordEncoder());\n        daoAuthenticationProvider.setUserDetailsService(userDetailService);\n        return daoAuthenticationProvider;\n    }\n    protected AuthenticationManager getAuthenticationManager()  {\n        ProviderManager authenticationManager = new ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));\n        return authenticationManager;\n    }\n```\n我再加需求：\n根据不同的客服端做不同的鉴权策略；\n实现方式：加投票器；\n```java\npublic class MyExpressionVoter extends WebExpressionVoter {\n    @Override\n    public int vote(Authentication authentication, FilterInvocation fi, Collection<ConfigAttribute> attributes) {\n//        这里写鉴权逻辑\n        return 0;\n    }\n}\n\n```\n\n再次改动config\n```java\n @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().accessDecisionManager(accessDecisionManager()).and().csrf().disable();\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n    }\n\n\n    MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());\n        return myUsernamePasswordAuthenticationFilte;\n    }\n    MyAuthenticationProvider getMyAuthenticationProvider(){\n        MyAuthenticationProvider myAuthenticationProvider = new MyAuthenticationProvider(userDetailService,new BCryptPasswordEncoder());\n        return myAuthenticationProvider;\n    }\n    DaoAuthenticationProvider daoAuthenticationProvider(){\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(new BCryptPasswordEncoder());\n        daoAuthenticationProvider.setUserDetailsService(userDetailService);\n        return daoAuthenticationProvider;\n    }\n    protected AuthenticationManager getAuthenticationManager()  {\n        ProviderManager authenticationManager = new ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));\n        return authenticationManager;\n    }\n\n    public AccessDecisionManager accessDecisionManager(){\n        List<AccessDecisionVoter<? extends Object>> decisionVoters\n                = Arrays.asList(\n                new MyExpressionVoter(),\n                new WebExpressionVoter(),\n                new RoleVoter(),\n                new AuthenticatedVoter());\n        return new UnanimousBased(decisionVoters);\n    }\n```\n在加两个鉴权失败处理器\n```java\npublic class MyAccessDeniedHandler implements AccessDeniedHandler {\n    @Override\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {\n        response.setContentType(\"application/json;charset=UTF-8\");\n        PrintWriter writer = response.getWriter();\n        writer.write(\"{\\\"code\\\":\\\"403\\\",\\\"msg\\\":\\\"没有权限\\\"}\");\n        writer.close();\n    }\n}\n\n```\n再加一个登出处理器\n\n```java\n\npublic class MyLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {\n        final PrintWriter writer = response.getWriter();\n\n        writer.write(\"{\\\"code\\\":\\\"200\\\",\\\"msg\\\":\\\"登出成功\\\"}\");\n        writer.close();\n    }\n}\n\n```\n最后修改SecurityConfig，最终模样为\n```java\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Autowired\n    RedisService redisService;\n    @Autowired\n    MyUserDetailService userDetailService;\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.userDetailsService(userDetailService).passwordEncoder(new BCryptPasswordEncoder());\n    }\n    @Override\n    public void configure(WebSecurity web) throws Exception {\n\n        web.ignoring().antMatchers(\"/resources/**/*.html\", \"/resources/**/*.js\",\n                \"/resources/**/*.css\", \"/resources/**/*.txt\",\n                \"/resources/**/*.png\", \"/**/*.bmp\", \"/**/*.gif\", \"/**/*.png\", \"/**/*.jpg\", \"/**/*.ico\");\n//        super.configure(web);\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n       http.formLogin().loginPage(\"/login_page\").passwordParameter(\"username\").passwordParameter(\"password\").loginProcessingUrl(\"/sign_in\").permitAll()\n               .and().authorizeRequests().antMatchers(\"/test\").hasRole(\"test\").anyRequest().authenticated().accessDecisionManager(accessDecisionManager())\n               .and().logout().logoutSuccessHandler(new MyLogoutSuccessHandler())\n               .and().csrf().disable();\n        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);\n        http.exceptionHandling().accessDeniedHandler(new MyAccessDeniedHandler());\n    }\n\n\n    MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){\n        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = new MyUsernamePasswordAuthenticationFilte(redisService);\n        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());\n        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());\n        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(\"/sign_in\");\n        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());\n        return myUsernamePasswordAuthenticationFilte;\n    }\n    MyAuthenticationProvider getMyAuthenticationProvider(){\n        MyAuthenticationProvider myAuthenticationProvider = new MyAuthenticationProvider(userDetailService,new BCryptPasswordEncoder());\n        return myAuthenticationProvider;\n    }\n    DaoAuthenticationProvider daoAuthenticationProvider(){\n        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();\n        daoAuthenticationProvider.setPasswordEncoder(new BCryptPasswordEncoder());\n        daoAuthenticationProvider.setUserDetailsService(userDetailService);\n        return daoAuthenticationProvider;\n    }\n    protected AuthenticationManager getAuthenticationManager()  {\n        ProviderManager authenticationManager = new ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));\n        return authenticationManager;\n    }\n\n    public AccessDecisionManager accessDecisionManager(){\n        List<AccessDecisionVoter<? extends Object>> decisionVoters\n                = Arrays.asList(\n                new MyExpressionVoter(),\n                new WebExpressionVoter(),\n                new RoleVoter(),\n                new AuthenticatedVoter());\n        return new UnanimousBased(decisionVoters);\n\n    }\n}\n```\n\n你可能想要用jwtToken 做token鉴权的方式；\n也好做，我这里提一下思路，鉴权都是在投票器里面，那我们在投票器之前填充好securitycontext就成，然后实现一个自己的投票器；填充securitycontext随便找个过滤器http.addFilterAfter() 然后在过滤器里面填充好就行，至于拿token的接口，在config里用.permitAll()放行就行了，比上面的改法还简单，我就不写了。\n\n#### 题外话\n\n具体的代码可以参考我的项目[poseindon](https://github.com/muggle0/poseidon/wiki)，这种security改动方式我经过生产实践的，不会有问题。另外篇幅有点长 感谢大佬的阅读。\n","slug":"springSecurity深度解析","published":1,"updated":"2021-01-11T07:31:23.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh79004s00wihl5x0zdu","content":"<p>作者：muggle</p>\n<h4 id=\"从一个基础的springsecurity开始，进行代码跟踪分析其原理\"><a href=\"#从一个基础的springsecurity开始，进行代码跟踪分析其原理\" class=\"headerlink\" title=\"从一个基础的springsecurity开始，进行代码跟踪分析其原理\"></a>从一个基础的springsecurity开始，进行代码跟踪分析其原理</h4><p>springsecurity是一个典型的责任链模式；我们先新建一个springboot项目，进行最基本的springsecurity配置，然后debug;我这里使用的开发工具是idea.建议大家也使用idea来进行日常开发。好了话不多说，开始：</p>\n<p>第一步</p>\n<p>新建springboot项目 maven依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.security<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-security-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>启动项目，控制台上会输出这样一段字符串：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2019</span>-<span class=\"number\">04</span>-<span class=\"number\">11</span> 09:<span class=\"number\">47</span>:<span class=\"number\">40.388</span>  INFO <span class=\"number\">16716</span> --- [           main] .s.s.UserDetailsServiceAutoConfiguration :</span><br><span class=\"line\"></span><br><span class=\"line\">Using generated security password: a6d55bc6-49fb-<span class=\"number\">4241</span>-a5ae-527e5e644731</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>现在我们访问 <a href=\"http://localhost:8080\">http://localhost:8080</a> 会自动跳转到 <a href=\"http://localhost:8080/login，并弹出一个登陆页面，用户名输user,密码输上面的字符串：\">http://localhost:8080/login，并弹出一个登陆页面，用户名输user,密码输上面的字符串：</a> a6d55bc6-49fb-4241-a5ae-527e5e644731，每次字符串都是随机的，要留意你的控制台打印的字符串，登陆成功了，现在我们开始debug,看看一次登陆和一次登陆后访问一次不登陆访问这三种情况security都做了哪些事情。</p>\n<p>先写一个接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;test&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hi 你好啊&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>springsecurity 执行过程是走一条过滤器链，所以我们要先明白，有哪些过滤器，并在过滤器上打上断点追踪，下面贴出各个过滤器名称及作用：</p>\n<blockquote>\n<p>1、WebAsyncManagerIntegrationFilter<br>将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。<br>2、SecurityContextPersistenceFilter<br>在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除<br>例如在Session中维护一个用户的安全信息就是这个过滤器处理的。<br>3、HeaderWriterFilter<br>用于将头信息加入响应中<br>4、CsrfFilter<br>用于处理跨站请求伪造<br>5、LogoutFilter<br>用于处理退出登录<br>6、UsernamePasswordAuthenticationFilter<br>用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。<br>从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。<br>7、DefaultLoginPageGeneratingFilter<br>如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。<br>8、BasicAuthenticationFilter<br>处理请求头信息，DigestAuthenticationFilter<br>9、RequestCacheAwareFilter<br>用来处理请求的缓存<br>10、SecurityContextHolderAwareRequestFilter<br>11、AnonymousAuthenticationFilter<br>12、SessionManagementFilter<br>13、ExceptionTranslationFilter<br>处理 AccessDeniedException 和 AuthenticationException 异常<br>14、FilterSecurityInterceptor<br>AbstractInterceptUrlConfigurer.createFilterSecurityInterceptor<br>15、RememberMeAuthenticationFilter的作用是, 当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统.</p>\n</blockquote>\n<p>先不管那么多，ctr+alt+shift+t（或者按两下shift） 输入类名找到类，打断点，开始debug</p>\n<h4 id=\"springsecurity-的默认登陆url是-login-我们访问一下来捋一捋：\"><a href=\"#springsecurity-的默认登陆url是-login-我们访问一下来捋一捋：\" class=\"headerlink\" title=\"springsecurity 的默认登陆url是/login:我们访问一下来捋一捋：\"></a>springsecurity 的默认登陆url是/login:我们访问一下来捋一捋：</h4><p>其代码顺序是：<br><code>WebAsyncManagerIntegrationFilter</code>  -&gt; <code>SecurityContextPersistenceFilter</code> -&gt; <code>HeaderWriterFilter</code> -&gt; <code>CsrfFilter</code> -&gt; <code>LogoutFilter</code> -&gt; <code>DefaultLoginPageGeneratingFilter</code></p>\n<p>然后浏览器会返回一个登陆页面：<br><img src=\"https://upload-images.jianshu.io/upload_images/13612520-d6e336c80cbf30c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h4><p>这其实是发起了一个请求登陆页面的请求，请求首先进入<code>WebAsyncManagerIntegrationFilter</code> 这个过滤器做了什么我们不必去关系，它下一个过滤器<code>SecurityContextPersistenceFilter</code> 通过request的attribute来上了一次请求锁，并且对SecurityContextHolder进行了管理；而SecurityContextHolder是对用户信息进行管理的一套系统，分为三大类</p>\n<ol>\n<li>SecurityContextHolder 对用户信息增删改查的操作<ol start=\"2\">\n<li>SecurityContext 将用户名，权限等封装成该对象</li>\n<li>SecurityContextHolderStrategy 用于存储 SecurityContext</li>\n</ol>\n</li>\n</ol>\n<p>默认的SecurityContextHolderStrategy 实现类是ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。<br>下一个过滤器<code>HeaderWriterFilter</code>请求和响应封装了一下，用于<code>CsrfFilter</code>鉴别csrf攻击 <code>LogoutFilter</code>判断是不是登出操作，如果是则不执行下面的过滤器，而执行登出的相关操作，DefaultLoginPageGeneratingFilter生成登录页</p>\n<p>我们先输入正确的代码登陆一次</p>\n<p>通过跟踪代码发现其执行顺序是：<br><code>WebAsyncManagerIntegrationFilter</code> -&gt; <code>SecurityContextPersistenceFilter</code> -&gt; <code>HeaderWriterFilter</code>-&gt;<code>CsrfFilter</code>-&gt; <code>LogoutFilter</code>-&gt;<code>UsernamePasswordAuthenticationFilter</code>-&gt;<code>WebAsyncManagerIntegrationFilter</code>-&gt;<code>SecurityContextPersistenceFilter</code>-&gt;<code>HeaderWriterFilter</code>-&gt;<code>CsrfFilter</code>-&gt;<code>LogoutFilter</code>-&gt;<code>DefaultLoginPageGeneratingFilter</code>-&gt;<code>BasicAuthenticationFilter</code>-&gt;<code>RequestCacheAwareFilter</code>-&gt;<code>SecurityContextHolderAwareRequestFilter</code>-&gt;<code>AnonymousAuthenticationFilter</code>-&gt;<code>SessionManagementFilter</code>-&gt;<code>ExceptionTranslationFilter</code>-&gt;<code>FilterSecurityInterceptor</code>-&gt;<code>SecurityContextPersistenceFilter</code>-&gt;<code>LogoutFilter</code>-&gt;<code>DefaultLoginPageGeneratingFilter</code>-&gt;<code>RequestCacheAwareFilter</code>-&gt;<code>SecurityContextHolderAwareRequestFilter</code>-&gt;<code>AnonymousAuthenticationFilter</code>-&gt;<code>SessionManagementFilter</code>-&gt;<code>ExceptionTranslationFilter</code>-&gt;<code>FilterSecurityInterceptor</code></p>\n<p>这一次之所以过滤器链跑这么长是因为，这里可以认为发起了三次请求，第一次请求是登陆，登陆成功后转发到 url 为“/”的接口，而我没有这个接口，发生了重定向到“/error” 而“/error”页面是springboot请求失败的错误页面返回机制。<br><code>WebAsyncManagerIntegrationFilter</code> -&gt; <code>SecurityContextPersistenceFilter</code> -&gt; <code>HeaderWriterFilter</code>-&gt;<code>CsrfFilter</code>-&gt; <code>LogoutFilter</code>-&gt;<code>UsernamePasswordAuthenticationFilter</code> 这一过程登陆请求。</p>\n<p><code>WebAsyncManagerIntegrationFilter</code>-&gt;<code>SecurityContextPersistenceFilter</code>-&gt;<code>HeaderWriterFilter</code>-&gt;<code>CsrfFilter</code>-&gt;<code>LogoutFilter</code>-&gt;<code>DefaultLoginPageGeneratingFilter</code>-&gt;<code>BasicAuthenticationFilter</code>-&gt;<code>RequestCacheAwareFilter</code>-&gt;<code>SecurityContextHolderAwareRequestFilter</code>-&gt;<code>AnonymousAuthenticationFilter</code>-&gt;<code>SessionManagementFilter</code>-&gt;<code>ExceptionTranslationFilter</code>-&gt;<code>FilterSecurityInterceptor</code><br>这是转发到“/”的过程</p>\n<p><code>SecurityContextPersistenceFilter</code>-&gt;<code>LogoutFilter</code>-&gt;<code>DefaultLoginPageGeneratingFilter</code>-&gt;<code>RequestCacheAwareFilter</code>-&gt;<code>SecurityContextHolderAwareRequestFilter</code>-&gt;<code>AnonymousAuthenticationFilter</code>-&gt;<code>SessionManagementFilter</code>-&gt;<code>ExceptionTranslationFilter</code>-&gt;<code>FilterSecurityInterceptor</code><br>这是重定向到error的过程</p>\n<p>接下来访问一下我们的/test接口<br>看看执行顺序：<br><code>WebAsyncManagerIntegrationFilter</code>-&gt;<code>SecurityContextPersistenceFilter</code>-&gt;<code>HeaderWriterFilter</code>-&gt;<code>CsrfFilter</code>-&gt;<code>LogoutFilter</code>-&gt;<code>DefaultLoginPageGeneratingFilter</code>-&gt;<code>BasicAuthenticationFilter</code>-&gt;<code>RequestCacheAwareFilter</code>-&gt;<code>SecurityContextHolderAwareRequestFilter</code>-&gt;<code>AnonymousAuthenticationFilter</code>-&gt;<code>SessionManagementFilter</code>-&gt;<code>ExceptionTranslationFilter</code>-&gt;<code>FilterSecurityInterceptor</code></p>\n<h4 id=\"说明：-1\"><a href=\"#说明：-1\" class=\"headerlink\" title=\"说明：\"></a>说明：</h4><p>BasicAuthenticationFilter就是看你请求头里面有没有basic开头的东西，有的话做一些处理，对我们来说没啥用，不必去关心，RequestCacheAwareFilter对请求和响应做了额外处理 SecurityContextHolderAwareRequestFilter 也是对请求做了一些额外处理，我们同样不去关心它。AnonymousAuthenticationFilter过滤器是当securitycontext为null时填充一个匿名权限，这里被执行的原因因为security未配置完全，后面进一步配置了之后再回来详解。ExceptionTranslationFilter是对鉴权或者登陆异常的处理过滤器，FilterSecurityInterceptor可以看做是过滤器链的出口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">       FilterInvocation fi = <span class=\"keyword\">new</span> FilterInvocation(request, response, chain);</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.invoke(fi);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这个fi就是请求的url值。</p>\n<p>现在我们完善一下security配置，让它复杂一点<br>实现 GrantedAuthority：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyGrantedAuthority</span> <span class=\"keyword\">implements</span> <span class=\"title\">GrantedAuthority</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String authority;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现UserDetails</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@Accessors(chain = true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUserDetail</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDetails</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;MyGrantedAuthority&gt; authorities;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> accountNonExpired;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> accountNonLocked;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> credentialsNonExpired;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> enabled;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>实现UserDetailsService</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUserDetailService</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDetailsService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserDetails <span class=\"title\">loadUserByUsername</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class=\"line\">        List&lt;MyGrantedAuthority&gt; authorities = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        MyGrantedAuthority myGrantedAuthority = <span class=\"keyword\">new</span> MyGrantedAuthority();</span><br><span class=\"line\">        myGrantedAuthority.setAuthority(<span class=\"string\">&quot;ROLE_test&quot;</span>);</span><br><span class=\"line\">        BCryptPasswordEncoder bCryptPasswordEncoder = <span class=\"keyword\">new</span> BCryptPasswordEncoder();</span><br><span class=\"line\">        String test = bCryptPasswordEncoder.encode(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">        authorities.add(myGrantedAuthority);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyUserDetail().setAuthorities(authorities).setAccountNonExpired(<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .setAccountNonLocked(<span class=\"keyword\">true</span>).setCredentialsNonExpired(<span class=\"keyword\">true</span>).setEnabled(<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .setPassword(test).setUsername(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重写security适配器WebSecurityConfigurerAdapter：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    MyUserDetailService userDetailService;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthenticationManagerBuilder auth)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        auth.userDetailsService(userDetailService).passwordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        web.ignoring().antMatchers(<span class=\"string\">&quot;/resources/**/*.html&quot;</span>, <span class=\"string\">&quot;/resources/**/*.js&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.css&quot;</span>, <span class=\"string\">&quot;/resources/**/*.txt&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.bmp&quot;</span>, <span class=\"string\">&quot;/**/*.gif&quot;</span>, <span class=\"string\">&quot;/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.jpg&quot;</span>, <span class=\"string\">&quot;/**/*.ico&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        super.configure(web);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">               .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().and().csrf().disable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里比开始又要复杂一点了，我先对相关操作进行说明一下：<br>先从SecurityConfig说起</p>\n<p>重写了三个config方法<br>1.第一个config涉及到的问题比较深——security的认证鉴权系统；<br>先说认证的过程，当过滤器跑到usernamepasswordFilter的时候就开始做认证了</p>\n<h4 id=\"security认证原理\"><a href=\"#security认证原理\" class=\"headerlink\" title=\"security认证原理\"></a>security认证原理</h4><p>认证的工作是交给AuthenticationManager去做，AuthenticationManager下有多个认证器 AuthenticationProvider<br>只要其中一个AuthenticationProvider通过认证就算登陆成功，而且在认证器中抛出异常，无法终止认证流程只是算该认证器未通过。<br>第一个config就算配置了一个AuthenticationManagerBuilder 这个类会生成一个 AuthenticationManager和DaoAuthenticationProvider认证器，认证调用userdetailservice 的loadUserByUsername方法来和你传入的username passworde做比较，password 是通过BCryptPasswordEncoder来做编码后比较的，这样做是为了提高安全性。</p>\n<p>2.第二个config是对静态资源的放行；</p>\n<p>3.第三个config 配置了登录页请求路径，登陆认证路径，用户名密码属性，和一个test权限，注意一点：我在config配的是hasRole(“test”)，我设置的权限是  myGrantedAuthority.setAuthority(“ROLE_test”);为什么这样弄后面会说。<br>接下来完善一下，边边角角，写个登陆的HTML,一个登陆页面请求接口:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;/sign_in&quot;</span>&gt;</span></span><br><span class=\"line\">    用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;test&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;test&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;verification&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/login_page&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">loginPage</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;loginPage.html&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>启动项目，访问localhost:8080/test<br>跳转到了/login_page<br><img src=\"https://upload-images.jianshu.io/upload_images/13612520-40e8574ede6fdade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>点登陆，debug看看有什么不同 新增的断点DaoAuthenticationProvider和MyUserDetailService<br>前面执行顺序还是一样，到SecurityContextHolderAwareRequestFilter的时候我们注意一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityContextHolderAwareRequestFilter</span> <span class=\"keyword\">extends</span> <span class=\"title\">GenericFilterBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String rolePrefix = <span class=\"string\">&quot;ROLE_&quot;</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们权限设置的前缀就是从这来的 到后面讲投票器的时候再细说。<br>到UsernamePasswordAuthenticationFilter这个过滤器后 下一步到了DaoAuthenticationProvider验证器，验证器执行的是其父类AbstractUserDetailsAuthenticationProvider的authenticate（）方法同时我们看到MyUserDetailService的loadUserByUsername被调用，最后，认证结束转发到访问前路径/test 重新走过滤器。流程和一开始的简单配置一样，走到FilterSecurityInterceptor的时候进入WebExpressionVoter了投票器；</p>\n<h4 id=\"security的投票器：\"><a href=\"#security的投票器：\" class=\"headerlink\" title=\"security的投票器：\"></a>security的投票器：</h4><p>当过滤器链走到尽头（FilterSecurityInterceptor）下一步就是鉴权了，鉴权功能会交给AccessDecisionManager去处理，而AccessDecisionManager下又有多个投票器，其中WebExpressionVoter是security的一个默认投票器，我们来分析一下这个类：<br>其有个这样的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">vote</span><span class=\"params\">(Authentication authentication, FilterInvocation fi, Collection&lt;ConfigAttribute&gt; attributes)</span></span></span><br></pre></td></tr></table></figure>\n<p>返回int类型，1表示赞成，0表示弃权，-1表示反对。当所有投票器的vote执行结束，如果最终结果小于0表示不通过，<br>方法的参数说明：</p>\n<ol>\n<li>FilterInvocation  可获得请求的相关信息，比如请求方式（get post）url 等</li>\n<li>authentication 是从securitycontext中拿出来的用户信息</li>\n<li>Collection<ConfigAttribute> 是可以访问该路径的权限集合。也就是前面SecurityContextHolderAwareRequestFilter 查找出来的权限，对于在WebSecurityConfigurerAdapter config方法中的hasRole(“test”)权限规则并不是直接取权限 test,而是加了前缀rolePrefix（“ROLE_”），这个前缀也是可配置的配置方式：<a href=\"https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#appendix-faq-role-prefix\">https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#appendix-faq-role-prefix</a></li>\n</ol>\n<p>一些基本的知识点交代的差不多了，现在，我进行下一步</p>\n<h4 id=\"security魔改\"><a href=\"#security魔改\" class=\"headerlink\" title=\"security魔改\"></a>security魔改</h4><p>需求：我希望后端能做验证码校验，没通过校验的直接登录失败；<br>实现方式：security给我们提供了在各个过滤器上追加过滤器的方法，我们在UsernamePasswordAuthenticationFilter追加一个过滤器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUsernamePasswordAuthenticationFilte</span> <span class=\"keyword\">extends</span> <span class=\"title\">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisService redisService;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> postOnly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyUsernamePasswordAuthenticationFilte</span><span class=\"params\">(RedisService redisService)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.redisService=redisService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Authentication <span class=\"title\">attemptAuthentication</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\">        redisService.getcCode(request);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.attemptAuthentication(request,response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里redisService 就是你要弄的验证逻辑，其他代码还是从父类那复制过来，不去动它。<br>为什么要继承UsernamePasswordAuthenticationFilter 而不是继承AbstractAuthenticationProcessingFilter，这样做的好处是可以少写代码少踩坑。<br>然后修改config</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\">RedisService redisService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">      http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">              .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().and().csrf().disable();</span><br><span class=\"line\">       http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>我在加两个处理器，当我登陆成功或者失败，由我自己弄；<br>登陆成功处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAuthenticationSuccessHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleUrlAuthenticationSuccessHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthenticationSuccess</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;200\\&quot;,\\&quot;msg\\&quot;:\\&quot;登录成功\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>登陆失败的处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUrlAuthenticationFailureHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleUrlAuthenticationFailureHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthenticationFailure</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(exception.getMessage().equals(<span class=\"string\">&quot;坏的凭证&quot;</span>))&#123;</span><br><span class=\"line\">            writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;401\\&quot;,\\&quot;msg\\&quot;:\\&quot;登录失败,用户名或者密码有误\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">            writer.close();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;401\\&quot;,\\&quot;msg\\&quot;:\\&quot;登录失败,&quot;</span>+exception.getMessage()+<span class=\"string\">&quot;\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">            writer.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"说明：-2\"><a href=\"#说明：-2\" class=\"headerlink\" title=\"说明：\"></a>说明：</h4><p>为什么要继承SimpleUrlAuthenticationFailureHandler和SimpleUrlAuthenticationSuccessHandler 而不是实现AuthenticationFailureHandler，还是那句话，为了少写代码少踩坑，我这里是返回json字符串，你也可以弄成重定向啥的，也比较容易。<br>config再改一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这里要注意 myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(“/sign_in”); 因为 http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);并不是替换掉UsernamePasswordAuthenticationFilter，而是和你自己添加的过滤器同时存在，security会根据url判断该走哪个过滤器，如果loginProcessingUrl还是“/login”的话走的是UsernamePasswordAuthenticationFilter，这里要留意一下。</p>\n<p>现在再加需求，我不仅需要普通登录方式，我想其他登录方式；<br>实现方式：加多个认证器，每个认证器对应一种登录方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAuthenticationProvider</span>  <span class=\"keyword\">implements</span> <span class=\"title\">AuthenticationProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDetailsService userDetailsService;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Authentication <span class=\"title\">authenticate</span><span class=\"params\">(Authentication authentication)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//       这里写验证逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在改SecurityConfig</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">      http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">              .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().and().csrf().disable();</span><br><span class=\"line\">       http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\">MyAuthenticationProvider <span class=\"title\">getMyAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyAuthenticationProvider myAuthenticationProvider = <span class=\"keyword\">new</span> MyAuthenticationProvider(userDetailService,<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myAuthenticationProvider;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\">DaoAuthenticationProvider <span class=\"title\">daoAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       DaoAuthenticationProvider daoAuthenticationProvider = <span class=\"keyword\">new</span> DaoAuthenticationProvider();</span><br><span class=\"line\">       daoAuthenticationProvider.setPasswordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">       daoAuthenticationProvider.setUserDetailsService(userDetailService);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> daoAuthenticationProvider;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationManager <span class=\"title\">getAuthenticationManager</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">       ProviderManager authenticationManager = <span class=\"keyword\">new</span> ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));</span><br><span class=\"line\">       <span class=\"keyword\">return</span> authenticationManager;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>我再加需求：<br>根据不同的客服端做不同的鉴权策略；<br>实现方式：加投票器；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExpressionVoter</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebExpressionVoter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">vote</span><span class=\"params\">(Authentication authentication, FilterInvocation fi, Collection&lt;ConfigAttribute&gt; attributes)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        这里写鉴权逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>再次改动config</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">      http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">              .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().accessDecisionManager(accessDecisionManager()).and().csrf().disable();</span><br><span class=\"line\">       http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\">MyAuthenticationProvider <span class=\"title\">getMyAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyAuthenticationProvider myAuthenticationProvider = <span class=\"keyword\">new</span> MyAuthenticationProvider(userDetailService,<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myAuthenticationProvider;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\">DaoAuthenticationProvider <span class=\"title\">daoAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       DaoAuthenticationProvider daoAuthenticationProvider = <span class=\"keyword\">new</span> DaoAuthenticationProvider();</span><br><span class=\"line\">       daoAuthenticationProvider.setPasswordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">       daoAuthenticationProvider.setUserDetailsService(userDetailService);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> daoAuthenticationProvider;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationManager <span class=\"title\">getAuthenticationManager</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">       ProviderManager authenticationManager = <span class=\"keyword\">new</span> ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));</span><br><span class=\"line\">       <span class=\"keyword\">return</span> authenticationManager;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> AccessDecisionManager <span class=\"title\">accessDecisionManager</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters</span><br><span class=\"line\">               = Arrays.asList(</span><br><span class=\"line\">               <span class=\"keyword\">new</span> MyExpressionVoter(),</span><br><span class=\"line\">               <span class=\"keyword\">new</span> WebExpressionVoter(),</span><br><span class=\"line\">               <span class=\"keyword\">new</span> RoleVoter(),</span><br><span class=\"line\">               <span class=\"keyword\">new</span> AuthenticatedVoter());</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UnanimousBased(decisionVoters);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>在加两个鉴权失败处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAccessDeniedHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessDeniedHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse response, AccessDeniedException e)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;403\\&quot;,\\&quot;msg\\&quot;:\\&quot;没有权限\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>再加一个登出处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLogoutSuccessHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">LogoutSuccessHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLogoutSuccess</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse response, Authentication authentication)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\"></span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;200\\&quot;,\\&quot;msg\\&quot;:\\&quot;登出成功\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>最后修改SecurityConfig，最终模样为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisService redisService;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    MyUserDetailService userDetailService;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthenticationManagerBuilder auth)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        auth.userDetailsService(userDetailService).passwordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        web.ignoring().antMatchers(<span class=\"string\">&quot;/resources/**/*.html&quot;</span>, <span class=\"string\">&quot;/resources/**/*.js&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.css&quot;</span>, <span class=\"string\">&quot;/resources/**/*.txt&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.bmp&quot;</span>, <span class=\"string\">&quot;/**/*.gif&quot;</span>, <span class=\"string\">&quot;/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.jpg&quot;</span>, <span class=\"string\">&quot;/**/*.ico&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        super.configure(web);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">               .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().accessDecisionManager(accessDecisionManager())</span><br><span class=\"line\">               .and().logout().logoutSuccessHandler(<span class=\"keyword\">new</span> MyLogoutSuccessHandler())</span><br><span class=\"line\">               .and().csrf().disable();</span><br><span class=\"line\">        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\">        http.exceptionHandling().accessDeniedHandler(<span class=\"keyword\">new</span> MyAccessDeniedHandler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">MyAuthenticationProvider <span class=\"title\">getMyAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MyAuthenticationProvider myAuthenticationProvider = <span class=\"keyword\">new</span> MyAuthenticationProvider(userDetailService,<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myAuthenticationProvider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">DaoAuthenticationProvider <span class=\"title\">daoAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        DaoAuthenticationProvider daoAuthenticationProvider = <span class=\"keyword\">new</span> DaoAuthenticationProvider();</span><br><span class=\"line\">        daoAuthenticationProvider.setPasswordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">        daoAuthenticationProvider.setUserDetailsService(userDetailService);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> daoAuthenticationProvider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationManager <span class=\"title\">getAuthenticationManager</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">        ProviderManager authenticationManager = <span class=\"keyword\">new</span> ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AccessDecisionManager <span class=\"title\">accessDecisionManager</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters</span><br><span class=\"line\">                = Arrays.asList(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MyExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> WebExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> RoleVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> AuthenticatedVoter());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UnanimousBased(decisionVoters);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可能想要用jwtToken 做token鉴权的方式；<br>也好做，我这里提一下思路，鉴权都是在投票器里面，那我们在投票器之前填充好securitycontext就成，然后实现一个自己的投票器；填充securitycontext随便找个过滤器http.addFilterAfter() 然后在过滤器里面填充好就行，至于拿token的接口，在config里用.permitAll()放行就行了，比上面的改法还简单，我就不写了。</p>\n<h4 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h4><p>具体的代码可以参考我的项目<a href=\"https://github.com/muggle0/poseidon/wiki\">poseindon</a>，这种security改动方式我经过生产实践的，不会有问题。另外篇幅有点长 感谢大佬的阅读。</p>\n","site":{"data":{}},"excerpt":"<p>作者：muggle</p>\n<h4 id=\"从一个基础的springsecurity开始，进行代码跟踪分析其原理\"><a href=\"#从一个基础的springsecurity开始，进行代码跟踪分析其原理\" class=\"headerlink\" title=\"从一个基础的springsecurity开始，进行代码跟踪分析其原理\"></a>从一个基础的springsecurity开始，进行代码跟踪分析其原理</h4><p>springsecurity是一个典型的责任链模式；我们先新建一个springboot项目，进行最基本的springsecurity配置，然后debug;我这里使用的开发工具是idea.建议大家也使用idea来进行日常开发。好了话不多说，开始：</p>\n<p>第一步</p>\n<p>新建springboot项目 maven依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.security<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-security-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>启动项目，控制台上会输出这样一段字符串：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2019</span>-<span class=\"number\">04</span>-<span class=\"number\">11</span> 09:<span class=\"number\">47</span>:<span class=\"number\">40.388</span>  INFO <span class=\"number\">16716</span> --- [           main] .s.s.UserDetailsServiceAutoConfiguration :</span><br><span class=\"line\"></span><br><span class=\"line\">Using generated security password: a6d55bc6-49fb-<span class=\"number\">4241</span>-a5ae-527e5e644731</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","more":"<p>现在我们访问 <a href=\"http://localhost:8080\">http://localhost:8080</a> 会自动跳转到 <a href=\"http://localhost:8080/login，并弹出一个登陆页面，用户名输user,密码输上面的字符串：\">http://localhost:8080/login，并弹出一个登陆页面，用户名输user,密码输上面的字符串：</a> a6d55bc6-49fb-4241-a5ae-527e5e644731，每次字符串都是随机的，要留意你的控制台打印的字符串，登陆成功了，现在我们开始debug,看看一次登陆和一次登陆后访问一次不登陆访问这三种情况security都做了哪些事情。</p>\n<p>先写一个接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;test&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hi 你好啊&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>springsecurity 执行过程是走一条过滤器链，所以我们要先明白，有哪些过滤器，并在过滤器上打上断点追踪，下面贴出各个过滤器名称及作用：</p>\n<blockquote>\n<p>1、WebAsyncManagerIntegrationFilter<br>将Security上下文与Spring Web中用于处理异步请求映射的 WebAsyncManager 进行集成。<br>2、SecurityContextPersistenceFilter<br>在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除<br>例如在Session中维护一个用户的安全信息就是这个过滤器处理的。<br>3、HeaderWriterFilter<br>用于将头信息加入响应中<br>4、CsrfFilter<br>用于处理跨站请求伪造<br>5、LogoutFilter<br>用于处理退出登录<br>6、UsernamePasswordAuthenticationFilter<br>用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自“/login”的请求。<br>从表单中获取用户名和密码时，默认使用的表单name值为“username”和“password”，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。<br>7、DefaultLoginPageGeneratingFilter<br>如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。<br>8、BasicAuthenticationFilter<br>处理请求头信息，DigestAuthenticationFilter<br>9、RequestCacheAwareFilter<br>用来处理请求的缓存<br>10、SecurityContextHolderAwareRequestFilter<br>11、AnonymousAuthenticationFilter<br>12、SessionManagementFilter<br>13、ExceptionTranslationFilter<br>处理 AccessDeniedException 和 AuthenticationException 异常<br>14、FilterSecurityInterceptor<br>AbstractInterceptUrlConfigurer.createFilterSecurityInterceptor<br>15、RememberMeAuthenticationFilter的作用是, 当用户没有登录而直接访问资源时, 从cookie里找出用户的信息, 如果Spring Security能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统.</p>\n</blockquote>\n<p>先不管那么多，ctr+alt+shift+t（或者按两下shift） 输入类名找到类，打断点，开始debug</p>\n<h4 id=\"springsecurity-的默认登陆url是-login-我们访问一下来捋一捋：\"><a href=\"#springsecurity-的默认登陆url是-login-我们访问一下来捋一捋：\" class=\"headerlink\" title=\"springsecurity 的默认登陆url是/login:我们访问一下来捋一捋：\"></a>springsecurity 的默认登陆url是/login:我们访问一下来捋一捋：</h4><p>其代码顺序是：<br><code>WebAsyncManagerIntegrationFilter</code>  -&gt; <code>SecurityContextPersistenceFilter</code> -&gt; <code>HeaderWriterFilter</code> -&gt; <code>CsrfFilter</code> -&gt; <code>LogoutFilter</code> -&gt; <code>DefaultLoginPageGeneratingFilter</code></p>\n<p>然后浏览器会返回一个登陆页面：<br><img src=\"https://upload-images.jianshu.io/upload_images/13612520-d6e336c80cbf30c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h4><p>这其实是发起了一个请求登陆页面的请求，请求首先进入<code>WebAsyncManagerIntegrationFilter</code> 这个过滤器做了什么我们不必去关系，它下一个过滤器<code>SecurityContextPersistenceFilter</code> 通过request的attribute来上了一次请求锁，并且对SecurityContextHolder进行了管理；而SecurityContextHolder是对用户信息进行管理的一套系统，分为三大类</p>\n<ol>\n<li>SecurityContextHolder 对用户信息增删改查的操作<ol start=\"2\">\n<li>SecurityContext 将用户名，权限等封装成该对象</li>\n<li>SecurityContextHolderStrategy 用于存储 SecurityContext</li>\n</ol>\n</li>\n</ol>\n<p>默认的SecurityContextHolderStrategy 实现类是ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。<br>下一个过滤器<code>HeaderWriterFilter</code>请求和响应封装了一下，用于<code>CsrfFilter</code>鉴别csrf攻击 <code>LogoutFilter</code>判断是不是登出操作，如果是则不执行下面的过滤器，而执行登出的相关操作，DefaultLoginPageGeneratingFilter生成登录页</p>\n<p>我们先输入正确的代码登陆一次</p>\n<p>通过跟踪代码发现其执行顺序是：<br><code>WebAsyncManagerIntegrationFilter</code> -&gt; <code>SecurityContextPersistenceFilter</code> -&gt; <code>HeaderWriterFilter</code>-&gt;<code>CsrfFilter</code>-&gt; <code>LogoutFilter</code>-&gt;<code>UsernamePasswordAuthenticationFilter</code>-&gt;<code>WebAsyncManagerIntegrationFilter</code>-&gt;<code>SecurityContextPersistenceFilter</code>-&gt;<code>HeaderWriterFilter</code>-&gt;<code>CsrfFilter</code>-&gt;<code>LogoutFilter</code>-&gt;<code>DefaultLoginPageGeneratingFilter</code>-&gt;<code>BasicAuthenticationFilter</code>-&gt;<code>RequestCacheAwareFilter</code>-&gt;<code>SecurityContextHolderAwareRequestFilter</code>-&gt;<code>AnonymousAuthenticationFilter</code>-&gt;<code>SessionManagementFilter</code>-&gt;<code>ExceptionTranslationFilter</code>-&gt;<code>FilterSecurityInterceptor</code>-&gt;<code>SecurityContextPersistenceFilter</code>-&gt;<code>LogoutFilter</code>-&gt;<code>DefaultLoginPageGeneratingFilter</code>-&gt;<code>RequestCacheAwareFilter</code>-&gt;<code>SecurityContextHolderAwareRequestFilter</code>-&gt;<code>AnonymousAuthenticationFilter</code>-&gt;<code>SessionManagementFilter</code>-&gt;<code>ExceptionTranslationFilter</code>-&gt;<code>FilterSecurityInterceptor</code></p>\n<p>这一次之所以过滤器链跑这么长是因为，这里可以认为发起了三次请求，第一次请求是登陆，登陆成功后转发到 url 为“/”的接口，而我没有这个接口，发生了重定向到“/error” 而“/error”页面是springboot请求失败的错误页面返回机制。<br><code>WebAsyncManagerIntegrationFilter</code> -&gt; <code>SecurityContextPersistenceFilter</code> -&gt; <code>HeaderWriterFilter</code>-&gt;<code>CsrfFilter</code>-&gt; <code>LogoutFilter</code>-&gt;<code>UsernamePasswordAuthenticationFilter</code> 这一过程登陆请求。</p>\n<p><code>WebAsyncManagerIntegrationFilter</code>-&gt;<code>SecurityContextPersistenceFilter</code>-&gt;<code>HeaderWriterFilter</code>-&gt;<code>CsrfFilter</code>-&gt;<code>LogoutFilter</code>-&gt;<code>DefaultLoginPageGeneratingFilter</code>-&gt;<code>BasicAuthenticationFilter</code>-&gt;<code>RequestCacheAwareFilter</code>-&gt;<code>SecurityContextHolderAwareRequestFilter</code>-&gt;<code>AnonymousAuthenticationFilter</code>-&gt;<code>SessionManagementFilter</code>-&gt;<code>ExceptionTranslationFilter</code>-&gt;<code>FilterSecurityInterceptor</code><br>这是转发到“/”的过程</p>\n<p><code>SecurityContextPersistenceFilter</code>-&gt;<code>LogoutFilter</code>-&gt;<code>DefaultLoginPageGeneratingFilter</code>-&gt;<code>RequestCacheAwareFilter</code>-&gt;<code>SecurityContextHolderAwareRequestFilter</code>-&gt;<code>AnonymousAuthenticationFilter</code>-&gt;<code>SessionManagementFilter</code>-&gt;<code>ExceptionTranslationFilter</code>-&gt;<code>FilterSecurityInterceptor</code><br>这是重定向到error的过程</p>\n<p>接下来访问一下我们的/test接口<br>看看执行顺序：<br><code>WebAsyncManagerIntegrationFilter</code>-&gt;<code>SecurityContextPersistenceFilter</code>-&gt;<code>HeaderWriterFilter</code>-&gt;<code>CsrfFilter</code>-&gt;<code>LogoutFilter</code>-&gt;<code>DefaultLoginPageGeneratingFilter</code>-&gt;<code>BasicAuthenticationFilter</code>-&gt;<code>RequestCacheAwareFilter</code>-&gt;<code>SecurityContextHolderAwareRequestFilter</code>-&gt;<code>AnonymousAuthenticationFilter</code>-&gt;<code>SessionManagementFilter</code>-&gt;<code>ExceptionTranslationFilter</code>-&gt;<code>FilterSecurityInterceptor</code></p>\n<h4 id=\"说明：-1\"><a href=\"#说明：-1\" class=\"headerlink\" title=\"说明：\"></a>说明：</h4><p>BasicAuthenticationFilter就是看你请求头里面有没有basic开头的东西，有的话做一些处理，对我们来说没啥用，不必去关心，RequestCacheAwareFilter对请求和响应做了额外处理 SecurityContextHolderAwareRequestFilter 也是对请求做了一些额外处理，我们同样不去关心它。AnonymousAuthenticationFilter过滤器是当securitycontext为null时填充一个匿名权限，这里被执行的原因因为security未配置完全，后面进一步配置了之后再回来详解。ExceptionTranslationFilter是对鉴权或者登陆异常的处理过滤器，FilterSecurityInterceptor可以看做是过滤器链的出口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">       FilterInvocation fi = <span class=\"keyword\">new</span> FilterInvocation(request, response, chain);</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.invoke(fi);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这个fi就是请求的url值。</p>\n<p>现在我们完善一下security配置，让它复杂一点<br>实现 GrantedAuthority：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyGrantedAuthority</span> <span class=\"keyword\">implements</span> <span class=\"title\">GrantedAuthority</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String authority;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现UserDetails</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@Accessors(chain = true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUserDetail</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDetails</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;MyGrantedAuthority&gt; authorities;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> accountNonExpired;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> accountNonLocked;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> credentialsNonExpired;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> enabled;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>实现UserDetailsService</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUserDetailService</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDetailsService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> UserDetails <span class=\"title\">loadUserByUsername</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class=\"line\">        List&lt;MyGrantedAuthority&gt; authorities = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        MyGrantedAuthority myGrantedAuthority = <span class=\"keyword\">new</span> MyGrantedAuthority();</span><br><span class=\"line\">        myGrantedAuthority.setAuthority(<span class=\"string\">&quot;ROLE_test&quot;</span>);</span><br><span class=\"line\">        BCryptPasswordEncoder bCryptPasswordEncoder = <span class=\"keyword\">new</span> BCryptPasswordEncoder();</span><br><span class=\"line\">        String test = bCryptPasswordEncoder.encode(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">        authorities.add(myGrantedAuthority);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyUserDetail().setAuthorities(authorities).setAccountNonExpired(<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .setAccountNonLocked(<span class=\"keyword\">true</span>).setCredentialsNonExpired(<span class=\"keyword\">true</span>).setEnabled(<span class=\"keyword\">true</span>)</span><br><span class=\"line\">                .setPassword(test).setUsername(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重写security适配器WebSecurityConfigurerAdapter：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    MyUserDetailService userDetailService;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthenticationManagerBuilder auth)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        auth.userDetailsService(userDetailService).passwordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        web.ignoring().antMatchers(<span class=\"string\">&quot;/resources/**/*.html&quot;</span>, <span class=\"string\">&quot;/resources/**/*.js&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.css&quot;</span>, <span class=\"string\">&quot;/resources/**/*.txt&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.bmp&quot;</span>, <span class=\"string\">&quot;/**/*.gif&quot;</span>, <span class=\"string\">&quot;/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.jpg&quot;</span>, <span class=\"string\">&quot;/**/*.ico&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        super.configure(web);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">               .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().and().csrf().disable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里比开始又要复杂一点了，我先对相关操作进行说明一下：<br>先从SecurityConfig说起</p>\n<p>重写了三个config方法<br>1.第一个config涉及到的问题比较深——security的认证鉴权系统；<br>先说认证的过程，当过滤器跑到usernamepasswordFilter的时候就开始做认证了</p>\n<h4 id=\"security认证原理\"><a href=\"#security认证原理\" class=\"headerlink\" title=\"security认证原理\"></a>security认证原理</h4><p>认证的工作是交给AuthenticationManager去做，AuthenticationManager下有多个认证器 AuthenticationProvider<br>只要其中一个AuthenticationProvider通过认证就算登陆成功，而且在认证器中抛出异常，无法终止认证流程只是算该认证器未通过。<br>第一个config就算配置了一个AuthenticationManagerBuilder 这个类会生成一个 AuthenticationManager和DaoAuthenticationProvider认证器，认证调用userdetailservice 的loadUserByUsername方法来和你传入的username passworde做比较，password 是通过BCryptPasswordEncoder来做编码后比较的，这样做是为了提高安全性。</p>\n<p>2.第二个config是对静态资源的放行；</p>\n<p>3.第三个config 配置了登录页请求路径，登陆认证路径，用户名密码属性，和一个test权限，注意一点：我在config配的是hasRole(“test”)，我设置的权限是  myGrantedAuthority.setAuthority(“ROLE_test”);为什么这样弄后面会说。<br>接下来完善一下，边边角角，写个登陆的HTML,一个登陆页面请求接口:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;/sign_in&quot;</span>&gt;</span></span><br><span class=\"line\">    用户名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;test&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;test&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;verification&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/login_page&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">loginPage</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;loginPage.html&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>启动项目，访问localhost:8080/test<br>跳转到了/login_page<br><img src=\"https://upload-images.jianshu.io/upload_images/13612520-40e8574ede6fdade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>点登陆，debug看看有什么不同 新增的断点DaoAuthenticationProvider和MyUserDetailService<br>前面执行顺序还是一样，到SecurityContextHolderAwareRequestFilter的时候我们注意一下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityContextHolderAwareRequestFilter</span> <span class=\"keyword\">extends</span> <span class=\"title\">GenericFilterBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String rolePrefix = <span class=\"string\">&quot;ROLE_&quot;</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们权限设置的前缀就是从这来的 到后面讲投票器的时候再细说。<br>到UsernamePasswordAuthenticationFilter这个过滤器后 下一步到了DaoAuthenticationProvider验证器，验证器执行的是其父类AbstractUserDetailsAuthenticationProvider的authenticate（）方法同时我们看到MyUserDetailService的loadUserByUsername被调用，最后，认证结束转发到访问前路径/test 重新走过滤器。流程和一开始的简单配置一样，走到FilterSecurityInterceptor的时候进入WebExpressionVoter了投票器；</p>\n<h4 id=\"security的投票器：\"><a href=\"#security的投票器：\" class=\"headerlink\" title=\"security的投票器：\"></a>security的投票器：</h4><p>当过滤器链走到尽头（FilterSecurityInterceptor）下一步就是鉴权了，鉴权功能会交给AccessDecisionManager去处理，而AccessDecisionManager下又有多个投票器，其中WebExpressionVoter是security的一个默认投票器，我们来分析一下这个类：<br>其有个这样的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">vote</span><span class=\"params\">(Authentication authentication, FilterInvocation fi, Collection&lt;ConfigAttribute&gt; attributes)</span></span></span><br></pre></td></tr></table></figure>\n<p>返回int类型，1表示赞成，0表示弃权，-1表示反对。当所有投票器的vote执行结束，如果最终结果小于0表示不通过，<br>方法的参数说明：</p>\n<ol>\n<li>FilterInvocation  可获得请求的相关信息，比如请求方式（get post）url 等</li>\n<li>authentication 是从securitycontext中拿出来的用户信息</li>\n<li>Collection<ConfigAttribute> 是可以访问该路径的权限集合。也就是前面SecurityContextHolderAwareRequestFilter 查找出来的权限，对于在WebSecurityConfigurerAdapter config方法中的hasRole(“test”)权限规则并不是直接取权限 test,而是加了前缀rolePrefix（“ROLE_”），这个前缀也是可配置的配置方式：<a href=\"https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#appendix-faq-role-prefix\">https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#appendix-faq-role-prefix</a></li>\n</ol>\n<p>一些基本的知识点交代的差不多了，现在，我进行下一步</p>\n<h4 id=\"security魔改\"><a href=\"#security魔改\" class=\"headerlink\" title=\"security魔改\"></a>security魔改</h4><p>需求：我希望后端能做验证码校验，没通过校验的直接登录失败；<br>实现方式：security给我们提供了在各个过滤器上追加过滤器的方法，我们在UsernamePasswordAuthenticationFilter追加一个过滤器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUsernamePasswordAuthenticationFilte</span> <span class=\"keyword\">extends</span> <span class=\"title\">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisService redisService;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> postOnly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyUsernamePasswordAuthenticationFilte</span><span class=\"params\">(RedisService redisService)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.redisService=redisService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Authentication <span class=\"title\">attemptAuthentication</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\">        redisService.getcCode(request);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.attemptAuthentication(request,response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里redisService 就是你要弄的验证逻辑，其他代码还是从父类那复制过来，不去动它。<br>为什么要继承UsernamePasswordAuthenticationFilter 而不是继承AbstractAuthenticationProcessingFilter，这样做的好处是可以少写代码少踩坑。<br>然后修改config</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\">RedisService redisService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">      http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">              .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().and().csrf().disable();</span><br><span class=\"line\">       http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>我在加两个处理器，当我登陆成功或者失败，由我自己弄；<br>登陆成功处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAuthenticationSuccessHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleUrlAuthenticationSuccessHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthenticationSuccess</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;200\\&quot;,\\&quot;msg\\&quot;:\\&quot;登录成功\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>登陆失败的处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyUrlAuthenticationFailureHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleUrlAuthenticationFailureHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAuthenticationFailure</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(exception.getMessage().equals(<span class=\"string\">&quot;坏的凭证&quot;</span>))&#123;</span><br><span class=\"line\">            writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;401\\&quot;,\\&quot;msg\\&quot;:\\&quot;登录失败,用户名或者密码有误\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">            writer.close();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;401\\&quot;,\\&quot;msg\\&quot;:\\&quot;登录失败,&quot;</span>+exception.getMessage()+<span class=\"string\">&quot;\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">            writer.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"说明：-2\"><a href=\"#说明：-2\" class=\"headerlink\" title=\"说明：\"></a>说明：</h4><p>为什么要继承SimpleUrlAuthenticationFailureHandler和SimpleUrlAuthenticationSuccessHandler 而不是实现AuthenticationFailureHandler，还是那句话，为了少写代码少踩坑，我这里是返回json字符串，你也可以弄成重定向啥的，也比较容易。<br>config再改一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这里要注意 myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(“/sign_in”); 因为 http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);并不是替换掉UsernamePasswordAuthenticationFilter，而是和你自己添加的过滤器同时存在，security会根据url判断该走哪个过滤器，如果loginProcessingUrl还是“/login”的话走的是UsernamePasswordAuthenticationFilter，这里要留意一下。</p>\n<p>现在再加需求，我不仅需要普通登录方式，我想其他登录方式；<br>实现方式：加多个认证器，每个认证器对应一种登录方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAuthenticationProvider</span>  <span class=\"keyword\">implements</span> <span class=\"title\">AuthenticationProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDetailsService userDetailsService;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Authentication <span class=\"title\">authenticate</span><span class=\"params\">(Authentication authentication)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//       这里写验证逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在改SecurityConfig</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">      http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">              .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().and().csrf().disable();</span><br><span class=\"line\">       http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\">MyAuthenticationProvider <span class=\"title\">getMyAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyAuthenticationProvider myAuthenticationProvider = <span class=\"keyword\">new</span> MyAuthenticationProvider(userDetailService,<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myAuthenticationProvider;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\">DaoAuthenticationProvider <span class=\"title\">daoAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       DaoAuthenticationProvider daoAuthenticationProvider = <span class=\"keyword\">new</span> DaoAuthenticationProvider();</span><br><span class=\"line\">       daoAuthenticationProvider.setPasswordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">       daoAuthenticationProvider.setUserDetailsService(userDetailService);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> daoAuthenticationProvider;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationManager <span class=\"title\">getAuthenticationManager</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">       ProviderManager authenticationManager = <span class=\"keyword\">new</span> ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));</span><br><span class=\"line\">       <span class=\"keyword\">return</span> authenticationManager;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>我再加需求：<br>根据不同的客服端做不同的鉴权策略；<br>实现方式：加投票器；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExpressionVoter</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebExpressionVoter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">vote</span><span class=\"params\">(Authentication authentication, FilterInvocation fi, Collection&lt;ConfigAttribute&gt; attributes)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        这里写鉴权逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>再次改动config</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">      http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">              .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().accessDecisionManager(accessDecisionManager()).and().csrf().disable();</span><br><span class=\"line\">       http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">       myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\">MyAuthenticationProvider <span class=\"title\">getMyAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       MyAuthenticationProvider myAuthenticationProvider = <span class=\"keyword\">new</span> MyAuthenticationProvider(userDetailService,<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">       <span class=\"keyword\">return</span> myAuthenticationProvider;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\">DaoAuthenticationProvider <span class=\"title\">daoAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       DaoAuthenticationProvider daoAuthenticationProvider = <span class=\"keyword\">new</span> DaoAuthenticationProvider();</span><br><span class=\"line\">       daoAuthenticationProvider.setPasswordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">       daoAuthenticationProvider.setUserDetailsService(userDetailService);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> daoAuthenticationProvider;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationManager <span class=\"title\">getAuthenticationManager</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">       ProviderManager authenticationManager = <span class=\"keyword\">new</span> ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));</span><br><span class=\"line\">       <span class=\"keyword\">return</span> authenticationManager;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> AccessDecisionManager <span class=\"title\">accessDecisionManager</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters</span><br><span class=\"line\">               = Arrays.asList(</span><br><span class=\"line\">               <span class=\"keyword\">new</span> MyExpressionVoter(),</span><br><span class=\"line\">               <span class=\"keyword\">new</span> WebExpressionVoter(),</span><br><span class=\"line\">               <span class=\"keyword\">new</span> RoleVoter(),</span><br><span class=\"line\">               <span class=\"keyword\">new</span> AuthenticatedVoter());</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UnanimousBased(decisionVoters);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>在加两个鉴权失败处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAccessDeniedHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">AccessDeniedHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse response, AccessDeniedException e)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">        PrintWriter writer = response.getWriter();</span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;403\\&quot;,\\&quot;msg\\&quot;:\\&quot;没有权限\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>再加一个登出处理器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLogoutSuccessHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">LogoutSuccessHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onLogoutSuccess</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse response, Authentication authentication)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> PrintWriter writer = response.getWriter();</span><br><span class=\"line\"></span><br><span class=\"line\">        writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;200\\&quot;,\\&quot;msg\\&quot;:\\&quot;登出成功\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">        writer.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>最后修改SecurityConfig，最终模样为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableWebSecurity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisService redisService;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    MyUserDetailService userDetailService;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthenticationManagerBuilder auth)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        auth.userDetailsService(userDetailService).passwordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(WebSecurity web)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        web.ignoring().antMatchers(<span class=\"string\">&quot;/resources/**/*.html&quot;</span>, <span class=\"string\">&quot;/resources/**/*.js&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.css&quot;</span>, <span class=\"string\">&quot;/resources/**/*.txt&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;/resources/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.bmp&quot;</span>, <span class=\"string\">&quot;/**/*.gif&quot;</span>, <span class=\"string\">&quot;/**/*.png&quot;</span>, <span class=\"string\">&quot;/**/*.jpg&quot;</span>, <span class=\"string\">&quot;/**/*.ico&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        super.configure(web);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">       http.formLogin().loginPage(<span class=\"string\">&quot;/login_page&quot;</span>).passwordParameter(<span class=\"string\">&quot;username&quot;</span>).passwordParameter(<span class=\"string\">&quot;password&quot;</span>).loginProcessingUrl(<span class=\"string\">&quot;/sign_in&quot;</span>).permitAll()</span><br><span class=\"line\">               .and().authorizeRequests().antMatchers(<span class=\"string\">&quot;/test&quot;</span>).hasRole(<span class=\"string\">&quot;test&quot;</span>).anyRequest().authenticated().accessDecisionManager(accessDecisionManager())</span><br><span class=\"line\">               .and().logout().logoutSuccessHandler(<span class=\"keyword\">new</span> MyLogoutSuccessHandler())</span><br><span class=\"line\">               .and().csrf().disable();</span><br><span class=\"line\">        http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</span><br><span class=\"line\">        http.exceptionHandling().accessDeniedHandler(<span class=\"keyword\">new</span> MyAccessDeniedHandler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">MyUsernamePasswordAuthenticationFilte <span class=\"title\">getAuthenticationFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MyUsernamePasswordAuthenticationFilte myUsernamePasswordAuthenticationFilte = <span class=\"keyword\">new</span> MyUsernamePasswordAuthenticationFilte(redisService);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationFailureHandler(<span class=\"keyword\">new</span> MyUrlAuthenticationFailureHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationSuccessHandler(<span class=\"keyword\">new</span> MyAuthenticationSuccessHandler());</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setFilterProcessesUrl(<span class=\"string\">&quot;/sign_in&quot;</span>);</span><br><span class=\"line\">        myUsernamePasswordAuthenticationFilte.setAuthenticationManager(getAuthenticationManager());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myUsernamePasswordAuthenticationFilte;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">MyAuthenticationProvider <span class=\"title\">getMyAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        MyAuthenticationProvider myAuthenticationProvider = <span class=\"keyword\">new</span> MyAuthenticationProvider(userDetailService,<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myAuthenticationProvider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">DaoAuthenticationProvider <span class=\"title\">daoAuthenticationProvider</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        DaoAuthenticationProvider daoAuthenticationProvider = <span class=\"keyword\">new</span> DaoAuthenticationProvider();</span><br><span class=\"line\">        daoAuthenticationProvider.setPasswordEncoder(<span class=\"keyword\">new</span> BCryptPasswordEncoder());</span><br><span class=\"line\">        daoAuthenticationProvider.setUserDetailsService(userDetailService);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> daoAuthenticationProvider;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationManager <span class=\"title\">getAuthenticationManager</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">        ProviderManager authenticationManager = <span class=\"keyword\">new</span> ProviderManager(Arrays.asList(getMyAuthenticationProvider(),daoAuthenticationProvider()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AccessDecisionManager <span class=\"title\">accessDecisionManager</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters</span><br><span class=\"line\">                = Arrays.asList(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MyExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> WebExpressionVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> RoleVoter(),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> AuthenticatedVoter());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UnanimousBased(decisionVoters);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可能想要用jwtToken 做token鉴权的方式；<br>也好做，我这里提一下思路，鉴权都是在投票器里面，那我们在投票器之前填充好securitycontext就成，然后实现一个自己的投票器；填充securitycontext随便找个过滤器http.addFilterAfter() 然后在过滤器里面填充好就行，至于拿token的接口，在config里用.permitAll()放行就行了，比上面的改法还简单，我就不写了。</p>\n<h4 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h4><p>具体的代码可以参考我的项目<a href=\"https://github.com/muggle0/poseidon/wiki\">poseindon</a>，这种security改动方式我经过生产实践的，不会有问题。另外篇幅有点长 感谢大佬的阅读。</p>"},{"title":" logback深度使用","date":"2019-03-28T01:44:50.000Z","_content":"\n\n##### 作者：muggle\n\nLogback是由log4j创始人设计的另一个开源日志组件,分为三个模块：\n\n1. logback-core：其它两个模块的基础模块\n\n2. logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging\n\n3. logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能\n在springboot中我们通过xml配置来操作logback\n\n<!--more-->\nspringboot中logback的默认配置文件名称为logback-spring.xml，若需要指定xml名称，需在application.properties（application.yml）中配置logging.config=xxxx.xml\n现在贴出一份logback的xml配置，可直接使用，懒得看的小伙伴复制粘贴到你的项目中去体验吧\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\n\n<configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\">\n\n    <jmxConfigurator/>\n\n    <property name=\"log_dir\" value=\"logs\"/>\n    <property name=\"maxHistory\" value=\"100\"/>\n\n    <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>\n                %d{yyyy-MM-dd HH:mm:ss.SSS} %highlight([%-5level]) %logger - %msg%n\n            </pattern>\n        </encoder>\n    </appender>\n    <appender name=\"logs\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <fileNamePattern>\n                ${log_dir}/%d{yyyy-MM-dd}-poseidon.log\n            </fileNamePattern>\n            <maxHistory>${maxHistory}</maxHistory>\n        </rollingPolicy>\n        <encoder>\n            <pattern>\n                %d{yyyy-MM-dd HH:mm:ss.SSS} %highlight([%-5level]) %logger - %msg%n\n            </pattern>\n        </encoder>\n    </appender>\n\n    <appender name=\"runningTime-file\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <fileNamePattern>${log_dir}/runningTime/%d{yyyy-MM-dd}-poseidon.log</fileNamePattern>\n            <maxHistory>${maxHistory}</maxHistory>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n        </encoder>\n    </appender>\n    <appender name=\"runningTime-console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>\n                %d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n\n            </pattern>\n        </encoder>\n    </appender>\n    <logger name=\"runningTime\" level=\"info\" additivity=\"false\">\n        <!--<appender-ref ref=\"runningTime-file\"/>-->\n        <appender-ref ref=\"runningTime-console\"/>\n    </logger>\n<!--  可能会抛出方言异常 两个解决方案 配置方言或者换连接池 换druid不会有这个异常-->\n    <appender name=\"requestLog-db\" class=\"ch.qos.logback.classic.db.DBAppender\">\n        <connectionSource class=\"ch.qos.logback.core.db.DataSourceConnectionSource\">\n            <dataSource class=\"org.apache.commons.dbcp.BasicDataSource\">\n                <driverClassName>com.mysql.cj.jdbc.Driver</driverClassName>\n                <url>jdbc:mysql://xxx/xxxx?characterEncoding=UTF-8</url>\n                <username>xx</username>\n                <password>xxxx</password>\n            </dataSource>\n        </connectionSource>\n        <!--<sqlDialect class=\"ch.qos.logback.core.db.dialect.MySQLDialect\" />-->\n    </appender>\n    <!--异步配置-->\n    <!--<appender name=\"requestLog-file\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n         <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n             <fileNamePattern>${log_dir}/requestLog/%d{yyyy-MM-dd}-poseidon.log</fileNamePattern>\n             <maxHistory>${maxHistory}</maxHistory>\n         </rollingPolicy>\n         <encoder>\n             <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n         </encoder>\n     </appender>-->\n    <!-- <appender name=\"request-asyn\" class=\"ch.qos.logback.classic.AsyncAppender\">\n        <appender-ref ref=\"requestLog-file\"/>\n    </appender> -->\n    <appender name=\"logs-asyn\" class=\"ch.qos.logback.classic.AsyncAppender\">\n        <appender-ref ref=\"logs\"/>\n    </appender>\n    <logger name=\"requestLog\" level=\"info\" additivity=\"false\">\n        <!--<appender-ref ref=\"requestLog-file\"/>-->\n        <!-- DBAppender 查看可知其父类dbappenderbase继承了UnsynchronizedAppenderBase<E> 所以dbappender本身是异步的 无需配置异步-->\n        <appender-ref ref=\"requestLog-db\"/>\n    </logger>\n    <root>\n        <level value=\"info\"/>\n        <appender-ref ref=\"console\"/>\n        <!--<appender-ref ref=\"logs\"/>-->\n        <appender-ref ref=\"logs-asyn\"/>\n    </root>\n</configuration>\n```\n\n我们可以看到xml中有四种节点\nappender，logger，root,configuration\n#### 节点解读\n\nconfiguration包含三个属性：\n\n1. scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。\n2. scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。\n3. debug: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。\n4.\nLogger作为日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别。\n\nAppender主要用于指定日志输出的目的地，目的地可以是控制台、文件、远程套接字服务器、 MySQL、PostreSQL、 Oracle和其他数据库、 JMS和远程UNIX Syslog守护进程等。\n\nroot 就是最高级别logger,所有不被指定logger的日志都归root管理。\n\n在slf4j框架下我们使用log是这样的:\n```java\n private static final Logger logger= LoggerFactory.getLogger(xxx.class);\n```\n或者\n```java\n private static final Logger logger= LoggerFactory.getLogger(\"xxxx\");\n```\n\n可以理解为代码中的getLogger() 方法就是获取xml配置中的logger,如果没有配置相应的logger则为root\n比如我配置了：\n```xml\n<logger name=\"hhh\" level=\"info\" additivity=\"false\">\n        <!--<appender-ref ref=\"requestLog-file\"/>-->\n        <appender-ref ref=\"xxx\"/>\n</logger>\n```\n那我在获得一个logger时可以这样获得它：\n```java\n private static final Logger logger= LoggerFactory.getLogger(\"hhh\");\n```\n我所输出的日志将被这个logger所管理\nlogger 上有三个配置 name level additivity\nname就是这个logger的名称，level就是这个日志过滤的级别，低于这个级别的日志不输入到对应的appender中；additivity是否向上级logger传递打印信息，默认是true。logger中可以配置多个appender-ref，也就是可以指定多个输出地点。\n而root只是特殊的logger，用法上无差别\n\n\nappender节点：\nappender节点是logback配置的关键，其name属性指定其名称，class属性指定实现类，对应得实现类有\n```java\nch.qos.logback.core.ConsoleAppender // 以控制台作为输出\nch.qos.logback.core.rolling.RollingFileAppender//以日志文件作为输出\nch.qos.logback.classic.db.DBAppender//以数据库作为输出\nnet.logstash.logback.appender.LogstashTcpSocketAppender//以logstash作为输出需要引入如下依赖：\nch.qos.logback.classic.AsyncAppender//异步输出 需要定义appender-ref\n\n// logstash依赖\n<dependency>\n  <groupId>net.logstash.logback</groupId>\n  <artifactId>logstash-logback-encoder</artifactId>\n  <version>4.11</version>\n</dependency>\n```\n\n所有的appender 实现ch.qos.logback.core.Appender接口或者 ch.qos.logback.core.UnsynchronizedAppenderBase接口（异步），我们也可以自定义appender来指定日志输出；\n\n在Appender中可以定义哪些节点我们一个个来看：\n\n第一种： ConsoleAppender\n如同它的名字一样，这个Appender将日志输出到console，更准确的说是System.out 或者System.err。\n它包含的参数如下：\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nencoder  | Encoder   | 通常在其pattern里指定日志格式  如： %d{yyyy-MM-dd HH:mm:ss.SSS} %highlight([%-5level]) %logger - %msg%n表示 日期格式 日志级别（高亮）logger的名称 logger的message\ntarget|String|指定输出目标。可选值：System.out 或 System.err。默认值：System.out\nwithJansi|boolean|是否支持ANSI color codes（类似linux中的shell脚本的输出字符串颜色控制代码）。默认为false。如果设置为true。例如：[31m 代表将前景色设置成红色。在windows中，需要提供\"org.fusesource.jansi:jansi:1.9\"，而在linux，mac os x中默认支持。\n\n第二种： FileAppender\n将日志输出到文件当中，目标文件取决于file属性。是否追加输出，取决于append属性。\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nappend |\tboolean\t| 是否以追加方式输出。默认为true。\nencoder |\tEncoder\t|See OutputStreamAppender properties.\nfile\t| String |\t指定文件名。注意在windows当中，反斜杠 \\ 需要转义，或直接使用 / 也可以。例如 c:/temp/test.logor 或 c:\\\\temp\\\\test.log 都可以。没有默认值，如果上层目录不存在，FileAppender会自动创建。\nprudent |\tboolean|\t是否工作在谨慎模式下。在谨慎模式下，FileAppender将会安全写入日志到指定文件，即时在不同的虚拟机jvm中有另一个相同的FileAppender实例。默认值：fales;设置为true，意味着append会被自动设置成true。prudent依赖于文件排它锁。实验表明，使用文件锁，会增加3倍的日志写入消耗。比如说，当prudent模式为off，写入一条日志到文件只要10毫秒，但是prudent为真，则会接近30毫秒。prudent 模式实际上是将I/O请求序列化，因此在I/O数量较大，比如说100次/s或更多的时候，带来的延迟也会显而易见，所以应该避免。在networked file system（远程文件系统）中，这种消耗将会更大，可能导致死锁。\n\n第三个： RollingFileAppender\n\nRollingFileAppender继承自FileAppender，提供日志目标文件自动切换的功能。例如可以用日期作为日志分割的条件。\nRollingFileAppender有两个重要属性，RollingPolicy负责怎么切换日志，TriggeringPolicy负责何时切换。为了使RollingFileAppender起作用，这两个属性必须设置，但是如果RollingPolicy的实现类同样实现了TriggeringPolicy接口，则也可以只设置RollingPolicy这个属性。\n下面是它的参数：\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nfile |\tString |\t指定文件名。注意在windows当中，反斜杠 \\ 需要转义，或直接使用 / 也可以。例如 c:/temp/test.logor 或 c:\\\\temp\\\\test.log 都可以。没有默认值，如果上层目录不存在，FileAppender会自动创建。\nappend\t|boolean\t|是否以追加方式输出。默认为true。\nencoder\t| Encoder\t| See OutputStreamAppender properties.\nrollingPolicy |\tRollingPolicy\t| 当发生日志切换时，RollingFileAppender的切换行为。例如日志文件名的修改\ntriggeringPolicy\t| TriggeringPolicy\t| 决定什么时候发生日志切换，例如日期，日志文件大小到达一定值\nprudent\t| boolean\t|FixedWindowRollingPolicy 不支持prudent模式。TimeBasedRollingPolicy 支持prudent模式，但是需要满足一下两条约束：在prudent模式中，日志文件的压缩是不被允许，不被支持的。不能设置file属性。\n\n第四个：SocketAppender及SSLSocketAppender（未尝试过）\n\n到目前为止我们讲的appender都只能将日志输出到本地资源。与之相对的，SocketAppender就是被设计用来输出日志到远程实例中的。SocketAppender输出日志采用明文方式，SSLSocketAppender则采用加密方式传输日志。\n被序列化的日志事件的类型是 LoggingEventVO 继承ILoggingEvent接口。远程日志记录并非是侵入式的。在反序列化接收后，日志事件就可以好像在本地生成的日志一样处理了。多个SockerAppender可以向同一台日志服务器发送日志。SocketAppender并不需要关联一个Layout，因为它只是发送序列化的日志事件给远程日志服务器。SocketAppender的发送操作是基于TCP协议的。因此如果远程服务器是可到达的，则日志会被其处理，如果远程服务器宕机或不可到达，那么日志将会被丢弃。等到远程服务器复活，日志发送将会透明的重新开始。这种透明式的重连，是通过一个“连接“线程周期性的尝试连接远程服务器实现的。\nLogging events会由TCP协议实现自动缓冲。这意味着，如果网络速度比日志请求产生速度快，则网络速度并不会影响应用。但如果网络速度过慢，则网络速度则会变成限制，在极端情况下，如果远程日志服务器不可到达，则会导致应用最终阻塞。不过，如果服务器可到达，但是服务器宕机了，这种情况，应用不会阻塞，而只是丢失一些日志事件而已。\n需要注意的是，即使SocketAppender没有被logger链接，它也不会被gc回收，因为他在connector thread中任然存在引用。一个connector thread 只有在网络不可达的情况下，才会退出。为了防止这个垃圾回收的问题，我们应该显示声明关闭SocketAppender。长久存活并创建/销毁大量的SocketAppender实例的应用，更应该注意这个问题。不过大多数应用可以忽略这个问题。如果JVM在SocketAppender关闭之前将其退出，又或者是被垃圾回收，这样子可能导致丢失一些还未被传输，在管道中等待的日志数据。为了防止避免日志丢失，经常可靠的办法就是调用SocketAppender的close方法，或者调用LoggerContext的stop方法，在退出应用之前。\n\n下面我们来看看SocketAppender的属性：\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nincludeCallerData |\tboolean\t|是否包含调用者的信息如果为true，则以下日志输出的 ?:? 会替换成调用者的文件名跟行号，为false，则为问号。2019-01-06 17:37:30,968 DEBUG [Thread-0] [?:?] chapters.appenders.socket.SocketClient2 - Hi\nport |\tint\t| 端口号\nreconnectionDelay\t| Duration\t| 重连延时，如果设置成“10 seconds”，就会在连接u武器失败后，等待10秒，再连接。默认值：“30 seconds”。如果设置成0，则关闭重连功能。\nqueueSize\t| int\t| 设置缓冲日志数，如果设置成0，日志发送是同步的，如果设置成大于0的值，会将日志放入队列，队列长度到达指定值，在统一发送。可以加大服务吞吐量。\neventDelayLimit |\tDuration |\t设置日志超时丢弃时间。当设置“10 seconds”类似的值，如果日志队列已满，而服务器长时间来不及接收，当滞留时间超过10 seconds，日志就会被丢弃。默认值： 100 milliseconds\nremoteHost |\tString |\t远程日志服务器的IP\nssl\t| SSLConfiguration | 只在SSLSocketAppender包含该属性节点。提供SSL配置，详情见 Using SSL.\n\n标准的Logback Classic包含四个可供使用的Receiver用来接收来自SocketAppender的logging evnets。\n\n第五个： SMTPAppender\n\nSMTPAppender 可以将logging event存放在一个或多个固定大小的缓冲区中，然后在用户指定的event到来之时，将适当的大小的logging event以邮件方式发送给运维人员。\n详细属性如下：\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nsmtpHost |\tString\t| SMTP server的地址，必需指定。如网易的SMTP服务器地址是： smtp.163.com\nsmtpPort |\tint\t| SMTP server的端口地址。默认值：25\nto\t| String |\t指定发送到那个邮箱，可设置多个<to>属性，指定多个目的邮箱\nfrom |\tString |\t指定发件人名称。如果设置成“muggle &lt;hh@moral.org&gt; ”，则邮件发件人将会是“muggle <hh@moral.org> ”\nsubject |\tString |指定emial的标题，它需要满足PatternLayout中的格式要求。如果设置成“Log: %logger - %msg”，就案例来讲，则发送邮件时，标题为“Log: com.foo.Bar - Hello World ”。 默认值：\"%logger{20} - %m\".\ndiscriminator\t| Discriminator\t| 通过Discriminator, SMTPAppender可以根据Discriminator的返回值，将到来的logging event分发到不同的缓冲区中。默认情况下，总是返回相同的值来达到使用一个缓冲区的目的。\nevaluator |\tIEvaluator\t| 指定触发日志发送的条件。通过<evaluator class=... />指定EventEvaluator接口的实现类。默认情况下SMTPAppeender使用的是OnErrorEvaluator，表示当发送ERROR或更高级别的日志请求时，发送邮件。Logback提供了几个evaluators：OnErrorEvaluator、OnMarkerEvaluator、JaninoEventEvaluator、GEventEvaluator（功能强大）\ncyclicBufferTracker |\tCyclicBufferTracker\t| 指定一个cyclicBufferTracker跟踪cyclic buffer。它是基于discriminator的实现的。如果你不指定，默认会创建一个CyclicBufferTracker ，默认设置cyclic buffer大小为256。你也可以手动指定使用默认的CyclicBufferTracker，并且通过<bufferSize>属性修改默认的缓冲区接收多少条logging event。\nusername\t| String |\t发送邮件账号，默认为null\npassword |\tString |\t发送邮件密码，默认为null\nSTARTTLS\t| boolean\t|如果设置为true，appender会尝试使用STARTTLS命令，如果服务端支持，则会将明文连接转换成加密连接。需要注意的是，与日志服务器连接一开始是未加密的。默认值：false\nSSL\t| boolean\t| 如果设置为true，appender将会使用SSL连接到日志服务器。 默认值：false\ncharsetEncoding |\tString\t|指定邮件信息的编码格式 默认值：UTF-8\nlocalhost\t| String |\t如果smtpHost没有正确配置，比如说不是完整的地址。这时候就需要localhost这个属性提供服务器的完整路径（如同java中的完全限定名 ），详情参考com.sun.mail.smtp 中的mail.smtp.localhost属性\nasynchronousSending\t| boolean\t| 这个属性决定email的发送是否是异步。默认：true，异步发送但是在某些情况下，需要以同步方式发送错误日志的邮件给管理人员，防止不能及时维护应用。\nincludeCallerData |\tboolean\t|默认：false 指定是否包含callerData在日志中\nsessionViaJNDI |\tboolean\t| SMTPAppender依赖javax.mail.Session来发送邮件。默认情况下，sessionViaJNDI为false。javax.mail.Session实例的创建依赖于SMTPAppender本身的配置信息。如果设置为true，则Session的创建时通过JNDI获取引用。这样做的好处可以让你的代码复用更好，让配置更简洁。需要注意的是，如果使用JNDI获取Session对象，需要保证移除mail.jar以及activation.jar这两个jar包\njndiLocation |\tString\t| 如果sessionViaJNDI设置为true，则jndiLocation指定JNDI的资源名，默认值为：\"java:comp/env/mail/Session\"\n\nSMTPAppender只保留最近的256条logging events 在循环缓冲区中，当缓冲区慢，就会开始丢弃最老的logging event。因此不管什么时候，SMTPAppender一封邮件最多传递256条日志事件。SMTPAppender依赖于JavaMail API。而JavaMail API又依赖于IOC框架（依赖注入）。\n\n第六个：DBAppender\n\n DBAppender 可以将日志事件插入到3张数据表中。它们分别是logging_event，logging_event_property，logging_event_exception。这三张数据表必须在DBAppender工作之前存在。它们的sql脚本可以在 logback-classic/src/main/java/ch/qos/logback/classic/db/script folder 这个目录下找到。这个脚本对大部分SQL数据库都是有效的，除了少部分，少数语法有差异需要调整。\n下面是logback与常见数据库的支持信息：\n\nRDBMS\t| tested version(s)\t| tested JDBC driver version(s)| \tsupports getGeneratedKeys() method |\tis a dialect provided by logback\n----------|----------|--------|----------|----\nDB2 |\tuntested |\tuntested |\tunknown |\tNO\nH2 |\t--| - |\tunknown\t| YES\nHSQL |-- |\t-\t| NO |\tYES\nMicrosoft SQL Server |\t-- | -- |\tYES\t| YES\nMySQL |\t5.7\t|  \t|YES|\tYES\nPostgreSQL | --|-- |\tNO|\tYES\nOracle\t|--|--|\tYES\t|YES\nSQLLite\t|--|\t-|\tunknown\t|YES\nSybase |--|\t\t-\t|unknown|\tYES\n\n\n下面给出三张表的sql语句：\n```sql\nBEGIN;\nDROP TABLE IF EXISTS logging_event_property;\nDROP TABLE IF EXISTS logging_event_exception;\nDROP TABLE IF EXISTS logging_event;\nCOMMIT;\n\nBEGIN;\nCREATE TABLE logging_event\n  (\n    timestmp         BIGINT NOT NULL,\n    formatted_message  TEXT NOT NULL,\n    logger_name       VARCHAR(254) NOT NULL,\n    level_string      VARCHAR(254) NOT NULL,\n    thread_name       VARCHAR(254),\n    reference_flag    SMALLINT,\n    arg0              VARCHAR(254),\n    arg1              VARCHAR(254),\n    arg2              VARCHAR(254),\n    arg3              VARCHAR(254),\n    caller_filename   VARCHAR(254) NOT NULL,\n    caller_class      VARCHAR(254) NOT NULL,\n    caller_method     VARCHAR(254) NOT NULL,\n    caller_line       CHAR(4) NOT NULL,\n    event_id          BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY\n  );\nCOMMIT;\n\n\nBEGIN;\nCREATE TABLE logging_event_property\n  (\n    event_id       BIGINT NOT NULL,\n    mapped_key        VARCHAR(254) NOT NULL,\n    mapped_value      TEXT,\n    PRIMARY KEY(event_id, mapped_key),\n    FOREIGN KEY (event_id) REFERENCES logging_event(event_id)\n  );\nCOMMIT;\n\n\nBEGIN;\nCREATE TABLE logging_event_exception\n  (\n    event_id         BIGINT NOT NULL,\n    i                SMALLINT NOT NULL,\n    trace_line       VARCHAR(254) NOT NULL,\n    PRIMARY KEY(event_id, i),\n    FOREIGN KEY (event_id) REFERENCES logging_event(event_id)\n  );\nCOMMIT;\n```\n\n第七个： AsyncAppender\n\nAsyncAppender记录ILoggingEvents的方式是异步的。它仅仅相当于一个event分配器，因此需要配合其他appender才能有所作为。\n\n需要注意的是：AsyncAppender将event缓存在 BlockingQueue ，一个由AsyncAppender创建的工作线程，会一直从这个队列的头部获取events，然后将它们分配给与AsyncAppender唯一关联的Appender中。默认情况下，如果这个队列80%已经被占满，则AsyncAppender会丢弃等级为 TRACE，DEBUG，INFO这三个等级的日志事件。\n在应用关闭或重新部署的时候，AsyncAppender一定要被关闭，目的是为了停止，回收再利用worker thread，和刷新缓冲队列中logging events。那如果关闭AsyncAppender呢？可以通过关闭LoggerContext来关闭所有appender，当然也包括AsyncAppender了。AsyncAppender会在maxFlushTime属性设置的时间内等待Worker thread刷新全部日志event。如果你发现缓冲的event在关闭LoggerContext的时候被丢弃，这时候你就也许需要增加等待的时间。将maxFlushTime设置成0，就是AsyncAppender一直等待直到工作线程将所有被缓冲的events全部刷新出去才执行才结束。\n根据JVM退出的模式，工作线程worker thread处理被缓冲的events的工作是可以被中断的，这样就导致了剩余未处理的events被搁浅。这种现象通常的原因是当LoggerContext没有完全关闭，或者当JVM终止那些非典型的控制流（不明觉厉）。为了避免工作线程的因为这些情况而发生中断，一个shutdown hook（关闭钩子）可以被插入到JVM运行的时候，这个钩子的作用是在JVM开始shutdown刚开始的时候执行关闭 LoggerContext的任务。\n\n下面是AsyncAppender的属性表\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nqueueSize\t| int\t| 设置blocking queue的最大容量，默认是256条events\ndiscardingThreshold\t| int\t| 默认，当blocking queue被占用80%以上，AsyncAppender就会丢弃level为 TRACE，DEBUG，INFO的日志事件，如果要保留所有等级的日志，需要设置成0\nincludeCallerData\t| boolean\t| 提取CallerData代价比较昂贵，为了提高性能，caller data默认不提供。只有一些获取代价较低的数据，如线程名称，MDC值才会被保留。如果设置为true，就会包含caller data\nmaxFlushTime | \tint\t|设置最大等待刷新事件，单位为miliseconds(毫秒)。当LoggerContext关闭的时候，AsyncAppender会在这个时间内等待工作线程完成events的flush工作，超时未处理的events将会被抛弃。\nneverBlock |\tboolean |\t默认为false，如果队列被填满，为了处理所有日志，就会阻塞的应用。如果为true，为了不阻塞你的应用，也会选择抛弃一些message。\n\n默认情况下，event queue最大的容量是256。如果队列被填充满那么就会阻塞你的应用，直到队列能够容纳新的logging event。所以当AsyncAppender工作在队列满的情况下，可以称作伪同步。\n在以下四种情况下容易导致AsyncAppender伪同步状态的出现：\n\n1. 应用中存在大量线程\n2. 每秒产生大量的logging events\n3. 每一个logging event都存在大量的数据\n4. 子appender中存在很高的延迟\n\n为了避免伪同步的出现，提高queueSizes普遍有效，但是就消耗了应用的可用内存。\n\n下面列出一些 appender配置示例：\n\n```xml\n\n<configuration>\n  <appender name=\"FILE\" class=\"ch.qos.logback.core.FileAppender\">\n    <file>myapp.log</file>\n    <encoder>\n      <pattern>%logger{35} - %msg%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name=\"ASYNC\" class=\"ch.qos.logback.classic.AsyncAppender\">\n    <appender-ref ref=\"FILE\" />\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"ASYNC\" />\n  </root>\n</configuration>\n\n<configuration>\n\n  <appender name=\"DB\" class=\"ch.qos.logback.classic.db.DBAppender\">\n    <connectionSource\n      class=\"ch.qos.logback.core.db.DataSourceConnectionSource\">\n      <dataSource\n        class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n        <driverClass>com.mysql.jdbc.Driver</driverClass>\n        <jdbcUrl>jdbc:mysql://${serverName}:${port}/${dbName}</jdbcUrl>\n        <user>${user}</user>\n        <password>${password}</password>\n      </dataSource>\n    </connectionSource>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"DB\" />\n  </root>\n</configuration>\n\n<configuration>\n  <appender name=\"EMAIL\" class=\"ch.qos.logback.classic.net.SMTPAppender\">\n    <smtpHost>smtp.gmail.com</smtpHost>\n    <smtpPort>465</smtpPort>\n    <SSL>true</SSL>\n    <username>YOUR_USERNAME@gmail.com</username>\n    <password>YOUR_GMAIL_PASSWORD</password>\n\n    <to>EMAIL-DESTINATION</to>\n    <to>ANOTHER_EMAIL_DESTINATION</to> <!-- additional destinations are possible -->\n    <from>YOUR_USERNAME@gmail.com</from>\n    <subject>TESTING: %logger{20} - %m</subject>\n    <layout class=\"ch.qos.logback.classic.PatternLayout\">\n      <pattern>%date %-5level %logger{35} - %message%n</pattern>\n    </layout>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"EMAIL\" />\n  </root>\n</configuration>\n\n<configuration>\n  <appender name=\"EMAIL\" class=\"ch.qos.logback.classic.net.SMTPAppender\">\n    <smtpHost>smtp.gmail.com</smtpHost>\n    <smtpPort>587</smtpPort>\n    <STARTTLS>true</STARTTLS>\n    <username>YOUR_USERNAME@gmail.com</username>\n    <password>YOUR_GMAIL_xPASSWORD</password>\n\n    <to>EMAIL-DESTINATION</to>\n    <to>ANOTHER_EMAIL_DESTINATION</to> <!-- additional destinations are possible -->\n    <from>YOUR_USERNAME@gmail.com</from>\n    <subject>TESTING: %logger{20} - %m</subject>\n    <layout class=\"ch.qos.logback.classic.PatternLayout\">\n      <pattern>%date %-5level %logger - %message%n</pattern>\n    </layout>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"EMAIL\" />\n  </root>\n</configuration>\n\nSimpleSocketServer需要两个命令行参数，port 和 configFile路径。(该方法待验证)\njava ch.qos.logback.classic.net.SimpleSocketServer 6000 \\ src/main/java/chapters/appenders/socket/server1.xml\n\n客户端的SocketAppender的简单配置例子：\n<configuration>\n\n  <appender name=\"SOCKET\" class=\"ch.qos.logback.classic.net.SocketAppender\">\n    <remoteHost>192.168.0.101</remoteHost>\n    <port>8888</port>\n    <reconnectionDelay>10000</reconnectionDelay>\n    <includeCallerData>true</includeCallerData>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"SOCKET\" />\n  </root>\n\n</configuration>\n\n在服务端使用SimpleSSLSocketServer\njava -Djavax.net.ssl.keyStore=src/main/java/chapters/appenders/socket/ssl/keystore.jks \\ -Djavax.net.ssl.keyStorePassword=changeit \\ ch.qos.logback.classic.net.SimpleSSLSocketServer 6000 \\ src/main/java/chapters/appenders/socket/ssl/server.xml\n\nSSLSocketAppender配置\n<configuration debug=\"true\">\n\n  <appender name=\"SOCKET\" class=\"ch.qos.logback.classic.net.SSLSocketAppender\">\n    <remoteHost>${host}</remoteHost>\n    <port>${port}</port>\n    <reconnectionDelay>10000</reconnectionDelay>\n    <ssl>\n      <trustStore>\n        <location>${truststore}</location>\n        <password>${password}</password>\n      </trustStore>\n    </ssl>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"SOCKET\" />\n  </root>\n\n</configuration>\n\n<configuration>\n\n  <appender name=\"FILE\" class=\"ch.qos.logback.core.FileAppender\">\n    <file>testFile.log</file>\n    <append>true</append>\n    <!-- encoders are assigned the type\n        ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->\n    <encoder>\n      <pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern>\n    </encoder>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"FILE\" />\n  </root>\n</configuration>\n```\n参考：https://blog.csdn.net/tianyaleixiaowu/article/details/73327752\n\n下面基于logback配置做一个请求日志的的封装\n\n功能：记录每次请求的参数和用户ID存入数据库或者elk\n问题：javaee规范中request输入输出流都只能被读取一次，所以如果用过滤器或者拦截器读取request中的流都会导致后面的controller无法接受到数据。\n所以我们要用原生的aop获得请求参数，切点为controller，这就很好的避开了以上问题。\n\n```java\npackage com.muggle.poseidon.core.aspect;\n\nimport com.muggle.poseidon.manager.UserInfoManager;\nimport com.muggle.poseidon.utils.RequestUtils;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.Serializable;\n\n/**\n * @program: hiram_erp\n * @description: 日志信息切面\n * @author: muggle\n * @create: 2019-02-21\n **/\n@Aspect\n@Component\npublic class LogMessageAspect {\n\n    private final static Logger logger = LoggerFactory.getLogger(\"requestLog\");\n//    private final static Logger timeLog = LoggerFactory.getLogger(LogMessageAspect.class);\n    private static final ThreadLocal<Long> threadLocal = new ThreadLocal<>();\n    @Pointcut(\"execution(public * com.hiram.erp.controller.*.*(..))\")\n    public void webLog() {}\n\n    /**\n     * 在切点之前织入\n     * @param joinPoint\n     * @throws Throwable\n     */\n    @Before(\"webLog()\")\n    public void doBefore(JoinPoint joinPoint) throws Throwable {\n//        System.out.println(\"sssssssssssssssssssssssssssssssssssssssssssssssssssss\");\n       /* // 开始打印请求日志\n        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = attributes.getRequest();\n\n        // 打印请求相关参数\n        // 打印请求 url\n        // 请求id\n        Long userId=null;\n        if (user!=null){\n            userId=user.getUserInfo().getUserId();\n        }\n        logger.info(\"URL : {}, 登录id: {} ,HTTP Method: {},ip :{},Request Args : {}\", request.getRequestURL().toString(),userId, request.getMethod(),request.getRemoteAddr());\n*/    }\n\n    /**\n     * 在切点之后织入\n     * @throws Throwable\n     */\n    @After(\"webLog()\")\n    public void doAfter(JoinPoint joinPoint) throws Throwable {\n\n\n\n    }\n\n    /**\n     * 环绕\n     * @param joinPoint\n     * @return\n     * @throws Throwable\n     */\n    @Around(\"webLog()\")\n    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        Object result = joinPoint.proceed();\n        // 打印出参\n//        logger.info(\"Response Args  : {},\", JSONObject.toJSONString(result),new Date());\n        // 执行耗时\n        // 开始打印请求日志\n        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = attributes.getRequest();\n        HttpServletResponse response = attributes.getResponse();\n        String requestURL = request.getRequestURL().toString();\n        if (requestURL.contains(\"/sys/log_info/\")){\n            return result;\n        }\n        // 打印请求相关参数\n        // 打印请求 url\n        // 请求id\n        String userId = UserInfoManager.getUserId();\n\n        String url = request.getRequestURL().toString();\n        String method = request.getMethod();\n        String remoteAddr = RequestUtils.getIpAddr(request);\n        Object[] args = joinPoint.getArgs();\n//        List<Object> objects=new ArrayList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i=0;i<args.length;i++){\n            if (args[i] instanceof Serializable||args[i] instanceof Number ||args[i] instanceof String){\n                stringBuilder.append( args[i].toString());\n//                objects.add(args[i]);\n            }\n        }\n        logger.info(\"{\\\"startTime\\\":\\\"{}\\\",\\\"url\\\":\\\"{}\\\",\\\"userId\\\":\\\"{}\\\" ,\\\"httpMethod\\\":\\\"{}\\\",\\\"ip\\\":\\\"{}\\\",\\\"requestArgs\\\":\\\"{}\\\",\\\"status\\\":{}}\",startTime,url,userId,method,remoteAddr,stringBuilder.toString(),response.getStatus());\n        return result;\n    }\n\n\n}\n\n```\n对于数据库存储，如果我们希望log存在另外一个数据库中不存在项目里的数据库中，并且可以通过持久化框架查询数据库内信息。我们则可以配置多数据源，如果将日志放在同一个数据库中则直接配置appender就行了，很方便。\n多数据源配置mybatis版：\n\n其原理是配置多个sessionfactory,然后根据不同的mapperscan来区分不同mapper对应的数据库\n\n以druid连接池为例\n\napplication.yml\n\n```java\nlog:\n  datasource:\n    druid:\n      url: ${mysql_url}/log?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowMultiQueries=true&serverTimezone=GMT%2B8&nullCatalogMeansCurrent=true\n      username:\n      password:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\n      filters: stat,wall\n      initialSize: 5\n      maxActive: 20\n      maxPoolPreparedStatementPerConnectionSize: 20\n      maxWait: 60000\n      minIdle: 5\n      poolPreparedStatements: true\n      testOnBorrow: false\n      testOnReturn: false\n      testWhileIdle: true\n      timeBetweenEvictionRunsMillis: 60000\n      validationQuery: SELECT 1\n\n\nspring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      url: ${mysql_url}/hiram_erp?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowMultiQueries=true&serverTimezone=GMT%2B8&nullCatalogMeansCurrent=true\n      username:\n      password:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\n      filters: stat,wall\n      initialSize: 5\n      maxActive: 20\n      maxPoolPreparedStatementPerConnectionSize: 20\n      maxWait: 60000\n      minIdle: 5\n      poolPreparedStatements: true\n      testOnBorrow: false\n      testOnReturn: false\n      testWhileIdle: true\n      timeBetweenEvictionRunsMillis: 60000\n      validationQuery: SELECT 1\n```\n\n```java\n\n@Configuration\n// 主数据库配置 指定mapper位置\n@MapperScan(basePackages = {\"com.muggle.poseidon.mapper\"}, sqlSessionTemplateRef = \"sqlSessionTemplate\")\npublic class ManySourceDBConfig {\n\n    @Bean(name = \"dataSource\")\n    // 读取application的配置信息\n   @ConfigurationProperties(prefix = \"spring.datasource.druid\")\n   // 最高优先级，表示系统默认使用该配置\n    @Primary\n    public DataSource dataSource() {\n        DruidDataSource druidDataSource = new DruidDataSource();\n\n        List filterList = new ArrayList<>();\n\n        filterList.add(wallFilter());\n\n        druidDataSource.setProxyFilters(filterList);\n\n        return druidDataSource;\n    }\n\n    @Bean(name = \"sqlSessionFactory\")\n    @Primary\n    public SqlSessionFactory sqlSessionFactory() throws Exception {\n        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();\n        sqlSessionFactoryBean.setDataSource(this.dataSource());\n\n        Properties props = new Properties();\n        props.setProperty(\"localCacheScope\", \"true\");\n        props.setProperty(\"lazyLoadingEnabled\", \"true\");\n        props.setProperty(\"aggressiveLazyLoading\", \"false\");\n        props.setProperty(\"jdbcTypeForNull\", \"NULL\");\n        sqlSessionFactoryBean.setConfigurationProperties(props);\n        sqlSessionFactoryBean.setVfs(SpringBootVFS.class);\n        //pageHelper\n        Properties properties = new Properties();\n        properties.setProperty(\"reasonable\", \"true\");\n        properties.setProperty(\"supportMethodsArguments\", \"true\");\n        properties.setProperty(\"params\", \"count=countSql\");\n        properties.setProperty(\"pageSizeZero\", \"true\");\n        PageInterceptor interceptor = new PageInterceptor();\n        interceptor.setProperties(properties);\n        sqlSessionFactoryBean.setPlugins(new Interceptor[]{interceptor});\n        sqlSessionFactoryBean.setTypeAliasesPackage(\"com.muggle.poseidon.model\");\n        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\n        sqlSessionFactoryBean.setMapperLocations(resolver.getResources(\"classpath*:/mapper/*.xml\"));\n        return sqlSessionFactoryBean.getObject();\n    }\n\n    @Bean(name = \"transactionManager\")\n    @Primary\n    public PlatformTransactionManager transactionManager() {\n        return new DataSourceTransactionManager(this.dataSource());\n    }\n\n    @Bean(name = \"sqlSessionTemplate\")\n    public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(\"sqlSessionFactory\") SqlSessionFactory sqlSessionFactory) throws Exception {\n        return new SqlSessionTemplate(sqlSessionFactory);\n    }\n\n    @Bean\n    public ServletRegistrationBean statViewServlet() {\n        ServletRegistrationBean druid = new ServletRegistrationBean();\n        druid.setServlet(new StatViewServlet());\n        druid.setUrlMappings(Collections.singletonList(\"/druid/*\"));\n        Map<String, String> params = new HashMap<>();\n        params.put(\"loginUsername\", \"\");\n        params.put(\"loginPassword\", \"\");\n        druid.setInitParameters(params);\n        return druid;\n    }\n\n    @Bean\n    public FilterRegistrationBean webStatFilter() {\n        FilterRegistrationBean fitler = new FilterRegistrationBean();\n        fitler.setFilter(new WebStatFilter());\n        fitler.setUrlPatterns(Collections.singletonList(\"/*\"));\n        fitler.addInitParameter(\"exclusions\", \"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\");\n        return fitler;\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n\n        WallFilter wallFilter = new WallFilter();\n\n        wallFilter.setConfig(wallConfig());\n\n        return wallFilter;\n\n    }\n\n    @Bean\n    public WallConfig wallConfig() {\n\n        WallConfig config = new WallConfig();\n\n        config.setMultiStatementAllow(true);//允许一次执行多条语句\n\n        config.setNoneBaseStatementAllow(true);//允许非基本语句的其他语句\n\n        return config;\n\n    }\n\n    @Bean\n    public ProcessEngineConfiguration processEngineConfiguration() {\n        ProcessEngineConfiguration pec = StandaloneProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();\n        pec.setDataSource(dataSource());\n        //如果表不存在，自动创建表\n        pec.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);\n        //属性asyncExecutorActivate定义为true，工作流引擎在启动时就建立启动async executor线程池\n        pec.setAsyncExecutorActivate(false);\n        return pec;\n    }\n\n\n    @Bean\n    public ProcessEngine processEngine() {\n        return processEngineConfiguration().buildProcessEngine();\n    }\n\n}\n\n```\n\nlog数据库配置\n\n```java\n\n\n\n/**\n * @program:\n * @description:\n * @author: muggle\n * @create: 2019-02-23\n **/\n@Configuration\n// 注意确保主配置无法扫描到这个包\n@MapperScan(basePackages = \"com.muggle.poseidon.logmapper\", sqlSessionTemplateRef  = \"test1SqlSessionTemplate\")\n\npublic class LogDBConfig  {\n    @Bean(name = \"test1DataSource\")\n    @ConfigurationProperties(prefix = \"log.datasource.druid\")\n    public DataSource dataSource() {\n        DruidDataSource druidDataSource = new DruidDataSource();\n\n        List filterList = new ArrayList<>();\n\n        filterList.add(wallFilter());\n\n        druidDataSource.setProxyFilters(filterList);\n\n        return druidDataSource;\n    }\n\n    @Bean(name = \"test1SqlSessionFactory\")\n    public SqlSessionFactory testSqlSessionFactory(@Qualifier(\"test1DataSource\") DataSource dataSource) throws Exception {\n        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();\n        bean.setDataSource(dataSource);\n        bean.setMapperLocations(new\n        // mapper位置，不要和主配置的mapper放到一起\n         PathMatchingResourcePatternResolver().getResources(\"classpath*:/mapper/log/*.xml\"));\n        return bean.getObject();\n    }\n\n    @Bean(name = \"test1TransactionManager\")\n    public DataSourceTransactionManager testTransactionManager(@Qualifier(\"test1DataSource\") DataSource dataSource) {\n        return new DataSourceTransactionManager(dataSource);\n    }\n\n    @Bean(name = \"test1SqlSessionTemplate\")\n    public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(\"test1SqlSessionFactory\") SqlSessionFactory sqlSessionFactory) throws Exception {\n        return new SqlSessionTemplate(sqlSessionFactory);\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n\n        WallFilter wallFilter = new WallFilter();\n\n        wallFilter.setConfig(wallConfig());\n\n        return wallFilter;\n\n    }\n    @Bean\n    public WallConfig wallConfig() {\n\n        WallConfig config = new WallConfig();\n\n        config.setMultiStatementAllow(true);//允许一次执行多条语句\n\n        config.setNoneBaseStatementAllow(true);//允许非基本语句的其他语句\n\n        return config;\n\n    }\n}\n\n```\n\n多数据源jpa版\n```java\npackage com.muggle.poseidon.config;\n\n\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.jdbc.DataSourceBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\npublic class DataSourceConfig {\n\n    /**\n     * 扫描spring.datasource.primary开头的配置信息\n     *\n     * @return 数据源配置信息\n     */\n    @Primary\n    @Bean(name = \"primaryDataSourceProperties\")\n    @ConfigurationProperties(prefix = \"spring.datasource\")\n    public DataSourceProperties dataSourceProperties() {\n        return new DataSourceProperties();\n    }\n\n    /**\n     * 获取主库数据源对象\n     *\n     * @param properties 注入名为primaryDataSourceProperties的bean\n     * @return 数据源对象\n     */\n    @Primary\n    @Bean(name = \"primaryDataSource\")\n    public DataSource dataSource(@Qualifier(\"primaryDataSourceProperties\") DataSourceProperties properties) {\n        return properties.initializeDataSourceBuilder().build();\n    }\n\n    /**\n     * 该方法仅在需要使用JdbcTemplate对象时选用\n     *\n     * @param dataSource 注入名为primaryDataSource的bean\n     * @return 数据源JdbcTemplate对象\n     */\n    @Primary\n    @Bean(name = \"primaryJdbcTemplate\")\n    public JdbcTemplate jdbcTemplate(@Qualifier(\"primaryDataSource\") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n\n\n\n\n}\n\n```\n\n```java\npackage com.muggle.poseidon.config;\n\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.sql.DataSource;\nimport java.util.Map;\n\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(\n        // repository包名\n        basePackages = \"com.muggle.poseidon.repos\",\n        // 实体管理bean名称\n        entityManagerFactoryRef = \"primaryEntityManagerFactory\",\n        // 事务管理bean名称\n        transactionManagerRef = \"primaryTransactionManager\"\n)\npublic class MainDataBaseConfig {\n\n    /**\n     * 扫描spring.jpa.primary开头的配置信息\n     *\n     * @return jpa配置信息\n     */\n    @Primary\n    @Bean(name = \"primaryJpaProperties\")\n    @ConfigurationProperties(prefix = \"spring.jpa\")\n    public JpaProperties jpaProperties() {\n        return new JpaProperties();\n    }\n\n    /**\n     * 获取主库实体管理工厂对象\n     *\n     * @param primaryDataSource 注入名为primaryDataSource的数据源\n     * @param jpaProperties     注入名为primaryJpaProperties的jpa配置信息\n     * @param builder           注入EntityManagerFactoryBuilder\n     * @return 实体管理工厂对象\n     */\n    @Primary\n    @Bean(name = \"primaryEntityManagerFactory\")\n    public LocalContainerEntityManagerFactoryBean entityManagerFactory(@Qualifier(\"primaryDataSource\") DataSource primaryDataSource\n            , @Qualifier(\"primaryJpaProperties\") JpaProperties jpaProperties, EntityManagerFactoryBuilder builder) {\n        return builder\n                // 设置数据源\n                .dataSource(primaryDataSource)\n                // 设置jpa配置\n                .properties(jpaProperties.getProperties())\n                // 设置hibernate配置\n                .properties(jpaProperties.getHibernateProperties(new HibernateSettings()))\n                // 设置实体包名\n                .packages(\"com.muggle.poseidon.model\")\n                // 设置持久化单元名，用于@PersistenceContext注解获取EntityManager时指定数据源\n                .persistenceUnit(\"primaryPersistenceUnit\")\n                .build();\n    }\n\n    /**\n     * 获取实体管理对象\n     *\n     * @param factory 注入名为primaryEntityManagerFactory的bean\n     * @return 实体管理对象\n     */\n    @Primary\n    @Bean(name = \"primaryEntityManager\")\n    public EntityManager entityManager(@Qualifier(\"primaryEntityManagerFactory\") EntityManagerFactory factory) {\n        return factory.createEntityManager();\n    }\n\n    /**\n     * 获取主库事务管理对象\n     *\n     * @param factory 注入名为primaryEntityManagerFactory的bean\n     * @return 事务管理对象\n     */\n    @Primary\n    @Bean(name = \"primaryTransactionManager\")\n    public PlatformTransactionManager transactionManager(@Qualifier(\"primaryEntityManagerFactory\") EntityManagerFactory factory) {\n        return new JpaTransactionManager(factory);\n    }\n}\n\n​```java\npackage com.muggle.poseidon.core.config;\n\n\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.sql.DataSource;\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(\n        // repository包名\n        basePackages = \"com.muggle.poseidon.logrep\",\n        // 实体管理bean名称\n        entityManagerFactoryRef = \"secondEntityManagerFactory\",\n        // 事务管理bean名称\n        transactionManagerRef = \"secondTransactionManager\"\n)\npublic class LogDataBaseConfig {\n\n    /**\n     * 扫描spring.jpa.second开头的配置信息\n     *\n     * @return jpa配置信息\n     */\n    @Bean(name = \"secondJpaProperties\")\n    @ConfigurationProperties(prefix = \"spring.aa\")\n    public JpaProperties jpaProperties() {\n        return new JpaProperties();\n    }\n\n    /**\n     * 获取从库实体管理工厂对象\n     *\n     * @param secondDataSource 注入名为secondDataSource的数据源\n     * @param jpaProperties    注入名为secondJpaProperties的jpa配置信息\n     * @param builder          注入EntityManagerFactoryBuilder\n     * @return 实体管理工厂对象\n     */\n    @Bean(name = \"secondEntityManagerFactory\")\n    public LocalContainerEntityManagerFactoryBean entityManagerFactory(@Qualifier(\"secondDataSource\") DataSource secondDataSource\n            , @Qualifier(\"secondJpaProperties\") JpaProperties jpaProperties, EntityManagerFactoryBuilder builder) {\n        return builder\n                // 设置数据源\n                .dataSource(secondDataSource)\n                // 设置jpa配置\n                .properties(jpaProperties.getProperties())\n                // 设置hibernate配置\n                .properties(jpaProperties.getHibernateProperties(new HibernateSettings()))\n                // 设置实体包名\n                .packages(\"com.muggle.poseidon.entity\")\n                // 设置持久化单元名，用于@PersistenceContext注解获取EntityManager时指定数据源\n                .persistenceUnit(\"secondPersistenceUnit\")\n                .build();\n    }\n\n    /**\n     * 获取实体管理对象\n     *\n     * @param factory 注入名为secondEntityManagerFactory的bean\n     * @return 实体管理对象\n     */\n    @Bean(name = \"secondEntityManager\")\n    public EntityManager entityManager(@Qualifier(\"secondEntityManagerFactory\") EntityManagerFactory factory) {\n        return factory.createEntityManager();\n    }\n\n    /**\n     * 获取从库事务管理对象\n     *\n     * @param factory 注入名为secondEntityManagerFactory的bean\n     * @return 事务管理对象\n     */\n    @Bean(name = \"secondTransactionManager\")\n    public PlatformTransactionManager transactionManager(@Qualifier(\"secondEntityManagerFactory\") EntityManagerFactory factory) {\n        return new JpaTransactionManager(factory);\n    }\n}\n\n```\n\n```java\n\npackage com.muggle.poseidon.core.config;\n\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\npublic class LogDataConfig {\n    /**\n     * 扫描spring.datasource.second开头的配置信息\n     *\n     * @return 数据源配置信息\n     */\n    @Bean(name = \"secondDataSourceProperties\")\n    @ConfigurationProperties(prefix = \"spring.ss\")\n    public DataSourceProperties dataSourceProperties() {\n        return new DataSourceProperties();\n    }\n\n    /**\n     * 获取从库数据源对象\n     *\n     * @param properties 注入名为secondDataSourceProperties的beanf\n     * @return 数据源对象\n     */\n    @Bean(name = \"secondDataSource\")\n    public DataSource dataSource(@Qualifier(\"secondDataSourceProperties\") DataSourceProperties properties) {\n        return properties.initializeDataSourceBuilder().build();\n    }\n\n    /**\n     * 该方法仅在需要使用JdbcTemplate对象时选用\n     *\n     * @param dataSource 注入名为secondDataSource的bean\n     * @return 数据源JdbcTemplate对象\n     */\n    @Bean(name = \"secondJdbcTemplate\")\n    public JdbcTemplate jdbcTemplate(@Qualifier(\"secondDataSource\") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n}\n\n```\n\napplication.properties\n\n```java\nserver.port=8080\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\n#spring.datasource.url = jdbc:mysql://localhost:3306/test\nspring.datasource.driverClassName = com.mysql.cj.jdbc.Driver\nspring.datasource.url = jdbc:mysql://119.23.75.58:3306/poseidon?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowMultiQueries=true\nspring.datasource.username =\nspring.datasource.password =\nspring.datasource.max-active=20\nspring.datasource.max-idle=8\nspring.datasource.min-idle=8\nspring.datasource.initial-size=10\n\nspring.jpa.database=mysql\nspring.jpa.show-sql = true\n#配置方言\nspring.jpa.database-platform=org.hibernate.dialect.MySQL5Dialect\n\nspring.ss.type=com.alibaba.druid.pool.DruidDataSource\n#spring.datasource.url = jdbc:mysql://localhost:3306/test\nspring.ss.driverClassName = com.mysql.cj.jdbc.Driver\nspring.ss.url = jdbc:mysql://zzzzz/log?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowMultiQueries=true\nspring.ss.username =\nspring.ss.password =\nspring.ss.max-active=20\nspring.ss.max-idle=8\nspring.ss.min-idle=8\nspring.ss.initial-size=10\n\n\nspring.aa.database=mysql\nspring.aa.show-sql = true\n#配置方言\nspring.aa.database-platform=org.hibernate.dialect.MySQL5Dialect\n```\n\n\n以数据库作为输出配置就算完成了，接下来整合elk系统到我们日志系统中：\n\n\n先整合logstash\n\nlogstash安装和配置：\nhttps://www.elastic.co/cn/downloads/logstash 选择zip包下载\n\n解压，进入bin目录 创建logstash.conf 并配置：\n```xml\ninput {\n    tcp {\n    ##host:port就是上面appender中的 destination，这里其实把logstash作为服务，开启9250端口接收logback发出的消息\n    host => \"127.0.0.1\"\n    port => 9100\n    mode => \"server\"\n    tags => [\"tags\"]\n    codec => json_lines\n    }\n}\noutput {\n    stdout { codec => rubydebug }\n    #输出到es\n    #elasticsearch { hosts => \"127.0.0.1:9200\" }\n        #输出到一个文件中\n    file {\n       path => \"D:\\logs\\test.log\"\n       codec => line\n    }\n}\n\n```\n我这里先配置输出到文件，后面再修改,创建文件：D:\\logs\\test.log\n\n启动：\n\n打开cmd（不要使用powershell），进入bin:\n```xml\nD:\\exe\\logstash-6.6.1\\logstash-6.6.1\\bin>logstash -f logstash.conf\n```\n\n然后在我们的项目中进行相应的配置：\n按这个来：https://github.com/logstash/logstash-logback-encoder\n\n加入pom并指定logback版本：\n```xml\n<!-- 父pom中 -->\n<ch.qos.logback.version>1.2.3</ch.qos.logback.version>\n\n<!--  日志模块-->\n<dependency>\n  <groupId>net.logstash.logback</groupId>\n  <artifactId>logstash-logback-encoder</artifactId>\n  <version>5.3</version>\n  </dependency>\n        <!-- Your project must also directly depend on either logback-classic or logback-access.  For example: -->\n  <dependency>\n    <groupId>ch.qos.logback</groupId>\n    <artifactId>logback-classic</artifactId>\n    <version>1.2.3</version>\n  </dependency>\n```\n\n配置apppender和logger\n\n```xml\n<appender name=\"stash\" class=\"net.logstash.logback.appender.LogstashTcpSocketAppender\">\n    <destination>127.0.0.1:9100</destination>\n    <includeCallerData>true</includeCallerData>\n\n    <encoder class=\"net.logstash.logback.encoder.LogstashEncoder\">\n        <includeCallerData>true</includeCallerData>\n    </encoder>\n  </appender>\n  <logger name=\"logstash\" level=\"info\">\n      <appender-ref ref=\"stash\"/>\n  </logger>\n```\n测试：\n```java\nRestController\n@RequestMapping(\"/public/log\")\npublic class LogTestController {\n    private static final Logger log = LoggerFactory.getLogger(\"logstash\");\n    @Autowired\n    LoggingEventRepository repository;\n\n    @GetMapping(\"/\")\n    public String test(){\n        log.info(\"sssssssssssssss\");\n        Iterable<LoggingEvent> all = repository.findAll();\n\n        return \"sss\";\n\n    }\n}\n```\n\n访问接口，logstash打印信息：\n\n```\n[2019-03-09T11:32:56,358][INFO ][logstash.outputs.file    ] Opening file {:path=>\"D:/logs/test.log\"}\n{\n                  \"host\" => \"www.xmind.net\",\n                 \"level\" => \"INFO\",\n     \"caller_class_name\" => \"com.muggle.poseidon.controller.LogTestController\",\n            \"@timestamp\" => 2019-03-09T03:33:03.413Z,\n           \"logger_name\" => \"logstash\",\n              \"@version\" => \"1\",\n           \"thread_name\" => \"http-nio-8080-exec-9\",\n               \"message\" => \"sssssssssssssss\",\n    \"caller_line_number\" => 22,\n                  \"port\" => 58368,\n           \"level_value\" => 20000,\n      \"caller_file_name\" => \"LogTestController.java\",\n                  \"tags\" => [\n        [0] \"tags\"\n    ],\n    \"caller_method_name\" => \"test\"\n}\n```\ntest.log输出了文件：\n\n```\n2019-03-09T03:33:03.413Z www.xmind.net sssssssssssssss\n```\n接下来只要把输出路径换成ES就可以了，这属于logstash和es的整合，这里先不讲解；重新回归到我们的请求模块：\n\n我希望我的模块，对每次请求都能记录下来（请求日志），并将记录存到数据库或者ES，同时我要对所有接口都进行一个幂等性的保障；保障接口的幂等性有多种方法，比较简单的是数据库做唯一索引或者加拦截器，我这里加了一个拦截器来保障接口幂等和拦截前端数据的重复提交(关于接口幂等性在其他文档中介绍)：\n```java\n@Slf4j\npublic class RequestLockInterceptor implements HandlerInterceptor {\n    RedisLock redisTool;\n    private int expireTime;\n\n    public RequestLockInterceptor(int expireTime, RedislockImpl redisTool) {\n        this.expireTime = expireTime;\n        this.redisTool = redisTool;\n    }\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        if(\"post\".equalsIgnoreCase(request.getMethod())){\n            String token = request.getParameter(\"request_key\");\n            if (token==null||\"\".equals(token)){\n                log.error(\"请求非法\");\n//            throw new PoseidonException(\"请求太频繁\",PoseidonProperties.TOO_NUMBER_REQUEST);\n                response.setContentType(\"application/json;charset=UTF-8\");\n                PrintWriter writer = response.getWriter();\n                writer.write(\"{\\\"code\\\":\\\"5001\\\",\\\"msg\\\":\\\"请求非法\\\"}\");\n                writer.close();\n                return false;\n            }\n            String ipAddr = RequestUtils.getIpAddr(request);\n            String lockKey = request.getRequestURI() + \"_\"  + \"_\" + token;\n            boolean lock = redisTool.lock(lockKey, ipAddr, expireTime);\n            if (!lock) {//\n                log.error(\"拦截表单重复提交\");\n//            throw new PoseidonException(\"请求太频繁\",PoseidonProperties.TOO_NUMBER_REQUEST);\n                response.setContentType(\"application/json;charset=UTF-8\");\n                PrintWriter writer = response.getWriter();\n                writer.write(\"{\\\"code\\\":\\\"5001\\\",\\\"msg\\\":\\\"请求太频繁\\\"}\");\n                writer.close();\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n//        String requestURI = request.getRequestURI();\n//        String lockKey = request.getRequestURI() + \"_\" + RequestUtils.getIpAddr(request);\n//        redisTool.unlock(lockKey,getIpAddr(request));\n    }\n\n\n}\n\n```\n项目使用了redis锁（redis锁原理和使用在其他文档中介绍）\n\n对于系统异常，如果是业务的异常，正常处理，如果是系统发生的异常比如空指针，数据库异常等我希望系统能马上通知，以便排查问题，所以我配置邮件异常通知(关于springboot邮件配置其他文档介绍)：\n\n```java\n\n@RestControllerAdvice\n@Slf4j\npublic class RestExceptionHandlerController {\n    @Autowired\n    EmailService emailService;\n    @Value(\"${admin.email}\")\n    private String adminEmail;\n\n    @ExceptionHandler(value = {PoseidonException.class})\n    public ResultBean poseidonExceptionHandler(PoseidonException e, HttpServletRequest req) {\n        return new ResultBean().setMsg(e.getMsg()).setCode(e.getCode());\n    }\n    @ExceptionHandler(value = {MethodArgumentNotValidException.class})\n    public ResultBean MethodArgumentNotValidException(MethodArgumentNotValidException e, HttpServletRequest req) {\n        System.out.println(e.getMessage());\n        return new ResultBean().setMsg(\"数据未通过校验\").setCode(PoseidonProperties.COMMIT_DATA_ERROR);\n    }\n\n    @ExceptionHandler(value = {Exception.class})\n    public ResultBean exceptionHandler(Exception e, HttpServletRequest req) {\n        log.error(\"系统异常：\" + req.getMethod() + req.getRequestURI(), e);\n        try {\n//\n            EmailBean emailBean = new EmailBean();\n            emailBean.setRecipient(adminEmail);\n            emailBean.setSubject(\"poseidon---系统异常\");\n            emailBean.setContent(\"系统异常：\" + req.getMethod() + req.getRequestURI()+\"----\"+e.getMessage());\n//            改良\n            emailService.sendSimpleMail(emailBean);\n        } finally {\n            return new ResultBean().setMsg(\"系统异常，请联系管理员\").setCode(\"500\");\n        }\n    }\n\n    @ExceptionHandler(value = {HttpRequestMethodNotSupportedException.class})\n    public ResultBean notsupported(Exception e, HttpServletRequest req) {\n        return new ResultBean().setMsg(\"不支持的请求方式\").setCode(PoseidonProperties.NOT_SUPPORT_METHOD);\n    }\n    @ExceptionHandler(value = {NoHandlerFoundException.class})\n    public ResultBean notFoundUrl(Exception e, HttpServletRequest req) {\n        return new ResultBean().setMsg(\"请求路径不存在\").setCode(\"404\");\n    }\n}\n\n```\n\n\n项目架构信得\ncommon 和core模块存在的意义\n\n\n","source":"_posts/logback.md","raw":"---\ntitle: ' logback深度使用'\ndate: 2019-03-28 09:44:50\ntags: log\n---\n\n\n##### 作者：muggle\n\nLogback是由log4j创始人设计的另一个开源日志组件,分为三个模块：\n\n1. logback-core：其它两个模块的基础模块\n\n2. logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging\n\n3. logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能\n在springboot中我们通过xml配置来操作logback\n\n<!--more-->\nspringboot中logback的默认配置文件名称为logback-spring.xml，若需要指定xml名称，需在application.properties（application.yml）中配置logging.config=xxxx.xml\n现在贴出一份logback的xml配置，可直接使用，懒得看的小伙伴复制粘贴到你的项目中去体验吧\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\n\n<configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\">\n\n    <jmxConfigurator/>\n\n    <property name=\"log_dir\" value=\"logs\"/>\n    <property name=\"maxHistory\" value=\"100\"/>\n\n    <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>\n                %d{yyyy-MM-dd HH:mm:ss.SSS} %highlight([%-5level]) %logger - %msg%n\n            </pattern>\n        </encoder>\n    </appender>\n    <appender name=\"logs\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <fileNamePattern>\n                ${log_dir}/%d{yyyy-MM-dd}-poseidon.log\n            </fileNamePattern>\n            <maxHistory>${maxHistory}</maxHistory>\n        </rollingPolicy>\n        <encoder>\n            <pattern>\n                %d{yyyy-MM-dd HH:mm:ss.SSS} %highlight([%-5level]) %logger - %msg%n\n            </pattern>\n        </encoder>\n    </appender>\n\n    <appender name=\"runningTime-file\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <fileNamePattern>${log_dir}/runningTime/%d{yyyy-MM-dd}-poseidon.log</fileNamePattern>\n            <maxHistory>${maxHistory}</maxHistory>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n        </encoder>\n    </appender>\n    <appender name=\"runningTime-console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>\n                %d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n\n            </pattern>\n        </encoder>\n    </appender>\n    <logger name=\"runningTime\" level=\"info\" additivity=\"false\">\n        <!--<appender-ref ref=\"runningTime-file\"/>-->\n        <appender-ref ref=\"runningTime-console\"/>\n    </logger>\n<!--  可能会抛出方言异常 两个解决方案 配置方言或者换连接池 换druid不会有这个异常-->\n    <appender name=\"requestLog-db\" class=\"ch.qos.logback.classic.db.DBAppender\">\n        <connectionSource class=\"ch.qos.logback.core.db.DataSourceConnectionSource\">\n            <dataSource class=\"org.apache.commons.dbcp.BasicDataSource\">\n                <driverClassName>com.mysql.cj.jdbc.Driver</driverClassName>\n                <url>jdbc:mysql://xxx/xxxx?characterEncoding=UTF-8</url>\n                <username>xx</username>\n                <password>xxxx</password>\n            </dataSource>\n        </connectionSource>\n        <!--<sqlDialect class=\"ch.qos.logback.core.db.dialect.MySQLDialect\" />-->\n    </appender>\n    <!--异步配置-->\n    <!--<appender name=\"requestLog-file\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n         <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n             <fileNamePattern>${log_dir}/requestLog/%d{yyyy-MM-dd}-poseidon.log</fileNamePattern>\n             <maxHistory>${maxHistory}</maxHistory>\n         </rollingPolicy>\n         <encoder>\n             <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n         </encoder>\n     </appender>-->\n    <!-- <appender name=\"request-asyn\" class=\"ch.qos.logback.classic.AsyncAppender\">\n        <appender-ref ref=\"requestLog-file\"/>\n    </appender> -->\n    <appender name=\"logs-asyn\" class=\"ch.qos.logback.classic.AsyncAppender\">\n        <appender-ref ref=\"logs\"/>\n    </appender>\n    <logger name=\"requestLog\" level=\"info\" additivity=\"false\">\n        <!--<appender-ref ref=\"requestLog-file\"/>-->\n        <!-- DBAppender 查看可知其父类dbappenderbase继承了UnsynchronizedAppenderBase<E> 所以dbappender本身是异步的 无需配置异步-->\n        <appender-ref ref=\"requestLog-db\"/>\n    </logger>\n    <root>\n        <level value=\"info\"/>\n        <appender-ref ref=\"console\"/>\n        <!--<appender-ref ref=\"logs\"/>-->\n        <appender-ref ref=\"logs-asyn\"/>\n    </root>\n</configuration>\n```\n\n我们可以看到xml中有四种节点\nappender，logger，root,configuration\n#### 节点解读\n\nconfiguration包含三个属性：\n\n1. scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。\n2. scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。\n3. debug: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。\n4.\nLogger作为日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别。\n\nAppender主要用于指定日志输出的目的地，目的地可以是控制台、文件、远程套接字服务器、 MySQL、PostreSQL、 Oracle和其他数据库、 JMS和远程UNIX Syslog守护进程等。\n\nroot 就是最高级别logger,所有不被指定logger的日志都归root管理。\n\n在slf4j框架下我们使用log是这样的:\n```java\n private static final Logger logger= LoggerFactory.getLogger(xxx.class);\n```\n或者\n```java\n private static final Logger logger= LoggerFactory.getLogger(\"xxxx\");\n```\n\n可以理解为代码中的getLogger() 方法就是获取xml配置中的logger,如果没有配置相应的logger则为root\n比如我配置了：\n```xml\n<logger name=\"hhh\" level=\"info\" additivity=\"false\">\n        <!--<appender-ref ref=\"requestLog-file\"/>-->\n        <appender-ref ref=\"xxx\"/>\n</logger>\n```\n那我在获得一个logger时可以这样获得它：\n```java\n private static final Logger logger= LoggerFactory.getLogger(\"hhh\");\n```\n我所输出的日志将被这个logger所管理\nlogger 上有三个配置 name level additivity\nname就是这个logger的名称，level就是这个日志过滤的级别，低于这个级别的日志不输入到对应的appender中；additivity是否向上级logger传递打印信息，默认是true。logger中可以配置多个appender-ref，也就是可以指定多个输出地点。\n而root只是特殊的logger，用法上无差别\n\n\nappender节点：\nappender节点是logback配置的关键，其name属性指定其名称，class属性指定实现类，对应得实现类有\n```java\nch.qos.logback.core.ConsoleAppender // 以控制台作为输出\nch.qos.logback.core.rolling.RollingFileAppender//以日志文件作为输出\nch.qos.logback.classic.db.DBAppender//以数据库作为输出\nnet.logstash.logback.appender.LogstashTcpSocketAppender//以logstash作为输出需要引入如下依赖：\nch.qos.logback.classic.AsyncAppender//异步输出 需要定义appender-ref\n\n// logstash依赖\n<dependency>\n  <groupId>net.logstash.logback</groupId>\n  <artifactId>logstash-logback-encoder</artifactId>\n  <version>4.11</version>\n</dependency>\n```\n\n所有的appender 实现ch.qos.logback.core.Appender接口或者 ch.qos.logback.core.UnsynchronizedAppenderBase接口（异步），我们也可以自定义appender来指定日志输出；\n\n在Appender中可以定义哪些节点我们一个个来看：\n\n第一种： ConsoleAppender\n如同它的名字一样，这个Appender将日志输出到console，更准确的说是System.out 或者System.err。\n它包含的参数如下：\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nencoder  | Encoder   | 通常在其pattern里指定日志格式  如： %d{yyyy-MM-dd HH:mm:ss.SSS} %highlight([%-5level]) %logger - %msg%n表示 日期格式 日志级别（高亮）logger的名称 logger的message\ntarget|String|指定输出目标。可选值：System.out 或 System.err。默认值：System.out\nwithJansi|boolean|是否支持ANSI color codes（类似linux中的shell脚本的输出字符串颜色控制代码）。默认为false。如果设置为true。例如：[31m 代表将前景色设置成红色。在windows中，需要提供\"org.fusesource.jansi:jansi:1.9\"，而在linux，mac os x中默认支持。\n\n第二种： FileAppender\n将日志输出到文件当中，目标文件取决于file属性。是否追加输出，取决于append属性。\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nappend |\tboolean\t| 是否以追加方式输出。默认为true。\nencoder |\tEncoder\t|See OutputStreamAppender properties.\nfile\t| String |\t指定文件名。注意在windows当中，反斜杠 \\ 需要转义，或直接使用 / 也可以。例如 c:/temp/test.logor 或 c:\\\\temp\\\\test.log 都可以。没有默认值，如果上层目录不存在，FileAppender会自动创建。\nprudent |\tboolean|\t是否工作在谨慎模式下。在谨慎模式下，FileAppender将会安全写入日志到指定文件，即时在不同的虚拟机jvm中有另一个相同的FileAppender实例。默认值：fales;设置为true，意味着append会被自动设置成true。prudent依赖于文件排它锁。实验表明，使用文件锁，会增加3倍的日志写入消耗。比如说，当prudent模式为off，写入一条日志到文件只要10毫秒，但是prudent为真，则会接近30毫秒。prudent 模式实际上是将I/O请求序列化，因此在I/O数量较大，比如说100次/s或更多的时候，带来的延迟也会显而易见，所以应该避免。在networked file system（远程文件系统）中，这种消耗将会更大，可能导致死锁。\n\n第三个： RollingFileAppender\n\nRollingFileAppender继承自FileAppender，提供日志目标文件自动切换的功能。例如可以用日期作为日志分割的条件。\nRollingFileAppender有两个重要属性，RollingPolicy负责怎么切换日志，TriggeringPolicy负责何时切换。为了使RollingFileAppender起作用，这两个属性必须设置，但是如果RollingPolicy的实现类同样实现了TriggeringPolicy接口，则也可以只设置RollingPolicy这个属性。\n下面是它的参数：\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nfile |\tString |\t指定文件名。注意在windows当中，反斜杠 \\ 需要转义，或直接使用 / 也可以。例如 c:/temp/test.logor 或 c:\\\\temp\\\\test.log 都可以。没有默认值，如果上层目录不存在，FileAppender会自动创建。\nappend\t|boolean\t|是否以追加方式输出。默认为true。\nencoder\t| Encoder\t| See OutputStreamAppender properties.\nrollingPolicy |\tRollingPolicy\t| 当发生日志切换时，RollingFileAppender的切换行为。例如日志文件名的修改\ntriggeringPolicy\t| TriggeringPolicy\t| 决定什么时候发生日志切换，例如日期，日志文件大小到达一定值\nprudent\t| boolean\t|FixedWindowRollingPolicy 不支持prudent模式。TimeBasedRollingPolicy 支持prudent模式，但是需要满足一下两条约束：在prudent模式中，日志文件的压缩是不被允许，不被支持的。不能设置file属性。\n\n第四个：SocketAppender及SSLSocketAppender（未尝试过）\n\n到目前为止我们讲的appender都只能将日志输出到本地资源。与之相对的，SocketAppender就是被设计用来输出日志到远程实例中的。SocketAppender输出日志采用明文方式，SSLSocketAppender则采用加密方式传输日志。\n被序列化的日志事件的类型是 LoggingEventVO 继承ILoggingEvent接口。远程日志记录并非是侵入式的。在反序列化接收后，日志事件就可以好像在本地生成的日志一样处理了。多个SockerAppender可以向同一台日志服务器发送日志。SocketAppender并不需要关联一个Layout，因为它只是发送序列化的日志事件给远程日志服务器。SocketAppender的发送操作是基于TCP协议的。因此如果远程服务器是可到达的，则日志会被其处理，如果远程服务器宕机或不可到达，那么日志将会被丢弃。等到远程服务器复活，日志发送将会透明的重新开始。这种透明式的重连，是通过一个“连接“线程周期性的尝试连接远程服务器实现的。\nLogging events会由TCP协议实现自动缓冲。这意味着，如果网络速度比日志请求产生速度快，则网络速度并不会影响应用。但如果网络速度过慢，则网络速度则会变成限制，在极端情况下，如果远程日志服务器不可到达，则会导致应用最终阻塞。不过，如果服务器可到达，但是服务器宕机了，这种情况，应用不会阻塞，而只是丢失一些日志事件而已。\n需要注意的是，即使SocketAppender没有被logger链接，它也不会被gc回收，因为他在connector thread中任然存在引用。一个connector thread 只有在网络不可达的情况下，才会退出。为了防止这个垃圾回收的问题，我们应该显示声明关闭SocketAppender。长久存活并创建/销毁大量的SocketAppender实例的应用，更应该注意这个问题。不过大多数应用可以忽略这个问题。如果JVM在SocketAppender关闭之前将其退出，又或者是被垃圾回收，这样子可能导致丢失一些还未被传输，在管道中等待的日志数据。为了防止避免日志丢失，经常可靠的办法就是调用SocketAppender的close方法，或者调用LoggerContext的stop方法，在退出应用之前。\n\n下面我们来看看SocketAppender的属性：\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nincludeCallerData |\tboolean\t|是否包含调用者的信息如果为true，则以下日志输出的 ?:? 会替换成调用者的文件名跟行号，为false，则为问号。2019-01-06 17:37:30,968 DEBUG [Thread-0] [?:?] chapters.appenders.socket.SocketClient2 - Hi\nport |\tint\t| 端口号\nreconnectionDelay\t| Duration\t| 重连延时，如果设置成“10 seconds”，就会在连接u武器失败后，等待10秒，再连接。默认值：“30 seconds”。如果设置成0，则关闭重连功能。\nqueueSize\t| int\t| 设置缓冲日志数，如果设置成0，日志发送是同步的，如果设置成大于0的值，会将日志放入队列，队列长度到达指定值，在统一发送。可以加大服务吞吐量。\neventDelayLimit |\tDuration |\t设置日志超时丢弃时间。当设置“10 seconds”类似的值，如果日志队列已满，而服务器长时间来不及接收，当滞留时间超过10 seconds，日志就会被丢弃。默认值： 100 milliseconds\nremoteHost |\tString |\t远程日志服务器的IP\nssl\t| SSLConfiguration | 只在SSLSocketAppender包含该属性节点。提供SSL配置，详情见 Using SSL.\n\n标准的Logback Classic包含四个可供使用的Receiver用来接收来自SocketAppender的logging evnets。\n\n第五个： SMTPAppender\n\nSMTPAppender 可以将logging event存放在一个或多个固定大小的缓冲区中，然后在用户指定的event到来之时，将适当的大小的logging event以邮件方式发送给运维人员。\n详细属性如下：\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nsmtpHost |\tString\t| SMTP server的地址，必需指定。如网易的SMTP服务器地址是： smtp.163.com\nsmtpPort |\tint\t| SMTP server的端口地址。默认值：25\nto\t| String |\t指定发送到那个邮箱，可设置多个<to>属性，指定多个目的邮箱\nfrom |\tString |\t指定发件人名称。如果设置成“muggle &lt;hh@moral.org&gt; ”，则邮件发件人将会是“muggle <hh@moral.org> ”\nsubject |\tString |指定emial的标题，它需要满足PatternLayout中的格式要求。如果设置成“Log: %logger - %msg”，就案例来讲，则发送邮件时，标题为“Log: com.foo.Bar - Hello World ”。 默认值：\"%logger{20} - %m\".\ndiscriminator\t| Discriminator\t| 通过Discriminator, SMTPAppender可以根据Discriminator的返回值，将到来的logging event分发到不同的缓冲区中。默认情况下，总是返回相同的值来达到使用一个缓冲区的目的。\nevaluator |\tIEvaluator\t| 指定触发日志发送的条件。通过<evaluator class=... />指定EventEvaluator接口的实现类。默认情况下SMTPAppeender使用的是OnErrorEvaluator，表示当发送ERROR或更高级别的日志请求时，发送邮件。Logback提供了几个evaluators：OnErrorEvaluator、OnMarkerEvaluator、JaninoEventEvaluator、GEventEvaluator（功能强大）\ncyclicBufferTracker |\tCyclicBufferTracker\t| 指定一个cyclicBufferTracker跟踪cyclic buffer。它是基于discriminator的实现的。如果你不指定，默认会创建一个CyclicBufferTracker ，默认设置cyclic buffer大小为256。你也可以手动指定使用默认的CyclicBufferTracker，并且通过<bufferSize>属性修改默认的缓冲区接收多少条logging event。\nusername\t| String |\t发送邮件账号，默认为null\npassword |\tString |\t发送邮件密码，默认为null\nSTARTTLS\t| boolean\t|如果设置为true，appender会尝试使用STARTTLS命令，如果服务端支持，则会将明文连接转换成加密连接。需要注意的是，与日志服务器连接一开始是未加密的。默认值：false\nSSL\t| boolean\t| 如果设置为true，appender将会使用SSL连接到日志服务器。 默认值：false\ncharsetEncoding |\tString\t|指定邮件信息的编码格式 默认值：UTF-8\nlocalhost\t| String |\t如果smtpHost没有正确配置，比如说不是完整的地址。这时候就需要localhost这个属性提供服务器的完整路径（如同java中的完全限定名 ），详情参考com.sun.mail.smtp 中的mail.smtp.localhost属性\nasynchronousSending\t| boolean\t| 这个属性决定email的发送是否是异步。默认：true，异步发送但是在某些情况下，需要以同步方式发送错误日志的邮件给管理人员，防止不能及时维护应用。\nincludeCallerData |\tboolean\t|默认：false 指定是否包含callerData在日志中\nsessionViaJNDI |\tboolean\t| SMTPAppender依赖javax.mail.Session来发送邮件。默认情况下，sessionViaJNDI为false。javax.mail.Session实例的创建依赖于SMTPAppender本身的配置信息。如果设置为true，则Session的创建时通过JNDI获取引用。这样做的好处可以让你的代码复用更好，让配置更简洁。需要注意的是，如果使用JNDI获取Session对象，需要保证移除mail.jar以及activation.jar这两个jar包\njndiLocation |\tString\t| 如果sessionViaJNDI设置为true，则jndiLocation指定JNDI的资源名，默认值为：\"java:comp/env/mail/Session\"\n\nSMTPAppender只保留最近的256条logging events 在循环缓冲区中，当缓冲区慢，就会开始丢弃最老的logging event。因此不管什么时候，SMTPAppender一封邮件最多传递256条日志事件。SMTPAppender依赖于JavaMail API。而JavaMail API又依赖于IOC框架（依赖注入）。\n\n第六个：DBAppender\n\n DBAppender 可以将日志事件插入到3张数据表中。它们分别是logging_event，logging_event_property，logging_event_exception。这三张数据表必须在DBAppender工作之前存在。它们的sql脚本可以在 logback-classic/src/main/java/ch/qos/logback/classic/db/script folder 这个目录下找到。这个脚本对大部分SQL数据库都是有效的，除了少部分，少数语法有差异需要调整。\n下面是logback与常见数据库的支持信息：\n\nRDBMS\t| tested version(s)\t| tested JDBC driver version(s)| \tsupports getGeneratedKeys() method |\tis a dialect provided by logback\n----------|----------|--------|----------|----\nDB2 |\tuntested |\tuntested |\tunknown |\tNO\nH2 |\t--| - |\tunknown\t| YES\nHSQL |-- |\t-\t| NO |\tYES\nMicrosoft SQL Server |\t-- | -- |\tYES\t| YES\nMySQL |\t5.7\t|  \t|YES|\tYES\nPostgreSQL | --|-- |\tNO|\tYES\nOracle\t|--|--|\tYES\t|YES\nSQLLite\t|--|\t-|\tunknown\t|YES\nSybase |--|\t\t-\t|unknown|\tYES\n\n\n下面给出三张表的sql语句：\n```sql\nBEGIN;\nDROP TABLE IF EXISTS logging_event_property;\nDROP TABLE IF EXISTS logging_event_exception;\nDROP TABLE IF EXISTS logging_event;\nCOMMIT;\n\nBEGIN;\nCREATE TABLE logging_event\n  (\n    timestmp         BIGINT NOT NULL,\n    formatted_message  TEXT NOT NULL,\n    logger_name       VARCHAR(254) NOT NULL,\n    level_string      VARCHAR(254) NOT NULL,\n    thread_name       VARCHAR(254),\n    reference_flag    SMALLINT,\n    arg0              VARCHAR(254),\n    arg1              VARCHAR(254),\n    arg2              VARCHAR(254),\n    arg3              VARCHAR(254),\n    caller_filename   VARCHAR(254) NOT NULL,\n    caller_class      VARCHAR(254) NOT NULL,\n    caller_method     VARCHAR(254) NOT NULL,\n    caller_line       CHAR(4) NOT NULL,\n    event_id          BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY\n  );\nCOMMIT;\n\n\nBEGIN;\nCREATE TABLE logging_event_property\n  (\n    event_id       BIGINT NOT NULL,\n    mapped_key        VARCHAR(254) NOT NULL,\n    mapped_value      TEXT,\n    PRIMARY KEY(event_id, mapped_key),\n    FOREIGN KEY (event_id) REFERENCES logging_event(event_id)\n  );\nCOMMIT;\n\n\nBEGIN;\nCREATE TABLE logging_event_exception\n  (\n    event_id         BIGINT NOT NULL,\n    i                SMALLINT NOT NULL,\n    trace_line       VARCHAR(254) NOT NULL,\n    PRIMARY KEY(event_id, i),\n    FOREIGN KEY (event_id) REFERENCES logging_event(event_id)\n  );\nCOMMIT;\n```\n\n第七个： AsyncAppender\n\nAsyncAppender记录ILoggingEvents的方式是异步的。它仅仅相当于一个event分配器，因此需要配合其他appender才能有所作为。\n\n需要注意的是：AsyncAppender将event缓存在 BlockingQueue ，一个由AsyncAppender创建的工作线程，会一直从这个队列的头部获取events，然后将它们分配给与AsyncAppender唯一关联的Appender中。默认情况下，如果这个队列80%已经被占满，则AsyncAppender会丢弃等级为 TRACE，DEBUG，INFO这三个等级的日志事件。\n在应用关闭或重新部署的时候，AsyncAppender一定要被关闭，目的是为了停止，回收再利用worker thread，和刷新缓冲队列中logging events。那如果关闭AsyncAppender呢？可以通过关闭LoggerContext来关闭所有appender，当然也包括AsyncAppender了。AsyncAppender会在maxFlushTime属性设置的时间内等待Worker thread刷新全部日志event。如果你发现缓冲的event在关闭LoggerContext的时候被丢弃，这时候你就也许需要增加等待的时间。将maxFlushTime设置成0，就是AsyncAppender一直等待直到工作线程将所有被缓冲的events全部刷新出去才执行才结束。\n根据JVM退出的模式，工作线程worker thread处理被缓冲的events的工作是可以被中断的，这样就导致了剩余未处理的events被搁浅。这种现象通常的原因是当LoggerContext没有完全关闭，或者当JVM终止那些非典型的控制流（不明觉厉）。为了避免工作线程的因为这些情况而发生中断，一个shutdown hook（关闭钩子）可以被插入到JVM运行的时候，这个钩子的作用是在JVM开始shutdown刚开始的时候执行关闭 LoggerContext的任务。\n\n下面是AsyncAppender的属性表\n\nProperty | Name\tType |\tDescription |\n---------|-----------| -----------\nqueueSize\t| int\t| 设置blocking queue的最大容量，默认是256条events\ndiscardingThreshold\t| int\t| 默认，当blocking queue被占用80%以上，AsyncAppender就会丢弃level为 TRACE，DEBUG，INFO的日志事件，如果要保留所有等级的日志，需要设置成0\nincludeCallerData\t| boolean\t| 提取CallerData代价比较昂贵，为了提高性能，caller data默认不提供。只有一些获取代价较低的数据，如线程名称，MDC值才会被保留。如果设置为true，就会包含caller data\nmaxFlushTime | \tint\t|设置最大等待刷新事件，单位为miliseconds(毫秒)。当LoggerContext关闭的时候，AsyncAppender会在这个时间内等待工作线程完成events的flush工作，超时未处理的events将会被抛弃。\nneverBlock |\tboolean |\t默认为false，如果队列被填满，为了处理所有日志，就会阻塞的应用。如果为true，为了不阻塞你的应用，也会选择抛弃一些message。\n\n默认情况下，event queue最大的容量是256。如果队列被填充满那么就会阻塞你的应用，直到队列能够容纳新的logging event。所以当AsyncAppender工作在队列满的情况下，可以称作伪同步。\n在以下四种情况下容易导致AsyncAppender伪同步状态的出现：\n\n1. 应用中存在大量线程\n2. 每秒产生大量的logging events\n3. 每一个logging event都存在大量的数据\n4. 子appender中存在很高的延迟\n\n为了避免伪同步的出现，提高queueSizes普遍有效，但是就消耗了应用的可用内存。\n\n下面列出一些 appender配置示例：\n\n```xml\n\n<configuration>\n  <appender name=\"FILE\" class=\"ch.qos.logback.core.FileAppender\">\n    <file>myapp.log</file>\n    <encoder>\n      <pattern>%logger{35} - %msg%n</pattern>\n    </encoder>\n  </appender>\n\n  <appender name=\"ASYNC\" class=\"ch.qos.logback.classic.AsyncAppender\">\n    <appender-ref ref=\"FILE\" />\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"ASYNC\" />\n  </root>\n</configuration>\n\n<configuration>\n\n  <appender name=\"DB\" class=\"ch.qos.logback.classic.db.DBAppender\">\n    <connectionSource\n      class=\"ch.qos.logback.core.db.DataSourceConnectionSource\">\n      <dataSource\n        class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n        <driverClass>com.mysql.jdbc.Driver</driverClass>\n        <jdbcUrl>jdbc:mysql://${serverName}:${port}/${dbName}</jdbcUrl>\n        <user>${user}</user>\n        <password>${password}</password>\n      </dataSource>\n    </connectionSource>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"DB\" />\n  </root>\n</configuration>\n\n<configuration>\n  <appender name=\"EMAIL\" class=\"ch.qos.logback.classic.net.SMTPAppender\">\n    <smtpHost>smtp.gmail.com</smtpHost>\n    <smtpPort>465</smtpPort>\n    <SSL>true</SSL>\n    <username>YOUR_USERNAME@gmail.com</username>\n    <password>YOUR_GMAIL_PASSWORD</password>\n\n    <to>EMAIL-DESTINATION</to>\n    <to>ANOTHER_EMAIL_DESTINATION</to> <!-- additional destinations are possible -->\n    <from>YOUR_USERNAME@gmail.com</from>\n    <subject>TESTING: %logger{20} - %m</subject>\n    <layout class=\"ch.qos.logback.classic.PatternLayout\">\n      <pattern>%date %-5level %logger{35} - %message%n</pattern>\n    </layout>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"EMAIL\" />\n  </root>\n</configuration>\n\n<configuration>\n  <appender name=\"EMAIL\" class=\"ch.qos.logback.classic.net.SMTPAppender\">\n    <smtpHost>smtp.gmail.com</smtpHost>\n    <smtpPort>587</smtpPort>\n    <STARTTLS>true</STARTTLS>\n    <username>YOUR_USERNAME@gmail.com</username>\n    <password>YOUR_GMAIL_xPASSWORD</password>\n\n    <to>EMAIL-DESTINATION</to>\n    <to>ANOTHER_EMAIL_DESTINATION</to> <!-- additional destinations are possible -->\n    <from>YOUR_USERNAME@gmail.com</from>\n    <subject>TESTING: %logger{20} - %m</subject>\n    <layout class=\"ch.qos.logback.classic.PatternLayout\">\n      <pattern>%date %-5level %logger - %message%n</pattern>\n    </layout>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"EMAIL\" />\n  </root>\n</configuration>\n\nSimpleSocketServer需要两个命令行参数，port 和 configFile路径。(该方法待验证)\njava ch.qos.logback.classic.net.SimpleSocketServer 6000 \\ src/main/java/chapters/appenders/socket/server1.xml\n\n客户端的SocketAppender的简单配置例子：\n<configuration>\n\n  <appender name=\"SOCKET\" class=\"ch.qos.logback.classic.net.SocketAppender\">\n    <remoteHost>192.168.0.101</remoteHost>\n    <port>8888</port>\n    <reconnectionDelay>10000</reconnectionDelay>\n    <includeCallerData>true</includeCallerData>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"SOCKET\" />\n  </root>\n\n</configuration>\n\n在服务端使用SimpleSSLSocketServer\njava -Djavax.net.ssl.keyStore=src/main/java/chapters/appenders/socket/ssl/keystore.jks \\ -Djavax.net.ssl.keyStorePassword=changeit \\ ch.qos.logback.classic.net.SimpleSSLSocketServer 6000 \\ src/main/java/chapters/appenders/socket/ssl/server.xml\n\nSSLSocketAppender配置\n<configuration debug=\"true\">\n\n  <appender name=\"SOCKET\" class=\"ch.qos.logback.classic.net.SSLSocketAppender\">\n    <remoteHost>${host}</remoteHost>\n    <port>${port}</port>\n    <reconnectionDelay>10000</reconnectionDelay>\n    <ssl>\n      <trustStore>\n        <location>${truststore}</location>\n        <password>${password}</password>\n      </trustStore>\n    </ssl>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"SOCKET\" />\n  </root>\n\n</configuration>\n\n<configuration>\n\n  <appender name=\"FILE\" class=\"ch.qos.logback.core.FileAppender\">\n    <file>testFile.log</file>\n    <append>true</append>\n    <!-- encoders are assigned the type\n        ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->\n    <encoder>\n      <pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern>\n    </encoder>\n  </appender>\n\n  <root level=\"DEBUG\">\n    <appender-ref ref=\"FILE\" />\n  </root>\n</configuration>\n```\n参考：https://blog.csdn.net/tianyaleixiaowu/article/details/73327752\n\n下面基于logback配置做一个请求日志的的封装\n\n功能：记录每次请求的参数和用户ID存入数据库或者elk\n问题：javaee规范中request输入输出流都只能被读取一次，所以如果用过滤器或者拦截器读取request中的流都会导致后面的controller无法接受到数据。\n所以我们要用原生的aop获得请求参数，切点为controller，这就很好的避开了以上问题。\n\n```java\npackage com.muggle.poseidon.core.aspect;\n\nimport com.muggle.poseidon.manager.UserInfoManager;\nimport com.muggle.poseidon.utils.RequestUtils;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.Serializable;\n\n/**\n * @program: hiram_erp\n * @description: 日志信息切面\n * @author: muggle\n * @create: 2019-02-21\n **/\n@Aspect\n@Component\npublic class LogMessageAspect {\n\n    private final static Logger logger = LoggerFactory.getLogger(\"requestLog\");\n//    private final static Logger timeLog = LoggerFactory.getLogger(LogMessageAspect.class);\n    private static final ThreadLocal<Long> threadLocal = new ThreadLocal<>();\n    @Pointcut(\"execution(public * com.hiram.erp.controller.*.*(..))\")\n    public void webLog() {}\n\n    /**\n     * 在切点之前织入\n     * @param joinPoint\n     * @throws Throwable\n     */\n    @Before(\"webLog()\")\n    public void doBefore(JoinPoint joinPoint) throws Throwable {\n//        System.out.println(\"sssssssssssssssssssssssssssssssssssssssssssssssssssss\");\n       /* // 开始打印请求日志\n        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = attributes.getRequest();\n\n        // 打印请求相关参数\n        // 打印请求 url\n        // 请求id\n        Long userId=null;\n        if (user!=null){\n            userId=user.getUserInfo().getUserId();\n        }\n        logger.info(\"URL : {}, 登录id: {} ,HTTP Method: {},ip :{},Request Args : {}\", request.getRequestURL().toString(),userId, request.getMethod(),request.getRemoteAddr());\n*/    }\n\n    /**\n     * 在切点之后织入\n     * @throws Throwable\n     */\n    @After(\"webLog()\")\n    public void doAfter(JoinPoint joinPoint) throws Throwable {\n\n\n\n    }\n\n    /**\n     * 环绕\n     * @param joinPoint\n     * @return\n     * @throws Throwable\n     */\n    @Around(\"webLog()\")\n    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        Object result = joinPoint.proceed();\n        // 打印出参\n//        logger.info(\"Response Args  : {},\", JSONObject.toJSONString(result),new Date());\n        // 执行耗时\n        // 开始打印请求日志\n        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = attributes.getRequest();\n        HttpServletResponse response = attributes.getResponse();\n        String requestURL = request.getRequestURL().toString();\n        if (requestURL.contains(\"/sys/log_info/\")){\n            return result;\n        }\n        // 打印请求相关参数\n        // 打印请求 url\n        // 请求id\n        String userId = UserInfoManager.getUserId();\n\n        String url = request.getRequestURL().toString();\n        String method = request.getMethod();\n        String remoteAddr = RequestUtils.getIpAddr(request);\n        Object[] args = joinPoint.getArgs();\n//        List<Object> objects=new ArrayList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i=0;i<args.length;i++){\n            if (args[i] instanceof Serializable||args[i] instanceof Number ||args[i] instanceof String){\n                stringBuilder.append( args[i].toString());\n//                objects.add(args[i]);\n            }\n        }\n        logger.info(\"{\\\"startTime\\\":\\\"{}\\\",\\\"url\\\":\\\"{}\\\",\\\"userId\\\":\\\"{}\\\" ,\\\"httpMethod\\\":\\\"{}\\\",\\\"ip\\\":\\\"{}\\\",\\\"requestArgs\\\":\\\"{}\\\",\\\"status\\\":{}}\",startTime,url,userId,method,remoteAddr,stringBuilder.toString(),response.getStatus());\n        return result;\n    }\n\n\n}\n\n```\n对于数据库存储，如果我们希望log存在另外一个数据库中不存在项目里的数据库中，并且可以通过持久化框架查询数据库内信息。我们则可以配置多数据源，如果将日志放在同一个数据库中则直接配置appender就行了，很方便。\n多数据源配置mybatis版：\n\n其原理是配置多个sessionfactory,然后根据不同的mapperscan来区分不同mapper对应的数据库\n\n以druid连接池为例\n\napplication.yml\n\n```java\nlog:\n  datasource:\n    druid:\n      url: ${mysql_url}/log?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowMultiQueries=true&serverTimezone=GMT%2B8&nullCatalogMeansCurrent=true\n      username:\n      password:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\n      filters: stat,wall\n      initialSize: 5\n      maxActive: 20\n      maxPoolPreparedStatementPerConnectionSize: 20\n      maxWait: 60000\n      minIdle: 5\n      poolPreparedStatements: true\n      testOnBorrow: false\n      testOnReturn: false\n      testWhileIdle: true\n      timeBetweenEvictionRunsMillis: 60000\n      validationQuery: SELECT 1\n\n\nspring:\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      url: ${mysql_url}/hiram_erp?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowMultiQueries=true&serverTimezone=GMT%2B8&nullCatalogMeansCurrent=true\n      username:\n      password:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\n      filters: stat,wall\n      initialSize: 5\n      maxActive: 20\n      maxPoolPreparedStatementPerConnectionSize: 20\n      maxWait: 60000\n      minIdle: 5\n      poolPreparedStatements: true\n      testOnBorrow: false\n      testOnReturn: false\n      testWhileIdle: true\n      timeBetweenEvictionRunsMillis: 60000\n      validationQuery: SELECT 1\n```\n\n```java\n\n@Configuration\n// 主数据库配置 指定mapper位置\n@MapperScan(basePackages = {\"com.muggle.poseidon.mapper\"}, sqlSessionTemplateRef = \"sqlSessionTemplate\")\npublic class ManySourceDBConfig {\n\n    @Bean(name = \"dataSource\")\n    // 读取application的配置信息\n   @ConfigurationProperties(prefix = \"spring.datasource.druid\")\n   // 最高优先级，表示系统默认使用该配置\n    @Primary\n    public DataSource dataSource() {\n        DruidDataSource druidDataSource = new DruidDataSource();\n\n        List filterList = new ArrayList<>();\n\n        filterList.add(wallFilter());\n\n        druidDataSource.setProxyFilters(filterList);\n\n        return druidDataSource;\n    }\n\n    @Bean(name = \"sqlSessionFactory\")\n    @Primary\n    public SqlSessionFactory sqlSessionFactory() throws Exception {\n        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();\n        sqlSessionFactoryBean.setDataSource(this.dataSource());\n\n        Properties props = new Properties();\n        props.setProperty(\"localCacheScope\", \"true\");\n        props.setProperty(\"lazyLoadingEnabled\", \"true\");\n        props.setProperty(\"aggressiveLazyLoading\", \"false\");\n        props.setProperty(\"jdbcTypeForNull\", \"NULL\");\n        sqlSessionFactoryBean.setConfigurationProperties(props);\n        sqlSessionFactoryBean.setVfs(SpringBootVFS.class);\n        //pageHelper\n        Properties properties = new Properties();\n        properties.setProperty(\"reasonable\", \"true\");\n        properties.setProperty(\"supportMethodsArguments\", \"true\");\n        properties.setProperty(\"params\", \"count=countSql\");\n        properties.setProperty(\"pageSizeZero\", \"true\");\n        PageInterceptor interceptor = new PageInterceptor();\n        interceptor.setProperties(properties);\n        sqlSessionFactoryBean.setPlugins(new Interceptor[]{interceptor});\n        sqlSessionFactoryBean.setTypeAliasesPackage(\"com.muggle.poseidon.model\");\n        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\n        sqlSessionFactoryBean.setMapperLocations(resolver.getResources(\"classpath*:/mapper/*.xml\"));\n        return sqlSessionFactoryBean.getObject();\n    }\n\n    @Bean(name = \"transactionManager\")\n    @Primary\n    public PlatformTransactionManager transactionManager() {\n        return new DataSourceTransactionManager(this.dataSource());\n    }\n\n    @Bean(name = \"sqlSessionTemplate\")\n    public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(\"sqlSessionFactory\") SqlSessionFactory sqlSessionFactory) throws Exception {\n        return new SqlSessionTemplate(sqlSessionFactory);\n    }\n\n    @Bean\n    public ServletRegistrationBean statViewServlet() {\n        ServletRegistrationBean druid = new ServletRegistrationBean();\n        druid.setServlet(new StatViewServlet());\n        druid.setUrlMappings(Collections.singletonList(\"/druid/*\"));\n        Map<String, String> params = new HashMap<>();\n        params.put(\"loginUsername\", \"\");\n        params.put(\"loginPassword\", \"\");\n        druid.setInitParameters(params);\n        return druid;\n    }\n\n    @Bean\n    public FilterRegistrationBean webStatFilter() {\n        FilterRegistrationBean fitler = new FilterRegistrationBean();\n        fitler.setFilter(new WebStatFilter());\n        fitler.setUrlPatterns(Collections.singletonList(\"/*\"));\n        fitler.addInitParameter(\"exclusions\", \"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\");\n        return fitler;\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n\n        WallFilter wallFilter = new WallFilter();\n\n        wallFilter.setConfig(wallConfig());\n\n        return wallFilter;\n\n    }\n\n    @Bean\n    public WallConfig wallConfig() {\n\n        WallConfig config = new WallConfig();\n\n        config.setMultiStatementAllow(true);//允许一次执行多条语句\n\n        config.setNoneBaseStatementAllow(true);//允许非基本语句的其他语句\n\n        return config;\n\n    }\n\n    @Bean\n    public ProcessEngineConfiguration processEngineConfiguration() {\n        ProcessEngineConfiguration pec = StandaloneProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();\n        pec.setDataSource(dataSource());\n        //如果表不存在，自动创建表\n        pec.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);\n        //属性asyncExecutorActivate定义为true，工作流引擎在启动时就建立启动async executor线程池\n        pec.setAsyncExecutorActivate(false);\n        return pec;\n    }\n\n\n    @Bean\n    public ProcessEngine processEngine() {\n        return processEngineConfiguration().buildProcessEngine();\n    }\n\n}\n\n```\n\nlog数据库配置\n\n```java\n\n\n\n/**\n * @program:\n * @description:\n * @author: muggle\n * @create: 2019-02-23\n **/\n@Configuration\n// 注意确保主配置无法扫描到这个包\n@MapperScan(basePackages = \"com.muggle.poseidon.logmapper\", sqlSessionTemplateRef  = \"test1SqlSessionTemplate\")\n\npublic class LogDBConfig  {\n    @Bean(name = \"test1DataSource\")\n    @ConfigurationProperties(prefix = \"log.datasource.druid\")\n    public DataSource dataSource() {\n        DruidDataSource druidDataSource = new DruidDataSource();\n\n        List filterList = new ArrayList<>();\n\n        filterList.add(wallFilter());\n\n        druidDataSource.setProxyFilters(filterList);\n\n        return druidDataSource;\n    }\n\n    @Bean(name = \"test1SqlSessionFactory\")\n    public SqlSessionFactory testSqlSessionFactory(@Qualifier(\"test1DataSource\") DataSource dataSource) throws Exception {\n        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();\n        bean.setDataSource(dataSource);\n        bean.setMapperLocations(new\n        // mapper位置，不要和主配置的mapper放到一起\n         PathMatchingResourcePatternResolver().getResources(\"classpath*:/mapper/log/*.xml\"));\n        return bean.getObject();\n    }\n\n    @Bean(name = \"test1TransactionManager\")\n    public DataSourceTransactionManager testTransactionManager(@Qualifier(\"test1DataSource\") DataSource dataSource) {\n        return new DataSourceTransactionManager(dataSource);\n    }\n\n    @Bean(name = \"test1SqlSessionTemplate\")\n    public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(\"test1SqlSessionFactory\") SqlSessionFactory sqlSessionFactory) throws Exception {\n        return new SqlSessionTemplate(sqlSessionFactory);\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n\n        WallFilter wallFilter = new WallFilter();\n\n        wallFilter.setConfig(wallConfig());\n\n        return wallFilter;\n\n    }\n    @Bean\n    public WallConfig wallConfig() {\n\n        WallConfig config = new WallConfig();\n\n        config.setMultiStatementAllow(true);//允许一次执行多条语句\n\n        config.setNoneBaseStatementAllow(true);//允许非基本语句的其他语句\n\n        return config;\n\n    }\n}\n\n```\n\n多数据源jpa版\n```java\npackage com.muggle.poseidon.config;\n\n\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.jdbc.DataSourceBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\npublic class DataSourceConfig {\n\n    /**\n     * 扫描spring.datasource.primary开头的配置信息\n     *\n     * @return 数据源配置信息\n     */\n    @Primary\n    @Bean(name = \"primaryDataSourceProperties\")\n    @ConfigurationProperties(prefix = \"spring.datasource\")\n    public DataSourceProperties dataSourceProperties() {\n        return new DataSourceProperties();\n    }\n\n    /**\n     * 获取主库数据源对象\n     *\n     * @param properties 注入名为primaryDataSourceProperties的bean\n     * @return 数据源对象\n     */\n    @Primary\n    @Bean(name = \"primaryDataSource\")\n    public DataSource dataSource(@Qualifier(\"primaryDataSourceProperties\") DataSourceProperties properties) {\n        return properties.initializeDataSourceBuilder().build();\n    }\n\n    /**\n     * 该方法仅在需要使用JdbcTemplate对象时选用\n     *\n     * @param dataSource 注入名为primaryDataSource的bean\n     * @return 数据源JdbcTemplate对象\n     */\n    @Primary\n    @Bean(name = \"primaryJdbcTemplate\")\n    public JdbcTemplate jdbcTemplate(@Qualifier(\"primaryDataSource\") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n\n\n\n\n}\n\n```\n\n```java\npackage com.muggle.poseidon.config;\n\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.sql.DataSource;\nimport java.util.Map;\n\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(\n        // repository包名\n        basePackages = \"com.muggle.poseidon.repos\",\n        // 实体管理bean名称\n        entityManagerFactoryRef = \"primaryEntityManagerFactory\",\n        // 事务管理bean名称\n        transactionManagerRef = \"primaryTransactionManager\"\n)\npublic class MainDataBaseConfig {\n\n    /**\n     * 扫描spring.jpa.primary开头的配置信息\n     *\n     * @return jpa配置信息\n     */\n    @Primary\n    @Bean(name = \"primaryJpaProperties\")\n    @ConfigurationProperties(prefix = \"spring.jpa\")\n    public JpaProperties jpaProperties() {\n        return new JpaProperties();\n    }\n\n    /**\n     * 获取主库实体管理工厂对象\n     *\n     * @param primaryDataSource 注入名为primaryDataSource的数据源\n     * @param jpaProperties     注入名为primaryJpaProperties的jpa配置信息\n     * @param builder           注入EntityManagerFactoryBuilder\n     * @return 实体管理工厂对象\n     */\n    @Primary\n    @Bean(name = \"primaryEntityManagerFactory\")\n    public LocalContainerEntityManagerFactoryBean entityManagerFactory(@Qualifier(\"primaryDataSource\") DataSource primaryDataSource\n            , @Qualifier(\"primaryJpaProperties\") JpaProperties jpaProperties, EntityManagerFactoryBuilder builder) {\n        return builder\n                // 设置数据源\n                .dataSource(primaryDataSource)\n                // 设置jpa配置\n                .properties(jpaProperties.getProperties())\n                // 设置hibernate配置\n                .properties(jpaProperties.getHibernateProperties(new HibernateSettings()))\n                // 设置实体包名\n                .packages(\"com.muggle.poseidon.model\")\n                // 设置持久化单元名，用于@PersistenceContext注解获取EntityManager时指定数据源\n                .persistenceUnit(\"primaryPersistenceUnit\")\n                .build();\n    }\n\n    /**\n     * 获取实体管理对象\n     *\n     * @param factory 注入名为primaryEntityManagerFactory的bean\n     * @return 实体管理对象\n     */\n    @Primary\n    @Bean(name = \"primaryEntityManager\")\n    public EntityManager entityManager(@Qualifier(\"primaryEntityManagerFactory\") EntityManagerFactory factory) {\n        return factory.createEntityManager();\n    }\n\n    /**\n     * 获取主库事务管理对象\n     *\n     * @param factory 注入名为primaryEntityManagerFactory的bean\n     * @return 事务管理对象\n     */\n    @Primary\n    @Bean(name = \"primaryTransactionManager\")\n    public PlatformTransactionManager transactionManager(@Qualifier(\"primaryEntityManagerFactory\") EntityManagerFactory factory) {\n        return new JpaTransactionManager(factory);\n    }\n}\n\n​```java\npackage com.muggle.poseidon.core.config;\n\n\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.sql.DataSource;\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(\n        // repository包名\n        basePackages = \"com.muggle.poseidon.logrep\",\n        // 实体管理bean名称\n        entityManagerFactoryRef = \"secondEntityManagerFactory\",\n        // 事务管理bean名称\n        transactionManagerRef = \"secondTransactionManager\"\n)\npublic class LogDataBaseConfig {\n\n    /**\n     * 扫描spring.jpa.second开头的配置信息\n     *\n     * @return jpa配置信息\n     */\n    @Bean(name = \"secondJpaProperties\")\n    @ConfigurationProperties(prefix = \"spring.aa\")\n    public JpaProperties jpaProperties() {\n        return new JpaProperties();\n    }\n\n    /**\n     * 获取从库实体管理工厂对象\n     *\n     * @param secondDataSource 注入名为secondDataSource的数据源\n     * @param jpaProperties    注入名为secondJpaProperties的jpa配置信息\n     * @param builder          注入EntityManagerFactoryBuilder\n     * @return 实体管理工厂对象\n     */\n    @Bean(name = \"secondEntityManagerFactory\")\n    public LocalContainerEntityManagerFactoryBean entityManagerFactory(@Qualifier(\"secondDataSource\") DataSource secondDataSource\n            , @Qualifier(\"secondJpaProperties\") JpaProperties jpaProperties, EntityManagerFactoryBuilder builder) {\n        return builder\n                // 设置数据源\n                .dataSource(secondDataSource)\n                // 设置jpa配置\n                .properties(jpaProperties.getProperties())\n                // 设置hibernate配置\n                .properties(jpaProperties.getHibernateProperties(new HibernateSettings()))\n                // 设置实体包名\n                .packages(\"com.muggle.poseidon.entity\")\n                // 设置持久化单元名，用于@PersistenceContext注解获取EntityManager时指定数据源\n                .persistenceUnit(\"secondPersistenceUnit\")\n                .build();\n    }\n\n    /**\n     * 获取实体管理对象\n     *\n     * @param factory 注入名为secondEntityManagerFactory的bean\n     * @return 实体管理对象\n     */\n    @Bean(name = \"secondEntityManager\")\n    public EntityManager entityManager(@Qualifier(\"secondEntityManagerFactory\") EntityManagerFactory factory) {\n        return factory.createEntityManager();\n    }\n\n    /**\n     * 获取从库事务管理对象\n     *\n     * @param factory 注入名为secondEntityManagerFactory的bean\n     * @return 事务管理对象\n     */\n    @Bean(name = \"secondTransactionManager\")\n    public PlatformTransactionManager transactionManager(@Qualifier(\"secondEntityManagerFactory\") EntityManagerFactory factory) {\n        return new JpaTransactionManager(factory);\n    }\n}\n\n```\n\n```java\n\npackage com.muggle.poseidon.core.config;\n\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\npublic class LogDataConfig {\n    /**\n     * 扫描spring.datasource.second开头的配置信息\n     *\n     * @return 数据源配置信息\n     */\n    @Bean(name = \"secondDataSourceProperties\")\n    @ConfigurationProperties(prefix = \"spring.ss\")\n    public DataSourceProperties dataSourceProperties() {\n        return new DataSourceProperties();\n    }\n\n    /**\n     * 获取从库数据源对象\n     *\n     * @param properties 注入名为secondDataSourceProperties的beanf\n     * @return 数据源对象\n     */\n    @Bean(name = \"secondDataSource\")\n    public DataSource dataSource(@Qualifier(\"secondDataSourceProperties\") DataSourceProperties properties) {\n        return properties.initializeDataSourceBuilder().build();\n    }\n\n    /**\n     * 该方法仅在需要使用JdbcTemplate对象时选用\n     *\n     * @param dataSource 注入名为secondDataSource的bean\n     * @return 数据源JdbcTemplate对象\n     */\n    @Bean(name = \"secondJdbcTemplate\")\n    public JdbcTemplate jdbcTemplate(@Qualifier(\"secondDataSource\") DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n}\n\n```\n\napplication.properties\n\n```java\nserver.port=8080\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\n#spring.datasource.url = jdbc:mysql://localhost:3306/test\nspring.datasource.driverClassName = com.mysql.cj.jdbc.Driver\nspring.datasource.url = jdbc:mysql://119.23.75.58:3306/poseidon?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowMultiQueries=true\nspring.datasource.username =\nspring.datasource.password =\nspring.datasource.max-active=20\nspring.datasource.max-idle=8\nspring.datasource.min-idle=8\nspring.datasource.initial-size=10\n\nspring.jpa.database=mysql\nspring.jpa.show-sql = true\n#配置方言\nspring.jpa.database-platform=org.hibernate.dialect.MySQL5Dialect\n\nspring.ss.type=com.alibaba.druid.pool.DruidDataSource\n#spring.datasource.url = jdbc:mysql://localhost:3306/test\nspring.ss.driverClassName = com.mysql.cj.jdbc.Driver\nspring.ss.url = jdbc:mysql://zzzzz/log?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowMultiQueries=true\nspring.ss.username =\nspring.ss.password =\nspring.ss.max-active=20\nspring.ss.max-idle=8\nspring.ss.min-idle=8\nspring.ss.initial-size=10\n\n\nspring.aa.database=mysql\nspring.aa.show-sql = true\n#配置方言\nspring.aa.database-platform=org.hibernate.dialect.MySQL5Dialect\n```\n\n\n以数据库作为输出配置就算完成了，接下来整合elk系统到我们日志系统中：\n\n\n先整合logstash\n\nlogstash安装和配置：\nhttps://www.elastic.co/cn/downloads/logstash 选择zip包下载\n\n解压，进入bin目录 创建logstash.conf 并配置：\n```xml\ninput {\n    tcp {\n    ##host:port就是上面appender中的 destination，这里其实把logstash作为服务，开启9250端口接收logback发出的消息\n    host => \"127.0.0.1\"\n    port => 9100\n    mode => \"server\"\n    tags => [\"tags\"]\n    codec => json_lines\n    }\n}\noutput {\n    stdout { codec => rubydebug }\n    #输出到es\n    #elasticsearch { hosts => \"127.0.0.1:9200\" }\n        #输出到一个文件中\n    file {\n       path => \"D:\\logs\\test.log\"\n       codec => line\n    }\n}\n\n```\n我这里先配置输出到文件，后面再修改,创建文件：D:\\logs\\test.log\n\n启动：\n\n打开cmd（不要使用powershell），进入bin:\n```xml\nD:\\exe\\logstash-6.6.1\\logstash-6.6.1\\bin>logstash -f logstash.conf\n```\n\n然后在我们的项目中进行相应的配置：\n按这个来：https://github.com/logstash/logstash-logback-encoder\n\n加入pom并指定logback版本：\n```xml\n<!-- 父pom中 -->\n<ch.qos.logback.version>1.2.3</ch.qos.logback.version>\n\n<!--  日志模块-->\n<dependency>\n  <groupId>net.logstash.logback</groupId>\n  <artifactId>logstash-logback-encoder</artifactId>\n  <version>5.3</version>\n  </dependency>\n        <!-- Your project must also directly depend on either logback-classic or logback-access.  For example: -->\n  <dependency>\n    <groupId>ch.qos.logback</groupId>\n    <artifactId>logback-classic</artifactId>\n    <version>1.2.3</version>\n  </dependency>\n```\n\n配置apppender和logger\n\n```xml\n<appender name=\"stash\" class=\"net.logstash.logback.appender.LogstashTcpSocketAppender\">\n    <destination>127.0.0.1:9100</destination>\n    <includeCallerData>true</includeCallerData>\n\n    <encoder class=\"net.logstash.logback.encoder.LogstashEncoder\">\n        <includeCallerData>true</includeCallerData>\n    </encoder>\n  </appender>\n  <logger name=\"logstash\" level=\"info\">\n      <appender-ref ref=\"stash\"/>\n  </logger>\n```\n测试：\n```java\nRestController\n@RequestMapping(\"/public/log\")\npublic class LogTestController {\n    private static final Logger log = LoggerFactory.getLogger(\"logstash\");\n    @Autowired\n    LoggingEventRepository repository;\n\n    @GetMapping(\"/\")\n    public String test(){\n        log.info(\"sssssssssssssss\");\n        Iterable<LoggingEvent> all = repository.findAll();\n\n        return \"sss\";\n\n    }\n}\n```\n\n访问接口，logstash打印信息：\n\n```\n[2019-03-09T11:32:56,358][INFO ][logstash.outputs.file    ] Opening file {:path=>\"D:/logs/test.log\"}\n{\n                  \"host\" => \"www.xmind.net\",\n                 \"level\" => \"INFO\",\n     \"caller_class_name\" => \"com.muggle.poseidon.controller.LogTestController\",\n            \"@timestamp\" => 2019-03-09T03:33:03.413Z,\n           \"logger_name\" => \"logstash\",\n              \"@version\" => \"1\",\n           \"thread_name\" => \"http-nio-8080-exec-9\",\n               \"message\" => \"sssssssssssssss\",\n    \"caller_line_number\" => 22,\n                  \"port\" => 58368,\n           \"level_value\" => 20000,\n      \"caller_file_name\" => \"LogTestController.java\",\n                  \"tags\" => [\n        [0] \"tags\"\n    ],\n    \"caller_method_name\" => \"test\"\n}\n```\ntest.log输出了文件：\n\n```\n2019-03-09T03:33:03.413Z www.xmind.net sssssssssssssss\n```\n接下来只要把输出路径换成ES就可以了，这属于logstash和es的整合，这里先不讲解；重新回归到我们的请求模块：\n\n我希望我的模块，对每次请求都能记录下来（请求日志），并将记录存到数据库或者ES，同时我要对所有接口都进行一个幂等性的保障；保障接口的幂等性有多种方法，比较简单的是数据库做唯一索引或者加拦截器，我这里加了一个拦截器来保障接口幂等和拦截前端数据的重复提交(关于接口幂等性在其他文档中介绍)：\n```java\n@Slf4j\npublic class RequestLockInterceptor implements HandlerInterceptor {\n    RedisLock redisTool;\n    private int expireTime;\n\n    public RequestLockInterceptor(int expireTime, RedislockImpl redisTool) {\n        this.expireTime = expireTime;\n        this.redisTool = redisTool;\n    }\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        if(\"post\".equalsIgnoreCase(request.getMethod())){\n            String token = request.getParameter(\"request_key\");\n            if (token==null||\"\".equals(token)){\n                log.error(\"请求非法\");\n//            throw new PoseidonException(\"请求太频繁\",PoseidonProperties.TOO_NUMBER_REQUEST);\n                response.setContentType(\"application/json;charset=UTF-8\");\n                PrintWriter writer = response.getWriter();\n                writer.write(\"{\\\"code\\\":\\\"5001\\\",\\\"msg\\\":\\\"请求非法\\\"}\");\n                writer.close();\n                return false;\n            }\n            String ipAddr = RequestUtils.getIpAddr(request);\n            String lockKey = request.getRequestURI() + \"_\"  + \"_\" + token;\n            boolean lock = redisTool.lock(lockKey, ipAddr, expireTime);\n            if (!lock) {//\n                log.error(\"拦截表单重复提交\");\n//            throw new PoseidonException(\"请求太频繁\",PoseidonProperties.TOO_NUMBER_REQUEST);\n                response.setContentType(\"application/json;charset=UTF-8\");\n                PrintWriter writer = response.getWriter();\n                writer.write(\"{\\\"code\\\":\\\"5001\\\",\\\"msg\\\":\\\"请求太频繁\\\"}\");\n                writer.close();\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n//        String requestURI = request.getRequestURI();\n//        String lockKey = request.getRequestURI() + \"_\" + RequestUtils.getIpAddr(request);\n//        redisTool.unlock(lockKey,getIpAddr(request));\n    }\n\n\n}\n\n```\n项目使用了redis锁（redis锁原理和使用在其他文档中介绍）\n\n对于系统异常，如果是业务的异常，正常处理，如果是系统发生的异常比如空指针，数据库异常等我希望系统能马上通知，以便排查问题，所以我配置邮件异常通知(关于springboot邮件配置其他文档介绍)：\n\n```java\n\n@RestControllerAdvice\n@Slf4j\npublic class RestExceptionHandlerController {\n    @Autowired\n    EmailService emailService;\n    @Value(\"${admin.email}\")\n    private String adminEmail;\n\n    @ExceptionHandler(value = {PoseidonException.class})\n    public ResultBean poseidonExceptionHandler(PoseidonException e, HttpServletRequest req) {\n        return new ResultBean().setMsg(e.getMsg()).setCode(e.getCode());\n    }\n    @ExceptionHandler(value = {MethodArgumentNotValidException.class})\n    public ResultBean MethodArgumentNotValidException(MethodArgumentNotValidException e, HttpServletRequest req) {\n        System.out.println(e.getMessage());\n        return new ResultBean().setMsg(\"数据未通过校验\").setCode(PoseidonProperties.COMMIT_DATA_ERROR);\n    }\n\n    @ExceptionHandler(value = {Exception.class})\n    public ResultBean exceptionHandler(Exception e, HttpServletRequest req) {\n        log.error(\"系统异常：\" + req.getMethod() + req.getRequestURI(), e);\n        try {\n//\n            EmailBean emailBean = new EmailBean();\n            emailBean.setRecipient(adminEmail);\n            emailBean.setSubject(\"poseidon---系统异常\");\n            emailBean.setContent(\"系统异常：\" + req.getMethod() + req.getRequestURI()+\"----\"+e.getMessage());\n//            改良\n            emailService.sendSimpleMail(emailBean);\n        } finally {\n            return new ResultBean().setMsg(\"系统异常，请联系管理员\").setCode(\"500\");\n        }\n    }\n\n    @ExceptionHandler(value = {HttpRequestMethodNotSupportedException.class})\n    public ResultBean notsupported(Exception e, HttpServletRequest req) {\n        return new ResultBean().setMsg(\"不支持的请求方式\").setCode(PoseidonProperties.NOT_SUPPORT_METHOD);\n    }\n    @ExceptionHandler(value = {NoHandlerFoundException.class})\n    public ResultBean notFoundUrl(Exception e, HttpServletRequest req) {\n        return new ResultBean().setMsg(\"请求路径不存在\").setCode(\"404\");\n    }\n}\n\n```\n\n\n项目架构信得\ncommon 和core模块存在的意义\n\n\n","slug":"logback","published":1,"updated":"2021-01-11T07:31:23.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjtgsh7b004w00wigzfbcw7a","content":"<h5 id=\"作者：muggle\"><a href=\"#作者：muggle\" class=\"headerlink\" title=\"作者：muggle\"></a>作者：muggle</h5><p>Logback是由log4j创始人设计的另一个开源日志组件,分为三个模块：</p>\n<ol>\n<li><p>logback-core：其它两个模块的基础模块</p>\n</li>\n<li><p>logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging</p>\n</li>\n<li><p>logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能<br>在springboot中我们通过xml配置来操作logback</p>\n</li>\n</ol>\n<a id=\"more\"></a>\n<p>springboot中logback的默认配置文件名称为logback-spring.xml，若需要指定xml名称，需在application.properties（application.yml）中配置logging.config=xxxx.xml<br>现在贴出一份logback的xml配置，可直接使用，懒得看的小伙伴复制粘贴到你的项目中去体验吧</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span> <span class=\"attr\">scan</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">scanPeriod</span>=<span class=\"string\">&quot;60 seconds&quot;</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">jmxConfigurator</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;log_dir&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;logs&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxHistory&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;100&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;console&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %highlight([%-5level]) %logger - %msg%n</span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;logs&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">                $&#123;log_dir&#125;/%d&#123;yyyy-MM-dd&#125;-poseidon.log</span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>$&#123;maxHistory&#125;<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %highlight([%-5level]) %logger - %msg%n</span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;runningTime-file&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log_dir&#125;/runningTime/%d&#123;yyyy-MM-dd&#125;-poseidon.log<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>$&#123;maxHistory&#125;<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %logger - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;runningTime-console&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %logger - %msg%n</span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;runningTime&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span> <span class=\"attr\">additivity</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;appender-ref ref=&quot;runningTime-file&quot;/&gt;--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;runningTime-console&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">logger</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--  可能会抛出方言异常 两个解决方案 配置方言或者换连接池 换druid不会有这个异常--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;requestLog-db&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.db.DBAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">connectionSource</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.db.DataSourceConnectionSource&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">driverClassName</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">driverClassName</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>jdbc:mysql://xxx/xxxx?characterEncoding=UTF-8<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>xx<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>xxxx<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">connectionSource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;sqlDialect class=&quot;ch.qos.logback.core.db.dialect.MySQLDialect&quot; /&gt;--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--异步配置--&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--&lt;appender name=&quot;requestLog-file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">             &lt;fileNamePattern&gt;$&#123;log_dir&#125;/requestLog/%d&#123;yyyy-MM-dd&#125;-poseidon.log&lt;/fileNamePattern&gt;</span></span><br><span class=\"line\"><span class=\"comment\">             &lt;maxHistory&gt;$&#123;maxHistory&#125;&lt;/maxHistory&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         &lt;/rollingPolicy&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         &lt;encoder&gt;</span></span><br><span class=\"line\"><span class=\"comment\">             &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %logger - %msg%n&lt;/pattern&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         &lt;/encoder&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     &lt;/appender&gt;--&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;appender name=&quot;request-asyn&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;appender-ref ref=&quot;requestLog-file&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;/appender&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;logs-asyn&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;logs&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;requestLog&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span> <span class=\"attr\">additivity</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;appender-ref ref=&quot;requestLog-file&quot;/&gt;--&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- DBAppender 查看可知其父类dbappenderbase继承了UnsynchronizedAppenderBase&lt;E&gt; 所以dbappender本身是异步的 无需配置异步--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;requestLog-db&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">logger</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">level</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;info&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;console&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;appender-ref ref=&quot;logs&quot;/&gt;--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;logs-asyn&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到xml中有四种节点<br>appender，logger，root,configuration</p>\n<h4 id=\"节点解读\"><a href=\"#节点解读\" class=\"headerlink\" title=\"节点解读\"></a>节点解读</h4><p>configuration包含三个属性：</p>\n<ol>\n<li>scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</li>\n<li>scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</li>\n<li>debug: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</li>\n<li>Logger作为日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别。</li>\n</ol>\n<p>Appender主要用于指定日志输出的目的地，目的地可以是控制台、文件、远程套接字服务器、 MySQL、PostreSQL、 Oracle和其他数据库、 JMS和远程UNIX Syslog守护进程等。</p>\n<p>root 就是最高级别logger,所有不被指定logger的日志都归root管理。</p>\n<p>在slf4j框架下我们使用log是这样的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger= LoggerFactory.getLogger(xxx.class);</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger= LoggerFactory.getLogger(<span class=\"string\">&quot;xxxx&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>可以理解为代码中的getLogger() 方法就是获取xml配置中的logger,如果没有配置相应的logger则为root<br>比如我配置了：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hhh&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span> <span class=\"attr\">additivity</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;appender-ref ref=&quot;requestLog-file&quot;/&gt;--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;xxx&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>那我在获得一个logger时可以这样获得它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger= LoggerFactory.getLogger(<span class=\"string\">&quot;hhh&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>我所输出的日志将被这个logger所管理<br>logger 上有三个配置 name level additivity<br>name就是这个logger的名称，level就是这个日志过滤的级别，低于这个级别的日志不输入到对应的appender中；additivity是否向上级logger传递打印信息，默认是true。logger中可以配置多个appender-ref，也就是可以指定多个输出地点。<br>而root只是特殊的logger，用法上无差别</p>\n<p>appender节点：<br>appender节点是logback配置的关键，其name属性指定其名称，class属性指定实现类，对应得实现类有</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch.qos.logback.core.ConsoleAppender <span class=\"comment\">// 以控制台作为输出</span></span><br><span class=\"line\">ch.qos.logback.core.rolling.RollingFileAppender<span class=\"comment\">//以日志文件作为输出</span></span><br><span class=\"line\">ch.qos.logback.classic.db.DBAppender<span class=\"comment\">//以数据库作为输出</span></span><br><span class=\"line\">net.logstash.logback.appender.LogstashTcpSocketAppender<span class=\"comment\">//以logstash作为输出需要引入如下依赖：</span></span><br><span class=\"line\">ch.qos.logback.classic.AsyncAppender<span class=\"comment\">//异步输出 需要定义appender-ref</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// logstash依赖</span></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;4.11&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>所有的appender 实现ch.qos.logback.core.Appender接口或者 ch.qos.logback.core.UnsynchronizedAppenderBase接口（异步），我们也可以自定义appender来指定日志输出；</p>\n<p>在Appender中可以定义哪些节点我们一个个来看：</p>\n<p>第一种： ConsoleAppender<br>如同它的名字一样，这个Appender将日志输出到console，更准确的说是System.out 或者System.err。<br>它包含的参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>encoder</td>\n<td>Encoder</td>\n<td>通常在其pattern里指定日志格式  如： %d{yyyy-MM-dd HH:mm:ss.SSS} %highlight([%-5level]) %logger - %msg%n表示 日期格式 日志级别（高亮）logger的名称 logger的message</td>\n</tr>\n<tr>\n<td>target</td>\n<td>String</td>\n<td>指定输出目标。可选值：System.out 或 System.err。默认值：System.out</td>\n</tr>\n<tr>\n<td>withJansi</td>\n<td>boolean</td>\n<td>是否支持ANSI color codes（类似linux中的shell脚本的输出字符串颜色控制代码）。默认为false。如果设置为true。例如：[31m 代表将前景色设置成红色。在windows中，需要提供”org.fusesource.jansi:jansi:1.9”，而在linux，mac os x中默认支持。</td>\n</tr>\n</tbody></table>\n<p>第二种： FileAppender<br>将日志输出到文件当中，目标文件取决于file属性。是否追加输出，取决于append属性。</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>append</td>\n<td>boolean</td>\n<td>是否以追加方式输出。默认为true。</td>\n</tr>\n<tr>\n<td>encoder</td>\n<td>Encoder</td>\n<td>See OutputStreamAppender properties.</td>\n</tr>\n<tr>\n<td>file</td>\n<td>String</td>\n<td>指定文件名。注意在windows当中，反斜杠 \\ 需要转义，或直接使用 / 也可以。例如 c:/temp/test.logor 或 c:\\temp\\test.log 都可以。没有默认值，如果上层目录不存在，FileAppender会自动创建。</td>\n</tr>\n<tr>\n<td>prudent</td>\n<td>boolean</td>\n<td>是否工作在谨慎模式下。在谨慎模式下，FileAppender将会安全写入日志到指定文件，即时在不同的虚拟机jvm中有另一个相同的FileAppender实例。默认值：fales;设置为true，意味着append会被自动设置成true。prudent依赖于文件排它锁。实验表明，使用文件锁，会增加3倍的日志写入消耗。比如说，当prudent模式为off，写入一条日志到文件只要10毫秒，但是prudent为真，则会接近30毫秒。prudent 模式实际上是将I/O请求序列化，因此在I/O数量较大，比如说100次/s或更多的时候，带来的延迟也会显而易见，所以应该避免。在networked file system（远程文件系统）中，这种消耗将会更大，可能导致死锁。</td>\n</tr>\n</tbody></table>\n<p>第三个： RollingFileAppender</p>\n<p>RollingFileAppender继承自FileAppender，提供日志目标文件自动切换的功能。例如可以用日期作为日志分割的条件。<br>RollingFileAppender有两个重要属性，RollingPolicy负责怎么切换日志，TriggeringPolicy负责何时切换。为了使RollingFileAppender起作用，这两个属性必须设置，但是如果RollingPolicy的实现类同样实现了TriggeringPolicy接口，则也可以只设置RollingPolicy这个属性。<br>下面是它的参数：</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>file</td>\n<td>String</td>\n<td>指定文件名。注意在windows当中，反斜杠 \\ 需要转义，或直接使用 / 也可以。例如 c:/temp/test.logor 或 c:\\temp\\test.log 都可以。没有默认值，如果上层目录不存在，FileAppender会自动创建。</td>\n</tr>\n<tr>\n<td>append</td>\n<td>boolean</td>\n<td>是否以追加方式输出。默认为true。</td>\n</tr>\n<tr>\n<td>encoder</td>\n<td>Encoder</td>\n<td>See OutputStreamAppender properties.</td>\n</tr>\n<tr>\n<td>rollingPolicy</td>\n<td>RollingPolicy</td>\n<td>当发生日志切换时，RollingFileAppender的切换行为。例如日志文件名的修改</td>\n</tr>\n<tr>\n<td>triggeringPolicy</td>\n<td>TriggeringPolicy</td>\n<td>决定什么时候发生日志切换，例如日期，日志文件大小到达一定值</td>\n</tr>\n<tr>\n<td>prudent</td>\n<td>boolean</td>\n<td>FixedWindowRollingPolicy 不支持prudent模式。TimeBasedRollingPolicy 支持prudent模式，但是需要满足一下两条约束：在prudent模式中，日志文件的压缩是不被允许，不被支持的。不能设置file属性。</td>\n</tr>\n</tbody></table>\n<p>第四个：SocketAppender及SSLSocketAppender（未尝试过）</p>\n<p>到目前为止我们讲的appender都只能将日志输出到本地资源。与之相对的，SocketAppender就是被设计用来输出日志到远程实例中的。SocketAppender输出日志采用明文方式，SSLSocketAppender则采用加密方式传输日志。<br>被序列化的日志事件的类型是 LoggingEventVO 继承ILoggingEvent接口。远程日志记录并非是侵入式的。在反序列化接收后，日志事件就可以好像在本地生成的日志一样处理了。多个SockerAppender可以向同一台日志服务器发送日志。SocketAppender并不需要关联一个Layout，因为它只是发送序列化的日志事件给远程日志服务器。SocketAppender的发送操作是基于TCP协议的。因此如果远程服务器是可到达的，则日志会被其处理，如果远程服务器宕机或不可到达，那么日志将会被丢弃。等到远程服务器复活，日志发送将会透明的重新开始。这种透明式的重连，是通过一个“连接“线程周期性的尝试连接远程服务器实现的。<br>Logging events会由TCP协议实现自动缓冲。这意味着，如果网络速度比日志请求产生速度快，则网络速度并不会影响应用。但如果网络速度过慢，则网络速度则会变成限制，在极端情况下，如果远程日志服务器不可到达，则会导致应用最终阻塞。不过，如果服务器可到达，但是服务器宕机了，这种情况，应用不会阻塞，而只是丢失一些日志事件而已。<br>需要注意的是，即使SocketAppender没有被logger链接，它也不会被gc回收，因为他在connector thread中任然存在引用。一个connector thread 只有在网络不可达的情况下，才会退出。为了防止这个垃圾回收的问题，我们应该显示声明关闭SocketAppender。长久存活并创建/销毁大量的SocketAppender实例的应用，更应该注意这个问题。不过大多数应用可以忽略这个问题。如果JVM在SocketAppender关闭之前将其退出，又或者是被垃圾回收，这样子可能导致丢失一些还未被传输，在管道中等待的日志数据。为了防止避免日志丢失，经常可靠的办法就是调用SocketAppender的close方法，或者调用LoggerContext的stop方法，在退出应用之前。</p>\n<p>下面我们来看看SocketAppender的属性：</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>includeCallerData</td>\n<td>boolean</td>\n<td>是否包含调用者的信息如果为true，则以下日志输出的 ?:? 会替换成调用者的文件名跟行号，为false，则为问号。2019-01-06 17:37:30,968 DEBUG [Thread-0] [?:?] chapters.appenders.socket.SocketClient2 - Hi</td>\n</tr>\n<tr>\n<td>port</td>\n<td>int</td>\n<td>端口号</td>\n</tr>\n<tr>\n<td>reconnectionDelay</td>\n<td>Duration</td>\n<td>重连延时，如果设置成“10 seconds”，就会在连接u武器失败后，等待10秒，再连接。默认值：“30 seconds”。如果设置成0，则关闭重连功能。</td>\n</tr>\n<tr>\n<td>queueSize</td>\n<td>int</td>\n<td>设置缓冲日志数，如果设置成0，日志发送是同步的，如果设置成大于0的值，会将日志放入队列，队列长度到达指定值，在统一发送。可以加大服务吞吐量。</td>\n</tr>\n<tr>\n<td>eventDelayLimit</td>\n<td>Duration</td>\n<td>设置日志超时丢弃时间。当设置“10 seconds”类似的值，如果日志队列已满，而服务器长时间来不及接收，当滞留时间超过10 seconds，日志就会被丢弃。默认值： 100 milliseconds</td>\n</tr>\n<tr>\n<td>remoteHost</td>\n<td>String</td>\n<td>远程日志服务器的IP</td>\n</tr>\n<tr>\n<td>ssl</td>\n<td>SSLConfiguration</td>\n<td>只在SSLSocketAppender包含该属性节点。提供SSL配置，详情见 Using SSL.</td>\n</tr>\n</tbody></table>\n<p>标准的Logback Classic包含四个可供使用的Receiver用来接收来自SocketAppender的logging evnets。</p>\n<p>第五个： SMTPAppender</p>\n<p>SMTPAppender 可以将logging event存放在一个或多个固定大小的缓冲区中，然后在用户指定的event到来之时，将适当的大小的logging event以邮件方式发送给运维人员。<br>详细属性如下：</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>smtpHost</td>\n<td>String</td>\n<td>SMTP server的地址，必需指定。如网易的SMTP服务器地址是： smtp.163.com</td>\n</tr>\n<tr>\n<td>smtpPort</td>\n<td>int</td>\n<td>SMTP server的端口地址。默认值：25</td>\n</tr>\n<tr>\n<td>to</td>\n<td>String</td>\n<td>指定发送到那个邮箱，可设置多个<to>属性，指定多个目的邮箱</td>\n</tr>\n<tr>\n<td>from</td>\n<td>String</td>\n<td>指定发件人名称。如果设置成“muggle &lt;<a href=\"mailto:hh@moral.org\">hh@moral.org</a>&gt; ”，则邮件发件人将会是“muggle <a href=\"mailto:&#104;&#104;&#64;&#109;&#x6f;&#x72;&#97;&#x6c;&#46;&#111;&#114;&#103;\">&#104;&#104;&#64;&#109;&#x6f;&#x72;&#97;&#x6c;&#46;&#111;&#114;&#103;</a> ”</td>\n</tr>\n<tr>\n<td>subject</td>\n<td>String</td>\n<td>指定emial的标题，它需要满足PatternLayout中的格式要求。如果设置成“Log: %logger - %msg”，就案例来讲，则发送邮件时，标题为“Log: com.foo.Bar - Hello World ”。 默认值：”%logger{20} - %m”.</td>\n</tr>\n<tr>\n<td>discriminator</td>\n<td>Discriminator</td>\n<td>通过Discriminator, SMTPAppender可以根据Discriminator的返回值，将到来的logging event分发到不同的缓冲区中。默认情况下，总是返回相同的值来达到使用一个缓冲区的目的。</td>\n</tr>\n<tr>\n<td>evaluator</td>\n<td>IEvaluator</td>\n<td>指定触发日志发送的条件。通过<evaluator class=... />指定EventEvaluator接口的实现类。默认情况下SMTPAppeender使用的是OnErrorEvaluator，表示当发送ERROR或更高级别的日志请求时，发送邮件。Logback提供了几个evaluators：OnErrorEvaluator、OnMarkerEvaluator、JaninoEventEvaluator、GEventEvaluator（功能强大）</td>\n</tr>\n<tr>\n<td>cyclicBufferTracker</td>\n<td>CyclicBufferTracker</td>\n<td>指定一个cyclicBufferTracker跟踪cyclic buffer。它是基于discriminator的实现的。如果你不指定，默认会创建一个CyclicBufferTracker ，默认设置cyclic buffer大小为256。你也可以手动指定使用默认的CyclicBufferTracker，并且通过<bufferSize>属性修改默认的缓冲区接收多少条logging event。</td>\n</tr>\n<tr>\n<td>username</td>\n<td>String</td>\n<td>发送邮件账号，默认为null</td>\n</tr>\n<tr>\n<td>password</td>\n<td>String</td>\n<td>发送邮件密码，默认为null</td>\n</tr>\n<tr>\n<td>STARTTLS</td>\n<td>boolean</td>\n<td>如果设置为true，appender会尝试使用STARTTLS命令，如果服务端支持，则会将明文连接转换成加密连接。需要注意的是，与日志服务器连接一开始是未加密的。默认值：false</td>\n</tr>\n<tr>\n<td>SSL</td>\n<td>boolean</td>\n<td>如果设置为true，appender将会使用SSL连接到日志服务器。 默认值：false</td>\n</tr>\n<tr>\n<td>charsetEncoding</td>\n<td>String</td>\n<td>指定邮件信息的编码格式 默认值：UTF-8</td>\n</tr>\n<tr>\n<td>localhost</td>\n<td>String</td>\n<td>如果smtpHost没有正确配置，比如说不是完整的地址。这时候就需要localhost这个属性提供服务器的完整路径（如同java中的完全限定名 ），详情参考com.sun.mail.smtp 中的mail.smtp.localhost属性</td>\n</tr>\n<tr>\n<td>asynchronousSending</td>\n<td>boolean</td>\n<td>这个属性决定email的发送是否是异步。默认：true，异步发送但是在某些情况下，需要以同步方式发送错误日志的邮件给管理人员，防止不能及时维护应用。</td>\n</tr>\n<tr>\n<td>includeCallerData</td>\n<td>boolean</td>\n<td>默认：false 指定是否包含callerData在日志中</td>\n</tr>\n<tr>\n<td>sessionViaJNDI</td>\n<td>boolean</td>\n<td>SMTPAppender依赖javax.mail.Session来发送邮件。默认情况下，sessionViaJNDI为false。javax.mail.Session实例的创建依赖于SMTPAppender本身的配置信息。如果设置为true，则Session的创建时通过JNDI获取引用。这样做的好处可以让你的代码复用更好，让配置更简洁。需要注意的是，如果使用JNDI获取Session对象，需要保证移除mail.jar以及activation.jar这两个jar包</td>\n</tr>\n<tr>\n<td>jndiLocation</td>\n<td>String</td>\n<td>如果sessionViaJNDI设置为true，则jndiLocation指定JNDI的资源名，默认值为：”java:comp/env/mail/Session”</td>\n</tr>\n</tbody></table>\n<p>SMTPAppender只保留最近的256条logging events 在循环缓冲区中，当缓冲区慢，就会开始丢弃最老的logging event。因此不管什么时候，SMTPAppender一封邮件最多传递256条日志事件。SMTPAppender依赖于JavaMail API。而JavaMail API又依赖于IOC框架（依赖注入）。</p>\n<p>第六个：DBAppender</p>\n<p> DBAppender 可以将日志事件插入到3张数据表中。它们分别是logging_event，logging_event_property，logging_event_exception。这三张数据表必须在DBAppender工作之前存在。它们的sql脚本可以在 logback-classic/src/main/java/ch/qos/logback/classic/db/script folder 这个目录下找到。这个脚本对大部分SQL数据库都是有效的，除了少部分，少数语法有差异需要调整。<br>下面是logback与常见数据库的支持信息：</p>\n<table>\n<thead>\n<tr>\n<th>RDBMS</th>\n<th>tested version(s)</th>\n<th>tested JDBC driver version(s)</th>\n<th>supports getGeneratedKeys() method</th>\n<th>is a dialect provided by logback</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DB2</td>\n<td>untested</td>\n<td>untested</td>\n<td>unknown</td>\n<td>NO</td>\n</tr>\n<tr>\n<td>H2</td>\n<td>–</td>\n<td>-</td>\n<td>unknown</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>HSQL</td>\n<td>–</td>\n<td>-</td>\n<td>NO</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>Microsoft SQL Server</td>\n<td>–</td>\n<td>–</td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>MySQL</td>\n<td>5.7</td>\n<td></td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>PostgreSQL</td>\n<td>–</td>\n<td>–</td>\n<td>NO</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>Oracle</td>\n<td>–</td>\n<td>–</td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>SQLLite</td>\n<td>–</td>\n<td>-</td>\n<td>unknown</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>Sybase</td>\n<td>–</td>\n<td>-</td>\n<td>unknown</td>\n<td>YES</td>\n</tr>\n</tbody></table>\n<p>下面给出三张表的sql语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">BEGIN</span>;</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> logging_event_property;</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> logging_event_exception;</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> logging_event;</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> logging_event</span><br><span class=\"line\">  (</span><br><span class=\"line\">    timestmp         <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    formatted_message  TEXT <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    logger_name       <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    level_string      <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    thread_name       <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>),</span><br><span class=\"line\">    reference_flag    <span class=\"type\">SMALLINT</span>,</span><br><span class=\"line\">    arg0              <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>),</span><br><span class=\"line\">    arg1              <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>),</span><br><span class=\"line\">    arg2              <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>),</span><br><span class=\"line\">    arg3              <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>),</span><br><span class=\"line\">    caller_filename   <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    caller_class      <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    caller_method     <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    caller_line       <span class=\"type\">CHAR</span>(<span class=\"number\">4</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    event_id          <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT <span class=\"keyword\">PRIMARY</span> <span class=\"keyword\">KEY</span></span><br><span class=\"line\">  );</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> logging_event_property</span><br><span class=\"line\">  (</span><br><span class=\"line\">    event_id       <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    mapped_key        <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    mapped_value      TEXT,</span><br><span class=\"line\">    <span class=\"keyword\">PRIMARY</span> <span class=\"keyword\">KEY</span>(event_id, mapped_key),</span><br><span class=\"line\">    <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (event_id) <span class=\"keyword\">REFERENCES</span> logging_event(event_id)</span><br><span class=\"line\">  );</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> logging_event_exception</span><br><span class=\"line\">  (</span><br><span class=\"line\">    event_id         <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    i                <span class=\"type\">SMALLINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    trace_line       <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    <span class=\"keyword\">PRIMARY</span> <span class=\"keyword\">KEY</span>(event_id, i),</span><br><span class=\"line\">    <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (event_id) <span class=\"keyword\">REFERENCES</span> logging_event(event_id)</span><br><span class=\"line\">  );</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n<p>第七个： AsyncAppender</p>\n<p>AsyncAppender记录ILoggingEvents的方式是异步的。它仅仅相当于一个event分配器，因此需要配合其他appender才能有所作为。</p>\n<p>需要注意的是：AsyncAppender将event缓存在 BlockingQueue ，一个由AsyncAppender创建的工作线程，会一直从这个队列的头部获取events，然后将它们分配给与AsyncAppender唯一关联的Appender中。默认情况下，如果这个队列80%已经被占满，则AsyncAppender会丢弃等级为 TRACE，DEBUG，INFO这三个等级的日志事件。<br>在应用关闭或重新部署的时候，AsyncAppender一定要被关闭，目的是为了停止，回收再利用worker thread，和刷新缓冲队列中logging events。那如果关闭AsyncAppender呢？可以通过关闭LoggerContext来关闭所有appender，当然也包括AsyncAppender了。AsyncAppender会在maxFlushTime属性设置的时间内等待Worker thread刷新全部日志event。如果你发现缓冲的event在关闭LoggerContext的时候被丢弃，这时候你就也许需要增加等待的时间。将maxFlushTime设置成0，就是AsyncAppender一直等待直到工作线程将所有被缓冲的events全部刷新出去才执行才结束。<br>根据JVM退出的模式，工作线程worker thread处理被缓冲的events的工作是可以被中断的，这样就导致了剩余未处理的events被搁浅。这种现象通常的原因是当LoggerContext没有完全关闭，或者当JVM终止那些非典型的控制流（不明觉厉）。为了避免工作线程的因为这些情况而发生中断，一个shutdown hook（关闭钩子）可以被插入到JVM运行的时候，这个钩子的作用是在JVM开始shutdown刚开始的时候执行关闭 LoggerContext的任务。</p>\n<p>下面是AsyncAppender的属性表</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>queueSize</td>\n<td>int</td>\n<td>设置blocking queue的最大容量，默认是256条events</td>\n</tr>\n<tr>\n<td>discardingThreshold</td>\n<td>int</td>\n<td>默认，当blocking queue被占用80%以上，AsyncAppender就会丢弃level为 TRACE，DEBUG，INFO的日志事件，如果要保留所有等级的日志，需要设置成0</td>\n</tr>\n<tr>\n<td>includeCallerData</td>\n<td>boolean</td>\n<td>提取CallerData代价比较昂贵，为了提高性能，caller data默认不提供。只有一些获取代价较低的数据，如线程名称，MDC值才会被保留。如果设置为true，就会包含caller data</td>\n</tr>\n<tr>\n<td>maxFlushTime</td>\n<td>int</td>\n<td>设置最大等待刷新事件，单位为miliseconds(毫秒)。当LoggerContext关闭的时候，AsyncAppender会在这个时间内等待工作线程完成events的flush工作，超时未处理的events将会被抛弃。</td>\n</tr>\n<tr>\n<td>neverBlock</td>\n<td>boolean</td>\n<td>默认为false，如果队列被填满，为了处理所有日志，就会阻塞的应用。如果为true，为了不阻塞你的应用，也会选择抛弃一些message。</td>\n</tr>\n</tbody></table>\n<p>默认情况下，event queue最大的容量是256。如果队列被填充满那么就会阻塞你的应用，直到队列能够容纳新的logging event。所以当AsyncAppender工作在队列满的情况下，可以称作伪同步。<br>在以下四种情况下容易导致AsyncAppender伪同步状态的出现：</p>\n<ol>\n<li>应用中存在大量线程</li>\n<li>每秒产生大量的logging events</li>\n<li>每一个logging event都存在大量的数据</li>\n<li>子appender中存在很高的延迟</li>\n</ol>\n<p>为了避免伪同步的出现，提高queueSizes普遍有效，但是就消耗了应用的可用内存。</p>\n<p>下面列出一些 appender配置示例：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;FILE&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>myapp.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%logger&#123;35&#125; - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;ASYNC&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;FILE&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;ASYNC&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;DB&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.db.DBAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    &lt;connectionSource</span><br><span class=\"line\">      class=&quot;ch.qos.logback.core.db.DataSourceConnectionSource&quot;&gt;</span><br><span class=\"line\">      &lt;dataSource</span><br><span class=\"line\">        class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">driverClass</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">driverClass</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">jdbcUrl</span>&gt;</span>jdbc:mysql://$&#123;serverName&#125;:$&#123;port&#125;/$&#123;dbName&#125;<span class=\"tag\">&lt;/<span class=\"name\">jdbcUrl</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">user</span>&gt;</span>$&#123;user&#125;<span class=\"tag\">&lt;/<span class=\"name\">user</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>$&#123;password&#125;<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">connectionSource</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;DB&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;EMAIL&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.net.SMTPAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">smtpHost</span>&gt;</span>smtp.gmail.com<span class=\"tag\">&lt;/<span class=\"name\">smtpHost</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">smtpPort</span>&gt;</span>465<span class=\"tag\">&lt;/<span class=\"name\">smtpPort</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">SSL</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">SSL</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>YOUR_USERNAME@gmail.com<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>YOUR_GMAIL_PASSWORD<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>EMAIL-DESTINATION<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>ANOTHER_EMAIL_DESTINATION<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span> <span class=\"comment\">&lt;!-- additional destinations are possible --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">from</span>&gt;</span>YOUR_USERNAME@gmail.com<span class=\"tag\">&lt;/<span class=\"name\">from</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">subject</span>&gt;</span>TESTING: %logger&#123;20&#125; - %m<span class=\"tag\">&lt;/<span class=\"name\">subject</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">layout</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%date %-5level %logger&#123;35&#125; - %message%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;EMAIL&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;EMAIL&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.net.SMTPAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">smtpHost</span>&gt;</span>smtp.gmail.com<span class=\"tag\">&lt;/<span class=\"name\">smtpHost</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">smtpPort</span>&gt;</span>587<span class=\"tag\">&lt;/<span class=\"name\">smtpPort</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">STARTTLS</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">STARTTLS</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>YOUR_USERNAME@gmail.com<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>YOUR_GMAIL_xPASSWORD<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>EMAIL-DESTINATION<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>ANOTHER_EMAIL_DESTINATION<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span> <span class=\"comment\">&lt;!-- additional destinations are possible --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">from</span>&gt;</span>YOUR_USERNAME@gmail.com<span class=\"tag\">&lt;/<span class=\"name\">from</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">subject</span>&gt;</span>TESTING: %logger&#123;20&#125; - %m<span class=\"tag\">&lt;/<span class=\"name\">subject</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">layout</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%date %-5level %logger - %message%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;EMAIL&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">SimpleSocketServer需要两个命令行参数，port 和 configFile路径。(该方法待验证)</span><br><span class=\"line\">java ch.qos.logback.classic.net.SimpleSocketServer 6000 \\ src/main/java/chapters/appenders/socket/server1.xml</span><br><span class=\"line\"></span><br><span class=\"line\">客户端的SocketAppender的简单配置例子：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;SOCKET&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.net.SocketAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">remoteHost</span>&gt;</span>192.168.0.101<span class=\"tag\">&lt;/<span class=\"name\">remoteHost</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">port</span>&gt;</span>8888<span class=\"tag\">&lt;/<span class=\"name\">port</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">reconnectionDelay</span>&gt;</span>10000<span class=\"tag\">&lt;/<span class=\"name\">reconnectionDelay</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">includeCallerData</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">includeCallerData</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;SOCKET&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">在服务端使用SimpleSSLSocketServer</span><br><span class=\"line\">java -Djavax.net.ssl.keyStore=src/main/java/chapters/appenders/socket/ssl/keystore.jks \\ -Djavax.net.ssl.keyStorePassword=changeit \\ ch.qos.logback.classic.net.SimpleSSLSocketServer 6000 \\ src/main/java/chapters/appenders/socket/ssl/server.xml</span><br><span class=\"line\"></span><br><span class=\"line\">SSLSocketAppender配置</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;SOCKET&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.net.SSLSocketAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">remoteHost</span>&gt;</span>$&#123;host&#125;<span class=\"tag\">&lt;/<span class=\"name\">remoteHost</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">port</span>&gt;</span>$&#123;port&#125;<span class=\"tag\">&lt;/<span class=\"name\">port</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">reconnectionDelay</span>&gt;</span>10000<span class=\"tag\">&lt;/<span class=\"name\">reconnectionDelay</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ssl</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">trustStore</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>$&#123;truststore&#125;<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>$&#123;password&#125;<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">trustStore</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ssl</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;SOCKET&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;FILE&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>testFile.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">append</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">append</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- encoders are assigned the type</span></span><br><span class=\"line\"><span class=\"comment\">        ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;FILE&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>参考：<a href=\"https://blog.csdn.net/tianyaleixiaowu/article/details/73327752\">https://blog.csdn.net/tianyaleixiaowu/article/details/73327752</a></p>\n<p>下面基于logback配置做一个请求日志的的封装</p>\n<p>功能：记录每次请求的参数和用户ID存入数据库或者elk<br>问题：javaee规范中request输入输出流都只能被读取一次，所以如果用过滤器或者拦截器读取request中的流都会导致后面的controller无法接受到数据。<br>所以我们要用原生的aop获得请求参数，切点为controller，这就很好的避开了以上问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.muggle.poseidon.core.aspect;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.muggle.poseidon.manager.UserInfoManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.muggle.poseidon.utils.RequestUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.JoinPoint;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>: hiram_erp</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 日志信息切面</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-02-21</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogMessageAspect</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Logger logger = LoggerFactory.getLogger(<span class=\"string\">&quot;requestLog&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//    private final static Logger timeLog = LoggerFactory.getLogger(LogMessageAspect.class);</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Long&gt; threadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(public * com.hiram.erp.controller.*.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">webLog</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在切点之前织入</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> joinPoint</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;webLog()&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(&quot;sssssssssssssssssssssssssssssssssssssssssssssssssssss&quot;);</span></span><br><span class=\"line\">       <span class=\"comment\">/* // 开始打印请求日志</span></span><br><span class=\"line\"><span class=\"comment\">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span></span><br><span class=\"line\"><span class=\"comment\">        HttpServletRequest request = attributes.getRequest();</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        // 打印请求相关参数</span></span><br><span class=\"line\"><span class=\"comment\">        // 打印请求 url</span></span><br><span class=\"line\"><span class=\"comment\">        // 请求id</span></span><br><span class=\"line\"><span class=\"comment\">        Long userId=null;</span></span><br><span class=\"line\"><span class=\"comment\">        if (user!=null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">            userId=user.getUserInfo().getUserId();</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        logger.info(&quot;URL : &#123;&#125;, 登录id: &#123;&#125; ,HTTP Method: &#123;&#125;,ip :&#123;&#125;,Request Args : &#123;&#125;&quot;, request.getRequestURL().toString(),userId, request.getMethod(),request.getRemoteAddr());</span></span><br><span class=\"line\"><span class=\"comment\">*/</span>    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在切点之后织入</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@After(&quot;webLog()&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doAfter</span><span class=\"params\">(JoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 环绕</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> joinPoint</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;webLog()&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">doAround</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">        Object result = joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"comment\">// 打印出参</span></span><br><span class=\"line\"><span class=\"comment\">//        logger.info(&quot;Response Args  : &#123;&#125;,&quot;, JSONObject.toJSONString(result),new Date());</span></span><br><span class=\"line\">        <span class=\"comment\">// 执行耗时</span></span><br><span class=\"line\">        <span class=\"comment\">// 开始打印请求日志</span></span><br><span class=\"line\">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">        HttpServletRequest request = attributes.getRequest();</span><br><span class=\"line\">        HttpServletResponse response = attributes.getResponse();</span><br><span class=\"line\">        String requestURL = request.getRequestURL().toString();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestURL.contains(<span class=\"string\">&quot;/sys/log_info/&quot;</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 打印请求相关参数</span></span><br><span class=\"line\">        <span class=\"comment\">// 打印请求 url</span></span><br><span class=\"line\">        <span class=\"comment\">// 请求id</span></span><br><span class=\"line\">        String userId = UserInfoManager.getUserId();</span><br><span class=\"line\"></span><br><span class=\"line\">        String url = request.getRequestURL().toString();</span><br><span class=\"line\">        String method = request.getMethod();</span><br><span class=\"line\">        String remoteAddr = RequestUtils.getIpAddr(request);</span><br><span class=\"line\">        Object[] args = joinPoint.getArgs();</span><br><span class=\"line\"><span class=\"comment\">//        List&lt;Object&gt; objects=new ArrayList&lt;&gt;();</span></span><br><span class=\"line\">        StringBuilder stringBuilder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;args.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (args[i] <span class=\"keyword\">instanceof</span> Serializable||args[i] <span class=\"keyword\">instanceof</span> Number ||args[i] <span class=\"keyword\">instanceof</span> String)&#123;</span><br><span class=\"line\">                stringBuilder.append( args[i].toString());</span><br><span class=\"line\"><span class=\"comment\">//                objects.add(args[i]);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;&#123;\\&quot;startTime\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;url\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;userId\\&quot;:\\&quot;&#123;&#125;\\&quot; ,\\&quot;httpMethod\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;ip\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;requestArgs\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;status\\&quot;:&#123;&#125;&#125;&quot;</span>,startTime,url,userId,method,remoteAddr,stringBuilder.toString(),response.getStatus());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对于数据库存储，如果我们希望log存在另外一个数据库中不存在项目里的数据库中，并且可以通过持久化框架查询数据库内信息。我们则可以配置多数据源，如果将日志放在同一个数据库中则直接配置appender就行了，很方便。<br>多数据源配置mybatis版：</p>\n<p>其原理是配置多个sessionfactory,然后根据不同的mapperscan来区分不同mapper对应的数据库</p>\n<p>以druid连接池为例</p>\n<p>application.yml</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log:</span><br><span class=\"line\">  datasource:</span><br><span class=\"line\">    druid:</span><br><span class=\"line\">      url: $&#123;mysql_url&#125;/log?useUnicode=<span class=\"keyword\">true</span>&amp;characterEncoding=UTF-<span class=\"number\">8</span>&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=<span class=\"keyword\">false</span>&amp;allowMultiQueries=<span class=\"keyword\">true</span>&amp;serverTimezone=GMT%2B8&amp;nullCatalogMeansCurrent=<span class=\"keyword\">true</span></span><br><span class=\"line\">      username:</span><br><span class=\"line\">      password:</span><br><span class=\"line\">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">      connectionProperties: druid.stat.mergeSql=<span class=\"keyword\">true</span>;druid.stat.slowSqlMillis=<span class=\"number\">5000</span></span><br><span class=\"line\">      filters: stat,wall</span><br><span class=\"line\">      initialSize: <span class=\"number\">5</span></span><br><span class=\"line\">      maxActive: <span class=\"number\">20</span></span><br><span class=\"line\">      maxPoolPreparedStatementPerConnectionSize: <span class=\"number\">20</span></span><br><span class=\"line\">      maxWait: <span class=\"number\">60000</span></span><br><span class=\"line\">      minIdle: <span class=\"number\">5</span></span><br><span class=\"line\">      poolPreparedStatements: <span class=\"keyword\">true</span></span><br><span class=\"line\">      testOnBorrow: <span class=\"keyword\">false</span></span><br><span class=\"line\">      testOnReturn: <span class=\"keyword\">false</span></span><br><span class=\"line\">      testWhileIdle: <span class=\"keyword\">true</span></span><br><span class=\"line\">      timeBetweenEvictionRunsMillis: <span class=\"number\">60000</span></span><br><span class=\"line\">      validationQuery: SELECT <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">spring:</span><br><span class=\"line\">  datasource:</span><br><span class=\"line\">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class=\"line\">    druid:</span><br><span class=\"line\">      url: $&#123;mysql_url&#125;/hiram_erp?useUnicode=<span class=\"keyword\">true</span>&amp;characterEncoding=UTF-<span class=\"number\">8</span>&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=<span class=\"keyword\">false</span>&amp;allowMultiQueries=<span class=\"keyword\">true</span>&amp;serverTimezone=GMT%2B8&amp;nullCatalogMeansCurrent=<span class=\"keyword\">true</span></span><br><span class=\"line\">      username:</span><br><span class=\"line\">      password:</span><br><span class=\"line\">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">      connectionProperties: druid.stat.mergeSql=<span class=\"keyword\">true</span>;druid.stat.slowSqlMillis=<span class=\"number\">5000</span></span><br><span class=\"line\">      filters: stat,wall</span><br><span class=\"line\">      initialSize: <span class=\"number\">5</span></span><br><span class=\"line\">      maxActive: <span class=\"number\">20</span></span><br><span class=\"line\">      maxPoolPreparedStatementPerConnectionSize: <span class=\"number\">20</span></span><br><span class=\"line\">      maxWait: <span class=\"number\">60000</span></span><br><span class=\"line\">      minIdle: <span class=\"number\">5</span></span><br><span class=\"line\">      poolPreparedStatements: <span class=\"keyword\">true</span></span><br><span class=\"line\">      testOnBorrow: <span class=\"keyword\">false</span></span><br><span class=\"line\">      testOnReturn: <span class=\"keyword\">false</span></span><br><span class=\"line\">      testWhileIdle: <span class=\"keyword\">true</span></span><br><span class=\"line\">      timeBetweenEvictionRunsMillis: <span class=\"number\">60000</span></span><br><span class=\"line\">      validationQuery: SELECT <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"comment\">// 主数据库配置 指定mapper位置</span></span><br><span class=\"line\"><span class=\"meta\">@MapperScan(basePackages = &#123;&quot;com.muggle.poseidon.mapper&quot;&#125;, sqlSessionTemplateRef = &quot;sqlSessionTemplate&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ManySourceDBConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class=\"line\">    <span class=\"comment\">// 读取application的配置信息</span></span><br><span class=\"line\">   <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.datasource.druid&quot;)</span></span><br><span class=\"line\">   <span class=\"comment\">// 最高优先级，表示系统默认使用该配置</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        DruidDataSource druidDataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">        List filterList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        filterList.add(wallFilter());</span><br><span class=\"line\"></span><br><span class=\"line\">        druidDataSource.setProxyFilters(filterList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> druidDataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;sqlSessionFactory&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">sqlSessionFactory</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class=\"keyword\">new</span> SqlSessionFactoryBean();</span><br><span class=\"line\">        sqlSessionFactoryBean.setDataSource(<span class=\"keyword\">this</span>.dataSource());</span><br><span class=\"line\"></span><br><span class=\"line\">        Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;localCacheScope&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;lazyLoadingEnabled&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;aggressiveLazyLoading&quot;</span>, <span class=\"string\">&quot;false&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;jdbcTypeForNull&quot;</span>, <span class=\"string\">&quot;NULL&quot;</span>);</span><br><span class=\"line\">        sqlSessionFactoryBean.setConfigurationProperties(props);</span><br><span class=\"line\">        sqlSessionFactoryBean.setVfs(SpringBootVFS.class);</span><br><span class=\"line\">        <span class=\"comment\">//pageHelper</span></span><br><span class=\"line\">        Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        properties.setProperty(<span class=\"string\">&quot;reasonable&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">        properties.setProperty(<span class=\"string\">&quot;supportMethodsArguments&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">        properties.setProperty(<span class=\"string\">&quot;params&quot;</span>, <span class=\"string\">&quot;count=countSql&quot;</span>);</span><br><span class=\"line\">        properties.setProperty(<span class=\"string\">&quot;pageSizeZero&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">        PageInterceptor interceptor = <span class=\"keyword\">new</span> PageInterceptor();</span><br><span class=\"line\">        interceptor.setProperties(properties);</span><br><span class=\"line\">        sqlSessionFactoryBean.setPlugins(<span class=\"keyword\">new</span> Interceptor[]&#123;interceptor&#125;);</span><br><span class=\"line\">        sqlSessionFactoryBean.setTypeAliasesPackage(<span class=\"string\">&quot;com.muggle.poseidon.model&quot;</span>);</span><br><span class=\"line\">        PathMatchingResourcePatternResolver resolver = <span class=\"keyword\">new</span> PathMatchingResourcePatternResolver();</span><br><span class=\"line\">        sqlSessionFactoryBean.setMapperLocations(resolver.getResources(<span class=\"string\">&quot;classpath*:/mapper/*.xml&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sqlSessionFactoryBean.getObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;transactionManager&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PlatformTransactionManager <span class=\"title\">transactionManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DataSourceTransactionManager(<span class=\"keyword\">this</span>.dataSource());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;sqlSessionTemplate&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionTemplate <span class=\"title\">testSqlSessionTemplate</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;sqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServletRegistrationBean <span class=\"title\">statViewServlet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ServletRegistrationBean druid = <span class=\"keyword\">new</span> ServletRegistrationBean();</span><br><span class=\"line\">        druid.setServlet(<span class=\"keyword\">new</span> StatViewServlet());</span><br><span class=\"line\">        druid.setUrlMappings(Collections.singletonList(<span class=\"string\">&quot;/druid/*&quot;</span>));</span><br><span class=\"line\">        Map&lt;String, String&gt; params = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;loginUsername&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;loginPassword&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        druid.setInitParameters(params);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> druid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">webStatFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean fitler = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        fitler.setFilter(<span class=\"keyword\">new</span> WebStatFilter());</span><br><span class=\"line\">        fitler.setUrlPatterns(Collections.singletonList(<span class=\"string\">&quot;/*&quot;</span>));</span><br><span class=\"line\">        fitler.addInitParameter(<span class=\"string\">&quot;exclusions&quot;</span>, <span class=\"string\">&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fitler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WallFilter <span class=\"title\">wallFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        WallFilter wallFilter = <span class=\"keyword\">new</span> WallFilter();</span><br><span class=\"line\"></span><br><span class=\"line\">        wallFilter.setConfig(wallConfig());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> wallFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WallConfig <span class=\"title\">wallConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        WallConfig config = <span class=\"keyword\">new</span> WallConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">        config.setMultiStatementAllow(<span class=\"keyword\">true</span>);<span class=\"comment\">//允许一次执行多条语句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        config.setNoneBaseStatementAllow(<span class=\"keyword\">true</span>);<span class=\"comment\">//允许非基本语句的其他语句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> config;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProcessEngineConfiguration <span class=\"title\">processEngineConfiguration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ProcessEngineConfiguration pec = StandaloneProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();</span><br><span class=\"line\">        pec.setDataSource(dataSource());</span><br><span class=\"line\">        <span class=\"comment\">//如果表不存在，自动创建表</span></span><br><span class=\"line\">        pec.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);</span><br><span class=\"line\">        <span class=\"comment\">//属性asyncExecutorActivate定义为true，工作流引擎在启动时就建立启动async executor线程池</span></span><br><span class=\"line\">        pec.setAsyncExecutorActivate(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pec;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProcessEngine <span class=\"title\">processEngine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> processEngineConfiguration().buildProcessEngine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>log数据库配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-02-23</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"comment\">// 注意确保主配置无法扫描到这个包</span></span><br><span class=\"line\"><span class=\"meta\">@MapperScan(basePackages = &quot;com.muggle.poseidon.logmapper&quot;, sqlSessionTemplateRef  = &quot;test1SqlSessionTemplate&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogDBConfig</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;test1DataSource&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;log.datasource.druid&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        DruidDataSource druidDataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">        List filterList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        filterList.add(wallFilter());</span><br><span class=\"line\"></span><br><span class=\"line\">        druidDataSource.setProxyFilters(filterList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> druidDataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;test1SqlSessionFactory&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">testSqlSessionFactory</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;test1DataSource&quot;)</span> DataSource dataSource)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        SqlSessionFactoryBean bean = <span class=\"keyword\">new</span> SqlSessionFactoryBean();</span><br><span class=\"line\">        bean.setDataSource(dataSource);</span><br><span class=\"line\">        bean.setMapperLocations(<span class=\"keyword\">new</span></span><br><span class=\"line\">        <span class=\"comment\">// mapper位置，不要和主配置的mapper放到一起</span></span><br><span class=\"line\">         PathMatchingResourcePatternResolver().getResources(<span class=\"string\">&quot;classpath*:/mapper/log/*.xml&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean.getObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;test1TransactionManager&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSourceTransactionManager <span class=\"title\">testTransactionManager</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;test1DataSource&quot;)</span> DataSource dataSource)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DataSourceTransactionManager(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;test1SqlSessionTemplate&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionTemplate <span class=\"title\">testSqlSessionTemplate</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;test1SqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WallFilter <span class=\"title\">wallFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        WallFilter wallFilter = <span class=\"keyword\">new</span> WallFilter();</span><br><span class=\"line\"></span><br><span class=\"line\">        wallFilter.setConfig(wallConfig());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> wallFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WallConfig <span class=\"title\">wallConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        WallConfig config = <span class=\"keyword\">new</span> WallConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">        config.setMultiStatementAllow(<span class=\"keyword\">true</span>);<span class=\"comment\">//允许一次执行多条语句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        config.setNoneBaseStatementAllow(<span class=\"keyword\">true</span>);<span class=\"comment\">//允许非基本语句的其他语句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> config;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>多数据源jpa版</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.muggle.poseidon.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.jdbc.DataSourceBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Primary;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.sql.DataSource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourceConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 扫描spring.datasource.primary开头的配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryDataSourceProperties&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSourceProperties <span class=\"title\">dataSourceProperties</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DataSourceProperties();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取主库数据源对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> properties 注入名为primaryDataSourceProperties的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryDataSource&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;primaryDataSourceProperties&quot;)</span> DataSourceProperties properties)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 该方法仅在需要使用JdbcTemplate对象时选用</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> dataSource 注入名为primaryDataSource的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源JdbcTemplate对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryJdbcTemplate&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JdbcTemplate <span class=\"title\">jdbcTemplate</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource dataSource)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTemplate(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.muggle.poseidon.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Primary;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.orm.jpa.JpaTransactionManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.persistence.EntityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.persistence.EntityManagerFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.sql.DataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"meta\">@EnableJpaRepositories(</span></span><br><span class=\"line\"><span class=\"meta\">        // repository包名</span></span><br><span class=\"line\"><span class=\"meta\">        basePackages = &quot;com.muggle.poseidon.repos&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">        // 实体管理bean名称</span></span><br><span class=\"line\"><span class=\"meta\">        entityManagerFactoryRef = &quot;primaryEntityManagerFactory&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">        // 事务管理bean名称</span></span><br><span class=\"line\"><span class=\"meta\">        transactionManagerRef = &quot;primaryTransactionManager&quot;</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainDataBaseConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 扫描spring.jpa.primary开头的配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> jpa配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryJpaProperties&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.jpa&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JpaProperties <span class=\"title\">jpaProperties</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaProperties();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取主库实体管理工厂对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> primaryDataSource 注入名为primaryDataSource的数据源</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jpaProperties     注入名为primaryJpaProperties的jpa配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> builder           注入EntityManagerFactoryBuilder</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 实体管理工厂对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryEntityManagerFactory&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalContainerEntityManagerFactoryBean <span class=\"title\">entityManagerFactory</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource primaryDataSource</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            , <span class=\"meta\">@Qualifier(&quot;primaryJpaProperties&quot;)</span> JpaProperties jpaProperties, EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> builder</span><br><span class=\"line\">                <span class=\"comment\">// 设置数据源</span></span><br><span class=\"line\">                .dataSource(primaryDataSource)</span><br><span class=\"line\">                <span class=\"comment\">// 设置jpa配置</span></span><br><span class=\"line\">                .properties(jpaProperties.getProperties())</span><br><span class=\"line\">                <span class=\"comment\">// 设置hibernate配置</span></span><br><span class=\"line\">                .properties(jpaProperties.getHibernateProperties(<span class=\"keyword\">new</span> HibernateSettings()))</span><br><span class=\"line\">                <span class=\"comment\">// 设置实体包名</span></span><br><span class=\"line\">                .packages(<span class=\"string\">&quot;com.muggle.poseidon.model&quot;</span>)</span><br><span class=\"line\">                <span class=\"comment\">// 设置持久化单元名，用于@PersistenceContext注解获取EntityManager时指定数据源</span></span><br><span class=\"line\">                .persistenceUnit(<span class=\"string\">&quot;primaryPersistenceUnit&quot;</span>)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取实体管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> factory 注入名为primaryEntityManagerFactory的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 实体管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryEntityManager&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EntityManager <span class=\"title\">entityManager</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;primaryEntityManagerFactory&quot;)</span> EntityManagerFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> factory.createEntityManager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取主库事务管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> factory 注入名为primaryEntityManagerFactory的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 事务管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryTransactionManager&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PlatformTransactionManager <span class=\"title\">transactionManager</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;primaryEntityManagerFactory&quot;)</span> EntityManagerFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaTransactionManager(factory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">​```java</span><br><span class=\"line\"><span class=\"keyword\">package</span> com.muggle.poseidon.core.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.orm.jpa.JpaTransactionManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.persistence.EntityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.persistence.EntityManagerFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.sql.DataSource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"meta\">@EnableJpaRepositories(</span></span><br><span class=\"line\"><span class=\"meta\">        // repository包名</span></span><br><span class=\"line\"><span class=\"meta\">        basePackages = &quot;com.muggle.poseidon.logrep&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">        // 实体管理bean名称</span></span><br><span class=\"line\"><span class=\"meta\">        entityManagerFactoryRef = &quot;secondEntityManagerFactory&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">        // 事务管理bean名称</span></span><br><span class=\"line\"><span class=\"meta\">        transactionManagerRef = &quot;secondTransactionManager&quot;</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogDataBaseConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 扫描spring.jpa.second开头的配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> jpa配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondJpaProperties&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.aa&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JpaProperties <span class=\"title\">jpaProperties</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaProperties();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取从库实体管理工厂对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> secondDataSource 注入名为secondDataSource的数据源</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jpaProperties    注入名为secondJpaProperties的jpa配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> builder          注入EntityManagerFactoryBuilder</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 实体管理工厂对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondEntityManagerFactory&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalContainerEntityManagerFactoryBean <span class=\"title\">entityManagerFactory</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;secondDataSource&quot;)</span> DataSource secondDataSource</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            , <span class=\"meta\">@Qualifier(&quot;secondJpaProperties&quot;)</span> JpaProperties jpaProperties, EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> builder</span><br><span class=\"line\">                <span class=\"comment\">// 设置数据源</span></span><br><span class=\"line\">                .dataSource(secondDataSource)</span><br><span class=\"line\">                <span class=\"comment\">// 设置jpa配置</span></span><br><span class=\"line\">                .properties(jpaProperties.getProperties())</span><br><span class=\"line\">                <span class=\"comment\">// 设置hibernate配置</span></span><br><span class=\"line\">                .properties(jpaProperties.getHibernateProperties(<span class=\"keyword\">new</span> HibernateSettings()))</span><br><span class=\"line\">                <span class=\"comment\">// 设置实体包名</span></span><br><span class=\"line\">                .packages(<span class=\"string\">&quot;com.muggle.poseidon.entity&quot;</span>)</span><br><span class=\"line\">                <span class=\"comment\">// 设置持久化单元名，用于@PersistenceContext注解获取EntityManager时指定数据源</span></span><br><span class=\"line\">                .persistenceUnit(<span class=\"string\">&quot;secondPersistenceUnit&quot;</span>)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取实体管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> factory 注入名为secondEntityManagerFactory的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 实体管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondEntityManager&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EntityManager <span class=\"title\">entityManager</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;secondEntityManagerFactory&quot;)</span> EntityManagerFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> factory.createEntityManager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取从库事务管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> factory 注入名为secondEntityManagerFactory的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 事务管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondTransactionManager&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PlatformTransactionManager <span class=\"title\">transactionManager</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;secondEntityManagerFactory&quot;)</span> EntityManagerFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaTransactionManager(factory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.muggle.poseidon.core.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.sql.DataSource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogDataConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 扫描spring.datasource.second开头的配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondDataSourceProperties&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.ss&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSourceProperties <span class=\"title\">dataSourceProperties</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DataSourceProperties();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取从库数据源对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> properties 注入名为secondDataSourceProperties的beanf</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondDataSource&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;secondDataSourceProperties&quot;)</span> DataSourceProperties properties)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 该方法仅在需要使用JdbcTemplate对象时选用</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> dataSource 注入名为secondDataSource的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源JdbcTemplate对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondJdbcTemplate&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JdbcTemplate <span class=\"title\">jdbcTemplate</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;secondDataSource&quot;)</span> DataSource dataSource)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTemplate(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>application.properties</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">8080</span></span><br><span class=\"line\">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class=\"line\">#spring.datasource.url = jdbc:mysql://localhost:3306/test</span><br><span class=\"line\">spring.datasource.driverClassName = com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">spring.datasource.url = jdbc:mysql:<span class=\"comment\">//119.23.75.58:3306/poseidon?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowMultiQueries=true</span></span><br><span class=\"line\">spring.datasource.username =</span><br><span class=\"line\">spring.datasource.password =</span><br><span class=\"line\">spring.datasource.max-active=<span class=\"number\">20</span></span><br><span class=\"line\">spring.datasource.max-idle=<span class=\"number\">8</span></span><br><span class=\"line\">spring.datasource.min-idle=<span class=\"number\">8</span></span><br><span class=\"line\">spring.datasource.initial-size=<span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">spring.jpa.database=mysql</span><br><span class=\"line\">spring.jpa.show-sql = <span class=\"keyword\">true</span></span><br><span class=\"line\">#配置方言</span><br><span class=\"line\">spring.jpa.database-platform=org.hibernate.dialect.MySQL5Dialect</span><br><span class=\"line\"></span><br><span class=\"line\">spring.ss.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class=\"line\">#spring.datasource.url = jdbc:mysql://localhost:3306/test</span><br><span class=\"line\">spring.ss.driverClassName = com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">spring.ss.url = jdbc:mysql:<span class=\"comment\">//zzzzz/log?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowMultiQueries=true</span></span><br><span class=\"line\">spring.ss.username =</span><br><span class=\"line\">spring.ss.password =</span><br><span class=\"line\">spring.ss.max-active=<span class=\"number\">20</span></span><br><span class=\"line\">spring.ss.max-idle=<span class=\"number\">8</span></span><br><span class=\"line\">spring.ss.min-idle=<span class=\"number\">8</span></span><br><span class=\"line\">spring.ss.initial-size=<span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">spring.aa.database=mysql</span><br><span class=\"line\">spring.aa.show-sql = <span class=\"keyword\">true</span></span><br><span class=\"line\">#配置方言</span><br><span class=\"line\">spring.aa.database-platform=org.hibernate.dialect.MySQL5Dialect</span><br></pre></td></tr></table></figure>\n\n<p>以数据库作为输出配置就算完成了，接下来整合elk系统到我们日志系统中：</p>\n<p>先整合logstash</p>\n<p>logstash安装和配置：<br><a href=\"https://www.elastic.co/cn/downloads/logstash\">https://www.elastic.co/cn/downloads/logstash</a> 选择zip包下载</p>\n<p>解压，进入bin目录 创建logstash.conf 并配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input &#123;</span><br><span class=\"line\">    tcp &#123;</span><br><span class=\"line\">    ##host:port就是上面appender中的 destination，这里其实把logstash作为服务，开启9250端口接收logback发出的消息</span><br><span class=\"line\">    host =&gt; &quot;127.0.0.1&quot;</span><br><span class=\"line\">    port =&gt; 9100</span><br><span class=\"line\">    mode =&gt; &quot;server&quot;</span><br><span class=\"line\">    tags =&gt; [&quot;tags&quot;]</span><br><span class=\"line\">    codec =&gt; json_lines</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output &#123;</span><br><span class=\"line\">    stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class=\"line\">    #输出到es</span><br><span class=\"line\">    #elasticsearch &#123; hosts =&gt; &quot;127.0.0.1:9200&quot; &#125;</span><br><span class=\"line\">        #输出到一个文件中</span><br><span class=\"line\">    file &#123;</span><br><span class=\"line\">       path =&gt; &quot;D:\\logs\\test.log&quot;</span><br><span class=\"line\">       codec =&gt; line</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我这里先配置输出到文件，后面再修改,创建文件：D:\\logs\\test.log</p>\n<p>启动：</p>\n<p>打开cmd（不要使用powershell），进入bin:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\exe\\logstash-6.6.1\\logstash-6.6.1\\bin&gt;logstash -f logstash.conf</span><br></pre></td></tr></table></figure>\n<p>然后在我们的项目中进行相应的配置：<br>按这个来：<a href=\"https://github.com/logstash/logstash-logback-encoder\">https://github.com/logstash/logstash-logback-encoder</a></p>\n<p>加入pom并指定logback版本：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 父pom中 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ch.qos.logback.version</span>&gt;</span>1.2.3<span class=\"tag\">&lt;/<span class=\"name\">ch.qos.logback.version</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--  日志模块--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.logstash.logback<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>logstash-logback-encoder<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- Your project must also directly depend on either logback-classic or logback-access.  For example: --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>ch.qos.logback<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>logback-classic<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>配置apppender和logger</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;stash&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">destination</span>&gt;</span>127.0.0.1:9100<span class=\"tag\">&lt;/<span class=\"name\">destination</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">includeCallerData</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">includeCallerData</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">includeCallerData</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">includeCallerData</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;logstash&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;stash&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RestController</span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/public/log&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogTestController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger log = LoggerFactory.getLogger(<span class=\"string\">&quot;logstash&quot;</span>);</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    LoggingEventRepository repository;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;sssssssssssssss&quot;</span>);</span><br><span class=\"line\">        Iterable&lt;LoggingEvent&gt; all = repository.findAll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;sss&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>访问接口，logstash打印信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[2019-03-09T11:32:56,358][INFO ][logstash.outputs.file    ] Opening file &#123;:path&#x3D;&gt;&quot;D:&#x2F;logs&#x2F;test.log&quot;&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">                  &quot;host&quot; &#x3D;&gt; &quot;www.xmind.net&quot;,</span><br><span class=\"line\">                 &quot;level&quot; &#x3D;&gt; &quot;INFO&quot;,</span><br><span class=\"line\">     &quot;caller_class_name&quot; &#x3D;&gt; &quot;com.muggle.poseidon.controller.LogTestController&quot;,</span><br><span class=\"line\">            &quot;@timestamp&quot; &#x3D;&gt; 2019-03-09T03:33:03.413Z,</span><br><span class=\"line\">           &quot;logger_name&quot; &#x3D;&gt; &quot;logstash&quot;,</span><br><span class=\"line\">              &quot;@version&quot; &#x3D;&gt; &quot;1&quot;,</span><br><span class=\"line\">           &quot;thread_name&quot; &#x3D;&gt; &quot;http-nio-8080-exec-9&quot;,</span><br><span class=\"line\">               &quot;message&quot; &#x3D;&gt; &quot;sssssssssssssss&quot;,</span><br><span class=\"line\">    &quot;caller_line_number&quot; &#x3D;&gt; 22,</span><br><span class=\"line\">                  &quot;port&quot; &#x3D;&gt; 58368,</span><br><span class=\"line\">           &quot;level_value&quot; &#x3D;&gt; 20000,</span><br><span class=\"line\">      &quot;caller_file_name&quot; &#x3D;&gt; &quot;LogTestController.java&quot;,</span><br><span class=\"line\">                  &quot;tags&quot; &#x3D;&gt; [</span><br><span class=\"line\">        [0] &quot;tags&quot;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;caller_method_name&quot; &#x3D;&gt; &quot;test&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>test.log输出了文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-03-09T03:33:03.413Z www.xmind.net sssssssssssssss</span><br></pre></td></tr></table></figure>\n<p>接下来只要把输出路径换成ES就可以了，这属于logstash和es的整合，这里先不讲解；重新回归到我们的请求模块：</p>\n<p>我希望我的模块，对每次请求都能记录下来（请求日志），并将记录存到数据库或者ES，同时我要对所有接口都进行一个幂等性的保障；保障接口的幂等性有多种方法，比较简单的是数据库做唯一索引或者加拦截器，我这里加了一个拦截器来保障接口幂等和拦截前端数据的重复提交(关于接口幂等性在其他文档中介绍)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestLockInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    RedisLock redisTool;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> expireTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestLockInterceptor</span><span class=\"params\">(<span class=\"keyword\">int</span> expireTime, RedislockImpl redisTool)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.expireTime = expireTime;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.redisTool = redisTool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">&quot;post&quot;</span>.equalsIgnoreCase(request.getMethod()))&#123;</span><br><span class=\"line\">            String token = request.getParameter(<span class=\"string\">&quot;request_key&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (token==<span class=\"keyword\">null</span>||<span class=\"string\">&quot;&quot;</span>.equals(token))&#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;请求非法&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//            throw new PoseidonException(&quot;请求太频繁&quot;,PoseidonProperties.TOO_NUMBER_REQUEST);</span></span><br><span class=\"line\">                response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">                PrintWriter writer = response.getWriter();</span><br><span class=\"line\">                writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;5001\\&quot;,\\&quot;msg\\&quot;:\\&quot;请求非法\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">                writer.close();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String ipAddr = RequestUtils.getIpAddr(request);</span><br><span class=\"line\">            String lockKey = request.getRequestURI() + <span class=\"string\">&quot;_&quot;</span>  + <span class=\"string\">&quot;_&quot;</span> + token;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> lock = redisTool.lock(lockKey, ipAddr, expireTime);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!lock) &#123;<span class=\"comment\">//</span></span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;拦截表单重复提交&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//            throw new PoseidonException(&quot;请求太频繁&quot;,PoseidonProperties.TOO_NUMBER_REQUEST);</span></span><br><span class=\"line\">                response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">                PrintWriter writer = response.getWriter();</span><br><span class=\"line\">                writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;5001\\&quot;,\\&quot;msg\\&quot;:\\&quot;请求太频繁\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">                writer.close();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        String requestURI = request.getRequestURI();</span></span><br><span class=\"line\"><span class=\"comment\">//        String lockKey = request.getRequestURI() + &quot;_&quot; + RequestUtils.getIpAddr(request);</span></span><br><span class=\"line\"><span class=\"comment\">//        redisTool.unlock(lockKey,getIpAddr(request));</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>项目使用了redis锁（redis锁原理和使用在其他文档中介绍）</p>\n<p>对于系统异常，如果是业务的异常，正常处理，如果是系统发生的异常比如空指针，数据库异常等我希望系统能马上通知，以便排查问题，所以我配置邮件异常通知(关于springboot邮件配置其他文档介绍)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestControllerAdvice</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RestExceptionHandlerController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    EmailService emailService;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;admin.email&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String adminEmail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(value = &#123;PoseidonException.class&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultBean <span class=\"title\">poseidonExceptionHandler</span><span class=\"params\">(PoseidonException e, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResultBean().setMsg(e.getMsg()).setCode(e.getCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(value = &#123;MethodArgumentNotValidException.class&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultBean <span class=\"title\">MethodArgumentNotValidException</span><span class=\"params\">(MethodArgumentNotValidException e, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResultBean().setMsg(<span class=\"string\">&quot;数据未通过校验&quot;</span>).setCode(PoseidonProperties.COMMIT_DATA_ERROR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(value = &#123;Exception.class&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultBean <span class=\"title\">exceptionHandler</span><span class=\"params\">(Exception e, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;系统异常：&quot;</span> + req.getMethod() + req.getRequestURI(), e);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">            EmailBean emailBean = <span class=\"keyword\">new</span> EmailBean();</span><br><span class=\"line\">            emailBean.setRecipient(adminEmail);</span><br><span class=\"line\">            emailBean.setSubject(<span class=\"string\">&quot;poseidon---系统异常&quot;</span>);</span><br><span class=\"line\">            emailBean.setContent(<span class=\"string\">&quot;系统异常：&quot;</span> + req.getMethod() + req.getRequestURI()+<span class=\"string\">&quot;----&quot;</span>+e.getMessage());</span><br><span class=\"line\"><span class=\"comment\">//            改良</span></span><br><span class=\"line\">            emailService.sendSimpleMail(emailBean);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResultBean().setMsg(<span class=\"string\">&quot;系统异常，请联系管理员&quot;</span>).setCode(<span class=\"string\">&quot;500&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(value = &#123;HttpRequestMethodNotSupportedException.class&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultBean <span class=\"title\">notsupported</span><span class=\"params\">(Exception e, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResultBean().setMsg(<span class=\"string\">&quot;不支持的请求方式&quot;</span>).setCode(PoseidonProperties.NOT_SUPPORT_METHOD);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(value = &#123;NoHandlerFoundException.class&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultBean <span class=\"title\">notFoundUrl</span><span class=\"params\">(Exception e, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResultBean().setMsg(<span class=\"string\">&quot;请求路径不存在&quot;</span>).setCode(<span class=\"string\">&quot;404&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>项目架构信得<br>common 和core模块存在的意义</p>\n","site":{"data":{}},"excerpt":"<h5 id=\"作者：muggle\"><a href=\"#作者：muggle\" class=\"headerlink\" title=\"作者：muggle\"></a>作者：muggle</h5><p>Logback是由log4j创始人设计的另一个开源日志组件,分为三个模块：</p>\n<ol>\n<li><p>logback-core：其它两个模块的基础模块</p>\n</li>\n<li><p>logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API使你可以很方便地更换成其它日志系统如log4j或JDK14 Logging</p>\n</li>\n<li><p>logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能<br>在springboot中我们通过xml配置来操作logback</p>\n</li>\n</ol>","more":"<p>springboot中logback的默认配置文件名称为logback-spring.xml，若需要指定xml名称，需在application.properties（application.yml）中配置logging.config=xxxx.xml<br>现在贴出一份logback的xml配置，可直接使用，懒得看的小伙伴复制粘贴到你的项目中去体验吧</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span> <span class=\"attr\">scan</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">scanPeriod</span>=<span class=\"string\">&quot;60 seconds&quot;</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">jmxConfigurator</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;log_dir&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;logs&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxHistory&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;100&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;console&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %highlight([%-5level]) %logger - %msg%n</span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;logs&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">                $&#123;log_dir&#125;/%d&#123;yyyy-MM-dd&#125;-poseidon.log</span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>$&#123;maxHistory&#125;<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %highlight([%-5level]) %logger - %msg%n</span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;runningTime-file&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log_dir&#125;/runningTime/%d&#123;yyyy-MM-dd&#125;-poseidon.log<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>$&#123;maxHistory&#125;<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %logger - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;runningTime-console&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">                %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %logger - %msg%n</span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;runningTime&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span> <span class=\"attr\">additivity</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;appender-ref ref=&quot;runningTime-file&quot;/&gt;--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;runningTime-console&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">logger</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--  可能会抛出方言异常 两个解决方案 配置方言或者换连接池 换druid不会有这个异常--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;requestLog-db&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.db.DBAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">connectionSource</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.db.DataSourceConnectionSource&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">driverClassName</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">driverClassName</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>jdbc:mysql://xxx/xxxx?characterEncoding=UTF-8<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>xx<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>xxxx<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">connectionSource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;sqlDialect class=&quot;ch.qos.logback.core.db.dialect.MySQLDialect&quot; /&gt;--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--异步配置--&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--&lt;appender name=&quot;requestLog-file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">             &lt;fileNamePattern&gt;$&#123;log_dir&#125;/requestLog/%d&#123;yyyy-MM-dd&#125;-poseidon.log&lt;/fileNamePattern&gt;</span></span><br><span class=\"line\"><span class=\"comment\">             &lt;maxHistory&gt;$&#123;maxHistory&#125;&lt;/maxHistory&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         &lt;/rollingPolicy&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         &lt;encoder&gt;</span></span><br><span class=\"line\"><span class=\"comment\">             &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %logger - %msg%n&lt;/pattern&gt;</span></span><br><span class=\"line\"><span class=\"comment\">         &lt;/encoder&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     &lt;/appender&gt;--&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;appender name=&quot;request-asyn&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;appender-ref ref=&quot;requestLog-file&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;/appender&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;logs-asyn&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;logs&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;requestLog&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span> <span class=\"attr\">additivity</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;appender-ref ref=&quot;requestLog-file&quot;/&gt;--&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- DBAppender 查看可知其父类dbappenderbase继承了UnsynchronizedAppenderBase&lt;E&gt; 所以dbappender本身是异步的 无需配置异步--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;requestLog-db&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">logger</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">level</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;info&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;console&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;appender-ref ref=&quot;logs&quot;/&gt;--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;logs-asyn&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到xml中有四种节点<br>appender，logger，root,configuration</p>\n<h4 id=\"节点解读\"><a href=\"#节点解读\" class=\"headerlink\" title=\"节点解读\"></a>节点解读</h4><p>configuration包含三个属性：</p>\n<ol>\n<li>scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</li>\n<li>scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</li>\n<li>debug: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</li>\n<li>Logger作为日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别。</li>\n</ol>\n<p>Appender主要用于指定日志输出的目的地，目的地可以是控制台、文件、远程套接字服务器、 MySQL、PostreSQL、 Oracle和其他数据库、 JMS和远程UNIX Syslog守护进程等。</p>\n<p>root 就是最高级别logger,所有不被指定logger的日志都归root管理。</p>\n<p>在slf4j框架下我们使用log是这样的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger= LoggerFactory.getLogger(xxx.class);</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger= LoggerFactory.getLogger(<span class=\"string\">&quot;xxxx&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>可以理解为代码中的getLogger() 方法就是获取xml配置中的logger,如果没有配置相应的logger则为root<br>比如我配置了：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hhh&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span> <span class=\"attr\">additivity</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;appender-ref ref=&quot;requestLog-file&quot;/&gt;--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;xxx&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>那我在获得一个logger时可以这样获得它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger= LoggerFactory.getLogger(<span class=\"string\">&quot;hhh&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>我所输出的日志将被这个logger所管理<br>logger 上有三个配置 name level additivity<br>name就是这个logger的名称，level就是这个日志过滤的级别，低于这个级别的日志不输入到对应的appender中；additivity是否向上级logger传递打印信息，默认是true。logger中可以配置多个appender-ref，也就是可以指定多个输出地点。<br>而root只是特殊的logger，用法上无差别</p>\n<p>appender节点：<br>appender节点是logback配置的关键，其name属性指定其名称，class属性指定实现类，对应得实现类有</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch.qos.logback.core.ConsoleAppender <span class=\"comment\">// 以控制台作为输出</span></span><br><span class=\"line\">ch.qos.logback.core.rolling.RollingFileAppender<span class=\"comment\">//以日志文件作为输出</span></span><br><span class=\"line\">ch.qos.logback.classic.db.DBAppender<span class=\"comment\">//以数据库作为输出</span></span><br><span class=\"line\">net.logstash.logback.appender.LogstashTcpSocketAppender<span class=\"comment\">//以logstash作为输出需要引入如下依赖：</span></span><br><span class=\"line\">ch.qos.logback.classic.AsyncAppender<span class=\"comment\">//异步输出 需要定义appender-ref</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// logstash依赖</span></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;4.11&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>所有的appender 实现ch.qos.logback.core.Appender接口或者 ch.qos.logback.core.UnsynchronizedAppenderBase接口（异步），我们也可以自定义appender来指定日志输出；</p>\n<p>在Appender中可以定义哪些节点我们一个个来看：</p>\n<p>第一种： ConsoleAppender<br>如同它的名字一样，这个Appender将日志输出到console，更准确的说是System.out 或者System.err。<br>它包含的参数如下：</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>encoder</td>\n<td>Encoder</td>\n<td>通常在其pattern里指定日志格式  如： %d{yyyy-MM-dd HH:mm:ss.SSS} %highlight([%-5level]) %logger - %msg%n表示 日期格式 日志级别（高亮）logger的名称 logger的message</td>\n</tr>\n<tr>\n<td>target</td>\n<td>String</td>\n<td>指定输出目标。可选值：System.out 或 System.err。默认值：System.out</td>\n</tr>\n<tr>\n<td>withJansi</td>\n<td>boolean</td>\n<td>是否支持ANSI color codes（类似linux中的shell脚本的输出字符串颜色控制代码）。默认为false。如果设置为true。例如：[31m 代表将前景色设置成红色。在windows中，需要提供”org.fusesource.jansi:jansi:1.9”，而在linux，mac os x中默认支持。</td>\n</tr>\n</tbody></table>\n<p>第二种： FileAppender<br>将日志输出到文件当中，目标文件取决于file属性。是否追加输出，取决于append属性。</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>append</td>\n<td>boolean</td>\n<td>是否以追加方式输出。默认为true。</td>\n</tr>\n<tr>\n<td>encoder</td>\n<td>Encoder</td>\n<td>See OutputStreamAppender properties.</td>\n</tr>\n<tr>\n<td>file</td>\n<td>String</td>\n<td>指定文件名。注意在windows当中，反斜杠 \\ 需要转义，或直接使用 / 也可以。例如 c:/temp/test.logor 或 c:\\temp\\test.log 都可以。没有默认值，如果上层目录不存在，FileAppender会自动创建。</td>\n</tr>\n<tr>\n<td>prudent</td>\n<td>boolean</td>\n<td>是否工作在谨慎模式下。在谨慎模式下，FileAppender将会安全写入日志到指定文件，即时在不同的虚拟机jvm中有另一个相同的FileAppender实例。默认值：fales;设置为true，意味着append会被自动设置成true。prudent依赖于文件排它锁。实验表明，使用文件锁，会增加3倍的日志写入消耗。比如说，当prudent模式为off，写入一条日志到文件只要10毫秒，但是prudent为真，则会接近30毫秒。prudent 模式实际上是将I/O请求序列化，因此在I/O数量较大，比如说100次/s或更多的时候，带来的延迟也会显而易见，所以应该避免。在networked file system（远程文件系统）中，这种消耗将会更大，可能导致死锁。</td>\n</tr>\n</tbody></table>\n<p>第三个： RollingFileAppender</p>\n<p>RollingFileAppender继承自FileAppender，提供日志目标文件自动切换的功能。例如可以用日期作为日志分割的条件。<br>RollingFileAppender有两个重要属性，RollingPolicy负责怎么切换日志，TriggeringPolicy负责何时切换。为了使RollingFileAppender起作用，这两个属性必须设置，但是如果RollingPolicy的实现类同样实现了TriggeringPolicy接口，则也可以只设置RollingPolicy这个属性。<br>下面是它的参数：</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>file</td>\n<td>String</td>\n<td>指定文件名。注意在windows当中，反斜杠 \\ 需要转义，或直接使用 / 也可以。例如 c:/temp/test.logor 或 c:\\temp\\test.log 都可以。没有默认值，如果上层目录不存在，FileAppender会自动创建。</td>\n</tr>\n<tr>\n<td>append</td>\n<td>boolean</td>\n<td>是否以追加方式输出。默认为true。</td>\n</tr>\n<tr>\n<td>encoder</td>\n<td>Encoder</td>\n<td>See OutputStreamAppender properties.</td>\n</tr>\n<tr>\n<td>rollingPolicy</td>\n<td>RollingPolicy</td>\n<td>当发生日志切换时，RollingFileAppender的切换行为。例如日志文件名的修改</td>\n</tr>\n<tr>\n<td>triggeringPolicy</td>\n<td>TriggeringPolicy</td>\n<td>决定什么时候发生日志切换，例如日期，日志文件大小到达一定值</td>\n</tr>\n<tr>\n<td>prudent</td>\n<td>boolean</td>\n<td>FixedWindowRollingPolicy 不支持prudent模式。TimeBasedRollingPolicy 支持prudent模式，但是需要满足一下两条约束：在prudent模式中，日志文件的压缩是不被允许，不被支持的。不能设置file属性。</td>\n</tr>\n</tbody></table>\n<p>第四个：SocketAppender及SSLSocketAppender（未尝试过）</p>\n<p>到目前为止我们讲的appender都只能将日志输出到本地资源。与之相对的，SocketAppender就是被设计用来输出日志到远程实例中的。SocketAppender输出日志采用明文方式，SSLSocketAppender则采用加密方式传输日志。<br>被序列化的日志事件的类型是 LoggingEventVO 继承ILoggingEvent接口。远程日志记录并非是侵入式的。在反序列化接收后，日志事件就可以好像在本地生成的日志一样处理了。多个SockerAppender可以向同一台日志服务器发送日志。SocketAppender并不需要关联一个Layout，因为它只是发送序列化的日志事件给远程日志服务器。SocketAppender的发送操作是基于TCP协议的。因此如果远程服务器是可到达的，则日志会被其处理，如果远程服务器宕机或不可到达，那么日志将会被丢弃。等到远程服务器复活，日志发送将会透明的重新开始。这种透明式的重连，是通过一个“连接“线程周期性的尝试连接远程服务器实现的。<br>Logging events会由TCP协议实现自动缓冲。这意味着，如果网络速度比日志请求产生速度快，则网络速度并不会影响应用。但如果网络速度过慢，则网络速度则会变成限制，在极端情况下，如果远程日志服务器不可到达，则会导致应用最终阻塞。不过，如果服务器可到达，但是服务器宕机了，这种情况，应用不会阻塞，而只是丢失一些日志事件而已。<br>需要注意的是，即使SocketAppender没有被logger链接，它也不会被gc回收，因为他在connector thread中任然存在引用。一个connector thread 只有在网络不可达的情况下，才会退出。为了防止这个垃圾回收的问题，我们应该显示声明关闭SocketAppender。长久存活并创建/销毁大量的SocketAppender实例的应用，更应该注意这个问题。不过大多数应用可以忽略这个问题。如果JVM在SocketAppender关闭之前将其退出，又或者是被垃圾回收，这样子可能导致丢失一些还未被传输，在管道中等待的日志数据。为了防止避免日志丢失，经常可靠的办法就是调用SocketAppender的close方法，或者调用LoggerContext的stop方法，在退出应用之前。</p>\n<p>下面我们来看看SocketAppender的属性：</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>includeCallerData</td>\n<td>boolean</td>\n<td>是否包含调用者的信息如果为true，则以下日志输出的 ?:? 会替换成调用者的文件名跟行号，为false，则为问号。2019-01-06 17:37:30,968 DEBUG [Thread-0] [?:?] chapters.appenders.socket.SocketClient2 - Hi</td>\n</tr>\n<tr>\n<td>port</td>\n<td>int</td>\n<td>端口号</td>\n</tr>\n<tr>\n<td>reconnectionDelay</td>\n<td>Duration</td>\n<td>重连延时，如果设置成“10 seconds”，就会在连接u武器失败后，等待10秒，再连接。默认值：“30 seconds”。如果设置成0，则关闭重连功能。</td>\n</tr>\n<tr>\n<td>queueSize</td>\n<td>int</td>\n<td>设置缓冲日志数，如果设置成0，日志发送是同步的，如果设置成大于0的值，会将日志放入队列，队列长度到达指定值，在统一发送。可以加大服务吞吐量。</td>\n</tr>\n<tr>\n<td>eventDelayLimit</td>\n<td>Duration</td>\n<td>设置日志超时丢弃时间。当设置“10 seconds”类似的值，如果日志队列已满，而服务器长时间来不及接收，当滞留时间超过10 seconds，日志就会被丢弃。默认值： 100 milliseconds</td>\n</tr>\n<tr>\n<td>remoteHost</td>\n<td>String</td>\n<td>远程日志服务器的IP</td>\n</tr>\n<tr>\n<td>ssl</td>\n<td>SSLConfiguration</td>\n<td>只在SSLSocketAppender包含该属性节点。提供SSL配置，详情见 Using SSL.</td>\n</tr>\n</tbody></table>\n<p>标准的Logback Classic包含四个可供使用的Receiver用来接收来自SocketAppender的logging evnets。</p>\n<p>第五个： SMTPAppender</p>\n<p>SMTPAppender 可以将logging event存放在一个或多个固定大小的缓冲区中，然后在用户指定的event到来之时，将适当的大小的logging event以邮件方式发送给运维人员。<br>详细属性如下：</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>smtpHost</td>\n<td>String</td>\n<td>SMTP server的地址，必需指定。如网易的SMTP服务器地址是： smtp.163.com</td>\n</tr>\n<tr>\n<td>smtpPort</td>\n<td>int</td>\n<td>SMTP server的端口地址。默认值：25</td>\n</tr>\n<tr>\n<td>to</td>\n<td>String</td>\n<td>指定发送到那个邮箱，可设置多个<to>属性，指定多个目的邮箱</td>\n</tr>\n<tr>\n<td>from</td>\n<td>String</td>\n<td>指定发件人名称。如果设置成“muggle &lt;<a href=\"mailto:hh@moral.org\">hh@moral.org</a>&gt; ”，则邮件发件人将会是“muggle <a href=\"mailto:&#104;&#104;&#64;&#109;&#x6f;&#x72;&#97;&#x6c;&#46;&#111;&#114;&#103;\">&#104;&#104;&#64;&#109;&#x6f;&#x72;&#97;&#x6c;&#46;&#111;&#114;&#103;</a> ”</td>\n</tr>\n<tr>\n<td>subject</td>\n<td>String</td>\n<td>指定emial的标题，它需要满足PatternLayout中的格式要求。如果设置成“Log: %logger - %msg”，就案例来讲，则发送邮件时，标题为“Log: com.foo.Bar - Hello World ”。 默认值：”%logger{20} - %m”.</td>\n</tr>\n<tr>\n<td>discriminator</td>\n<td>Discriminator</td>\n<td>通过Discriminator, SMTPAppender可以根据Discriminator的返回值，将到来的logging event分发到不同的缓冲区中。默认情况下，总是返回相同的值来达到使用一个缓冲区的目的。</td>\n</tr>\n<tr>\n<td>evaluator</td>\n<td>IEvaluator</td>\n<td>指定触发日志发送的条件。通过<evaluator class=... />指定EventEvaluator接口的实现类。默认情况下SMTPAppeender使用的是OnErrorEvaluator，表示当发送ERROR或更高级别的日志请求时，发送邮件。Logback提供了几个evaluators：OnErrorEvaluator、OnMarkerEvaluator、JaninoEventEvaluator、GEventEvaluator（功能强大）</td>\n</tr>\n<tr>\n<td>cyclicBufferTracker</td>\n<td>CyclicBufferTracker</td>\n<td>指定一个cyclicBufferTracker跟踪cyclic buffer。它是基于discriminator的实现的。如果你不指定，默认会创建一个CyclicBufferTracker ，默认设置cyclic buffer大小为256。你也可以手动指定使用默认的CyclicBufferTracker，并且通过<bufferSize>属性修改默认的缓冲区接收多少条logging event。</td>\n</tr>\n<tr>\n<td>username</td>\n<td>String</td>\n<td>发送邮件账号，默认为null</td>\n</tr>\n<tr>\n<td>password</td>\n<td>String</td>\n<td>发送邮件密码，默认为null</td>\n</tr>\n<tr>\n<td>STARTTLS</td>\n<td>boolean</td>\n<td>如果设置为true，appender会尝试使用STARTTLS命令，如果服务端支持，则会将明文连接转换成加密连接。需要注意的是，与日志服务器连接一开始是未加密的。默认值：false</td>\n</tr>\n<tr>\n<td>SSL</td>\n<td>boolean</td>\n<td>如果设置为true，appender将会使用SSL连接到日志服务器。 默认值：false</td>\n</tr>\n<tr>\n<td>charsetEncoding</td>\n<td>String</td>\n<td>指定邮件信息的编码格式 默认值：UTF-8</td>\n</tr>\n<tr>\n<td>localhost</td>\n<td>String</td>\n<td>如果smtpHost没有正确配置，比如说不是完整的地址。这时候就需要localhost这个属性提供服务器的完整路径（如同java中的完全限定名 ），详情参考com.sun.mail.smtp 中的mail.smtp.localhost属性</td>\n</tr>\n<tr>\n<td>asynchronousSending</td>\n<td>boolean</td>\n<td>这个属性决定email的发送是否是异步。默认：true，异步发送但是在某些情况下，需要以同步方式发送错误日志的邮件给管理人员，防止不能及时维护应用。</td>\n</tr>\n<tr>\n<td>includeCallerData</td>\n<td>boolean</td>\n<td>默认：false 指定是否包含callerData在日志中</td>\n</tr>\n<tr>\n<td>sessionViaJNDI</td>\n<td>boolean</td>\n<td>SMTPAppender依赖javax.mail.Session来发送邮件。默认情况下，sessionViaJNDI为false。javax.mail.Session实例的创建依赖于SMTPAppender本身的配置信息。如果设置为true，则Session的创建时通过JNDI获取引用。这样做的好处可以让你的代码复用更好，让配置更简洁。需要注意的是，如果使用JNDI获取Session对象，需要保证移除mail.jar以及activation.jar这两个jar包</td>\n</tr>\n<tr>\n<td>jndiLocation</td>\n<td>String</td>\n<td>如果sessionViaJNDI设置为true，则jndiLocation指定JNDI的资源名，默认值为：”java:comp/env/mail/Session”</td>\n</tr>\n</tbody></table>\n<p>SMTPAppender只保留最近的256条logging events 在循环缓冲区中，当缓冲区慢，就会开始丢弃最老的logging event。因此不管什么时候，SMTPAppender一封邮件最多传递256条日志事件。SMTPAppender依赖于JavaMail API。而JavaMail API又依赖于IOC框架（依赖注入）。</p>\n<p>第六个：DBAppender</p>\n<p> DBAppender 可以将日志事件插入到3张数据表中。它们分别是logging_event，logging_event_property，logging_event_exception。这三张数据表必须在DBAppender工作之前存在。它们的sql脚本可以在 logback-classic/src/main/java/ch/qos/logback/classic/db/script folder 这个目录下找到。这个脚本对大部分SQL数据库都是有效的，除了少部分，少数语法有差异需要调整。<br>下面是logback与常见数据库的支持信息：</p>\n<table>\n<thead>\n<tr>\n<th>RDBMS</th>\n<th>tested version(s)</th>\n<th>tested JDBC driver version(s)</th>\n<th>supports getGeneratedKeys() method</th>\n<th>is a dialect provided by logback</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DB2</td>\n<td>untested</td>\n<td>untested</td>\n<td>unknown</td>\n<td>NO</td>\n</tr>\n<tr>\n<td>H2</td>\n<td>–</td>\n<td>-</td>\n<td>unknown</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>HSQL</td>\n<td>–</td>\n<td>-</td>\n<td>NO</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>Microsoft SQL Server</td>\n<td>–</td>\n<td>–</td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>MySQL</td>\n<td>5.7</td>\n<td></td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>PostgreSQL</td>\n<td>–</td>\n<td>–</td>\n<td>NO</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>Oracle</td>\n<td>–</td>\n<td>–</td>\n<td>YES</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>SQLLite</td>\n<td>–</td>\n<td>-</td>\n<td>unknown</td>\n<td>YES</td>\n</tr>\n<tr>\n<td>Sybase</td>\n<td>–</td>\n<td>-</td>\n<td>unknown</td>\n<td>YES</td>\n</tr>\n</tbody></table>\n<p>下面给出三张表的sql语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">BEGIN</span>;</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> logging_event_property;</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> logging_event_exception;</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> logging_event;</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> logging_event</span><br><span class=\"line\">  (</span><br><span class=\"line\">    timestmp         <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    formatted_message  TEXT <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    logger_name       <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    level_string      <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    thread_name       <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>),</span><br><span class=\"line\">    reference_flag    <span class=\"type\">SMALLINT</span>,</span><br><span class=\"line\">    arg0              <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>),</span><br><span class=\"line\">    arg1              <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>),</span><br><span class=\"line\">    arg2              <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>),</span><br><span class=\"line\">    arg3              <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>),</span><br><span class=\"line\">    caller_filename   <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    caller_class      <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    caller_method     <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    caller_line       <span class=\"type\">CHAR</span>(<span class=\"number\">4</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    event_id          <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT <span class=\"keyword\">PRIMARY</span> <span class=\"keyword\">KEY</span></span><br><span class=\"line\">  );</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> logging_event_property</span><br><span class=\"line\">  (</span><br><span class=\"line\">    event_id       <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    mapped_key        <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    mapped_value      TEXT,</span><br><span class=\"line\">    <span class=\"keyword\">PRIMARY</span> <span class=\"keyword\">KEY</span>(event_id, mapped_key),</span><br><span class=\"line\">    <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (event_id) <span class=\"keyword\">REFERENCES</span> logging_event(event_id)</span><br><span class=\"line\">  );</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> logging_event_exception</span><br><span class=\"line\">  (</span><br><span class=\"line\">    event_id         <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    i                <span class=\"type\">SMALLINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    trace_line       <span class=\"type\">VARCHAR</span>(<span class=\"number\">254</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    <span class=\"keyword\">PRIMARY</span> <span class=\"keyword\">KEY</span>(event_id, i),</span><br><span class=\"line\">    <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (event_id) <span class=\"keyword\">REFERENCES</span> logging_event(event_id)</span><br><span class=\"line\">  );</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n<p>第七个： AsyncAppender</p>\n<p>AsyncAppender记录ILoggingEvents的方式是异步的。它仅仅相当于一个event分配器，因此需要配合其他appender才能有所作为。</p>\n<p>需要注意的是：AsyncAppender将event缓存在 BlockingQueue ，一个由AsyncAppender创建的工作线程，会一直从这个队列的头部获取events，然后将它们分配给与AsyncAppender唯一关联的Appender中。默认情况下，如果这个队列80%已经被占满，则AsyncAppender会丢弃等级为 TRACE，DEBUG，INFO这三个等级的日志事件。<br>在应用关闭或重新部署的时候，AsyncAppender一定要被关闭，目的是为了停止，回收再利用worker thread，和刷新缓冲队列中logging events。那如果关闭AsyncAppender呢？可以通过关闭LoggerContext来关闭所有appender，当然也包括AsyncAppender了。AsyncAppender会在maxFlushTime属性设置的时间内等待Worker thread刷新全部日志event。如果你发现缓冲的event在关闭LoggerContext的时候被丢弃，这时候你就也许需要增加等待的时间。将maxFlushTime设置成0，就是AsyncAppender一直等待直到工作线程将所有被缓冲的events全部刷新出去才执行才结束。<br>根据JVM退出的模式，工作线程worker thread处理被缓冲的events的工作是可以被中断的，这样就导致了剩余未处理的events被搁浅。这种现象通常的原因是当LoggerContext没有完全关闭，或者当JVM终止那些非典型的控制流（不明觉厉）。为了避免工作线程的因为这些情况而发生中断，一个shutdown hook（关闭钩子）可以被插入到JVM运行的时候，这个钩子的作用是在JVM开始shutdown刚开始的时候执行关闭 LoggerContext的任务。</p>\n<p>下面是AsyncAppender的属性表</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Name    Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>queueSize</td>\n<td>int</td>\n<td>设置blocking queue的最大容量，默认是256条events</td>\n</tr>\n<tr>\n<td>discardingThreshold</td>\n<td>int</td>\n<td>默认，当blocking queue被占用80%以上，AsyncAppender就会丢弃level为 TRACE，DEBUG，INFO的日志事件，如果要保留所有等级的日志，需要设置成0</td>\n</tr>\n<tr>\n<td>includeCallerData</td>\n<td>boolean</td>\n<td>提取CallerData代价比较昂贵，为了提高性能，caller data默认不提供。只有一些获取代价较低的数据，如线程名称，MDC值才会被保留。如果设置为true，就会包含caller data</td>\n</tr>\n<tr>\n<td>maxFlushTime</td>\n<td>int</td>\n<td>设置最大等待刷新事件，单位为miliseconds(毫秒)。当LoggerContext关闭的时候，AsyncAppender会在这个时间内等待工作线程完成events的flush工作，超时未处理的events将会被抛弃。</td>\n</tr>\n<tr>\n<td>neverBlock</td>\n<td>boolean</td>\n<td>默认为false，如果队列被填满，为了处理所有日志，就会阻塞的应用。如果为true，为了不阻塞你的应用，也会选择抛弃一些message。</td>\n</tr>\n</tbody></table>\n<p>默认情况下，event queue最大的容量是256。如果队列被填充满那么就会阻塞你的应用，直到队列能够容纳新的logging event。所以当AsyncAppender工作在队列满的情况下，可以称作伪同步。<br>在以下四种情况下容易导致AsyncAppender伪同步状态的出现：</p>\n<ol>\n<li>应用中存在大量线程</li>\n<li>每秒产生大量的logging events</li>\n<li>每一个logging event都存在大量的数据</li>\n<li>子appender中存在很高的延迟</li>\n</ol>\n<p>为了避免伪同步的出现，提高queueSizes普遍有效，但是就消耗了应用的可用内存。</p>\n<p>下面列出一些 appender配置示例：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;FILE&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>myapp.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%logger&#123;35&#125; - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;ASYNC&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;FILE&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;ASYNC&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;DB&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.db.DBAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    &lt;connectionSource</span><br><span class=\"line\">      class=&quot;ch.qos.logback.core.db.DataSourceConnectionSource&quot;&gt;</span><br><span class=\"line\">      &lt;dataSource</span><br><span class=\"line\">        class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">driverClass</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">driverClass</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">jdbcUrl</span>&gt;</span>jdbc:mysql://$&#123;serverName&#125;:$&#123;port&#125;/$&#123;dbName&#125;<span class=\"tag\">&lt;/<span class=\"name\">jdbcUrl</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">user</span>&gt;</span>$&#123;user&#125;<span class=\"tag\">&lt;/<span class=\"name\">user</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>$&#123;password&#125;<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">connectionSource</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;DB&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;EMAIL&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.net.SMTPAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">smtpHost</span>&gt;</span>smtp.gmail.com<span class=\"tag\">&lt;/<span class=\"name\">smtpHost</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">smtpPort</span>&gt;</span>465<span class=\"tag\">&lt;/<span class=\"name\">smtpPort</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">SSL</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">SSL</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>YOUR_USERNAME@gmail.com<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>YOUR_GMAIL_PASSWORD<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>EMAIL-DESTINATION<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>ANOTHER_EMAIL_DESTINATION<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span> <span class=\"comment\">&lt;!-- additional destinations are possible --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">from</span>&gt;</span>YOUR_USERNAME@gmail.com<span class=\"tag\">&lt;/<span class=\"name\">from</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">subject</span>&gt;</span>TESTING: %logger&#123;20&#125; - %m<span class=\"tag\">&lt;/<span class=\"name\">subject</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">layout</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%date %-5level %logger&#123;35&#125; - %message%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;EMAIL&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;EMAIL&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.net.SMTPAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">smtpHost</span>&gt;</span>smtp.gmail.com<span class=\"tag\">&lt;/<span class=\"name\">smtpHost</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">smtpPort</span>&gt;</span>587<span class=\"tag\">&lt;/<span class=\"name\">smtpPort</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">STARTTLS</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">STARTTLS</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>YOUR_USERNAME@gmail.com<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>YOUR_GMAIL_xPASSWORD<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>EMAIL-DESTINATION<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">to</span>&gt;</span>ANOTHER_EMAIL_DESTINATION<span class=\"tag\">&lt;/<span class=\"name\">to</span>&gt;</span> <span class=\"comment\">&lt;!-- additional destinations are possible --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">from</span>&gt;</span>YOUR_USERNAME@gmail.com<span class=\"tag\">&lt;/<span class=\"name\">from</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">subject</span>&gt;</span>TESTING: %logger&#123;20&#125; - %m<span class=\"tag\">&lt;/<span class=\"name\">subject</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">layout</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%date %-5level %logger - %message%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;EMAIL&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">SimpleSocketServer需要两个命令行参数，port 和 configFile路径。(该方法待验证)</span><br><span class=\"line\">java ch.qos.logback.classic.net.SimpleSocketServer 6000 \\ src/main/java/chapters/appenders/socket/server1.xml</span><br><span class=\"line\"></span><br><span class=\"line\">客户端的SocketAppender的简单配置例子：</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;SOCKET&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.net.SocketAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">remoteHost</span>&gt;</span>192.168.0.101<span class=\"tag\">&lt;/<span class=\"name\">remoteHost</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">port</span>&gt;</span>8888<span class=\"tag\">&lt;/<span class=\"name\">port</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">reconnectionDelay</span>&gt;</span>10000<span class=\"tag\">&lt;/<span class=\"name\">reconnectionDelay</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">includeCallerData</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">includeCallerData</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;SOCKET&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">在服务端使用SimpleSSLSocketServer</span><br><span class=\"line\">java -Djavax.net.ssl.keyStore=src/main/java/chapters/appenders/socket/ssl/keystore.jks \\ -Djavax.net.ssl.keyStorePassword=changeit \\ ch.qos.logback.classic.net.SimpleSSLSocketServer 6000 \\ src/main/java/chapters/appenders/socket/ssl/server.xml</span><br><span class=\"line\"></span><br><span class=\"line\">SSLSocketAppender配置</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;SOCKET&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.net.SSLSocketAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">remoteHost</span>&gt;</span>$&#123;host&#125;<span class=\"tag\">&lt;/<span class=\"name\">remoteHost</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">port</span>&gt;</span>$&#123;port&#125;<span class=\"tag\">&lt;/<span class=\"name\">port</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">reconnectionDelay</span>&gt;</span>10000<span class=\"tag\">&lt;/<span class=\"name\">reconnectionDelay</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ssl</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">trustStore</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>$&#123;truststore&#125;<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>$&#123;password&#125;<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">trustStore</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ssl</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;SOCKET&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;FILE&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>testFile.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">append</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">append</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- encoders are assigned the type</span></span><br><span class=\"line\"><span class=\"comment\">        ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;FILE&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>参考：<a href=\"https://blog.csdn.net/tianyaleixiaowu/article/details/73327752\">https://blog.csdn.net/tianyaleixiaowu/article/details/73327752</a></p>\n<p>下面基于logback配置做一个请求日志的的封装</p>\n<p>功能：记录每次请求的参数和用户ID存入数据库或者elk<br>问题：javaee规范中request输入输出流都只能被读取一次，所以如果用过滤器或者拦截器读取request中的流都会导致后面的controller无法接受到数据。<br>所以我们要用原生的aop获得请求参数，切点为controller，这就很好的避开了以上问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.muggle.poseidon.core.aspect;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.muggle.poseidon.manager.UserInfoManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.muggle.poseidon.utils.RequestUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.JoinPoint;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.RequestContextHolder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>: hiram_erp</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 日志信息切面</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-02-21</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogMessageAspect</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Logger logger = LoggerFactory.getLogger(<span class=\"string\">&quot;requestLog&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//    private final static Logger timeLog = LoggerFactory.getLogger(LogMessageAspect.class);</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Long&gt; threadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(public * com.hiram.erp.controller.*.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">webLog</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在切点之前织入</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> joinPoint</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;webLog()&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doBefore</span><span class=\"params\">(JoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(&quot;sssssssssssssssssssssssssssssssssssssssssssssssssssss&quot;);</span></span><br><span class=\"line\">       <span class=\"comment\">/* // 开始打印请求日志</span></span><br><span class=\"line\"><span class=\"comment\">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span></span><br><span class=\"line\"><span class=\"comment\">        HttpServletRequest request = attributes.getRequest();</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        // 打印请求相关参数</span></span><br><span class=\"line\"><span class=\"comment\">        // 打印请求 url</span></span><br><span class=\"line\"><span class=\"comment\">        // 请求id</span></span><br><span class=\"line\"><span class=\"comment\">        Long userId=null;</span></span><br><span class=\"line\"><span class=\"comment\">        if (user!=null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">            userId=user.getUserInfo().getUserId();</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        logger.info(&quot;URL : &#123;&#125;, 登录id: &#123;&#125; ,HTTP Method: &#123;&#125;,ip :&#123;&#125;,Request Args : &#123;&#125;&quot;, request.getRequestURL().toString(),userId, request.getMethod(),request.getRemoteAddr());</span></span><br><span class=\"line\"><span class=\"comment\">*/</span>    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在切点之后织入</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@After(&quot;webLog()&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doAfter</span><span class=\"params\">(JoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 环绕</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> joinPoint</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Throwable</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;webLog()&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">doAround</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">        Object result = joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"comment\">// 打印出参</span></span><br><span class=\"line\"><span class=\"comment\">//        logger.info(&quot;Response Args  : &#123;&#125;,&quot;, JSONObject.toJSONString(result),new Date());</span></span><br><span class=\"line\">        <span class=\"comment\">// 执行耗时</span></span><br><span class=\"line\">        <span class=\"comment\">// 开始打印请求日志</span></span><br><span class=\"line\">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">        HttpServletRequest request = attributes.getRequest();</span><br><span class=\"line\">        HttpServletResponse response = attributes.getResponse();</span><br><span class=\"line\">        String requestURL = request.getRequestURL().toString();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestURL.contains(<span class=\"string\">&quot;/sys/log_info/&quot;</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 打印请求相关参数</span></span><br><span class=\"line\">        <span class=\"comment\">// 打印请求 url</span></span><br><span class=\"line\">        <span class=\"comment\">// 请求id</span></span><br><span class=\"line\">        String userId = UserInfoManager.getUserId();</span><br><span class=\"line\"></span><br><span class=\"line\">        String url = request.getRequestURL().toString();</span><br><span class=\"line\">        String method = request.getMethod();</span><br><span class=\"line\">        String remoteAddr = RequestUtils.getIpAddr(request);</span><br><span class=\"line\">        Object[] args = joinPoint.getArgs();</span><br><span class=\"line\"><span class=\"comment\">//        List&lt;Object&gt; objects=new ArrayList&lt;&gt;();</span></span><br><span class=\"line\">        StringBuilder stringBuilder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;args.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (args[i] <span class=\"keyword\">instanceof</span> Serializable||args[i] <span class=\"keyword\">instanceof</span> Number ||args[i] <span class=\"keyword\">instanceof</span> String)&#123;</span><br><span class=\"line\">                stringBuilder.append( args[i].toString());</span><br><span class=\"line\"><span class=\"comment\">//                objects.add(args[i]);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;&#123;\\&quot;startTime\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;url\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;userId\\&quot;:\\&quot;&#123;&#125;\\&quot; ,\\&quot;httpMethod\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;ip\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;requestArgs\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;status\\&quot;:&#123;&#125;&#125;&quot;</span>,startTime,url,userId,method,remoteAddr,stringBuilder.toString(),response.getStatus());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对于数据库存储，如果我们希望log存在另外一个数据库中不存在项目里的数据库中，并且可以通过持久化框架查询数据库内信息。我们则可以配置多数据源，如果将日志放在同一个数据库中则直接配置appender就行了，很方便。<br>多数据源配置mybatis版：</p>\n<p>其原理是配置多个sessionfactory,然后根据不同的mapperscan来区分不同mapper对应的数据库</p>\n<p>以druid连接池为例</p>\n<p>application.yml</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log:</span><br><span class=\"line\">  datasource:</span><br><span class=\"line\">    druid:</span><br><span class=\"line\">      url: $&#123;mysql_url&#125;/log?useUnicode=<span class=\"keyword\">true</span>&amp;characterEncoding=UTF-<span class=\"number\">8</span>&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=<span class=\"keyword\">false</span>&amp;allowMultiQueries=<span class=\"keyword\">true</span>&amp;serverTimezone=GMT%2B8&amp;nullCatalogMeansCurrent=<span class=\"keyword\">true</span></span><br><span class=\"line\">      username:</span><br><span class=\"line\">      password:</span><br><span class=\"line\">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">      connectionProperties: druid.stat.mergeSql=<span class=\"keyword\">true</span>;druid.stat.slowSqlMillis=<span class=\"number\">5000</span></span><br><span class=\"line\">      filters: stat,wall</span><br><span class=\"line\">      initialSize: <span class=\"number\">5</span></span><br><span class=\"line\">      maxActive: <span class=\"number\">20</span></span><br><span class=\"line\">      maxPoolPreparedStatementPerConnectionSize: <span class=\"number\">20</span></span><br><span class=\"line\">      maxWait: <span class=\"number\">60000</span></span><br><span class=\"line\">      minIdle: <span class=\"number\">5</span></span><br><span class=\"line\">      poolPreparedStatements: <span class=\"keyword\">true</span></span><br><span class=\"line\">      testOnBorrow: <span class=\"keyword\">false</span></span><br><span class=\"line\">      testOnReturn: <span class=\"keyword\">false</span></span><br><span class=\"line\">      testWhileIdle: <span class=\"keyword\">true</span></span><br><span class=\"line\">      timeBetweenEvictionRunsMillis: <span class=\"number\">60000</span></span><br><span class=\"line\">      validationQuery: SELECT <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">spring:</span><br><span class=\"line\">  datasource:</span><br><span class=\"line\">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class=\"line\">    druid:</span><br><span class=\"line\">      url: $&#123;mysql_url&#125;/hiram_erp?useUnicode=<span class=\"keyword\">true</span>&amp;characterEncoding=UTF-<span class=\"number\">8</span>&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=<span class=\"keyword\">false</span>&amp;allowMultiQueries=<span class=\"keyword\">true</span>&amp;serverTimezone=GMT%2B8&amp;nullCatalogMeansCurrent=<span class=\"keyword\">true</span></span><br><span class=\"line\">      username:</span><br><span class=\"line\">      password:</span><br><span class=\"line\">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">      connectionProperties: druid.stat.mergeSql=<span class=\"keyword\">true</span>;druid.stat.slowSqlMillis=<span class=\"number\">5000</span></span><br><span class=\"line\">      filters: stat,wall</span><br><span class=\"line\">      initialSize: <span class=\"number\">5</span></span><br><span class=\"line\">      maxActive: <span class=\"number\">20</span></span><br><span class=\"line\">      maxPoolPreparedStatementPerConnectionSize: <span class=\"number\">20</span></span><br><span class=\"line\">      maxWait: <span class=\"number\">60000</span></span><br><span class=\"line\">      minIdle: <span class=\"number\">5</span></span><br><span class=\"line\">      poolPreparedStatements: <span class=\"keyword\">true</span></span><br><span class=\"line\">      testOnBorrow: <span class=\"keyword\">false</span></span><br><span class=\"line\">      testOnReturn: <span class=\"keyword\">false</span></span><br><span class=\"line\">      testWhileIdle: <span class=\"keyword\">true</span></span><br><span class=\"line\">      timeBetweenEvictionRunsMillis: <span class=\"number\">60000</span></span><br><span class=\"line\">      validationQuery: SELECT <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"comment\">// 主数据库配置 指定mapper位置</span></span><br><span class=\"line\"><span class=\"meta\">@MapperScan(basePackages = &#123;&quot;com.muggle.poseidon.mapper&quot;&#125;, sqlSessionTemplateRef = &quot;sqlSessionTemplate&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ManySourceDBConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class=\"line\">    <span class=\"comment\">// 读取application的配置信息</span></span><br><span class=\"line\">   <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.datasource.druid&quot;)</span></span><br><span class=\"line\">   <span class=\"comment\">// 最高优先级，表示系统默认使用该配置</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        DruidDataSource druidDataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">        List filterList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        filterList.add(wallFilter());</span><br><span class=\"line\"></span><br><span class=\"line\">        druidDataSource.setProxyFilters(filterList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> druidDataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;sqlSessionFactory&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">sqlSessionFactory</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class=\"keyword\">new</span> SqlSessionFactoryBean();</span><br><span class=\"line\">        sqlSessionFactoryBean.setDataSource(<span class=\"keyword\">this</span>.dataSource());</span><br><span class=\"line\"></span><br><span class=\"line\">        Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;localCacheScope&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;lazyLoadingEnabled&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;aggressiveLazyLoading&quot;</span>, <span class=\"string\">&quot;false&quot;</span>);</span><br><span class=\"line\">        props.setProperty(<span class=\"string\">&quot;jdbcTypeForNull&quot;</span>, <span class=\"string\">&quot;NULL&quot;</span>);</span><br><span class=\"line\">        sqlSessionFactoryBean.setConfigurationProperties(props);</span><br><span class=\"line\">        sqlSessionFactoryBean.setVfs(SpringBootVFS.class);</span><br><span class=\"line\">        <span class=\"comment\">//pageHelper</span></span><br><span class=\"line\">        Properties properties = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">        properties.setProperty(<span class=\"string\">&quot;reasonable&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">        properties.setProperty(<span class=\"string\">&quot;supportMethodsArguments&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">        properties.setProperty(<span class=\"string\">&quot;params&quot;</span>, <span class=\"string\">&quot;count=countSql&quot;</span>);</span><br><span class=\"line\">        properties.setProperty(<span class=\"string\">&quot;pageSizeZero&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">        PageInterceptor interceptor = <span class=\"keyword\">new</span> PageInterceptor();</span><br><span class=\"line\">        interceptor.setProperties(properties);</span><br><span class=\"line\">        sqlSessionFactoryBean.setPlugins(<span class=\"keyword\">new</span> Interceptor[]&#123;interceptor&#125;);</span><br><span class=\"line\">        sqlSessionFactoryBean.setTypeAliasesPackage(<span class=\"string\">&quot;com.muggle.poseidon.model&quot;</span>);</span><br><span class=\"line\">        PathMatchingResourcePatternResolver resolver = <span class=\"keyword\">new</span> PathMatchingResourcePatternResolver();</span><br><span class=\"line\">        sqlSessionFactoryBean.setMapperLocations(resolver.getResources(<span class=\"string\">&quot;classpath*:/mapper/*.xml&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sqlSessionFactoryBean.getObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;transactionManager&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PlatformTransactionManager <span class=\"title\">transactionManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DataSourceTransactionManager(<span class=\"keyword\">this</span>.dataSource());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;sqlSessionTemplate&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionTemplate <span class=\"title\">testSqlSessionTemplate</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;sqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServletRegistrationBean <span class=\"title\">statViewServlet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ServletRegistrationBean druid = <span class=\"keyword\">new</span> ServletRegistrationBean();</span><br><span class=\"line\">        druid.setServlet(<span class=\"keyword\">new</span> StatViewServlet());</span><br><span class=\"line\">        druid.setUrlMappings(Collections.singletonList(<span class=\"string\">&quot;/druid/*&quot;</span>));</span><br><span class=\"line\">        Map&lt;String, String&gt; params = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;loginUsername&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;loginPassword&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        druid.setInitParameters(params);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> druid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">webStatFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean fitler = <span class=\"keyword\">new</span> FilterRegistrationBean();</span><br><span class=\"line\">        fitler.setFilter(<span class=\"keyword\">new</span> WebStatFilter());</span><br><span class=\"line\">        fitler.setUrlPatterns(Collections.singletonList(<span class=\"string\">&quot;/*&quot;</span>));</span><br><span class=\"line\">        fitler.addInitParameter(<span class=\"string\">&quot;exclusions&quot;</span>, <span class=\"string\">&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fitler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WallFilter <span class=\"title\">wallFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        WallFilter wallFilter = <span class=\"keyword\">new</span> WallFilter();</span><br><span class=\"line\"></span><br><span class=\"line\">        wallFilter.setConfig(wallConfig());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> wallFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WallConfig <span class=\"title\">wallConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        WallConfig config = <span class=\"keyword\">new</span> WallConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">        config.setMultiStatementAllow(<span class=\"keyword\">true</span>);<span class=\"comment\">//允许一次执行多条语句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        config.setNoneBaseStatementAllow(<span class=\"keyword\">true</span>);<span class=\"comment\">//允许非基本语句的其他语句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> config;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProcessEngineConfiguration <span class=\"title\">processEngineConfiguration</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ProcessEngineConfiguration pec = StandaloneProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();</span><br><span class=\"line\">        pec.setDataSource(dataSource());</span><br><span class=\"line\">        <span class=\"comment\">//如果表不存在，自动创建表</span></span><br><span class=\"line\">        pec.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);</span><br><span class=\"line\">        <span class=\"comment\">//属性asyncExecutorActivate定义为true，工作流引擎在启动时就建立启动async executor线程池</span></span><br><span class=\"line\">        pec.setAsyncExecutorActivate(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pec;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProcessEngine <span class=\"title\">processEngine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> processEngineConfiguration().buildProcessEngine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>log数据库配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@program</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>: muggle</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@create</span>: 2019-02-23</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"comment\">// 注意确保主配置无法扫描到这个包</span></span><br><span class=\"line\"><span class=\"meta\">@MapperScan(basePackages = &quot;com.muggle.poseidon.logmapper&quot;, sqlSessionTemplateRef  = &quot;test1SqlSessionTemplate&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogDBConfig</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;test1DataSource&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;log.datasource.druid&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        DruidDataSource druidDataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">        List filterList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        filterList.add(wallFilter());</span><br><span class=\"line\"></span><br><span class=\"line\">        druidDataSource.setProxyFilters(filterList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> druidDataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;test1SqlSessionFactory&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">testSqlSessionFactory</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;test1DataSource&quot;)</span> DataSource dataSource)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        SqlSessionFactoryBean bean = <span class=\"keyword\">new</span> SqlSessionFactoryBean();</span><br><span class=\"line\">        bean.setDataSource(dataSource);</span><br><span class=\"line\">        bean.setMapperLocations(<span class=\"keyword\">new</span></span><br><span class=\"line\">        <span class=\"comment\">// mapper位置，不要和主配置的mapper放到一起</span></span><br><span class=\"line\">         PathMatchingResourcePatternResolver().getResources(<span class=\"string\">&quot;classpath*:/mapper/log/*.xml&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean.getObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;test1TransactionManager&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSourceTransactionManager <span class=\"title\">testTransactionManager</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;test1DataSource&quot;)</span> DataSource dataSource)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DataSourceTransactionManager(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;test1SqlSessionTemplate&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SqlSessionTemplate <span class=\"title\">testSqlSessionTemplate</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;test1SqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WallFilter <span class=\"title\">wallFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        WallFilter wallFilter = <span class=\"keyword\">new</span> WallFilter();</span><br><span class=\"line\"></span><br><span class=\"line\">        wallFilter.setConfig(wallConfig());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> wallFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WallConfig <span class=\"title\">wallConfig</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        WallConfig config = <span class=\"keyword\">new</span> WallConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">        config.setMultiStatementAllow(<span class=\"keyword\">true</span>);<span class=\"comment\">//允许一次执行多条语句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        config.setNoneBaseStatementAllow(<span class=\"keyword\">true</span>);<span class=\"comment\">//允许非基本语句的其他语句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> config;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>多数据源jpa版</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.muggle.poseidon.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.jdbc.DataSourceBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Primary;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.sql.DataSource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourceConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 扫描spring.datasource.primary开头的配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryDataSourceProperties&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSourceProperties <span class=\"title\">dataSourceProperties</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DataSourceProperties();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取主库数据源对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> properties 注入名为primaryDataSourceProperties的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryDataSource&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;primaryDataSourceProperties&quot;)</span> DataSourceProperties properties)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 该方法仅在需要使用JdbcTemplate对象时选用</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> dataSource 注入名为primaryDataSource的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源JdbcTemplate对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryJdbcTemplate&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JdbcTemplate <span class=\"title\">jdbcTemplate</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource dataSource)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTemplate(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.muggle.poseidon.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Primary;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.orm.jpa.JpaTransactionManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.persistence.EntityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.persistence.EntityManagerFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.sql.DataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"meta\">@EnableJpaRepositories(</span></span><br><span class=\"line\"><span class=\"meta\">        // repository包名</span></span><br><span class=\"line\"><span class=\"meta\">        basePackages = &quot;com.muggle.poseidon.repos&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">        // 实体管理bean名称</span></span><br><span class=\"line\"><span class=\"meta\">        entityManagerFactoryRef = &quot;primaryEntityManagerFactory&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">        // 事务管理bean名称</span></span><br><span class=\"line\"><span class=\"meta\">        transactionManagerRef = &quot;primaryTransactionManager&quot;</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainDataBaseConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 扫描spring.jpa.primary开头的配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> jpa配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryJpaProperties&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.jpa&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JpaProperties <span class=\"title\">jpaProperties</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaProperties();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取主库实体管理工厂对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> primaryDataSource 注入名为primaryDataSource的数据源</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jpaProperties     注入名为primaryJpaProperties的jpa配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> builder           注入EntityManagerFactoryBuilder</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 实体管理工厂对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryEntityManagerFactory&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalContainerEntityManagerFactoryBean <span class=\"title\">entityManagerFactory</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;primaryDataSource&quot;)</span> DataSource primaryDataSource</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            , <span class=\"meta\">@Qualifier(&quot;primaryJpaProperties&quot;)</span> JpaProperties jpaProperties, EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> builder</span><br><span class=\"line\">                <span class=\"comment\">// 设置数据源</span></span><br><span class=\"line\">                .dataSource(primaryDataSource)</span><br><span class=\"line\">                <span class=\"comment\">// 设置jpa配置</span></span><br><span class=\"line\">                .properties(jpaProperties.getProperties())</span><br><span class=\"line\">                <span class=\"comment\">// 设置hibernate配置</span></span><br><span class=\"line\">                .properties(jpaProperties.getHibernateProperties(<span class=\"keyword\">new</span> HibernateSettings()))</span><br><span class=\"line\">                <span class=\"comment\">// 设置实体包名</span></span><br><span class=\"line\">                .packages(<span class=\"string\">&quot;com.muggle.poseidon.model&quot;</span>)</span><br><span class=\"line\">                <span class=\"comment\">// 设置持久化单元名，用于@PersistenceContext注解获取EntityManager时指定数据源</span></span><br><span class=\"line\">                .persistenceUnit(<span class=\"string\">&quot;primaryPersistenceUnit&quot;</span>)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取实体管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> factory 注入名为primaryEntityManagerFactory的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 实体管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryEntityManager&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EntityManager <span class=\"title\">entityManager</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;primaryEntityManagerFactory&quot;)</span> EntityManagerFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> factory.createEntityManager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取主库事务管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> factory 注入名为primaryEntityManagerFactory的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 事务管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;primaryTransactionManager&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PlatformTransactionManager <span class=\"title\">transactionManager</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;primaryEntityManagerFactory&quot;)</span> EntityManagerFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaTransactionManager(factory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">​```java</span><br><span class=\"line\"><span class=\"keyword\">package</span> com.muggle.poseidon.core.config;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.orm.jpa.JpaTransactionManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.persistence.EntityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.persistence.EntityManagerFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.sql.DataSource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"meta\">@EnableJpaRepositories(</span></span><br><span class=\"line\"><span class=\"meta\">        // repository包名</span></span><br><span class=\"line\"><span class=\"meta\">        basePackages = &quot;com.muggle.poseidon.logrep&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">        // 实体管理bean名称</span></span><br><span class=\"line\"><span class=\"meta\">        entityManagerFactoryRef = &quot;secondEntityManagerFactory&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">        // 事务管理bean名称</span></span><br><span class=\"line\"><span class=\"meta\">        transactionManagerRef = &quot;secondTransactionManager&quot;</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogDataBaseConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 扫描spring.jpa.second开头的配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> jpa配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondJpaProperties&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.aa&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JpaProperties <span class=\"title\">jpaProperties</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaProperties();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取从库实体管理工厂对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> secondDataSource 注入名为secondDataSource的数据源</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> jpaProperties    注入名为secondJpaProperties的jpa配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> builder          注入EntityManagerFactoryBuilder</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 实体管理工厂对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondEntityManagerFactory&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalContainerEntityManagerFactoryBean <span class=\"title\">entityManagerFactory</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;secondDataSource&quot;)</span> DataSource secondDataSource</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            , <span class=\"meta\">@Qualifier(&quot;secondJpaProperties&quot;)</span> JpaProperties jpaProperties, EntityManagerFactoryBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> builder</span><br><span class=\"line\">                <span class=\"comment\">// 设置数据源</span></span><br><span class=\"line\">                .dataSource(secondDataSource)</span><br><span class=\"line\">                <span class=\"comment\">// 设置jpa配置</span></span><br><span class=\"line\">                .properties(jpaProperties.getProperties())</span><br><span class=\"line\">                <span class=\"comment\">// 设置hibernate配置</span></span><br><span class=\"line\">                .properties(jpaProperties.getHibernateProperties(<span class=\"keyword\">new</span> HibernateSettings()))</span><br><span class=\"line\">                <span class=\"comment\">// 设置实体包名</span></span><br><span class=\"line\">                .packages(<span class=\"string\">&quot;com.muggle.poseidon.entity&quot;</span>)</span><br><span class=\"line\">                <span class=\"comment\">// 设置持久化单元名，用于@PersistenceContext注解获取EntityManager时指定数据源</span></span><br><span class=\"line\">                .persistenceUnit(<span class=\"string\">&quot;secondPersistenceUnit&quot;</span>)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取实体管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> factory 注入名为secondEntityManagerFactory的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 实体管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondEntityManager&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EntityManager <span class=\"title\">entityManager</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;secondEntityManagerFactory&quot;)</span> EntityManagerFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> factory.createEntityManager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取从库事务管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> factory 注入名为secondEntityManagerFactory的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 事务管理对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondTransactionManager&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PlatformTransactionManager <span class=\"title\">transactionManager</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;secondEntityManagerFactory&quot;)</span> EntityManagerFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaTransactionManager(factory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.muggle.poseidon.core.config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.sql.DataSource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogDataConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 扫描spring.datasource.second开头的配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源配置信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondDataSourceProperties&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.ss&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSourceProperties <span class=\"title\">dataSourceProperties</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DataSourceProperties();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取从库数据源对象</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> properties 注入名为secondDataSourceProperties的beanf</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondDataSource&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dataSource</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;secondDataSourceProperties&quot;)</span> DataSourceProperties properties)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 该方法仅在需要使用JdbcTemplate对象时选用</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> dataSource 注入名为secondDataSource的bean</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 数据源JdbcTemplate对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;secondJdbcTemplate&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JdbcTemplate <span class=\"title\">jdbcTemplate</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;secondDataSource&quot;)</span> DataSource dataSource)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTemplate(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>application.properties</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=<span class=\"number\">8080</span></span><br><span class=\"line\">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class=\"line\">#spring.datasource.url = jdbc:mysql://localhost:3306/test</span><br><span class=\"line\">spring.datasource.driverClassName = com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">spring.datasource.url = jdbc:mysql:<span class=\"comment\">//119.23.75.58:3306/poseidon?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowMultiQueries=true</span></span><br><span class=\"line\">spring.datasource.username =</span><br><span class=\"line\">spring.datasource.password =</span><br><span class=\"line\">spring.datasource.max-active=<span class=\"number\">20</span></span><br><span class=\"line\">spring.datasource.max-idle=<span class=\"number\">8</span></span><br><span class=\"line\">spring.datasource.min-idle=<span class=\"number\">8</span></span><br><span class=\"line\">spring.datasource.initial-size=<span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">spring.jpa.database=mysql</span><br><span class=\"line\">spring.jpa.show-sql = <span class=\"keyword\">true</span></span><br><span class=\"line\">#配置方言</span><br><span class=\"line\">spring.jpa.database-platform=org.hibernate.dialect.MySQL5Dialect</span><br><span class=\"line\"></span><br><span class=\"line\">spring.ss.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class=\"line\">#spring.datasource.url = jdbc:mysql://localhost:3306/test</span><br><span class=\"line\">spring.ss.driverClassName = com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">spring.ss.url = jdbc:mysql:<span class=\"comment\">//zzzzz/log?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowMultiQueries=true</span></span><br><span class=\"line\">spring.ss.username =</span><br><span class=\"line\">spring.ss.password =</span><br><span class=\"line\">spring.ss.max-active=<span class=\"number\">20</span></span><br><span class=\"line\">spring.ss.max-idle=<span class=\"number\">8</span></span><br><span class=\"line\">spring.ss.min-idle=<span class=\"number\">8</span></span><br><span class=\"line\">spring.ss.initial-size=<span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">spring.aa.database=mysql</span><br><span class=\"line\">spring.aa.show-sql = <span class=\"keyword\">true</span></span><br><span class=\"line\">#配置方言</span><br><span class=\"line\">spring.aa.database-platform=org.hibernate.dialect.MySQL5Dialect</span><br></pre></td></tr></table></figure>\n\n<p>以数据库作为输出配置就算完成了，接下来整合elk系统到我们日志系统中：</p>\n<p>先整合logstash</p>\n<p>logstash安装和配置：<br><a href=\"https://www.elastic.co/cn/downloads/logstash\">https://www.elastic.co/cn/downloads/logstash</a> 选择zip包下载</p>\n<p>解压，进入bin目录 创建logstash.conf 并配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input &#123;</span><br><span class=\"line\">    tcp &#123;</span><br><span class=\"line\">    ##host:port就是上面appender中的 destination，这里其实把logstash作为服务，开启9250端口接收logback发出的消息</span><br><span class=\"line\">    host =&gt; &quot;127.0.0.1&quot;</span><br><span class=\"line\">    port =&gt; 9100</span><br><span class=\"line\">    mode =&gt; &quot;server&quot;</span><br><span class=\"line\">    tags =&gt; [&quot;tags&quot;]</span><br><span class=\"line\">    codec =&gt; json_lines</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output &#123;</span><br><span class=\"line\">    stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class=\"line\">    #输出到es</span><br><span class=\"line\">    #elasticsearch &#123; hosts =&gt; &quot;127.0.0.1:9200&quot; &#125;</span><br><span class=\"line\">        #输出到一个文件中</span><br><span class=\"line\">    file &#123;</span><br><span class=\"line\">       path =&gt; &quot;D:\\logs\\test.log&quot;</span><br><span class=\"line\">       codec =&gt; line</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我这里先配置输出到文件，后面再修改,创建文件：D:\\logs\\test.log</p>\n<p>启动：</p>\n<p>打开cmd（不要使用powershell），进入bin:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\exe\\logstash-6.6.1\\logstash-6.6.1\\bin&gt;logstash -f logstash.conf</span><br></pre></td></tr></table></figure>\n<p>然后在我们的项目中进行相应的配置：<br>按这个来：<a href=\"https://github.com/logstash/logstash-logback-encoder\">https://github.com/logstash/logstash-logback-encoder</a></p>\n<p>加入pom并指定logback版本：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 父pom中 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ch.qos.logback.version</span>&gt;</span>1.2.3<span class=\"tag\">&lt;/<span class=\"name\">ch.qos.logback.version</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--  日志模块--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.logstash.logback<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>logstash-logback-encoder<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- Your project must also directly depend on either logback-classic or logback-access.  For example: --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>ch.qos.logback<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>logback-classic<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>配置apppender和logger</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;stash&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">destination</span>&gt;</span>127.0.0.1:9100<span class=\"tag\">&lt;/<span class=\"name\">destination</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">includeCallerData</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">includeCallerData</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">includeCallerData</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">includeCallerData</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;logstash&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;stash&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RestController</span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/public/log&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogTestController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger log = LoggerFactory.getLogger(<span class=\"string\">&quot;logstash&quot;</span>);</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    LoggingEventRepository repository;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;sssssssssssssss&quot;</span>);</span><br><span class=\"line\">        Iterable&lt;LoggingEvent&gt; all = repository.findAll();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;sss&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>访问接口，logstash打印信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[2019-03-09T11:32:56,358][INFO ][logstash.outputs.file    ] Opening file &#123;:path&#x3D;&gt;&quot;D:&#x2F;logs&#x2F;test.log&quot;&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">                  &quot;host&quot; &#x3D;&gt; &quot;www.xmind.net&quot;,</span><br><span class=\"line\">                 &quot;level&quot; &#x3D;&gt; &quot;INFO&quot;,</span><br><span class=\"line\">     &quot;caller_class_name&quot; &#x3D;&gt; &quot;com.muggle.poseidon.controller.LogTestController&quot;,</span><br><span class=\"line\">            &quot;@timestamp&quot; &#x3D;&gt; 2019-03-09T03:33:03.413Z,</span><br><span class=\"line\">           &quot;logger_name&quot; &#x3D;&gt; &quot;logstash&quot;,</span><br><span class=\"line\">              &quot;@version&quot; &#x3D;&gt; &quot;1&quot;,</span><br><span class=\"line\">           &quot;thread_name&quot; &#x3D;&gt; &quot;http-nio-8080-exec-9&quot;,</span><br><span class=\"line\">               &quot;message&quot; &#x3D;&gt; &quot;sssssssssssssss&quot;,</span><br><span class=\"line\">    &quot;caller_line_number&quot; &#x3D;&gt; 22,</span><br><span class=\"line\">                  &quot;port&quot; &#x3D;&gt; 58368,</span><br><span class=\"line\">           &quot;level_value&quot; &#x3D;&gt; 20000,</span><br><span class=\"line\">      &quot;caller_file_name&quot; &#x3D;&gt; &quot;LogTestController.java&quot;,</span><br><span class=\"line\">                  &quot;tags&quot; &#x3D;&gt; [</span><br><span class=\"line\">        [0] &quot;tags&quot;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;caller_method_name&quot; &#x3D;&gt; &quot;test&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>test.log输出了文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-03-09T03:33:03.413Z www.xmind.net sssssssssssssss</span><br></pre></td></tr></table></figure>\n<p>接下来只要把输出路径换成ES就可以了，这属于logstash和es的整合，这里先不讲解；重新回归到我们的请求模块：</p>\n<p>我希望我的模块，对每次请求都能记录下来（请求日志），并将记录存到数据库或者ES，同时我要对所有接口都进行一个幂等性的保障；保障接口的幂等性有多种方法，比较简单的是数据库做唯一索引或者加拦截器，我这里加了一个拦截器来保障接口幂等和拦截前端数据的重复提交(关于接口幂等性在其他文档中介绍)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RequestLockInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    RedisLock redisTool;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> expireTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestLockInterceptor</span><span class=\"params\">(<span class=\"keyword\">int</span> expireTime, RedislockImpl redisTool)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.expireTime = expireTime;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.redisTool = redisTool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">&quot;post&quot;</span>.equalsIgnoreCase(request.getMethod()))&#123;</span><br><span class=\"line\">            String token = request.getParameter(<span class=\"string\">&quot;request_key&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (token==<span class=\"keyword\">null</span>||<span class=\"string\">&quot;&quot;</span>.equals(token))&#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;请求非法&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//            throw new PoseidonException(&quot;请求太频繁&quot;,PoseidonProperties.TOO_NUMBER_REQUEST);</span></span><br><span class=\"line\">                response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">                PrintWriter writer = response.getWriter();</span><br><span class=\"line\">                writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;5001\\&quot;,\\&quot;msg\\&quot;:\\&quot;请求非法\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">                writer.close();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String ipAddr = RequestUtils.getIpAddr(request);</span><br><span class=\"line\">            String lockKey = request.getRequestURI() + <span class=\"string\">&quot;_&quot;</span>  + <span class=\"string\">&quot;_&quot;</span> + token;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> lock = redisTool.lock(lockKey, ipAddr, expireTime);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!lock) &#123;<span class=\"comment\">//</span></span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;拦截表单重复提交&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//            throw new PoseidonException(&quot;请求太频繁&quot;,PoseidonProperties.TOO_NUMBER_REQUEST);</span></span><br><span class=\"line\">                response.setContentType(<span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class=\"line\">                PrintWriter writer = response.getWriter();</span><br><span class=\"line\">                writer.write(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:\\&quot;5001\\&quot;,\\&quot;msg\\&quot;:\\&quot;请求太频繁\\&quot;&#125;&quot;</span>);</span><br><span class=\"line\">                writer.close();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        String requestURI = request.getRequestURI();</span></span><br><span class=\"line\"><span class=\"comment\">//        String lockKey = request.getRequestURI() + &quot;_&quot; + RequestUtils.getIpAddr(request);</span></span><br><span class=\"line\"><span class=\"comment\">//        redisTool.unlock(lockKey,getIpAddr(request));</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>项目使用了redis锁（redis锁原理和使用在其他文档中介绍）</p>\n<p>对于系统异常，如果是业务的异常，正常处理，如果是系统发生的异常比如空指针，数据库异常等我希望系统能马上通知，以便排查问题，所以我配置邮件异常通知(关于springboot邮件配置其他文档介绍)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestControllerAdvice</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RestExceptionHandlerController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    EmailService emailService;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;admin.email&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String adminEmail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(value = &#123;PoseidonException.class&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultBean <span class=\"title\">poseidonExceptionHandler</span><span class=\"params\">(PoseidonException e, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResultBean().setMsg(e.getMsg()).setCode(e.getCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(value = &#123;MethodArgumentNotValidException.class&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultBean <span class=\"title\">MethodArgumentNotValidException</span><span class=\"params\">(MethodArgumentNotValidException e, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(e.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResultBean().setMsg(<span class=\"string\">&quot;数据未通过校验&quot;</span>).setCode(PoseidonProperties.COMMIT_DATA_ERROR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(value = &#123;Exception.class&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultBean <span class=\"title\">exceptionHandler</span><span class=\"params\">(Exception e, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">        log.error(<span class=\"string\">&quot;系统异常：&quot;</span> + req.getMethod() + req.getRequestURI(), e);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">            EmailBean emailBean = <span class=\"keyword\">new</span> EmailBean();</span><br><span class=\"line\">            emailBean.setRecipient(adminEmail);</span><br><span class=\"line\">            emailBean.setSubject(<span class=\"string\">&quot;poseidon---系统异常&quot;</span>);</span><br><span class=\"line\">            emailBean.setContent(<span class=\"string\">&quot;系统异常：&quot;</span> + req.getMethod() + req.getRequestURI()+<span class=\"string\">&quot;----&quot;</span>+e.getMessage());</span><br><span class=\"line\"><span class=\"comment\">//            改良</span></span><br><span class=\"line\">            emailService.sendSimpleMail(emailBean);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResultBean().setMsg(<span class=\"string\">&quot;系统异常，请联系管理员&quot;</span>).setCode(<span class=\"string\">&quot;500&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(value = &#123;HttpRequestMethodNotSupportedException.class&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultBean <span class=\"title\">notsupported</span><span class=\"params\">(Exception e, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResultBean().setMsg(<span class=\"string\">&quot;不支持的请求方式&quot;</span>).setCode(PoseidonProperties.NOT_SUPPORT_METHOD);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(value = &#123;NoHandlerFoundException.class&#125;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultBean <span class=\"title\">notFoundUrl</span><span class=\"params\">(Exception e, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResultBean().setMsg(<span class=\"string\">&quot;请求路径不存在&quot;</span>).setCode(<span class=\"string\">&quot;404&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>项目架构信得<br>common 和core模块存在的意义</p>"},{"title":"kafka事务","date":"2021-01-31T03:31:50.000Z","_content":"\n\nkafka 的事务是从0.11 版本开始支持的，kafka 的事务是基于 Exactly Once 语义的，它能保证生产或消费消息在跨分区和会话的情况下要么全部成功要么全部失败\n\n### 生产者事务\n\n当生产者投递一条事务性的消息时，会先获取一个 transactionID ，并将Producer 获得的PID 和 transactionID 绑定，当 Producer 重启，Producer\n会根据当前事务的 transactionID 获取对应的PID。\nkafka 管理事务是通过其组件 Transaction Coordinator 来实现的，这个组件管理每个事务的状态，Producer 可以通过transactionID 从这个组件中获得\n对应事务的状态，该组件还会将事务状态持久化到kafka一个内部的 Topic 中。\n生产者事务的场景：\n一批消息写入 a、b、c 三个分区，如果 ab写入成功而c失败，那么kafka就会根据事务的状态对消息进行回滚，将ab写入的消息剔除掉并通知 Producer 投递消息失败。\n\n### 消费者事务\n\n消费者事务的一致性比较弱，只能够保证消费者消费消息是精准一次的（有且只有一次）。消费者有一个参数 islation.level，这个参数指定的是事务的隔离级别。\n它的默认值是 read_uncommitted（未提交读），意思是消费者可以消费未commit的消息。当参数设置为 read_committed，则消费者不能消费到未commit的消息。\n\n### 事务的使用场景\n\nkafka事务主要是为了保证数据的一致性，现列举如下几个场景供读者参考：\n\n- producer发的多条消息组成一个事务，这些消息需要对consumer同时可见或者同时不可见；\n- producer可能会给多个topic发送消息，需要保证消息要么全部发送成功要么全部发送失败（操作的原子性）；\n- 消费者 消费一个topic，然后做处理再发到另一个topic，这个消费和转发的动作应该在同一事物中；\n- 如果下游消费者只有等上游消息事务提交以后才能读到，当吞吐量大的时候就会有问题，因此有了 read committed和read uncommitted两种事务隔离级别","source":"_posts/kafka事务.md","raw":"---\ntitle: kafka事务\ndate: 2021-01-31 11:31:50\ntags: 中间件\n---\n\n\nkafka 的事务是从0.11 版本开始支持的，kafka 的事务是基于 Exactly Once 语义的，它能保证生产或消费消息在跨分区和会话的情况下要么全部成功要么全部失败\n\n### 生产者事务\n\n当生产者投递一条事务性的消息时，会先获取一个 transactionID ，并将Producer 获得的PID 和 transactionID 绑定，当 Producer 重启，Producer\n会根据当前事务的 transactionID 获取对应的PID。\nkafka 管理事务是通过其组件 Transaction Coordinator 来实现的，这个组件管理每个事务的状态，Producer 可以通过transactionID 从这个组件中获得\n对应事务的状态，该组件还会将事务状态持久化到kafka一个内部的 Topic 中。\n生产者事务的场景：\n一批消息写入 a、b、c 三个分区，如果 ab写入成功而c失败，那么kafka就会根据事务的状态对消息进行回滚，将ab写入的消息剔除掉并通知 Producer 投递消息失败。\n\n### 消费者事务\n\n消费者事务的一致性比较弱，只能够保证消费者消费消息是精准一次的（有且只有一次）。消费者有一个参数 islation.level，这个参数指定的是事务的隔离级别。\n它的默认值是 read_uncommitted（未提交读），意思是消费者可以消费未commit的消息。当参数设置为 read_committed，则消费者不能消费到未commit的消息。\n\n### 事务的使用场景\n\nkafka事务主要是为了保证数据的一致性，现列举如下几个场景供读者参考：\n\n- producer发的多条消息组成一个事务，这些消息需要对consumer同时可见或者同时不可见；\n- producer可能会给多个topic发送消息，需要保证消息要么全部发送成功要么全部发送失败（操作的原子性）；\n- 消费者 消费一个topic，然后做处理再发到另一个topic，这个消费和转发的动作应该在同一事物中；\n- 如果下游消费者只有等上游消息事务提交以后才能读到，当吞吐量大的时候就会有问题，因此有了 read committed和read uncommitted两种事务隔离级别","slug":"kafka事务","published":1,"updated":"2021-03-23T02:12:29.054Z","_id":"ckkkluq9i000069oe8yqiaioz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>kafka 的事务是从0.11 版本开始支持的，kafka 的事务是基于 Exactly Once 语义的，它能保证生产或消费消息在跨分区和会话的情况下要么全部成功要么全部失败</p>\n<h3 id=\"生产者事务\"><a href=\"#生产者事务\" class=\"headerlink\" title=\"生产者事务\"></a>生产者事务</h3><p>当生产者投递一条事务性的消息时，会先获取一个 transactionID ，并将Producer 获得的PID 和 transactionID 绑定，当 Producer 重启，Producer<br>会根据当前事务的 transactionID 获取对应的PID。<br>kafka 管理事务是通过其组件 Transaction Coordinator 来实现的，这个组件管理每个事务的状态，Producer 可以通过transactionID 从这个组件中获得<br>对应事务的状态，该组件还会将事务状态持久化到kafka一个内部的 Topic 中。<br>生产者事务的场景：<br>一批消息写入 a、b、c 三个分区，如果 ab写入成功而c失败，那么kafka就会根据事务的状态对消息进行回滚，将ab写入的消息剔除掉并通知 Producer 投递消息失败。</p>\n<h3 id=\"消费者事务\"><a href=\"#消费者事务\" class=\"headerlink\" title=\"消费者事务\"></a>消费者事务</h3><p>消费者事务的一致性比较弱，只能够保证消费者消费消息是精准一次的（有且只有一次）。消费者有一个参数 islation.level，这个参数指定的是事务的隔离级别。<br>它的默认值是 read_uncommitted（未提交读），意思是消费者可以消费未commit的消息。当参数设置为 read_committed，则消费者不能消费到未commit的消息。</p>\n<h3 id=\"事务的使用场景\"><a href=\"#事务的使用场景\" class=\"headerlink\" title=\"事务的使用场景\"></a>事务的使用场景</h3><p>kafka事务主要是为了保证数据的一致性，现列举如下几个场景供读者参考：</p>\n<ul>\n<li>producer发的多条消息组成一个事务，这些消息需要对consumer同时可见或者同时不可见；</li>\n<li>producer可能会给多个topic发送消息，需要保证消息要么全部发送成功要么全部发送失败（操作的原子性）；</li>\n<li>消费者 消费一个topic，然后做处理再发到另一个topic，这个消费和转发的动作应该在同一事物中；</li>\n<li>如果下游消费者只有等上游消息事务提交以后才能读到，当吞吐量大的时候就会有问题，因此有了 read committed和read uncommitted两种事务隔离级别</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>kafka 的事务是从0.11 版本开始支持的，kafka 的事务是基于 Exactly Once 语义的，它能保证生产或消费消息在跨分区和会话的情况下要么全部成功要么全部失败</p>\n<h3 id=\"生产者事务\"><a href=\"#生产者事务\" class=\"headerlink\" title=\"生产者事务\"></a>生产者事务</h3><p>当生产者投递一条事务性的消息时，会先获取一个 transactionID ，并将Producer 获得的PID 和 transactionID 绑定，当 Producer 重启，Producer<br>会根据当前事务的 transactionID 获取对应的PID。<br>kafka 管理事务是通过其组件 Transaction Coordinator 来实现的，这个组件管理每个事务的状态，Producer 可以通过transactionID 从这个组件中获得<br>对应事务的状态，该组件还会将事务状态持久化到kafka一个内部的 Topic 中。<br>生产者事务的场景：<br>一批消息写入 a、b、c 三个分区，如果 ab写入成功而c失败，那么kafka就会根据事务的状态对消息进行回滚，将ab写入的消息剔除掉并通知 Producer 投递消息失败。</p>\n<h3 id=\"消费者事务\"><a href=\"#消费者事务\" class=\"headerlink\" title=\"消费者事务\"></a>消费者事务</h3><p>消费者事务的一致性比较弱，只能够保证消费者消费消息是精准一次的（有且只有一次）。消费者有一个参数 islation.level，这个参数指定的是事务的隔离级别。<br>它的默认值是 read_uncommitted（未提交读），意思是消费者可以消费未commit的消息。当参数设置为 read_committed，则消费者不能消费到未commit的消息。</p>\n<h3 id=\"事务的使用场景\"><a href=\"#事务的使用场景\" class=\"headerlink\" title=\"事务的使用场景\"></a>事务的使用场景</h3><p>kafka事务主要是为了保证数据的一致性，现列举如下几个场景供读者参考：</p>\n<ul>\n<li>producer发的多条消息组成一个事务，这些消息需要对consumer同时可见或者同时不可见；</li>\n<li>producer可能会给多个topic发送消息，需要保证消息要么全部发送成功要么全部发送失败（操作的原子性）；</li>\n<li>消费者 消费一个topic，然后做处理再发到另一个topic，这个消费和转发的动作应该在同一事物中；</li>\n<li>如果下游消费者只有等上游消息事务提交以后才能读到，当吞吐量大的时候就会有问题，因此有了 read committed和read uncommitted两种事务隔离级别</li>\n</ul>\n"},{"title":"开发小计","date":"2021-02-06T09:47:50.000Z","_content":"\n## 接手项目的一次采坑\n\n#### `springboot` 有读取外部配置文件的方法，如下优先级：\n\n- 第一种是在jar包的同一目录下建一个config文件夹，然后把配置文件放到这个文件夹下。\n- 第二种是直接把配置文件放到jar包的同级目录。\n- 第三种在classpath下建一个config文件夹，然后把配置文件放进去。\n- 第四种是在classpath下直接放配置文件。\n\n<!--more-->\n\nmyisam 将整数型索引设置可为null的索引时会被变成可变索引\n\n1、方式一\njava -jar x.jar a b c  通过main(String[] args ) ,传入到args\n\n2、方式二 \njava -jar x.jar -Da=111 -Db=222 -Dc=3333 通过  System.getProperty(\"a\"); 方式获取。作为环境变量\n\n3、方式三 \njava -jar x.jar --a=111 --b=2222 是springboot支持的写法，可以通过@Value(\"${a}\"） 获取\n\n\n\nmaven dockerfile 打包\n\n```\nmvn package org.springframework.boot:spring-boot-maven-plugin:2.3.5.RELEASE:build-info dockerfile:build\n```\n\n指定settings\n\n```\n\nmvn install --settings /xxx/settings.xml\n```\n\n安装本地jar \n\nmvn install:install-file -DgroupId=com.baidu -DartifactId=ueditor -Dversion=1.0.0 -Dpackaging=jar -Dfile=ueditor-1.1.2.jar\n\n```shell\n-Dfile=/Users/lcc/IdeaProjects/dubhe-node/dubhe-node-provider/lib/ring/release/tdh-5.2/hadoop-annotations-2.7.2-transwarp-5.2.0.jar   \n-DgroupId=org.apache.hadoop  \n-DartifactId=hadoop-annotations \n-Dversion=hadoop-2.7.2-transwarp-5.2.0-SNAPSHOT \n-Durl=http://xxxx/repository/maven-snapshots/ \n-Dpackaging=jar \n-DrepositoryId=snapshots\n```\n\nmaven 推包到远程\n\n```\nmvn -s \"D:\\data\\maven\\settings.xml\" deploy:deploy-file -Dfile=libs/xxx.jar -DgroupId=com.qcloud -DartifactId=xxx -Dversion=1.1.1.Alpha -Dpackaging=jar -Durl=https://mirrors.cloud.xxx/maven-public/ -DrepositoryId=aaa\n```\n\ndocker\n\n当 dockerfile-maven-plugin 插件版本冲突的时候 会报一个莫名其妙的异常：\n\n```\nno String-argument constructor/factory method to deserialize from String value ('xxx')\n[ERROR]  at [Source: N/A; line: -1, column: -1] (through reference chain: java.util.LinkedHashMap[\"xxx\"])\n\n```\n\nDOCKER_HOST:\n\n```\ntcp://127.0.0.1:2375\n```\n\n设置之后报错：\n\n```\nNo connection could be made because the target machine actively refused it.\n```\n\n原因：需要给2375端口加上守护进程\n\n勾选 expose daemon on tcp://.......tls\n\n nohup java -jar xxxx.jar >/dev/null 2>&1&\n\n","source":"_posts/开发小计.md","raw":"---\ntitle: 开发小计\ndate: 2021-02-06 17:47:50\ntags: javaee\n---\n\n## 接手项目的一次采坑\n\n#### `springboot` 有读取外部配置文件的方法，如下优先级：\n\n- 第一种是在jar包的同一目录下建一个config文件夹，然后把配置文件放到这个文件夹下。\n- 第二种是直接把配置文件放到jar包的同级目录。\n- 第三种在classpath下建一个config文件夹，然后把配置文件放进去。\n- 第四种是在classpath下直接放配置文件。\n\n<!--more-->\n\nmyisam 将整数型索引设置可为null的索引时会被变成可变索引\n\n1、方式一\njava -jar x.jar a b c  通过main(String[] args ) ,传入到args\n\n2、方式二 \njava -jar x.jar -Da=111 -Db=222 -Dc=3333 通过  System.getProperty(\"a\"); 方式获取。作为环境变量\n\n3、方式三 \njava -jar x.jar --a=111 --b=2222 是springboot支持的写法，可以通过@Value(\"${a}\"） 获取\n\n\n\nmaven dockerfile 打包\n\n```\nmvn package org.springframework.boot:spring-boot-maven-plugin:2.3.5.RELEASE:build-info dockerfile:build\n```\n\n指定settings\n\n```\n\nmvn install --settings /xxx/settings.xml\n```\n\n安装本地jar \n\nmvn install:install-file -DgroupId=com.baidu -DartifactId=ueditor -Dversion=1.0.0 -Dpackaging=jar -Dfile=ueditor-1.1.2.jar\n\n```shell\n-Dfile=/Users/lcc/IdeaProjects/dubhe-node/dubhe-node-provider/lib/ring/release/tdh-5.2/hadoop-annotations-2.7.2-transwarp-5.2.0.jar   \n-DgroupId=org.apache.hadoop  \n-DartifactId=hadoop-annotations \n-Dversion=hadoop-2.7.2-transwarp-5.2.0-SNAPSHOT \n-Durl=http://xxxx/repository/maven-snapshots/ \n-Dpackaging=jar \n-DrepositoryId=snapshots\n```\n\nmaven 推包到远程\n\n```\nmvn -s \"D:\\data\\maven\\settings.xml\" deploy:deploy-file -Dfile=libs/xxx.jar -DgroupId=com.qcloud -DartifactId=xxx -Dversion=1.1.1.Alpha -Dpackaging=jar -Durl=https://mirrors.cloud.xxx/maven-public/ -DrepositoryId=aaa\n```\n\ndocker\n\n当 dockerfile-maven-plugin 插件版本冲突的时候 会报一个莫名其妙的异常：\n\n```\nno String-argument constructor/factory method to deserialize from String value ('xxx')\n[ERROR]  at [Source: N/A; line: -1, column: -1] (through reference chain: java.util.LinkedHashMap[\"xxx\"])\n\n```\n\nDOCKER_HOST:\n\n```\ntcp://127.0.0.1:2375\n```\n\n设置之后报错：\n\n```\nNo connection could be made because the target machine actively refused it.\n```\n\n原因：需要给2375端口加上守护进程\n\n勾选 expose daemon on tcp://.......tls\n\n nohup java -jar xxxx.jar >/dev/null 2>&1&\n\n","slug":"开发小计","published":1,"updated":"2021-02-22T02:42:58.349Z","_id":"ckktjgrav0000xcqk5lt5fgmk","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"接手项目的一次采坑\"><a href=\"#接手项目的一次采坑\" class=\"headerlink\" title=\"接手项目的一次采坑\"></a>接手项目的一次采坑</h2><h4 id=\"springboot-有读取外部配置文件的方法，如下优先级：\"><a href=\"#springboot-有读取外部配置文件的方法，如下优先级：\" class=\"headerlink\" title=\"springboot 有读取外部配置文件的方法，如下优先级：\"></a><code>springboot</code> 有读取外部配置文件的方法，如下优先级：</h4><ul>\n<li>第一种是在jar包的同一目录下建一个config文件夹，然后把配置文件放到这个文件夹下。</li>\n<li>第二种是直接把配置文件放到jar包的同级目录。</li>\n<li>第三种在classpath下建一个config文件夹，然后把配置文件放进去。</li>\n<li>第四种是在classpath下直接放配置文件。</li>\n</ul>\n<a id=\"more\"></a>\n\n<p>myisam 将整数型索引设置可为null的索引时会被变成可变索引</p>\n<p>1、方式一<br>java -jar x.jar a b c  通过main(String[] args ) ,传入到args</p>\n<p>2、方式二<br>java -jar x.jar -Da=111 -Db=222 -Dc=3333 通过  System.getProperty(“a”); 方式获取。作为环境变量</p>\n<p>3、方式三<br>java -jar x.jar –a=111 –b=2222 是springboot支持的写法，可以通过@Value(“${a}”） 获取</p>\n<p>maven dockerfile 打包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn package org.springframework.boot:spring-boot-maven-plugin:2.3.5.RELEASE:build-info dockerfile:build</span><br></pre></td></tr></table></figure>\n<p>指定settings</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mvn install --settings &#x2F;xxx&#x2F;settings.xml</span><br></pre></td></tr></table></figure>\n<p>安装本地jar </p>\n<p>mvn install:install-file -DgroupId=com.baidu -DartifactId=ueditor -Dversion=1.0.0 -Dpackaging=jar -Dfile=ueditor-1.1.2.jar</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dfile=/Users/lcc/IdeaProjects/dubhe-node/dubhe-node-provider/lib/ring/release/tdh-5.2/hadoop-annotations-2.7.2-transwarp-5.2.0.jar   </span><br><span class=\"line\">-DgroupId=org.apache.hadoop  </span><br><span class=\"line\">-DartifactId=hadoop-annotations </span><br><span class=\"line\">-Dversion=hadoop-2.7.2-transwarp-5.2.0-SNAPSHOT </span><br><span class=\"line\">-Durl=http://xxxx/repository/maven-snapshots/ </span><br><span class=\"line\">-Dpackaging=jar </span><br><span class=\"line\">-DrepositoryId=snapshots</span><br></pre></td></tr></table></figure>\n<p>maven 推包到远程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn -s &quot;D:\\data\\maven\\settings.xml&quot; deploy:deploy-file -Dfile&#x3D;libs&#x2F;xxx.jar -DgroupId&#x3D;com.qcloud -DartifactId&#x3D;xxx -Dversion&#x3D;1.1.1.Alpha -Dpackaging&#x3D;jar -Durl&#x3D;https:&#x2F;&#x2F;mirrors.cloud.xxx&#x2F;maven-public&#x2F; -DrepositoryId&#x3D;aaa</span><br></pre></td></tr></table></figure>\n<p>docker</p>\n<p>当 dockerfile-maven-plugin 插件版本冲突的时候 会报一个莫名其妙的异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">no String-argument constructor&#x2F;factory method to deserialize from String value (&#39;xxx&#39;)</span><br><span class=\"line\">[ERROR]  at [Source: N&#x2F;A; line: -1, column: -1] (through reference chain: java.util.LinkedHashMap[&quot;xxx&quot;])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>DOCKER_HOST:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcp:&#x2F;&#x2F;127.0.0.1:2375</span><br></pre></td></tr></table></figure>\n<p>设置之后报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No connection could be made because the target machine actively refused it.</span><br></pre></td></tr></table></figure>\n<p>原因：需要给2375端口加上守护进程</p>\n<p>勾选 expose daemon on tcp://…….tls</p>\n<p> nohup java -jar xxxx.jar &gt;/dev/null 2&gt;&amp;1&amp;</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"接手项目的一次采坑\"><a href=\"#接手项目的一次采坑\" class=\"headerlink\" title=\"接手项目的一次采坑\"></a>接手项目的一次采坑</h2><h4 id=\"springboot-有读取外部配置文件的方法，如下优先级：\"><a href=\"#springboot-有读取外部配置文件的方法，如下优先级：\" class=\"headerlink\" title=\"springboot 有读取外部配置文件的方法，如下优先级：\"></a><code>springboot</code> 有读取外部配置文件的方法，如下优先级：</h4><ul>\n<li>第一种是在jar包的同一目录下建一个config文件夹，然后把配置文件放到这个文件夹下。</li>\n<li>第二种是直接把配置文件放到jar包的同级目录。</li>\n<li>第三种在classpath下建一个config文件夹，然后把配置文件放进去。</li>\n<li>第四种是在classpath下直接放配置文件。</li>\n</ul>","more":"<p>myisam 将整数型索引设置可为null的索引时会被变成可变索引</p>\n<p>1、方式一<br>java -jar x.jar a b c  通过main(String[] args ) ,传入到args</p>\n<p>2、方式二<br>java -jar x.jar -Da=111 -Db=222 -Dc=3333 通过  System.getProperty(“a”); 方式获取。作为环境变量</p>\n<p>3、方式三<br>java -jar x.jar –a=111 –b=2222 是springboot支持的写法，可以通过@Value(“${a}”） 获取</p>\n<p>maven dockerfile 打包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn package org.springframework.boot:spring-boot-maven-plugin:2.3.5.RELEASE:build-info dockerfile:build</span><br></pre></td></tr></table></figure>\n<p>指定settings</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mvn install --settings &#x2F;xxx&#x2F;settings.xml</span><br></pre></td></tr></table></figure>\n<p>安装本地jar </p>\n<p>mvn install:install-file -DgroupId=com.baidu -DartifactId=ueditor -Dversion=1.0.0 -Dpackaging=jar -Dfile=ueditor-1.1.2.jar</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dfile=/Users/lcc/IdeaProjects/dubhe-node/dubhe-node-provider/lib/ring/release/tdh-5.2/hadoop-annotations-2.7.2-transwarp-5.2.0.jar   </span><br><span class=\"line\">-DgroupId=org.apache.hadoop  </span><br><span class=\"line\">-DartifactId=hadoop-annotations </span><br><span class=\"line\">-Dversion=hadoop-2.7.2-transwarp-5.2.0-SNAPSHOT </span><br><span class=\"line\">-Durl=http://xxxx/repository/maven-snapshots/ </span><br><span class=\"line\">-Dpackaging=jar </span><br><span class=\"line\">-DrepositoryId=snapshots</span><br></pre></td></tr></table></figure>\n<p>maven 推包到远程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn -s &quot;D:\\data\\maven\\settings.xml&quot; deploy:deploy-file -Dfile&#x3D;libs&#x2F;xxx.jar -DgroupId&#x3D;com.qcloud -DartifactId&#x3D;xxx -Dversion&#x3D;1.1.1.Alpha -Dpackaging&#x3D;jar -Durl&#x3D;https:&#x2F;&#x2F;mirrors.cloud.xxx&#x2F;maven-public&#x2F; -DrepositoryId&#x3D;aaa</span><br></pre></td></tr></table></figure>\n<p>docker</p>\n<p>当 dockerfile-maven-plugin 插件版本冲突的时候 会报一个莫名其妙的异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">no String-argument constructor&#x2F;factory method to deserialize from String value (&#39;xxx&#39;)</span><br><span class=\"line\">[ERROR]  at [Source: N&#x2F;A; line: -1, column: -1] (through reference chain: java.util.LinkedHashMap[&quot;xxx&quot;])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>DOCKER_HOST:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcp:&#x2F;&#x2F;127.0.0.1:2375</span><br></pre></td></tr></table></figure>\n<p>设置之后报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No connection could be made because the target machine actively refused it.</span><br></pre></td></tr></table></figure>\n<p>原因：需要给2375端口加上守护进程</p>\n<p>勾选 expose daemon on tcp://…….tls</p>\n<p> nohup java -jar xxxx.jar &gt;/dev/null 2&gt;&amp;1&amp;</p>"},{"title":"kafka+spring boot","date":"2021-03-28T02:55:32.000Z","_content":"前文介绍了 kafka 的相关特性和原理，这一节我们将学习怎么在springboot中使用kafka；\n\n首先导入依赖\n\n```xml\n<dependency>\n   <groupId>org.springframework.kafka</groupId>\n   <artifactId>spring-kafka</artifactId>\n</dependency>\n```\n\n<!--more-->\n\n然后启动项添加注解 `@EnableScheduling`，`@EnableKafka` 。第一个注解是用来添加springboot定时任务以方便测试，第二个注解是装配kafka 配置。\n\n接下来我们要在 application 的配置文件：\n\n```properties\n## 生产者配置\nspring.kafka.consumer.bootstrap-servers=localhost:9092\nspring.kafka.consumer.group-id=test-consumer-group\nspring.kafka.consumer.auto-offset-reset=earliest\nspring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer\nspring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer\n\n## 消费者配置\nspring.kafka.producer.bootstrap-servers=localhost:9092\nspring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer\nspring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer\n\n#消费监听接口监听的主题不存在时，默认会报错\nspring.kafka.listener.missing-topics-fatal=false\n\n```\n\n注册一个 `AdminClient` :\n\n```java\n @Bean\n    public AdminClient init( KafkaProperties kafkaProperties){\n        return KafkaAdminClient.create(kafkaProperties.buildAdminProperties());\n    }\n```\n\n这里因为是demo，我就将生产者和消费者写在一个程序里面了。\n\n先测试一个简单的收发消息：\n\n```java\n@RestController\npublic class TestController {\n    @Autowired\n    private KafkaTemplate<String, String> kafkaTemplate;\n    \n\n    @Autowired\n    private   AdminClient adminClient;\n    \n    @Scheduled(cron = \"*/15 * * * * ?\")\n    public void send() {\n        kafkaTemplate.send(\"xxxxx\", \"test\");\n    }\n    \n    @KafkaListener(topics = \"xxxxx\",groupId = \"test-consumer-group\")\n    public void listen(ConsumerRecord<?, String> record) throws ExecutionException, InterruptedException {\n        String value = record.value();\n        System.out.println(value);\n    }\n\n}\n```\n\n这里我调用了`kafkaTemplate.send` 方法发送消息,第一个参数是消息的主题,第二个参数是消息.\n这里我并没有先创建主题,直接往主题里面发消息了,框架会给你直接创建一个默认的主题.\n我们也可以直接创建一个主题:\n\n```java\n @Bean\n    public NewTopic topic() {\n        return new NewTopic(\"topic-test\", 1, (short) 1);\n    }\n```\n当然像 rabbitMQ 的api 那样,spring boot 还非常贴心的准备了 topic 建造者类:\n\n```java\n@Bean\npublic NewTopic topic1() {\n    return TopicBuilder.name(\"thing1\")\n            .partitions(10)\n            .replicas(3)\n            .compact()\n            .build();\n}\n```\n\n还可以通过 AdminClient 创建主题：\n```java\n    @Autowired\n    private   AdminClient adminClient;\n\n    public String createTopic(){\n        Collection<NewTopic> newTopics = new ArrayList<>(1);\n        newTopics.add(new NewTopic(\"topic-a\",1,(short) 1));\n        adminClient.createTopics(newTopics);\n        System.out.println(\"》》》》》》》》》》》》》》》 创建topic\");\n        ListTopicsResult listTopicsResult = adminClient.listTopics();\n        System.out.println(\">>>>>>>>>>>>>>>>>>>获取列表\");\n        return \"success\";\n    }\n```\n第一个参数是主题名称,第二个参数是分区数,第三个分区是副本数(包括leader).\n\n我们可以通过 `AdminClient` 查看 主题信息:\n\n```java\n    public String getTopic() throws ExecutionException, InterruptedException {\n        ListTopicsResult listTopicsResult = adminClient.listTopics();\n        Collection<TopicListing> topicListings = listTopicsResult.listings().get();\n        System.out.println(\">>>>>>>>>>>>>>>>>>>获取列表\");\n        return \"success\";\n    }\n```\n\n`ListTopicsResult` 的方法返回值都是 `Future` 类型的,这意味这它是异步的,使用的时候需要注意这一点.\n\n和rabbitMQ 类似,kafka 给我们准备了一个默认主题:\n\n```java\n    @Scheduled(cron = \"*/15 * * * * ?\")\n    public void sendDefault() {\n        kafkaTemplate.sendDefault(\"xxx\");\n    }\n\n```\n这条消息会被发送到名为 `topic.quick.default` 的主题当中去.\n我们要注意 `kafkaTemplate.send` 它的返回值是`ListenableFuture`,从名字我们就能知道它实际上是一个异步的方法,\n我们可以通过 `ListenableFuture.addCallback` 方法去指定回调函数:\n\n```java\n\n   @Scheduled(cron = \"*/15 * * * * ?\")\n    public void send() {\n        ListenableFuture<SendResult<String, String>> send = kafkaTemplate.send(\"xxxxx\", \"test\");\n        send.addCallback(new ListenableFutureCallback(){\n            @Override\n            public void onSuccess(Object o) {\n\n            }\n            @Override\n            public void onFailure(Throwable throwable) {\n                \n            }\n        });\n    }\n```\n\n我们也可以通过 `ListenableFuture.get` 方法让它阻塞:\n\n```java\n    //    @Scheduled(cron = \"*/15 * * * * ?\")\n    public void send1() {\n        try {\n            kafkaTemplate.send(\"xxxxx\", \"test\").get(10, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        } catch (TimeoutException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n\n## kafka 事务消息\n\nSpring-kafka自动注册的KafkaTemplate实例是不具有事务消息发送能力的。需要配置属性：\n\n\n```shell script\nspring.kafka.producer.acks=-1\nspring.kafka.producer.transaction-id-prefix=kafka_tx\n```\n\n\n当激活事务时 kafkaTemplate 就只能发送事务消息了，发送非事务的消息会报异常。\n发送事务消息的方法有两种，一种是通过 kafkaTemplate.executeInTransaction 实现，一种是通过 spring的注解 `@Transactional`\n 来实现，代码示例：\n\n```java\n    @Scheduled(cron = \"*/15 * * * * ?\")\n    public void sendTrans() {\n      kafkaTemplate.executeInTransaction(t ->{\n          t.send(\"xxxxx\",\"test1\");\n          t.send(\"xxxxx\",\"test2\");\n          return true;\n      }\n          );\n    }\n\n    @Scheduled(cron = \"*/15 * * * * ?\")\n    @Transactional(rollbackFor = Exception.class)\n    public void sendFoo() {\n        kafkaTemplate.send(\"topic_input\", \"test\");\n    \n    }\n\n```\n\n## 消费者Ack\n\n消费者消息消息可以自动确认，也可以通过手动确认，开启手动首先需要关闭自动提交，然后设置下consumer的消费模式：\n\n```properties\nspring.kafka.consumer.enable-auto-commit=false\nspring.kafka.listener.ack-mode=manual\n```\n\n配置完成之后我们需要对消费者监听器做一点小改动：\n\n```java\n    @KafkaListener( topics = \"topic_input\")\n    public void listen(ConsumerRecord<?, String> record, Acknowledgment ack) {\n        System.out.println(record.value());\n        ack.acknowledge();\n    }\n```\n如你所见，我们可以通过 `Acknowledgment.acknowledge()` 来手动的确认消息的消费，不确认就不算消费成功，监听器会再次收到这个消息。\n对于某些业务场景这个功能还是很必要的，比如消费消息的同时导致写库异常，数据库回滚，那么消息也不应该被ack。\n\n## 消费者监听器生命周期控制\n消费者监听器有三个生命周期：启动、停止、继续；如果我们想控制消费者监听器生命周期，需要修改` @KafkaListener` 的 `autoStartup` 属性为false，\n并给监听器 id 属性赋值\n然后通过`KafkaListenerEndpointRegistry` 控制id 对应的监听器的启动停止继续：\n\n```java\nimport org.springframework.stereotype.Service;\n@Service\npublic class test {\n    @Autowired\n    KafkaListenerEndpointRegistry listenerRegistry;\n\n    @Autowired\n    private KafkaTemplate<String, String> kafkaTemplate;\n    \n    @Scheduled(cron = \"*/15 * * * * ?\")\n    @Transactional\n    public void testListener(){\n        if (i==20){\n            listenerRegistry.getListenerContainer(\"listener1\").start();\n        }\n        System.out.println(\"生产者生产消息\"+i++);\n        kafkaTemplate.send(\"test\",\"xxx\"+i);\n    }\n    \n     @KafkaListener( id = \"listener1\",topics = \"test\",autoStartup =\"false\" )\n    public void testStart(ConsumerRecord<?, String> record){\n        System.out.println(record.value());\n    }\n\n\n}\n```\n\n通过观察窗口输出就能看到，生产者生产了20条数据后消费者监听器才开始启动消费。\n\n## 消息转发\nkafka 消费者可以将消费到的消息转发到指定的主题中去，比如一条消息需要经过多次流转加工才能走完整个业务流程，需要多个consumer来配合完成。\n转发代码示例如下：\n\n```java\n\n    @KafkaListener(topics = \"send-a\")\n    @SendTo(\"send-b\")\n    public String sendTest0(ConsumerRecord<?, String> record){\n        System.out.println(record.value());\n        return \"转发消息\"+record.value();\n    }\n    \n    @KafkaListener(topics = \"send-b\")\n    public void sendTest1(ConsumerRecord<?, String> record){\n        System.out.println(record.value());\n    }\n    \n    @Scheduled(cron = \"*/15 * * * * ?\")\n    @Transactional\n    public void producerTest(){\n        kafkaTemplate.send(\"send-a\",\"xxxxxxxxxxxxxx\");\n    }\n\n```\n\n## 生产者获取消费者响应\n结合 `@sendTo注解` 和 `ReplyingKafkaTemplate` 类 生产者可以获取消费者消费消息的结果;\n因为 ReplyingKafkaTemplate 是kafkaTemplate 的一个子类，当你往spring 容器注册 这个bean,\nkafkaTemplate 的自动装配就会关闭，但是kafkaTemplate 是必须的，因此你需要把这两个bean 都手动注册上。 \n配置示例：\n\n```java \n\n@Configuration\npublic class KafkaConfig {\n\n    @Bean\n    public NewTopic topic2() {\n        return new NewTopic(\"topic-kl\", 1, (short) 1);\n    }\n\n\n\n    @Bean\n    public AdminClient init( KafkaProperties kafkaProperties){\n        return KafkaAdminClient.create(kafkaProperties.buildAdminProperties());\n    }\n    \n    /**\n     * 同步的kafka需要ReplyingKafkaTemplate,指定repliesContainer\n     *\n     * @param producerFactory\n     * @param repliesContainer\n     * @return\n     */\n    @Bean\n    public ReplyingKafkaTemplate<String, String, String> replyingTemplate(\n        ProducerFactory<String, String> producerFactory,\n        ConcurrentMessageListenerContainer<String, String> repliesContainer) {\n        ReplyingKafkaTemplate template = new ReplyingKafkaTemplate<>(producerFactory, repliesContainer);\n        //同步相应超时时间：10s\n        template.setReplyTimeout(10000);\n        return template;\n    }\n    \n    @Bean\n    public ProducerFactory<String,String> producerFactory(KafkaProperties properties) {\n        DefaultKafkaProducerFactory<String, String> producerFactory = new DefaultKafkaProducerFactory<>(properties.buildProducerProperties());\n        producerFactory.setTransactionIdPrefix(properties.getProducer().getTransactionIdPrefix());\n        return  producerFactory;\n//        return new DefaultKafkaProducerFactory<>(properties.producerConfigs(properties));\n    }\n\n    public Map<String, Object> producerConfigs(KafkaProperties properties) {\n        Map<String, Object> props = new HashMap<>();\n        //用于建立与kafka集群的连接，这个list仅仅影响用于初始化的hosts，来发现全部的servers。 格式：host1:port1,host2:port2,…，\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,String.join(\",\",properties.getBootstrapServers()));\n        // 重试次数\n        props.put(ProducerConfig.RETRIES_CONFIG, 3);\n        // Producer可以将发往同一个Partition的数据做成一个Produce Request发送请求以减少请求次数，该值即为每次批处理的大小,若将该值设为0，则不会进行批处理\n        props.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384);\n        // Producer可以用来缓存数据的内存大小。该值实际为RecordAccumulator类中的BufferPool，即Producer所管理的最大内存。\n        props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 33554432);\n        //发送一次message最大大小，默认是1M\n        //props.put(ProducerConfig.MAX_REQUEST_SIZE_CONFIG, 20971520);\n        // 序列化器\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n        return props;\n    }\n    \n    /**\n     * 指定consumer返回数据到指定的topic\n     * @return\n     */\n    @Bean\n    public ConcurrentMessageListenerContainer<String, String>\n    repliesContainer(ConcurrentKafkaListenerContainerFactory<String, String> containerFactory) {\n        ConcurrentMessageListenerContainer<String, String> repliesContainer =\n            containerFactory.createContainer(\"topic-return\");\n        repliesContainer.setAutoStartup(true);\n        return repliesContainer;\n    }\n    \n    @Bean\n//    @ConditionalOnMissingBean(KafkaTemplate.class)\n    public KafkaTemplate<?, ?> kafkaTemplate(ProducerFactory<String, String> kafkaProducerFactory,\n                                             ObjectProvider<RecordMessageConverter> messageConverter,KafkaProperties properties) {\n        KafkaTemplate<String, String> kafkaTemplate = new KafkaTemplate<>(kafkaProducerFactory);\n        messageConverter.ifUnique(kafkaTemplate::setMessageConverter);\n        kafkaTemplate.setProducerListener( new LoggingProducerListener<>());\n        kafkaTemplate.setDefaultTopic(properties.getTemplate().getDefaultTopic());\n        return kafkaTemplate;\n    }\n\n\n}\n```\n\n生产者接收消费者返回值（这俩最好不要开到一个应用中，否则会很容易生产者超时，观察不到返回的结果）：\n\n```java\n\n    @Scheduled(cron = \"*/1 * * * * ?\")\n    @Transactional\n    public void returnTestProducer(){\n        ProducerRecord<String, String> record = new ProducerRecord<>(\"topic-return\", \"test-return\");\n        RequestReplyFuture<String, String, String> replyFuture = replyingTemplate.sendAndReceive(record);\n        try {\n            String value = replyFuture.get().value();\n            System.out.println(value);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    @KafkaListener(topics = \"topic-return\")\n    @SendTo\n    public String listen(String message) {\n        return \"consumer return:\".concat(message);\n    }\n\n\n```","source":"_posts/kafka-spring-boot.md","raw":"---\ntitle: kafka+spring boot\ndate: 2021-03-28 10:55:32\ntags: 中间件\n---\n前文介绍了 kafka 的相关特性和原理，这一节我们将学习怎么在springboot中使用kafka；\n\n首先导入依赖\n\n```xml\n<dependency>\n   <groupId>org.springframework.kafka</groupId>\n   <artifactId>spring-kafka</artifactId>\n</dependency>\n```\n\n<!--more-->\n\n然后启动项添加注解 `@EnableScheduling`，`@EnableKafka` 。第一个注解是用来添加springboot定时任务以方便测试，第二个注解是装配kafka 配置。\n\n接下来我们要在 application 的配置文件：\n\n```properties\n## 生产者配置\nspring.kafka.consumer.bootstrap-servers=localhost:9092\nspring.kafka.consumer.group-id=test-consumer-group\nspring.kafka.consumer.auto-offset-reset=earliest\nspring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer\nspring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer\n\n## 消费者配置\nspring.kafka.producer.bootstrap-servers=localhost:9092\nspring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer\nspring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer\n\n#消费监听接口监听的主题不存在时，默认会报错\nspring.kafka.listener.missing-topics-fatal=false\n\n```\n\n注册一个 `AdminClient` :\n\n```java\n @Bean\n    public AdminClient init( KafkaProperties kafkaProperties){\n        return KafkaAdminClient.create(kafkaProperties.buildAdminProperties());\n    }\n```\n\n这里因为是demo，我就将生产者和消费者写在一个程序里面了。\n\n先测试一个简单的收发消息：\n\n```java\n@RestController\npublic class TestController {\n    @Autowired\n    private KafkaTemplate<String, String> kafkaTemplate;\n    \n\n    @Autowired\n    private   AdminClient adminClient;\n    \n    @Scheduled(cron = \"*/15 * * * * ?\")\n    public void send() {\n        kafkaTemplate.send(\"xxxxx\", \"test\");\n    }\n    \n    @KafkaListener(topics = \"xxxxx\",groupId = \"test-consumer-group\")\n    public void listen(ConsumerRecord<?, String> record) throws ExecutionException, InterruptedException {\n        String value = record.value();\n        System.out.println(value);\n    }\n\n}\n```\n\n这里我调用了`kafkaTemplate.send` 方法发送消息,第一个参数是消息的主题,第二个参数是消息.\n这里我并没有先创建主题,直接往主题里面发消息了,框架会给你直接创建一个默认的主题.\n我们也可以直接创建一个主题:\n\n```java\n @Bean\n    public NewTopic topic() {\n        return new NewTopic(\"topic-test\", 1, (short) 1);\n    }\n```\n当然像 rabbitMQ 的api 那样,spring boot 还非常贴心的准备了 topic 建造者类:\n\n```java\n@Bean\npublic NewTopic topic1() {\n    return TopicBuilder.name(\"thing1\")\n            .partitions(10)\n            .replicas(3)\n            .compact()\n            .build();\n}\n```\n\n还可以通过 AdminClient 创建主题：\n```java\n    @Autowired\n    private   AdminClient adminClient;\n\n    public String createTopic(){\n        Collection<NewTopic> newTopics = new ArrayList<>(1);\n        newTopics.add(new NewTopic(\"topic-a\",1,(short) 1));\n        adminClient.createTopics(newTopics);\n        System.out.println(\"》》》》》》》》》》》》》》》 创建topic\");\n        ListTopicsResult listTopicsResult = adminClient.listTopics();\n        System.out.println(\">>>>>>>>>>>>>>>>>>>获取列表\");\n        return \"success\";\n    }\n```\n第一个参数是主题名称,第二个参数是分区数,第三个分区是副本数(包括leader).\n\n我们可以通过 `AdminClient` 查看 主题信息:\n\n```java\n    public String getTopic() throws ExecutionException, InterruptedException {\n        ListTopicsResult listTopicsResult = adminClient.listTopics();\n        Collection<TopicListing> topicListings = listTopicsResult.listings().get();\n        System.out.println(\">>>>>>>>>>>>>>>>>>>获取列表\");\n        return \"success\";\n    }\n```\n\n`ListTopicsResult` 的方法返回值都是 `Future` 类型的,这意味这它是异步的,使用的时候需要注意这一点.\n\n和rabbitMQ 类似,kafka 给我们准备了一个默认主题:\n\n```java\n    @Scheduled(cron = \"*/15 * * * * ?\")\n    public void sendDefault() {\n        kafkaTemplate.sendDefault(\"xxx\");\n    }\n\n```\n这条消息会被发送到名为 `topic.quick.default` 的主题当中去.\n我们要注意 `kafkaTemplate.send` 它的返回值是`ListenableFuture`,从名字我们就能知道它实际上是一个异步的方法,\n我们可以通过 `ListenableFuture.addCallback` 方法去指定回调函数:\n\n```java\n\n   @Scheduled(cron = \"*/15 * * * * ?\")\n    public void send() {\n        ListenableFuture<SendResult<String, String>> send = kafkaTemplate.send(\"xxxxx\", \"test\");\n        send.addCallback(new ListenableFutureCallback(){\n            @Override\n            public void onSuccess(Object o) {\n\n            }\n            @Override\n            public void onFailure(Throwable throwable) {\n                \n            }\n        });\n    }\n```\n\n我们也可以通过 `ListenableFuture.get` 方法让它阻塞:\n\n```java\n    //    @Scheduled(cron = \"*/15 * * * * ?\")\n    public void send1() {\n        try {\n            kafkaTemplate.send(\"xxxxx\", \"test\").get(10, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        } catch (TimeoutException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n\n## kafka 事务消息\n\nSpring-kafka自动注册的KafkaTemplate实例是不具有事务消息发送能力的。需要配置属性：\n\n\n```shell script\nspring.kafka.producer.acks=-1\nspring.kafka.producer.transaction-id-prefix=kafka_tx\n```\n\n\n当激活事务时 kafkaTemplate 就只能发送事务消息了，发送非事务的消息会报异常。\n发送事务消息的方法有两种，一种是通过 kafkaTemplate.executeInTransaction 实现，一种是通过 spring的注解 `@Transactional`\n 来实现，代码示例：\n\n```java\n    @Scheduled(cron = \"*/15 * * * * ?\")\n    public void sendTrans() {\n      kafkaTemplate.executeInTransaction(t ->{\n          t.send(\"xxxxx\",\"test1\");\n          t.send(\"xxxxx\",\"test2\");\n          return true;\n      }\n          );\n    }\n\n    @Scheduled(cron = \"*/15 * * * * ?\")\n    @Transactional(rollbackFor = Exception.class)\n    public void sendFoo() {\n        kafkaTemplate.send(\"topic_input\", \"test\");\n    \n    }\n\n```\n\n## 消费者Ack\n\n消费者消息消息可以自动确认，也可以通过手动确认，开启手动首先需要关闭自动提交，然后设置下consumer的消费模式：\n\n```properties\nspring.kafka.consumer.enable-auto-commit=false\nspring.kafka.listener.ack-mode=manual\n```\n\n配置完成之后我们需要对消费者监听器做一点小改动：\n\n```java\n    @KafkaListener( topics = \"topic_input\")\n    public void listen(ConsumerRecord<?, String> record, Acknowledgment ack) {\n        System.out.println(record.value());\n        ack.acknowledge();\n    }\n```\n如你所见，我们可以通过 `Acknowledgment.acknowledge()` 来手动的确认消息的消费，不确认就不算消费成功，监听器会再次收到这个消息。\n对于某些业务场景这个功能还是很必要的，比如消费消息的同时导致写库异常，数据库回滚，那么消息也不应该被ack。\n\n## 消费者监听器生命周期控制\n消费者监听器有三个生命周期：启动、停止、继续；如果我们想控制消费者监听器生命周期，需要修改` @KafkaListener` 的 `autoStartup` 属性为false，\n并给监听器 id 属性赋值\n然后通过`KafkaListenerEndpointRegistry` 控制id 对应的监听器的启动停止继续：\n\n```java\nimport org.springframework.stereotype.Service;\n@Service\npublic class test {\n    @Autowired\n    KafkaListenerEndpointRegistry listenerRegistry;\n\n    @Autowired\n    private KafkaTemplate<String, String> kafkaTemplate;\n    \n    @Scheduled(cron = \"*/15 * * * * ?\")\n    @Transactional\n    public void testListener(){\n        if (i==20){\n            listenerRegistry.getListenerContainer(\"listener1\").start();\n        }\n        System.out.println(\"生产者生产消息\"+i++);\n        kafkaTemplate.send(\"test\",\"xxx\"+i);\n    }\n    \n     @KafkaListener( id = \"listener1\",topics = \"test\",autoStartup =\"false\" )\n    public void testStart(ConsumerRecord<?, String> record){\n        System.out.println(record.value());\n    }\n\n\n}\n```\n\n通过观察窗口输出就能看到，生产者生产了20条数据后消费者监听器才开始启动消费。\n\n## 消息转发\nkafka 消费者可以将消费到的消息转发到指定的主题中去，比如一条消息需要经过多次流转加工才能走完整个业务流程，需要多个consumer来配合完成。\n转发代码示例如下：\n\n```java\n\n    @KafkaListener(topics = \"send-a\")\n    @SendTo(\"send-b\")\n    public String sendTest0(ConsumerRecord<?, String> record){\n        System.out.println(record.value());\n        return \"转发消息\"+record.value();\n    }\n    \n    @KafkaListener(topics = \"send-b\")\n    public void sendTest1(ConsumerRecord<?, String> record){\n        System.out.println(record.value());\n    }\n    \n    @Scheduled(cron = \"*/15 * * * * ?\")\n    @Transactional\n    public void producerTest(){\n        kafkaTemplate.send(\"send-a\",\"xxxxxxxxxxxxxx\");\n    }\n\n```\n\n## 生产者获取消费者响应\n结合 `@sendTo注解` 和 `ReplyingKafkaTemplate` 类 生产者可以获取消费者消费消息的结果;\n因为 ReplyingKafkaTemplate 是kafkaTemplate 的一个子类，当你往spring 容器注册 这个bean,\nkafkaTemplate 的自动装配就会关闭，但是kafkaTemplate 是必须的，因此你需要把这两个bean 都手动注册上。 \n配置示例：\n\n```java \n\n@Configuration\npublic class KafkaConfig {\n\n    @Bean\n    public NewTopic topic2() {\n        return new NewTopic(\"topic-kl\", 1, (short) 1);\n    }\n\n\n\n    @Bean\n    public AdminClient init( KafkaProperties kafkaProperties){\n        return KafkaAdminClient.create(kafkaProperties.buildAdminProperties());\n    }\n    \n    /**\n     * 同步的kafka需要ReplyingKafkaTemplate,指定repliesContainer\n     *\n     * @param producerFactory\n     * @param repliesContainer\n     * @return\n     */\n    @Bean\n    public ReplyingKafkaTemplate<String, String, String> replyingTemplate(\n        ProducerFactory<String, String> producerFactory,\n        ConcurrentMessageListenerContainer<String, String> repliesContainer) {\n        ReplyingKafkaTemplate template = new ReplyingKafkaTemplate<>(producerFactory, repliesContainer);\n        //同步相应超时时间：10s\n        template.setReplyTimeout(10000);\n        return template;\n    }\n    \n    @Bean\n    public ProducerFactory<String,String> producerFactory(KafkaProperties properties) {\n        DefaultKafkaProducerFactory<String, String> producerFactory = new DefaultKafkaProducerFactory<>(properties.buildProducerProperties());\n        producerFactory.setTransactionIdPrefix(properties.getProducer().getTransactionIdPrefix());\n        return  producerFactory;\n//        return new DefaultKafkaProducerFactory<>(properties.producerConfigs(properties));\n    }\n\n    public Map<String, Object> producerConfigs(KafkaProperties properties) {\n        Map<String, Object> props = new HashMap<>();\n        //用于建立与kafka集群的连接，这个list仅仅影响用于初始化的hosts，来发现全部的servers。 格式：host1:port1,host2:port2,…，\n        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,String.join(\",\",properties.getBootstrapServers()));\n        // 重试次数\n        props.put(ProducerConfig.RETRIES_CONFIG, 3);\n        // Producer可以将发往同一个Partition的数据做成一个Produce Request发送请求以减少请求次数，该值即为每次批处理的大小,若将该值设为0，则不会进行批处理\n        props.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384);\n        // Producer可以用来缓存数据的内存大小。该值实际为RecordAccumulator类中的BufferPool，即Producer所管理的最大内存。\n        props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 33554432);\n        //发送一次message最大大小，默认是1M\n        //props.put(ProducerConfig.MAX_REQUEST_SIZE_CONFIG, 20971520);\n        // 序列化器\n        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n        return props;\n    }\n    \n    /**\n     * 指定consumer返回数据到指定的topic\n     * @return\n     */\n    @Bean\n    public ConcurrentMessageListenerContainer<String, String>\n    repliesContainer(ConcurrentKafkaListenerContainerFactory<String, String> containerFactory) {\n        ConcurrentMessageListenerContainer<String, String> repliesContainer =\n            containerFactory.createContainer(\"topic-return\");\n        repliesContainer.setAutoStartup(true);\n        return repliesContainer;\n    }\n    \n    @Bean\n//    @ConditionalOnMissingBean(KafkaTemplate.class)\n    public KafkaTemplate<?, ?> kafkaTemplate(ProducerFactory<String, String> kafkaProducerFactory,\n                                             ObjectProvider<RecordMessageConverter> messageConverter,KafkaProperties properties) {\n        KafkaTemplate<String, String> kafkaTemplate = new KafkaTemplate<>(kafkaProducerFactory);\n        messageConverter.ifUnique(kafkaTemplate::setMessageConverter);\n        kafkaTemplate.setProducerListener( new LoggingProducerListener<>());\n        kafkaTemplate.setDefaultTopic(properties.getTemplate().getDefaultTopic());\n        return kafkaTemplate;\n    }\n\n\n}\n```\n\n生产者接收消费者返回值（这俩最好不要开到一个应用中，否则会很容易生产者超时，观察不到返回的结果）：\n\n```java\n\n    @Scheduled(cron = \"*/1 * * * * ?\")\n    @Transactional\n    public void returnTestProducer(){\n        ProducerRecord<String, String> record = new ProducerRecord<>(\"topic-return\", \"test-return\");\n        RequestReplyFuture<String, String, String> replyFuture = replyingTemplate.sendAndReceive(record);\n        try {\n            String value = replyFuture.get().value();\n            System.out.println(value);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    @KafkaListener(topics = \"topic-return\")\n    @SendTo\n    public String listen(String message) {\n        return \"consumer return:\".concat(message);\n    }\n\n\n```","slug":"kafka-spring-boot","published":1,"updated":"2021-03-28T03:47:58.425Z","_id":"ckmsmcd170000roqk5qambyer","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前文介绍了 kafka 的相关特性和原理，这一节我们将学习怎么在springboot中使用kafka；</p>\n<p>首先导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.kafka<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-kafka<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n\n<p>然后启动项添加注解 <code>@EnableScheduling</code>，<code>@EnableKafka</code> 。第一个注解是用来添加springboot定时任务以方便测试，第二个注解是装配kafka 配置。</p>\n<p>接下来我们要在 application 的配置文件：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 生产者配置</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.bootstrap-servers</span>=<span class=\"string\">localhost:9092</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.group-id</span>=<span class=\"string\">test-consumer-group</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.auto-offset-reset</span>=<span class=\"string\">earliest</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.key-deserializer</span>=<span class=\"string\">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.value-deserializer</span>=<span class=\"string\">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 消费者配置</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.producer.bootstrap-servers</span>=<span class=\"string\">localhost:9092</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.producer.key-serializer</span>=<span class=\"string\">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.producer.value-serializer</span>=<span class=\"string\">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#消费监听接口监听的主题不存在时，默认会报错</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.listener.missing-topics-fatal</span>=<span class=\"string\">false</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>注册一个 <code>AdminClient</code> :</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> AdminClient <span class=\"title\">init</span><span class=\"params\">( KafkaProperties kafkaProperties)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> KafkaAdminClient.create(kafkaProperties.buildAdminProperties());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这里因为是demo，我就将生产者和消费者写在一个程序里面了。</p>\n<p>先测试一个简单的收发消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>   AdminClient adminClient;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        kafkaTemplate.send(<span class=\"string\">&quot;xxxxx&quot;</span>, <span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@KafkaListener(topics = &quot;xxxxx&quot;,groupId = &quot;test-consumer-group&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listen</span><span class=\"params\">(ConsumerRecord&lt;?, String&gt; record)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        String value = record.value();</span><br><span class=\"line\">        System.out.println(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我调用了<code>kafkaTemplate.send</code> 方法发送消息,第一个参数是消息的主题,第二个参数是消息.<br>这里我并没有先创建主题,直接往主题里面发消息了,框架会给你直接创建一个默认的主题.<br>我们也可以直接创建一个主题:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> NewTopic <span class=\"title\">topic</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NewTopic(<span class=\"string\">&quot;topic-test&quot;</span>, <span class=\"number\">1</span>, (<span class=\"keyword\">short</span>) <span class=\"number\">1</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>当然像 rabbitMQ 的api 那样,spring boot 还非常贴心的准备了 topic 建造者类:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> NewTopic <span class=\"title\">topic1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> TopicBuilder.name(<span class=\"string\">&quot;thing1&quot;</span>)</span><br><span class=\"line\">            .partitions(<span class=\"number\">10</span>)</span><br><span class=\"line\">            .replicas(<span class=\"number\">3</span>)</span><br><span class=\"line\">            .compact()</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还可以通过 AdminClient 创建主题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>   AdminClient adminClient;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">createTopic</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Collection&lt;NewTopic&gt; newTopics = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">    newTopics.add(<span class=\"keyword\">new</span> NewTopic(<span class=\"string\">&quot;topic-a&quot;</span>,<span class=\"number\">1</span>,(<span class=\"keyword\">short</span>) <span class=\"number\">1</span>));</span><br><span class=\"line\">    adminClient.createTopics(newTopics);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;》》》》》》》》》》》》》》》 创建topic&quot;</span>);</span><br><span class=\"line\">    ListTopicsResult listTopicsResult = adminClient.listTopics();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;获取列表&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一个参数是主题名称,第二个参数是分区数,第三个分区是副本数(包括leader).</p>\n<p>我们可以通过 <code>AdminClient</code> 查看 主题信息:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTopic</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">    ListTopicsResult listTopicsResult = adminClient.listTopics();</span><br><span class=\"line\">    Collection&lt;TopicListing&gt; topicListings = listTopicsResult.listings().get();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;获取列表&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ListTopicsResult</code> 的方法返回值都是 <code>Future</code> 类型的,这意味这它是异步的,使用的时候需要注意这一点.</p>\n<p>和rabbitMQ 类似,kafka 给我们准备了一个默认主题:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendDefault</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    kafkaTemplate.sendDefault(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这条消息会被发送到名为 <code>topic.quick.default</code> 的主题当中去.<br>我们要注意 <code>kafkaTemplate.send</code> 它的返回值是<code>ListenableFuture</code>,从名字我们就能知道它实际上是一个异步的方法,<br>我们可以通过 <code>ListenableFuture.addCallback</code> 方法去指定回调函数:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; send = kafkaTemplate.send(<span class=\"string\">&quot;xxxxx&quot;</span>, <span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">     send.addCallback(<span class=\"keyword\">new</span> ListenableFutureCallback()&#123;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</span><br><span class=\"line\">             </span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>我们也可以通过 <code>ListenableFuture.get</code> 方法让它阻塞:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//    @Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        kafkaTemplate.send(<span class=\"string\">&quot;xxxxx&quot;</span>, <span class=\"string\">&quot;test&quot;</span>).get(<span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (TimeoutException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"kafka-事务消息\"><a href=\"#kafka-事务消息\" class=\"headerlink\" title=\"kafka 事务消息\"></a>kafka 事务消息</h2><p>Spring-kafka自动注册的KafkaTemplate实例是不具有事务消息发送能力的。需要配置属性：</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.kafka.producer.acks=-1</span><br><span class=\"line\">spring.kafka.producer.transaction-id-prefix=kafka_tx</span><br></pre></td></tr></table></figure>\n\n<p>当激活事务时 kafkaTemplate 就只能发送事务消息了，发送非事务的消息会报异常。<br>发送事务消息的方法有两种，一种是通过 kafkaTemplate.executeInTransaction 实现，一种是通过 spring的注解 <code>@Transactional</code><br> 来实现，代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendTrans</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  kafkaTemplate.executeInTransaction(t -&gt;&#123;</span><br><span class=\"line\">      t.send(<span class=\"string\">&quot;xxxxx&quot;</span>,<span class=\"string\">&quot;test1&quot;</span>);</span><br><span class=\"line\">      t.send(<span class=\"string\">&quot;xxxxx&quot;</span>,<span class=\"string\">&quot;test2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">      );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendFoo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    kafkaTemplate.send(<span class=\"string\">&quot;topic_input&quot;</span>, <span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"消费者Ack\"><a href=\"#消费者Ack\" class=\"headerlink\" title=\"消费者Ack\"></a>消费者Ack</h2><p>消费者消息消息可以自动确认，也可以通过手动确认，开启手动首先需要关闭自动提交，然后设置下consumer的消费模式：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.enable-auto-commit</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.listener.ack-mode</span>=<span class=\"string\">manual</span></span><br></pre></td></tr></table></figure>\n<p>配置完成之后我们需要对消费者监听器做一点小改动：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@KafkaListener( topics = &quot;topic_input&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listen</span><span class=\"params\">(ConsumerRecord&lt;?, String&gt; record, Acknowledgment ack)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(record.value());</span><br><span class=\"line\">    ack.acknowledge();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如你所见，我们可以通过 <code>Acknowledgment.acknowledge()</code> 来手动的确认消息的消费，不确认就不算消费成功，监听器会再次收到这个消息。<br>对于某些业务场景这个功能还是很必要的，比如消费消息的同时导致写库异常，数据库回滚，那么消息也不应该被ack。</p>\n<h2 id=\"消费者监听器生命周期控制\"><a href=\"#消费者监听器生命周期控制\" class=\"headerlink\" title=\"消费者监听器生命周期控制\"></a>消费者监听器生命周期控制</h2><p>消费者监听器有三个生命周期：启动、停止、继续；如果我们想控制消费者监听器生命周期，需要修改<code>@KafkaListener</code> 的 <code>autoStartup</code> 属性为false，<br>并给监听器 id 属性赋值<br>然后通过<code>KafkaListenerEndpointRegistry</code> 控制id 对应的监听器的启动停止继续：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    KafkaListenerEndpointRegistry listenerRegistry;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testListener</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i==<span class=\"number\">20</span>)&#123;</span><br><span class=\"line\">            listenerRegistry.getListenerContainer(<span class=\"string\">&quot;listener1&quot;</span>).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;生产者生产消息&quot;</span>+i++);</span><br><span class=\"line\">        kafkaTemplate.send(<span class=\"string\">&quot;test&quot;</span>,<span class=\"string\">&quot;xxx&quot;</span>+i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"meta\">@KafkaListener( id = &quot;listener1&quot;,topics = &quot;test&quot;,autoStartup =&quot;false&quot; )</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testStart</span><span class=\"params\">(ConsumerRecord&lt;?, String&gt; record)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(record.value());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过观察窗口输出就能看到，生产者生产了20条数据后消费者监听器才开始启动消费。</p>\n<h2 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h2><p>kafka 消费者可以将消费到的消息转发到指定的主题中去，比如一条消息需要经过多次流转加工才能走完整个业务流程，需要多个consumer来配合完成。<br>转发代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KafkaListener(topics = &quot;send-a&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SendTo(&quot;send-b&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendTest0</span><span class=\"params\">(ConsumerRecord&lt;?, String&gt; record)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(record.value());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;转发消息&quot;</span>+record.value();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KafkaListener(topics = &quot;send-b&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendTest1</span><span class=\"params\">(ConsumerRecord&lt;?, String&gt; record)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(record.value());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">producerTest</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    kafkaTemplate.send(<span class=\"string\">&quot;send-a&quot;</span>,<span class=\"string\">&quot;xxxxxxxxxxxxxx&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"生产者获取消费者响应\"><a href=\"#生产者获取消费者响应\" class=\"headerlink\" title=\"生产者获取消费者响应\"></a>生产者获取消费者响应</h2><p>结合 <code>@sendTo注解</code> 和 <code>ReplyingKafkaTemplate</code> 类 生产者可以获取消费者消费消息的结果;<br>因为 ReplyingKafkaTemplate 是kafkaTemplate 的一个子类，当你往spring 容器注册 这个bean,<br>kafkaTemplate 的自动装配就会关闭，但是kafkaTemplate 是必须的，因此你需要把这两个bean 都手动注册上。<br>配置示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KafkaConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> NewTopic <span class=\"title\">topic2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NewTopic(<span class=\"string\">&quot;topic-kl&quot;</span>, <span class=\"number\">1</span>, (<span class=\"keyword\">short</span>) <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AdminClient <span class=\"title\">init</span><span class=\"params\">( KafkaProperties kafkaProperties)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> KafkaAdminClient.create(kafkaProperties.buildAdminProperties());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 同步的kafka需要ReplyingKafkaTemplate,指定repliesContainer</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> producerFactory</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> repliesContainer</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ReplyingKafkaTemplate&lt;String, String, String&gt; <span class=\"title\">replyingTemplate</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProducerFactory&lt;String, String&gt; producerFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ConcurrentMessageListenerContainer&lt;String, String&gt; repliesContainer)</span> </span>&#123;</span><br><span class=\"line\">        ReplyingKafkaTemplate template = <span class=\"keyword\">new</span> ReplyingKafkaTemplate&lt;&gt;(producerFactory, repliesContainer);</span><br><span class=\"line\">        <span class=\"comment\">//同步相应超时时间：10s</span></span><br><span class=\"line\">        template.setReplyTimeout(<span class=\"number\">10000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProducerFactory&lt;String,String&gt; <span class=\"title\">producerFactory</span><span class=\"params\">(KafkaProperties properties)</span> </span>&#123;</span><br><span class=\"line\">        DefaultKafkaProducerFactory&lt;String, String&gt; producerFactory = <span class=\"keyword\">new</span> DefaultKafkaProducerFactory&lt;&gt;(properties.buildProducerProperties());</span><br><span class=\"line\">        producerFactory.setTransactionIdPrefix(properties.getProducer().getTransactionIdPrefix());</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  producerFactory;</span><br><span class=\"line\"><span class=\"comment\">//        return new DefaultKafkaProducerFactory&lt;&gt;(properties.producerConfigs(properties));</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, Object&gt; <span class=\"title\">producerConfigs</span><span class=\"params\">(KafkaProperties properties)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; props = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//用于建立与kafka集群的连接，这个list仅仅影响用于初始化的hosts，来发现全部的servers。 格式：host1:port1,host2:port2,…，</span></span><br><span class=\"line\">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,String.join(<span class=\"string\">&quot;,&quot;</span>,properties.getBootstrapServers()));</span><br><span class=\"line\">        <span class=\"comment\">// 重试次数</span></span><br><span class=\"line\">        props.put(ProducerConfig.RETRIES_CONFIG, <span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Producer可以将发往同一个Partition的数据做成一个Produce Request发送请求以减少请求次数，该值即为每次批处理的大小,若将该值设为0，则不会进行批处理</span></span><br><span class=\"line\">        props.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class=\"number\">16384</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Producer可以用来缓存数据的内存大小。该值实际为RecordAccumulator类中的BufferPool，即Producer所管理的最大内存。</span></span><br><span class=\"line\">        props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class=\"number\">33554432</span>);</span><br><span class=\"line\">        <span class=\"comment\">//发送一次message最大大小，默认是1M</span></span><br><span class=\"line\">        <span class=\"comment\">//props.put(ProducerConfig.MAX_REQUEST_SIZE_CONFIG, 20971520);</span></span><br><span class=\"line\">        <span class=\"comment\">// 序列化器</span></span><br><span class=\"line\">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class=\"line\">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> props;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定consumer返回数据到指定的topic</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ConcurrentMessageListenerContainer&lt;String, String&gt;</span><br><span class=\"line\">    repliesContainer(ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; containerFactory) &#123;</span><br><span class=\"line\">        ConcurrentMessageListenerContainer&lt;String, String&gt; repliesContainer =</span><br><span class=\"line\">            containerFactory.createContainer(<span class=\"string\">&quot;topic-return&quot;</span>);</span><br><span class=\"line\">        repliesContainer.setAutoStartup(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> repliesContainer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"comment\">//    @ConditionalOnMissingBean(KafkaTemplate.class)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> KafkaTemplate&lt;?, ?&gt; kafkaTemplate(ProducerFactory&lt;String, String&gt; kafkaProducerFactory,</span><br><span class=\"line\">                                             ObjectProvider&lt;RecordMessageConverter&gt; messageConverter,KafkaProperties properties) &#123;</span><br><span class=\"line\">        KafkaTemplate&lt;String, String&gt; kafkaTemplate = <span class=\"keyword\">new</span> KafkaTemplate&lt;&gt;(kafkaProducerFactory);</span><br><span class=\"line\">        messageConverter.ifUnique(kafkaTemplate::setMessageConverter);</span><br><span class=\"line\">        kafkaTemplate.setProducerListener( <span class=\"keyword\">new</span> LoggingProducerListener&lt;&gt;());</span><br><span class=\"line\">        kafkaTemplate.setDefaultTopic(properties.getTemplate().getDefaultTopic());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> kafkaTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生产者接收消费者返回值（这俩最好不要开到一个应用中，否则会很容易生产者超时，观察不到返回的结果）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/1 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">returnTestProducer</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ProducerRecord&lt;String, String&gt; record = <span class=\"keyword\">new</span> ProducerRecord&lt;&gt;(<span class=\"string\">&quot;topic-return&quot;</span>, <span class=\"string\">&quot;test-return&quot;</span>);</span><br><span class=\"line\">    RequestReplyFuture&lt;String, String, String&gt; replyFuture = replyingTemplate.sendAndReceive(record);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        String value = replyFuture.get().value();</span><br><span class=\"line\">        System.out.println(value);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KafkaListener(topics = &quot;topic-return&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SendTo</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">listen</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;consumer return:&quot;</span>.concat(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>前文介绍了 kafka 的相关特性和原理，这一节我们将学习怎么在springboot中使用kafka；</p>\n<p>首先导入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.kafka<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-kafka<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>","more":"<p>然后启动项添加注解 <code>@EnableScheduling</code>，<code>@EnableKafka</code> 。第一个注解是用来添加springboot定时任务以方便测试，第二个注解是装配kafka 配置。</p>\n<p>接下来我们要在 application 的配置文件：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 生产者配置</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.bootstrap-servers</span>=<span class=\"string\">localhost:9092</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.group-id</span>=<span class=\"string\">test-consumer-group</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.auto-offset-reset</span>=<span class=\"string\">earliest</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.key-deserializer</span>=<span class=\"string\">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.value-deserializer</span>=<span class=\"string\">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 消费者配置</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.producer.bootstrap-servers</span>=<span class=\"string\">localhost:9092</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.producer.key-serializer</span>=<span class=\"string\">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.producer.value-serializer</span>=<span class=\"string\">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#消费监听接口监听的主题不存在时，默认会报错</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.listener.missing-topics-fatal</span>=<span class=\"string\">false</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>注册一个 <code>AdminClient</code> :</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> AdminClient <span class=\"title\">init</span><span class=\"params\">( KafkaProperties kafkaProperties)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> KafkaAdminClient.create(kafkaProperties.buildAdminProperties());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>这里因为是demo，我就将生产者和消费者写在一个程序里面了。</p>\n<p>先测试一个简单的收发消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>   AdminClient adminClient;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        kafkaTemplate.send(<span class=\"string\">&quot;xxxxx&quot;</span>, <span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@KafkaListener(topics = &quot;xxxxx&quot;,groupId = &quot;test-consumer-group&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listen</span><span class=\"params\">(ConsumerRecord&lt;?, String&gt; record)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        String value = record.value();</span><br><span class=\"line\">        System.out.println(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我调用了<code>kafkaTemplate.send</code> 方法发送消息,第一个参数是消息的主题,第二个参数是消息.<br>这里我并没有先创建主题,直接往主题里面发消息了,框架会给你直接创建一个默认的主题.<br>我们也可以直接创建一个主题:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> NewTopic <span class=\"title\">topic</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NewTopic(<span class=\"string\">&quot;topic-test&quot;</span>, <span class=\"number\">1</span>, (<span class=\"keyword\">short</span>) <span class=\"number\">1</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>当然像 rabbitMQ 的api 那样,spring boot 还非常贴心的准备了 topic 建造者类:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> NewTopic <span class=\"title\">topic1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> TopicBuilder.name(<span class=\"string\">&quot;thing1&quot;</span>)</span><br><span class=\"line\">            .partitions(<span class=\"number\">10</span>)</span><br><span class=\"line\">            .replicas(<span class=\"number\">3</span>)</span><br><span class=\"line\">            .compact()</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还可以通过 AdminClient 创建主题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>   AdminClient adminClient;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">createTopic</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Collection&lt;NewTopic&gt; newTopics = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">    newTopics.add(<span class=\"keyword\">new</span> NewTopic(<span class=\"string\">&quot;topic-a&quot;</span>,<span class=\"number\">1</span>,(<span class=\"keyword\">short</span>) <span class=\"number\">1</span>));</span><br><span class=\"line\">    adminClient.createTopics(newTopics);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;》》》》》》》》》》》》》》》 创建topic&quot;</span>);</span><br><span class=\"line\">    ListTopicsResult listTopicsResult = adminClient.listTopics();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;获取列表&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一个参数是主题名称,第二个参数是分区数,第三个分区是副本数(包括leader).</p>\n<p>我们可以通过 <code>AdminClient</code> 查看 主题信息:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTopic</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">    ListTopicsResult listTopicsResult = adminClient.listTopics();</span><br><span class=\"line\">    Collection&lt;TopicListing&gt; topicListings = listTopicsResult.listings().get();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;获取列表&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ListTopicsResult</code> 的方法返回值都是 <code>Future</code> 类型的,这意味这它是异步的,使用的时候需要注意这一点.</p>\n<p>和rabbitMQ 类似,kafka 给我们准备了一个默认主题:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendDefault</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    kafkaTemplate.sendDefault(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这条消息会被发送到名为 <code>topic.quick.default</code> 的主题当中去.<br>我们要注意 <code>kafkaTemplate.send</code> 它的返回值是<code>ListenableFuture</code>,从名字我们就能知道它实际上是一个异步的方法,<br>我们可以通过 <code>ListenableFuture.addCallback</code> 方法去指定回调函数:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; send = kafkaTemplate.send(<span class=\"string\">&quot;xxxxx&quot;</span>, <span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">     send.addCallback(<span class=\"keyword\">new</span> ListenableFutureCallback()&#123;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</span><br><span class=\"line\">             </span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>我们也可以通过 <code>ListenableFuture.get</code> 方法让它阻塞:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//    @Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        kafkaTemplate.send(<span class=\"string\">&quot;xxxxx&quot;</span>, <span class=\"string\">&quot;test&quot;</span>).get(<span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (TimeoutException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"kafka-事务消息\"><a href=\"#kafka-事务消息\" class=\"headerlink\" title=\"kafka 事务消息\"></a>kafka 事务消息</h2><p>Spring-kafka自动注册的KafkaTemplate实例是不具有事务消息发送能力的。需要配置属性：</p>\n<figure class=\"highlight shell\"><figcaption><span>script</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring.kafka.producer.acks=-1</span><br><span class=\"line\">spring.kafka.producer.transaction-id-prefix=kafka_tx</span><br></pre></td></tr></table></figure>\n\n<p>当激活事务时 kafkaTemplate 就只能发送事务消息了，发送非事务的消息会报异常。<br>发送事务消息的方法有两种，一种是通过 kafkaTemplate.executeInTransaction 实现，一种是通过 spring的注解 <code>@Transactional</code><br> 来实现，代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendTrans</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  kafkaTemplate.executeInTransaction(t -&gt;&#123;</span><br><span class=\"line\">      t.send(<span class=\"string\">&quot;xxxxx&quot;</span>,<span class=\"string\">&quot;test1&quot;</span>);</span><br><span class=\"line\">      t.send(<span class=\"string\">&quot;xxxxx&quot;</span>,<span class=\"string\">&quot;test2&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">      );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendFoo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    kafkaTemplate.send(<span class=\"string\">&quot;topic_input&quot;</span>, <span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"消费者Ack\"><a href=\"#消费者Ack\" class=\"headerlink\" title=\"消费者Ack\"></a>消费者Ack</h2><p>消费者消息消息可以自动确认，也可以通过手动确认，开启手动首先需要关闭自动提交，然后设置下consumer的消费模式：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">spring.kafka.consumer.enable-auto-commit</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"meta\">spring.kafka.listener.ack-mode</span>=<span class=\"string\">manual</span></span><br></pre></td></tr></table></figure>\n<p>配置完成之后我们需要对消费者监听器做一点小改动：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@KafkaListener( topics = &quot;topic_input&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">listen</span><span class=\"params\">(ConsumerRecord&lt;?, String&gt; record, Acknowledgment ack)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(record.value());</span><br><span class=\"line\">    ack.acknowledge();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如你所见，我们可以通过 <code>Acknowledgment.acknowledge()</code> 来手动的确认消息的消费，不确认就不算消费成功，监听器会再次收到这个消息。<br>对于某些业务场景这个功能还是很必要的，比如消费消息的同时导致写库异常，数据库回滚，那么消息也不应该被ack。</p>\n<h2 id=\"消费者监听器生命周期控制\"><a href=\"#消费者监听器生命周期控制\" class=\"headerlink\" title=\"消费者监听器生命周期控制\"></a>消费者监听器生命周期控制</h2><p>消费者监听器有三个生命周期：启动、停止、继续；如果我们想控制消费者监听器生命周期，需要修改<code>@KafkaListener</code> 的 <code>autoStartup</code> 属性为false，<br>并给监听器 id 属性赋值<br>然后通过<code>KafkaListenerEndpointRegistry</code> 控制id 对应的监听器的启动停止继续：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    KafkaListenerEndpointRegistry listenerRegistry;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testListener</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i==<span class=\"number\">20</span>)&#123;</span><br><span class=\"line\">            listenerRegistry.getListenerContainer(<span class=\"string\">&quot;listener1&quot;</span>).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;生产者生产消息&quot;</span>+i++);</span><br><span class=\"line\">        kafkaTemplate.send(<span class=\"string\">&quot;test&quot;</span>,<span class=\"string\">&quot;xxx&quot;</span>+i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"meta\">@KafkaListener( id = &quot;listener1&quot;,topics = &quot;test&quot;,autoStartup =&quot;false&quot; )</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testStart</span><span class=\"params\">(ConsumerRecord&lt;?, String&gt; record)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(record.value());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过观察窗口输出就能看到，生产者生产了20条数据后消费者监听器才开始启动消费。</p>\n<h2 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h2><p>kafka 消费者可以将消费到的消息转发到指定的主题中去，比如一条消息需要经过多次流转加工才能走完整个业务流程，需要多个consumer来配合完成。<br>转发代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KafkaListener(topics = &quot;send-a&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SendTo(&quot;send-b&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sendTest0</span><span class=\"params\">(ConsumerRecord&lt;?, String&gt; record)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(record.value());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;转发消息&quot;</span>+record.value();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KafkaListener(topics = &quot;send-b&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendTest1</span><span class=\"params\">(ConsumerRecord&lt;?, String&gt; record)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(record.value());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/15 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">producerTest</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    kafkaTemplate.send(<span class=\"string\">&quot;send-a&quot;</span>,<span class=\"string\">&quot;xxxxxxxxxxxxxx&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"生产者获取消费者响应\"><a href=\"#生产者获取消费者响应\" class=\"headerlink\" title=\"生产者获取消费者响应\"></a>生产者获取消费者响应</h2><p>结合 <code>@sendTo注解</code> 和 <code>ReplyingKafkaTemplate</code> 类 生产者可以获取消费者消费消息的结果;<br>因为 ReplyingKafkaTemplate 是kafkaTemplate 的一个子类，当你往spring 容器注册 这个bean,<br>kafkaTemplate 的自动装配就会关闭，但是kafkaTemplate 是必须的，因此你需要把这两个bean 都手动注册上。<br>配置示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KafkaConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> NewTopic <span class=\"title\">topic2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NewTopic(<span class=\"string\">&quot;topic-kl&quot;</span>, <span class=\"number\">1</span>, (<span class=\"keyword\">short</span>) <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AdminClient <span class=\"title\">init</span><span class=\"params\">( KafkaProperties kafkaProperties)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> KafkaAdminClient.create(kafkaProperties.buildAdminProperties());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 同步的kafka需要ReplyingKafkaTemplate,指定repliesContainer</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> producerFactory</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> repliesContainer</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ReplyingKafkaTemplate&lt;String, String, String&gt; <span class=\"title\">replyingTemplate</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProducerFactory&lt;String, String&gt; producerFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ConcurrentMessageListenerContainer&lt;String, String&gt; repliesContainer)</span> </span>&#123;</span><br><span class=\"line\">        ReplyingKafkaTemplate template = <span class=\"keyword\">new</span> ReplyingKafkaTemplate&lt;&gt;(producerFactory, repliesContainer);</span><br><span class=\"line\">        <span class=\"comment\">//同步相应超时时间：10s</span></span><br><span class=\"line\">        template.setReplyTimeout(<span class=\"number\">10000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProducerFactory&lt;String,String&gt; <span class=\"title\">producerFactory</span><span class=\"params\">(KafkaProperties properties)</span> </span>&#123;</span><br><span class=\"line\">        DefaultKafkaProducerFactory&lt;String, String&gt; producerFactory = <span class=\"keyword\">new</span> DefaultKafkaProducerFactory&lt;&gt;(properties.buildProducerProperties());</span><br><span class=\"line\">        producerFactory.setTransactionIdPrefix(properties.getProducer().getTransactionIdPrefix());</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  producerFactory;</span><br><span class=\"line\"><span class=\"comment\">//        return new DefaultKafkaProducerFactory&lt;&gt;(properties.producerConfigs(properties));</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, Object&gt; <span class=\"title\">producerConfigs</span><span class=\"params\">(KafkaProperties properties)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; props = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//用于建立与kafka集群的连接，这个list仅仅影响用于初始化的hosts，来发现全部的servers。 格式：host1:port1,host2:port2,…，</span></span><br><span class=\"line\">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,String.join(<span class=\"string\">&quot;,&quot;</span>,properties.getBootstrapServers()));</span><br><span class=\"line\">        <span class=\"comment\">// 重试次数</span></span><br><span class=\"line\">        props.put(ProducerConfig.RETRIES_CONFIG, <span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Producer可以将发往同一个Partition的数据做成一个Produce Request发送请求以减少请求次数，该值即为每次批处理的大小,若将该值设为0，则不会进行批处理</span></span><br><span class=\"line\">        props.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class=\"number\">16384</span>);</span><br><span class=\"line\">        <span class=\"comment\">// Producer可以用来缓存数据的内存大小。该值实际为RecordAccumulator类中的BufferPool，即Producer所管理的最大内存。</span></span><br><span class=\"line\">        props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class=\"number\">33554432</span>);</span><br><span class=\"line\">        <span class=\"comment\">//发送一次message最大大小，默认是1M</span></span><br><span class=\"line\">        <span class=\"comment\">//props.put(ProducerConfig.MAX_REQUEST_SIZE_CONFIG, 20971520);</span></span><br><span class=\"line\">        <span class=\"comment\">// 序列化器</span></span><br><span class=\"line\">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class=\"line\">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> props;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定consumer返回数据到指定的topic</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ConcurrentMessageListenerContainer&lt;String, String&gt;</span><br><span class=\"line\">    repliesContainer(ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; containerFactory) &#123;</span><br><span class=\"line\">        ConcurrentMessageListenerContainer&lt;String, String&gt; repliesContainer =</span><br><span class=\"line\">            containerFactory.createContainer(<span class=\"string\">&quot;topic-return&quot;</span>);</span><br><span class=\"line\">        repliesContainer.setAutoStartup(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> repliesContainer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"comment\">//    @ConditionalOnMissingBean(KafkaTemplate.class)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> KafkaTemplate&lt;?, ?&gt; kafkaTemplate(ProducerFactory&lt;String, String&gt; kafkaProducerFactory,</span><br><span class=\"line\">                                             ObjectProvider&lt;RecordMessageConverter&gt; messageConverter,KafkaProperties properties) &#123;</span><br><span class=\"line\">        KafkaTemplate&lt;String, String&gt; kafkaTemplate = <span class=\"keyword\">new</span> KafkaTemplate&lt;&gt;(kafkaProducerFactory);</span><br><span class=\"line\">        messageConverter.ifUnique(kafkaTemplate::setMessageConverter);</span><br><span class=\"line\">        kafkaTemplate.setProducerListener( <span class=\"keyword\">new</span> LoggingProducerListener&lt;&gt;());</span><br><span class=\"line\">        kafkaTemplate.setDefaultTopic(properties.getTemplate().getDefaultTopic());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> kafkaTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生产者接收消费者返回值（这俩最好不要开到一个应用中，否则会很容易生产者超时，观察不到返回的结果）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Scheduled(cron = &quot;*/1 * * * * ?&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">returnTestProducer</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ProducerRecord&lt;String, String&gt; record = <span class=\"keyword\">new</span> ProducerRecord&lt;&gt;(<span class=\"string\">&quot;topic-return&quot;</span>, <span class=\"string\">&quot;test-return&quot;</span>);</span><br><span class=\"line\">    RequestReplyFuture&lt;String, String, String&gt; replyFuture = replyingTemplate.sendAndReceive(record);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        String value = replyFuture.get().value();</span><br><span class=\"line\">        System.out.println(value);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@KafkaListener(topics = &quot;topic-return&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SendTo</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">listen</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;consumer return:&quot;</span>.concat(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"流控组件-sentinel","date":"2021-07-25T03:51:42.000Z","_content":"\n## sentinel介绍\nsentinel 是阿里开源的流量控制，熔断降级，系统负载保护的一个Java组件；\n\nSentinel 分为两个部分:\n核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。\n控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。\n\n[sentinel 官方文档点击这里](https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D)\n\n## 快速开始\n我们这里还是以springboot 项目写一个demo，创建完成springboot 项目之后pom中引入依赖：\n\n```pom\n<dependency>\n    <groupId>com.alibaba.csp</groupId>\n    <artifactId>sentinel-core</artifactId>\n    <version>1.8.1</version>\n</dependency>\n```\n然后定义流控规则并加载到内存：\n```java\n\n@Configuration\npublic class SentileConfig {\n\n\n    @PostConstruct\n    private void initRules() throws Exception {\n        FlowRule rule1 = new FlowRule();\n        rule1.setResource(\"test.hello\");\n        rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);\n        rule1.setCount(1);   // 每秒调用最大次数为 1 次\n        List<FlowRule> rules = new ArrayList<>();\n        rules.add(rule1);\n        // 将控制规则载入到 Sentinel\n        com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager.loadRules(rules);\n    }\n}\n```\n\n然后创建 `controller` 并定义资源：\n\n```java\n\n@RestController\npublic class TestController {\n   \n\n    @GetMapping(\"/test0\")\n    public String test0(){\n        try {\n            Entry resourceName = SphU.entry(\"test.hello\");\n            return resourceName.toString();\n        } catch (BlockException e) {\n            e.printStackTrace();\n            return \"error\";\n        }\n    }\n}\n\n```\n\n然后我们启动项目并访问 `http://localhost:8081/test0` 然后不断的刷新，就会发现如果刷新频率超过一秒就会返回error 否则会返回一个时间戳。\n这里这些类的api和源码我们先不介绍，只对其功能先做一个大致的体验。\n\n接下来我们继续引入依赖：\n```xml\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-annotation-aspectj</artifactId>\n            <version>1.8.1</version>\n        </dependency>\n```\n\n同时注入一个切面到springboot 中去：\n\n```java\n    @Bean\n    public SentinelResourceAspect sentinelResourceAspect() {\n        return new SentinelResourceAspect();\n    }\n\n```\n\n这个时候我们就可以通过注解去做流量控制了，写一个接口测试一下：\n\n```java\n    @GetMapping(\"/test\")\n    @SentinelResource(value = \"test.hello\")\n    public String test(){\n        return \"success\";\n    }\n\n```\n\n同样通过浏览器访问这个接口并不断刷新，会发现会频率过快的时候会返回 springboot 的错误页面，这是因为当aop切面会抛出 `BlockException`，当没有对应的\n异常处理器的时候springboot就会返回默认错误页面。这个时候我们有两种方式处理我们超出访问频率的时候的逻辑。\n\n第一种，加降级方法：\n\n```java\n @GetMapping(\"/test\")\n    @SentinelResource(value = \"test.hello\",fallback = \"testFallback\")\n    public String test(){\n        return \"success\";\n    }\n    \n    public String testFallback() {\n        return \"xxx\";\n    }\n\n```\n\n第二种，加`BlockException`异常处理器：\n\n```java\n\n@ControllerAdvice\npublic class ExceptionHandlerConfig {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @ExceptionHandler(BlockException.class)\n    @ResponseBody\n    public ResultWrapper sentinelBlockHandler(BlockException e) {\n        logger.warn(\"Blocked by Sentinel: {}\", e.getRule());\n        // Return the customized result.\n        return \"error\";\n    }\n}\n\n```\n\n\n## 对所有controller 层做流控\n`sentinel` 还提供了 spring-mvc 的拦截器，配置该拦截器你可以对你项目的所有所有请求进行流控管理，首先我们需要引入依赖：\n```xml\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-spring-webmvc-adapter</artifactId>\n            <version>1.8.1</version>\n        </dependency>\n```\n\n然后注入一个sentinel 的拦截器：\n```java\n@Configuration\npublic class SimpleWebmvcConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 注冊sentinel 拦截器\n        SentinelWebMvcConfig config = new SentinelWebMvcConfig();\n        config.setHttpMethodSpecify(true);\n        config.setWebContextUnify(true);\n        config.setBlockExceptionHandler(new SimpleBlockExceptionHandler());\n        registry.addInterceptor(new SentinelWebInterceptor(config)).addPathPatterns(\"/**\");\n    }\n}\n```\n\n代码中 `SimpleBlockExceptionHandler` 是自定义流控异常处理器，作用是处理流控异常 `BlockException` 源码如下：\n```java\n\npublic class SimpleBlockExceptionHandler implements BlockExceptionHandler {\n    @Override\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws Exception {\n        httpServletResponse.setContentType(\"application/json\");\n        PrintWriter out = httpServletResponse.getWriter();\n        out.print(\"{\\\"code\\\":500}\");\n        out.flush();\n        out.close();\n    }\n}\n```\n`SentinelWebMvcConfig` 是流控配置类，通过其属性命名就不难猜出其作用 `isHttpMethodSpecify` 是否区分请求方式；\n`isWebContextUnify`是否使用统一web上下文； `UrlCleaner` 是url清理器，作用是对url进行整理\n\n## 接入控制台\n`sentinel` 为我们提供了一个控制台应用，通过这个控制台我们可以直观的看到流控数据，动态的修改流控规则，下面让我们看看如何接入控制台。\n\n首先引入依赖：\n\n```xml\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-transport-simple-http</artifactId>\n            <version>1.8.1</version>\n        </dependency>\n```\n\n这个依赖sentinel连接 控制端的通讯包。\n\n然后添加配置：\n```properties\ncsp.sentinel.dashboard.server=localhost:8080\n```\n\n注意，因为这个配置项不是属于 springboot的 所以不能添加在application中，要通过 -D 的方式在jvm启动的时候添加这个配置项。\n\n再去 [sentinel的github](https://github.com/alibaba/Sentinel/releases) 下载 控制台jar包 ，启动该jar包；访问8080 端口，\n登录账号密码和密码都是 sentinel。这个控制台实际上是一个springboot应用，启动端口和账号密码都可以通过application 修改。\n接下来，启动我们自己的应用，并访问一些接口，我们就能再界面上看到监控数据：\n![sentinel-dashboard](sentinel-1.jpg)\n\n通过控制台我们可以监控流量，管理流控降级等规则，这些规则都是存储在我们程序应用的内存中的，因此我们还需要学会这些规则的配置使用及其持久化。\n\nsentinel 官方还提供了 springcloud 的包，可以让我们很方便的在 spring cloud 项目中使用sentinel，springcloud 中使用 sentinel和 springboot\n中使用sentinel方式差不多，只是多了一个链路调用；因此我们要先学会了如何在 springboot中使用它。","source":"_posts/流控组件-sentinel.md","raw":"---\ntitle: 流控组件-sentinel\ndate: 2021-07-25 11:51:42\ntags: 中间件\n---\n\n## sentinel介绍\nsentinel 是阿里开源的流量控制，熔断降级，系统负载保护的一个Java组件；\n\nSentinel 分为两个部分:\n核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。\n控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。\n\n[sentinel 官方文档点击这里](https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D)\n\n## 快速开始\n我们这里还是以springboot 项目写一个demo，创建完成springboot 项目之后pom中引入依赖：\n\n```pom\n<dependency>\n    <groupId>com.alibaba.csp</groupId>\n    <artifactId>sentinel-core</artifactId>\n    <version>1.8.1</version>\n</dependency>\n```\n然后定义流控规则并加载到内存：\n```java\n\n@Configuration\npublic class SentileConfig {\n\n\n    @PostConstruct\n    private void initRules() throws Exception {\n        FlowRule rule1 = new FlowRule();\n        rule1.setResource(\"test.hello\");\n        rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);\n        rule1.setCount(1);   // 每秒调用最大次数为 1 次\n        List<FlowRule> rules = new ArrayList<>();\n        rules.add(rule1);\n        // 将控制规则载入到 Sentinel\n        com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager.loadRules(rules);\n    }\n}\n```\n\n然后创建 `controller` 并定义资源：\n\n```java\n\n@RestController\npublic class TestController {\n   \n\n    @GetMapping(\"/test0\")\n    public String test0(){\n        try {\n            Entry resourceName = SphU.entry(\"test.hello\");\n            return resourceName.toString();\n        } catch (BlockException e) {\n            e.printStackTrace();\n            return \"error\";\n        }\n    }\n}\n\n```\n\n然后我们启动项目并访问 `http://localhost:8081/test0` 然后不断的刷新，就会发现如果刷新频率超过一秒就会返回error 否则会返回一个时间戳。\n这里这些类的api和源码我们先不介绍，只对其功能先做一个大致的体验。\n\n接下来我们继续引入依赖：\n```xml\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-annotation-aspectj</artifactId>\n            <version>1.8.1</version>\n        </dependency>\n```\n\n同时注入一个切面到springboot 中去：\n\n```java\n    @Bean\n    public SentinelResourceAspect sentinelResourceAspect() {\n        return new SentinelResourceAspect();\n    }\n\n```\n\n这个时候我们就可以通过注解去做流量控制了，写一个接口测试一下：\n\n```java\n    @GetMapping(\"/test\")\n    @SentinelResource(value = \"test.hello\")\n    public String test(){\n        return \"success\";\n    }\n\n```\n\n同样通过浏览器访问这个接口并不断刷新，会发现会频率过快的时候会返回 springboot 的错误页面，这是因为当aop切面会抛出 `BlockException`，当没有对应的\n异常处理器的时候springboot就会返回默认错误页面。这个时候我们有两种方式处理我们超出访问频率的时候的逻辑。\n\n第一种，加降级方法：\n\n```java\n @GetMapping(\"/test\")\n    @SentinelResource(value = \"test.hello\",fallback = \"testFallback\")\n    public String test(){\n        return \"success\";\n    }\n    \n    public String testFallback() {\n        return \"xxx\";\n    }\n\n```\n\n第二种，加`BlockException`异常处理器：\n\n```java\n\n@ControllerAdvice\npublic class ExceptionHandlerConfig {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @ExceptionHandler(BlockException.class)\n    @ResponseBody\n    public ResultWrapper sentinelBlockHandler(BlockException e) {\n        logger.warn(\"Blocked by Sentinel: {}\", e.getRule());\n        // Return the customized result.\n        return \"error\";\n    }\n}\n\n```\n\n\n## 对所有controller 层做流控\n`sentinel` 还提供了 spring-mvc 的拦截器，配置该拦截器你可以对你项目的所有所有请求进行流控管理，首先我们需要引入依赖：\n```xml\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-spring-webmvc-adapter</artifactId>\n            <version>1.8.1</version>\n        </dependency>\n```\n\n然后注入一个sentinel 的拦截器：\n```java\n@Configuration\npublic class SimpleWebmvcConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        // 注冊sentinel 拦截器\n        SentinelWebMvcConfig config = new SentinelWebMvcConfig();\n        config.setHttpMethodSpecify(true);\n        config.setWebContextUnify(true);\n        config.setBlockExceptionHandler(new SimpleBlockExceptionHandler());\n        registry.addInterceptor(new SentinelWebInterceptor(config)).addPathPatterns(\"/**\");\n    }\n}\n```\n\n代码中 `SimpleBlockExceptionHandler` 是自定义流控异常处理器，作用是处理流控异常 `BlockException` 源码如下：\n```java\n\npublic class SimpleBlockExceptionHandler implements BlockExceptionHandler {\n    @Override\n    public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws Exception {\n        httpServletResponse.setContentType(\"application/json\");\n        PrintWriter out = httpServletResponse.getWriter();\n        out.print(\"{\\\"code\\\":500}\");\n        out.flush();\n        out.close();\n    }\n}\n```\n`SentinelWebMvcConfig` 是流控配置类，通过其属性命名就不难猜出其作用 `isHttpMethodSpecify` 是否区分请求方式；\n`isWebContextUnify`是否使用统一web上下文； `UrlCleaner` 是url清理器，作用是对url进行整理\n\n## 接入控制台\n`sentinel` 为我们提供了一个控制台应用，通过这个控制台我们可以直观的看到流控数据，动态的修改流控规则，下面让我们看看如何接入控制台。\n\n首先引入依赖：\n\n```xml\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-transport-simple-http</artifactId>\n            <version>1.8.1</version>\n        </dependency>\n```\n\n这个依赖sentinel连接 控制端的通讯包。\n\n然后添加配置：\n```properties\ncsp.sentinel.dashboard.server=localhost:8080\n```\n\n注意，因为这个配置项不是属于 springboot的 所以不能添加在application中，要通过 -D 的方式在jvm启动的时候添加这个配置项。\n\n再去 [sentinel的github](https://github.com/alibaba/Sentinel/releases) 下载 控制台jar包 ，启动该jar包；访问8080 端口，\n登录账号密码和密码都是 sentinel。这个控制台实际上是一个springboot应用，启动端口和账号密码都可以通过application 修改。\n接下来，启动我们自己的应用，并访问一些接口，我们就能再界面上看到监控数据：\n![sentinel-dashboard](sentinel-1.jpg)\n\n通过控制台我们可以监控流量，管理流控降级等规则，这些规则都是存储在我们程序应用的内存中的，因此我们还需要学会这些规则的配置使用及其持久化。\n\nsentinel 官方还提供了 springcloud 的包，可以让我们很方便的在 spring cloud 项目中使用sentinel，springcloud 中使用 sentinel和 springboot\n中使用sentinel方式差不多，只是多了一个链路调用；因此我们要先学会了如何在 springboot中使用它。","slug":"流控组件-sentinel","published":1,"updated":"2021-07-26T04:28:01.354Z","_id":"ckrio0f1g0000u0qkgwzzgrqi","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"sentinel介绍\"><a href=\"#sentinel介绍\" class=\"headerlink\" title=\"sentinel介绍\"></a>sentinel介绍</h2><p>sentinel 是阿里开源的流量控制，熔断降级，系统负载保护的一个Java组件；</p>\n<p>Sentinel 分为两个部分:<br>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。<br>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</p>\n<p><a href=\"https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D\">sentinel 官方文档点击这里</a></p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><p>我们这里还是以springboot 项目写一个demo，创建完成springboot 项目之后pom中引入依赖：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.8.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>然后定义流控规则并加载到内存：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SentileConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initRules</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        FlowRule rule1 = <span class=\"keyword\">new</span> FlowRule();</span><br><span class=\"line\">        rule1.setResource(<span class=\"string\">&quot;test.hello&quot;</span>);</span><br><span class=\"line\">        rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class=\"line\">        rule1.setCount(<span class=\"number\">1</span>);   <span class=\"comment\">// 每秒调用最大次数为 1 次</span></span><br><span class=\"line\">        List&lt;FlowRule&gt; rules = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        rules.add(rule1);</span><br><span class=\"line\">        <span class=\"comment\">// 将控制规则载入到 Sentinel</span></span><br><span class=\"line\">        com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager.loadRules(rules);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后创建 <code>controller</code> 并定义资源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/test0&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test0</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Entry resourceName = SphU.entry(<span class=\"string\">&quot;test.hello&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> resourceName.toString();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BlockException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;error&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后我们启动项目并访问 <code>http://localhost:8081/test0</code> 然后不断的刷新，就会发现如果刷新频率超过一秒就会返回error 否则会返回一个时间戳。<br>这里这些类的api和源码我们先不介绍，只对其功能先做一个大致的体验。</p>\n<p>接下来我们继续引入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>同时注入一个切面到springboot 中去：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SentinelResourceAspect <span class=\"title\">sentinelResourceAspect</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SentinelResourceAspect();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这个时候我们就可以通过注解去做流量控制了，写一个接口测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/test&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SentinelResource(value = &quot;test.hello&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同样通过浏览器访问这个接口并不断刷新，会发现会频率过快的时候会返回 springboot 的错误页面，这是因为当aop切面会抛出 <code>BlockException</code>，当没有对应的<br>异常处理器的时候springboot就会返回默认错误页面。这个时候我们有两种方式处理我们超出访问频率的时候的逻辑。</p>\n<p>第一种，加降级方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">   <span class=\"meta\">@SentinelResource(value = &quot;test.hello&quot;,fallback = &quot;testFallback&quot;)</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">testFallback</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>第二种，加<code>BlockException</code>异常处理器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionHandlerConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Logger logger = LoggerFactory.getLogger(<span class=\"keyword\">this</span>.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(BlockException.class)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultWrapper <span class=\"title\">sentinelBlockHandler</span><span class=\"params\">(BlockException e)</span> </span>&#123;</span><br><span class=\"line\">        logger.warn(<span class=\"string\">&quot;Blocked by Sentinel: &#123;&#125;&quot;</span>, e.getRule());</span><br><span class=\"line\">        <span class=\"comment\">// Return the customized result.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;error&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"对所有controller-层做流控\"><a href=\"#对所有controller-层做流控\" class=\"headerlink\" title=\"对所有controller 层做流控\"></a>对所有controller 层做流控</h2><p><code>sentinel</code> 还提供了 spring-mvc 的拦截器，配置该拦截器你可以对你项目的所有所有请求进行流控管理，首先我们需要引入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-spring-webmvc-adapter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后注入一个sentinel 的拦截器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleWebmvcConfig</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebMvcConfigurer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注冊sentinel 拦截器</span></span><br><span class=\"line\">        SentinelWebMvcConfig config = <span class=\"keyword\">new</span> SentinelWebMvcConfig();</span><br><span class=\"line\">        config.setHttpMethodSpecify(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        config.setWebContextUnify(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        config.setBlockExceptionHandler(<span class=\"keyword\">new</span> SimpleBlockExceptionHandler());</span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> SentinelWebInterceptor(config)).addPathPatterns(<span class=\"string\">&quot;/**&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码中 <code>SimpleBlockExceptionHandler</code> 是自定义流控异常处理器，作用是处理流控异常 <code>BlockException</code> 源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleBlockExceptionHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">BlockExceptionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        httpServletResponse.setContentType(<span class=\"string\">&quot;application/json&quot;</span>);</span><br><span class=\"line\">        PrintWriter out = httpServletResponse.getWriter();</span><br><span class=\"line\">        out.print(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:500&#125;&quot;</span>);</span><br><span class=\"line\">        out.flush();</span><br><span class=\"line\">        out.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SentinelWebMvcConfig</code> 是流控配置类，通过其属性命名就不难猜出其作用 <code>isHttpMethodSpecify</code> 是否区分请求方式；<br><code>isWebContextUnify</code>是否使用统一web上下文； <code>UrlCleaner</code> 是url清理器，作用是对url进行整理</p>\n<h2 id=\"接入控制台\"><a href=\"#接入控制台\" class=\"headerlink\" title=\"接入控制台\"></a>接入控制台</h2><p><code>sentinel</code> 为我们提供了一个控制台应用，通过这个控制台我们可以直观的看到流控数据，动态的修改流控规则，下面让我们看看如何接入控制台。</p>\n<p>首先引入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个依赖sentinel连接 控制端的通讯包。</p>\n<p>然后添加配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">csp.sentinel.dashboard.server</span>=<span class=\"string\">localhost:8080</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，因为这个配置项不是属于 springboot的 所以不能添加在application中，要通过 -D 的方式在jvm启动的时候添加这个配置项。</p>\n<p>再去 <a href=\"https://github.com/alibaba/Sentinel/releases\">sentinel的github</a> 下载 控制台jar包 ，启动该jar包；访问8080 端口，<br>登录账号密码和密码都是 sentinel。这个控制台实际上是一个springboot应用，启动端口和账号密码都可以通过application 修改。<br>接下来，启动我们自己的应用，并访问一些接口，我们就能再界面上看到监控数据：<br><img src=\"sentinel-1.jpg\" alt=\"sentinel-dashboard\"></p>\n<p>通过控制台我们可以监控流量，管理流控降级等规则，这些规则都是存储在我们程序应用的内存中的，因此我们还需要学会这些规则的配置使用及其持久化。</p>\n<p>sentinel 官方还提供了 springcloud 的包，可以让我们很方便的在 spring cloud 项目中使用sentinel，springcloud 中使用 sentinel和 springboot<br>中使用sentinel方式差不多，只是多了一个链路调用；因此我们要先学会了如何在 springboot中使用它。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"sentinel介绍\"><a href=\"#sentinel介绍\" class=\"headerlink\" title=\"sentinel介绍\"></a>sentinel介绍</h2><p>sentinel 是阿里开源的流量控制，熔断降级，系统负载保护的一个Java组件；</p>\n<p>Sentinel 分为两个部分:<br>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。<br>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</p>\n<p><a href=\"https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D\">sentinel 官方文档点击这里</a></p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><p>我们这里还是以springboot 项目写一个demo，创建完成springboot 项目之后pom中引入依赖：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.8.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>然后定义流控规则并加载到内存：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SentileConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initRules</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        FlowRule rule1 = <span class=\"keyword\">new</span> FlowRule();</span><br><span class=\"line\">        rule1.setResource(<span class=\"string\">&quot;test.hello&quot;</span>);</span><br><span class=\"line\">        rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class=\"line\">        rule1.setCount(<span class=\"number\">1</span>);   <span class=\"comment\">// 每秒调用最大次数为 1 次</span></span><br><span class=\"line\">        List&lt;FlowRule&gt; rules = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        rules.add(rule1);</span><br><span class=\"line\">        <span class=\"comment\">// 将控制规则载入到 Sentinel</span></span><br><span class=\"line\">        com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager.loadRules(rules);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后创建 <code>controller</code> 并定义资源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/test0&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test0</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Entry resourceName = SphU.entry(<span class=\"string\">&quot;test.hello&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> resourceName.toString();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BlockException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;error&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后我们启动项目并访问 <code>http://localhost:8081/test0</code> 然后不断的刷新，就会发现如果刷新频率超过一秒就会返回error 否则会返回一个时间戳。<br>这里这些类的api和源码我们先不介绍，只对其功能先做一个大致的体验。</p>\n<p>接下来我们继续引入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>同时注入一个切面到springboot 中去：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SentinelResourceAspect <span class=\"title\">sentinelResourceAspect</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SentinelResourceAspect();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这个时候我们就可以通过注解去做流量控制了，写一个接口测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/test&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SentinelResource(value = &quot;test.hello&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>同样通过浏览器访问这个接口并不断刷新，会发现会频率过快的时候会返回 springboot 的错误页面，这是因为当aop切面会抛出 <code>BlockException</code>，当没有对应的<br>异常处理器的时候springboot就会返回默认错误页面。这个时候我们有两种方式处理我们超出访问频率的时候的逻辑。</p>\n<p>第一种，加降级方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">   <span class=\"meta\">@SentinelResource(value = &quot;test.hello&quot;,fallback = &quot;testFallback&quot;)</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">testFallback</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">&quot;xxx&quot;</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>第二种，加<code>BlockException</code>异常处理器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionHandlerConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Logger logger = LoggerFactory.getLogger(<span class=\"keyword\">this</span>.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(BlockException.class)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResultWrapper <span class=\"title\">sentinelBlockHandler</span><span class=\"params\">(BlockException e)</span> </span>&#123;</span><br><span class=\"line\">        logger.warn(<span class=\"string\">&quot;Blocked by Sentinel: &#123;&#125;&quot;</span>, e.getRule());</span><br><span class=\"line\">        <span class=\"comment\">// Return the customized result.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;error&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"对所有controller-层做流控\"><a href=\"#对所有controller-层做流控\" class=\"headerlink\" title=\"对所有controller 层做流控\"></a>对所有controller 层做流控</h2><p><code>sentinel</code> 还提供了 spring-mvc 的拦截器，配置该拦截器你可以对你项目的所有所有请求进行流控管理，首先我们需要引入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-spring-webmvc-adapter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后注入一个sentinel 的拦截器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleWebmvcConfig</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebMvcConfigurer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注冊sentinel 拦截器</span></span><br><span class=\"line\">        SentinelWebMvcConfig config = <span class=\"keyword\">new</span> SentinelWebMvcConfig();</span><br><span class=\"line\">        config.setHttpMethodSpecify(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        config.setWebContextUnify(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        config.setBlockExceptionHandler(<span class=\"keyword\">new</span> SimpleBlockExceptionHandler());</span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> SentinelWebInterceptor(config)).addPathPatterns(<span class=\"string\">&quot;/**&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码中 <code>SimpleBlockExceptionHandler</code> 是自定义流控异常处理器，作用是处理流控异常 <code>BlockException</code> 源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleBlockExceptionHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">BlockExceptionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        httpServletResponse.setContentType(<span class=\"string\">&quot;application/json&quot;</span>);</span><br><span class=\"line\">        PrintWriter out = httpServletResponse.getWriter();</span><br><span class=\"line\">        out.print(<span class=\"string\">&quot;&#123;\\&quot;code\\&quot;:500&#125;&quot;</span>);</span><br><span class=\"line\">        out.flush();</span><br><span class=\"line\">        out.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>SentinelWebMvcConfig</code> 是流控配置类，通过其属性命名就不难猜出其作用 <code>isHttpMethodSpecify</code> 是否区分请求方式；<br><code>isWebContextUnify</code>是否使用统一web上下文； <code>UrlCleaner</code> 是url清理器，作用是对url进行整理</p>\n<h2 id=\"接入控制台\"><a href=\"#接入控制台\" class=\"headerlink\" title=\"接入控制台\"></a>接入控制台</h2><p><code>sentinel</code> 为我们提供了一个控制台应用，通过这个控制台我们可以直观的看到流控数据，动态的修改流控规则，下面让我们看看如何接入控制台。</p>\n<p>首先引入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个依赖sentinel连接 控制端的通讯包。</p>\n<p>然后添加配置：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">csp.sentinel.dashboard.server</span>=<span class=\"string\">localhost:8080</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，因为这个配置项不是属于 springboot的 所以不能添加在application中，要通过 -D 的方式在jvm启动的时候添加这个配置项。</p>\n<p>再去 <a href=\"https://github.com/alibaba/Sentinel/releases\">sentinel的github</a> 下载 控制台jar包 ，启动该jar包；访问8080 端口，<br>登录账号密码和密码都是 sentinel。这个控制台实际上是一个springboot应用，启动端口和账号密码都可以通过application 修改。<br>接下来，启动我们自己的应用，并访问一些接口，我们就能再界面上看到监控数据：<br><img src=\"sentinel-1.jpg\" alt=\"sentinel-dashboard\"></p>\n<p>通过控制台我们可以监控流量，管理流控降级等规则，这些规则都是存储在我们程序应用的内存中的，因此我们还需要学会这些规则的配置使用及其持久化。</p>\n<p>sentinel 官方还提供了 springcloud 的包，可以让我们很方便的在 spring cloud 项目中使用sentinel，springcloud 中使用 sentinel和 springboot<br>中使用sentinel方式差不多，只是多了一个链路调用；因此我们要先学会了如何在 springboot中使用它。</p>\n"},{"title":"sentinel 持久化","date":"2021-07-26T04:23:21.000Z","_content":"\n我们之前配置的流控规则都是存储在应用的内存中的，这种方式明显无法满足我们实际开发的需求，一旦项目被重启，流控规则就被初始化了，需要我们再次去重新配置，因此规则的持久化就显得很有必要了。\n\n本节会介绍几类主流持久化方式并对自定义持久化做介绍\n\n### 文件持久化\n\n文件持久化是通过 sentinel spi 扩展点来加载本地文件中的持久化数据到内存中，它依赖接口 `InitFunc`，对于非spring项目这种方式可以很便捷的实现\n文件持久化。\n\n实现文件持久化首先要自定义一个类并实现`InitFunc` 接口：\n\n```java\n\npublic class MyflieInitFunc implements InitFunc {\n    @Override\n    public void init() throws Exception {\n        URL resource = MyflieInitFunc.class.getClassLoader().getResource(\"\");\n        File file = new File(resource.getPath()+\"/config/flow.json\");\n        File fileParent = file.getParentFile();\n        if(!fileParent.exists()){\n            fileParent.mkdirs();\n        }\n        if (!file.exists()){\n            file.createNewFile();\n        }\n        ReadableDataSource<String, List<FlowRule>> flowReadDataSource = new FileRefreshableDataSource<>(\n            resource.getPath()+\"/config/flow.json\",\n            source -> JSON.parseObject(\n                source,\n                new TypeReference<List<FlowRule>>() {\n                }\n            ));\n        FlowRuleManager.register2Property(flowReadDataSource.getProperty());\n        WritableDataSource<List<FlowRule>> flowWriteDataSource = new FileWritableDataSource<>(\n            resource.getPath()+\"/config/flow.json\",\n            t->JSON.toJSONString(t)\n        );\n        WritableDataSourceRegistry.registerFlowDataSource(flowWriteDataSource);\n    }\n}\n```\n\n然后在resources 文件夹下新建文件 `META-INF\\services\\com.alibaba.csp.sentinel.init.InitFunc` \n内容为`MyflieInitFunc` 的类路径：\n```properties\ncom.muggle.sentinel.config.MyflieInitFunc\n```\n\n完成以上步骤后，文件持久化的方式就配置完成了。\n\n`InitFunc` 的资源初始化方法 `init()` 并不是在项目启动的时候调用的，而是在首次产生流控数据的时候调用的，\n也就是说它是一个懒加载的方法。\n在文件持久化配置中，`FileRefreshableDataSource` , `FileWritableDataSource` , `FlowRuleManager` 这三个类是有必要去熟识的。\n\n- FlowRuleManager 流控规则管理器，用于对流控规则的加载和管理，每类规则都有对应的管理器，后文会介绍。\n- FileRefreshableDataSource 流控规则读取及刷新的类，该类配置到sentinel中后会定时拉取流控文件中的流控规则\n- FileWritableDataSource 流控规则写入类，当我们在控制台编辑新的流控规则后，控制台会将规则推送给应用，应用接收到推送的规则后，\n会通过该类将数据写入流控文件中\n\n### `FlowRuleManager` 源码分析\n\n```java\n\npublic class FlowRuleManager {\n    private static final AtomicReference<Map<String, List<FlowRule>>> flowRules = new AtomicReference();\n    private static final FlowRuleManager.FlowPropertyListener LISTENER = new FlowRuleManager.FlowPropertyListener();\n    private static SentinelProperty<List<FlowRule>> currentProperty = new DynamicSentinelProperty();\n    private static final ScheduledExecutorService SCHEDULER = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"sentinel-metrics-record-task\", true));\n     \n    public static List<FlowRule> getRules() {\n       \n        List<FlowRule> rules = new ArrayList();\n        Iterator var1 = ((Map)flowRules.get()).entrySet().iterator();\n\n        while(var1.hasNext()) {\n            Entry<String, List<FlowRule>> entry = (Entry)var1.next();\n            rules.addAll((Collection)entry.getValue());\n        }\n\n        return rules;\n    }\n    \n    public static void loadRules(List<FlowRule> rules){\n         currentProperty.updateValue(rules);\n    }\n    \n     public static boolean hasConfig(String resource) {\n         return ((Map)flowRules.get()).containsKey(resource);\n    }\n}\n```\n该类的静态属性包括 流控规则数组 `flowRules` ，用于监控流控规则更新的监听器`LISTENER` , 轮询监听流控配置的线程池`SCHEDULER`,sentinel 配置类`currentProperty`.\n而它几个api也很明了，就是对流控规则的增删改查。\n\n### `FileRefreshableDataSource` 源码分析\n\n`FileRefreshableDataSource` 继承了`AutoRefreshDataSource`,而`AutoRefreshDataSource` 中有一个线程池 `service` 用于拉取 文件中存储的规则\n以及拉取间隔 `recommendRefreshMs` .\n：\n\n```java\n\npublic abstract class AutoRefreshDataSource<S, T> extends AbstractDataSource<S, T> {\n    private ScheduledExecutorService service;\n    protected long recommendRefreshMs = 3000L;\n\n    public AutoRefreshDataSource(Converter<S, T> configParser) {\n        super(configParser);\n        this.startTimerService();\n    }\n......\n     private void startTimerService() {\n            this.service = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"sentinel-datasource-auto-refresh-task\", true));\n            this.service.scheduleAtFixedRate(new Runnable() {\n                public void run() {\n                    try {\n                        if (!AutoRefreshDataSource.this.isModified()) {\n                            return;\n                        }\n    \n                        T newValue = AutoRefreshDataSource.this.loadConfig();\n                        AutoRefreshDataSource.this.getProperty().updateValue(newValue);\n                    } catch (Throwable var2) {\n                        RecordLog.info(\"loadConfig exception\", var2);\n                    }\n    \n                }\n            }, this.recommendRefreshMs, this.recommendRefreshMs, TimeUnit.MILLISECONDS);\n        }\n\n}\n```\n我们重点关注 `startTimerService` 这个方法,这个方法是在构造器里面调用的，也就是说当你new 一个 `FileRefreshableDataSource` 时就会调用该方法\n\n该方法就是通过线程池定时调用`isModified` 方法判断配置是否更新过，如果更新了就同步更新到父类属性 `SentinelProperty` 中，代码对应:\n\n```java\n AutoRefreshDataSource.this.getProperty().updateValue(newValue)\n```\n不难判读出，父类抽象类的`property` 属性才是真正的获取规则提供拦截判断的关键属性。后文也会用到这个知识点，这里记一下。\n\n我们可以看一下 `FileRefreshableDataSource` 构造函数：\n\n```java\n\n public FileRefreshableDataSource(File file, Converter<String, T> configParser) throws FileNotFoundException {\n        this(file, configParser, 3000L, 1048576, DEFAULT_CHAR_SET);\n    }\n\n    public FileRefreshableDataSource(String fileName, Converter<String, T> configParser) throws FileNotFoundException {\n        this(new File(fileName), configParser, 3000L, 1048576, DEFAULT_CHAR_SET);\n    }\n\n    public FileRefreshableDataSource(File file, Converter<String, T> configParser, int bufSize) throws FileNotFoundException {\n        this(file, configParser, 3000L, bufSize, DEFAULT_CHAR_SET);\n    }\n\n    public FileRefreshableDataSource(File file, Converter<String, T> configParser, Charset charset) throws FileNotFoundException {\n        this(file, configParser, 3000L, 1048576, charset);\n    }\n\n    public FileRefreshableDataSource(File file, Converter<String, T> configParser, long recommendRefreshMs, int bufSize, Charset charset) \n```\n\n不难看出，如果在 new `FileRefreshableDataSource` 时不指定刷新间隔就取默认值 3000 毫秒。\n\n### `FileWritableDataSource` 源码分析\n\n```java\n\npublic class FileWritableDataSource<T> implements WritableDataSource<T> {\n    private static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n    private final Converter<T, String> configEncoder;\n    private final File file;\n    private final Charset charset;\n    private final Lock lock;\n    \n    public void write(T value) throws Exception {\n        this.lock.lock();\n        try {\n            String convertResult = (String)this.configEncoder.convert(value);\n            FileOutputStream outputStream = null;\n\n            try {\n                outputStream = new FileOutputStream(this.file);\n                byte[] bytesArray = convertResult.getBytes(this.charset);\n                RecordLog.info(\"[FileWritableDataSource] Writing to file {}: {}\", new Object[]{this.file, convertResult});\n                outputStream.write(bytesArray);\n                outputStream.flush();\n            } finally {\n                if (outputStream != null) {\n                    try {\n                        outputStream.close();\n                    } catch (Exception var16) {\n                    }\n                }\n\n            }\n        } finally {\n            this.lock.unlock();\n        }\n    }\n}\n\n```\n代码结构也很了然，一个数据转换器，一个 file 一个lock ,当框架调用 `write` 方法时上锁并往 file中写配置。\n\n分析得差不多了，让我们看看实战效果吧；\n\n首先启动项目和控制台，然后在控制台上配置一个流控规则，可以观察到项目规则存储文件中多了点内容：\n![2](sentinel2.jpg)\n\n文件中新增的数据：\n\n```json\n[{\"clusterConfig\":{\"acquireRefuseStrategy\":0,\"clientOfflineTime\":2000,\"fallbackToLocalWhenFail\":true,\"resourceTimeout\":2000,\"resourceTimeoutStrategy\":0,\"sampleCount\":10,\"strategy\":0,\"thresholdType\":0,\"windowIntervalMs\":1000},\"clusterMode\":false,\"controlBehavior\":0,\"count\":1.0,\"grade\":1,\"limitApp\":\"default\",\"maxQueueingTimeMs\":500,\"resource\":\"test\",\"strategy\":0,\"warmUpPeriodSec\":10}]\n```\n\n我们重启项目和控制台规则也不会丢失，规则持久化生效。\n\n通过分析我们知道，这种持久化方式是一种拉模式，胜在配置简单，不需要外部数据源就能完成流控数据的持久化。由于规则是用 FileRefreshableDataSource 定时更新的，所以规则更新会有延迟。\n如果FileRefreshableDataSource定时时间过大，可能长时间延迟；如果FileRefreshableDataSource过小，又会影响性能；\n因为规则存储在本地文件，如果需要迁移微服务，那么需要把规则文件一起迁移，否则规则会丢失。\n\n文件持久化能应付我们需求的大部分场景，但对于微服务而言是不那么满足要求的；\n因为文件持久化就必定要求我们在服务器上提供一个用于存储配置文件的文件夹，而微服务项目大部分情况是容器部署，这就让文件持久化显得不那么好用了。\n\n为此，官方提供了自定义的持久化maven依赖：\n```xml\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-datasource-extension</artifactId>\n        </dependency>\n\n```\n以及在这个依赖的基础上开发的以CONSUL NACOS REDIS 作为数据源的maven 依赖：\n\n```xml\n        <dependency>\n            <artifactId>sentinel-datasource-consul</artifactId>\n            <groupId>com.alibaba.csp</groupId>\n        </dependency>\n        <dependency>\n            <artifactId>sentinel-datasource-redis</artifactId>\n            <groupId>com.alibaba.csp</groupId>\n        </dependency>\n\n        <dependency>\n            <artifactId>sentinel-datasource-nacos</artifactId>\n            <groupId>com.alibaba.csp</groupId>\n        </dependency>\n\n```\n### nacos持久化\n以上三种种持久化不同于文件持久化，它们是推模式的，而且迁移部署起来更为方便，符合微服务的特性。接下来我们就以nacos持久化为例来学习一下这种方式是怎么配置的。\n\n首先引入 nacos 相关依赖依赖：\n```xml\n\n        <dependency>\n            <artifactId>sentinel-datasource-nacos</artifactId>\n            <groupId>com.alibaba.csp</groupId>\n        </dependency>\n```\n然后通过`FlowRuleManager` 注册数据源就ok了\n```java\n        ReadableDataSource<String, List<FlowRule>> flowRuleDataSource = new NacosDataSource<>(remoteAddress, groupId, dataId,\n            source -> JSON.parseObject(source, new TypeReference<List<FlowRule>>() {\n            }));\n        FlowRuleManager.register2Property(flowRuleDataSource.getProperty());\n```\nremoteAddress 是nacos 的地址； groupId和dataId均为nacos配置中心的属性，在创建配置项的时候由使用者自定义，如图为在nacos创建配置项的截图：\n\n![3](sentinel3.jpg)\n\n\n启动nacos，启动我们的项目和控制台，然后修改nacos中的配置项，就能再控制台上观测到规则变化，nacos中存储的规则也是json,我们可以把文件持久化教程中产生json\n复制进去，这里就不在赘述。\n\n这种模式是推模式，优点是这种方式有更好的实时性和一致性保证。因为我们和文件持久化比起来少注册了一个与`FileWritableDataSource` 对应的类，\n也就是说应用中更新的规则不能反写到nacos,只能通过nacos读取到配置；因此我们在控制台上修改的规则也不会持久化到nacos中。这样设计是合理的，因为nacos作为\n配置中心不应该允许应用去反写自己的配置。\n\n## 源码分析\n\n因为文件持久化分析了一部分源码，因此这里不会对源码分析太多，只简单的介绍它是如何去读取到配置的。\n\n\n```java\n\npublic class NacosDataSource<T> extends AbstractDataSource<String, T> {\n\n    private static final int DEFAULT_TIMEOUT = 3000;\n    private final ExecutorService pool;\n    private final Listener configListener;\n    private final String groupId;\n    private final String dataId;\n    private final Properties properties;\n    private ConfigService configService;\n\n    public NacosDataSource(final Properties properties, final String groupId, final String dataId, Converter<String, T> parser) {\n        super(parser);\n        this.pool = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue(1), new NamedThreadFactory(\"sentinel-nacos-ds-update\"), new DiscardOldestPolicy());\n        this.configService = null;\n        if (!StringUtil.isBlank(groupId) && !StringUtil.isBlank(dataId)) {\n            AssertUtil.notNull(properties, \"Nacos properties must not be null, you could put some keys from PropertyKeyConst\");\n            this.groupId = groupId;\n            this.dataId = dataId;\n            this.properties = properties;\n            this.configListener = new Listener() {\n                public Executor getExecutor() {\n                    return NacosDataSource.this.pool;\n                }\n\n                public void receiveConfigInfo(String configInfo) {\n                    RecordLog.info(\"[NacosDataSource] New property value received for (properties: {}) (dataId: {}, groupId: {}): {}\", new Object[]{properties, dataId, groupId, configInfo});\n                    T newValue = NacosDataSource.this.parser.convert(configInfo);\n                    NacosDataSource.this.getProperty().updateValue(newValue);\n                }\n            };\n            this.initNacosListener();\n            this.loadInitialConfig();\n        } else {\n            throw new IllegalArgumentException(String.format(\"Bad argument: groupId=[%s], dataId=[%s]\", groupId, dataId));\n        }\n    }\n}\n```\n我们看它的构造方法，创建了一个线程池，然后通过这个线程池 new 了一个nacos的Listener，Listener是一个监听器，initNacosListener() 方法是将监听器\n注册到 nacos的configService 里面，通过这个监听器去监听nacos的配置变化，当配置发生更新的时候，调用监听器的 `receiveConfigInfo` 方法：\n\n```java\npublic void receiveConfigInfo(String configInfo) {\n    RecordLog.info(\"[NacosDataSource] New property value received for (properties: {}) (dataId: {}, groupId: {}): {}\", new Object[]{properties, dataId, groupId, configInfo});\n    T newValue = NacosDataSource.this.parser.convert(configInfo);\n    NacosDataSource.this.getProperty().updateValue(newValue);\n}\n\n```\n\n前面分析文件持久话我们就分析过，配置最终要被更新到父类的`property` 属性里面，再这里我们也看到了同样的代码。","source":"_posts/sentinel-持久化.md","raw":"---\ntitle: sentinel 持久化\ndate: 2021-07-26 12:23:21\ntags: 中间件\n---\n\n我们之前配置的流控规则都是存储在应用的内存中的，这种方式明显无法满足我们实际开发的需求，一旦项目被重启，流控规则就被初始化了，需要我们再次去重新配置，因此规则的持久化就显得很有必要了。\n\n本节会介绍几类主流持久化方式并对自定义持久化做介绍\n\n### 文件持久化\n\n文件持久化是通过 sentinel spi 扩展点来加载本地文件中的持久化数据到内存中，它依赖接口 `InitFunc`，对于非spring项目这种方式可以很便捷的实现\n文件持久化。\n\n实现文件持久化首先要自定义一个类并实现`InitFunc` 接口：\n\n```java\n\npublic class MyflieInitFunc implements InitFunc {\n    @Override\n    public void init() throws Exception {\n        URL resource = MyflieInitFunc.class.getClassLoader().getResource(\"\");\n        File file = new File(resource.getPath()+\"/config/flow.json\");\n        File fileParent = file.getParentFile();\n        if(!fileParent.exists()){\n            fileParent.mkdirs();\n        }\n        if (!file.exists()){\n            file.createNewFile();\n        }\n        ReadableDataSource<String, List<FlowRule>> flowReadDataSource = new FileRefreshableDataSource<>(\n            resource.getPath()+\"/config/flow.json\",\n            source -> JSON.parseObject(\n                source,\n                new TypeReference<List<FlowRule>>() {\n                }\n            ));\n        FlowRuleManager.register2Property(flowReadDataSource.getProperty());\n        WritableDataSource<List<FlowRule>> flowWriteDataSource = new FileWritableDataSource<>(\n            resource.getPath()+\"/config/flow.json\",\n            t->JSON.toJSONString(t)\n        );\n        WritableDataSourceRegistry.registerFlowDataSource(flowWriteDataSource);\n    }\n}\n```\n\n然后在resources 文件夹下新建文件 `META-INF\\services\\com.alibaba.csp.sentinel.init.InitFunc` \n内容为`MyflieInitFunc` 的类路径：\n```properties\ncom.muggle.sentinel.config.MyflieInitFunc\n```\n\n完成以上步骤后，文件持久化的方式就配置完成了。\n\n`InitFunc` 的资源初始化方法 `init()` 并不是在项目启动的时候调用的，而是在首次产生流控数据的时候调用的，\n也就是说它是一个懒加载的方法。\n在文件持久化配置中，`FileRefreshableDataSource` , `FileWritableDataSource` , `FlowRuleManager` 这三个类是有必要去熟识的。\n\n- FlowRuleManager 流控规则管理器，用于对流控规则的加载和管理，每类规则都有对应的管理器，后文会介绍。\n- FileRefreshableDataSource 流控规则读取及刷新的类，该类配置到sentinel中后会定时拉取流控文件中的流控规则\n- FileWritableDataSource 流控规则写入类，当我们在控制台编辑新的流控规则后，控制台会将规则推送给应用，应用接收到推送的规则后，\n会通过该类将数据写入流控文件中\n\n### `FlowRuleManager` 源码分析\n\n```java\n\npublic class FlowRuleManager {\n    private static final AtomicReference<Map<String, List<FlowRule>>> flowRules = new AtomicReference();\n    private static final FlowRuleManager.FlowPropertyListener LISTENER = new FlowRuleManager.FlowPropertyListener();\n    private static SentinelProperty<List<FlowRule>> currentProperty = new DynamicSentinelProperty();\n    private static final ScheduledExecutorService SCHEDULER = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"sentinel-metrics-record-task\", true));\n     \n    public static List<FlowRule> getRules() {\n       \n        List<FlowRule> rules = new ArrayList();\n        Iterator var1 = ((Map)flowRules.get()).entrySet().iterator();\n\n        while(var1.hasNext()) {\n            Entry<String, List<FlowRule>> entry = (Entry)var1.next();\n            rules.addAll((Collection)entry.getValue());\n        }\n\n        return rules;\n    }\n    \n    public static void loadRules(List<FlowRule> rules){\n         currentProperty.updateValue(rules);\n    }\n    \n     public static boolean hasConfig(String resource) {\n         return ((Map)flowRules.get()).containsKey(resource);\n    }\n}\n```\n该类的静态属性包括 流控规则数组 `flowRules` ，用于监控流控规则更新的监听器`LISTENER` , 轮询监听流控配置的线程池`SCHEDULER`,sentinel 配置类`currentProperty`.\n而它几个api也很明了，就是对流控规则的增删改查。\n\n### `FileRefreshableDataSource` 源码分析\n\n`FileRefreshableDataSource` 继承了`AutoRefreshDataSource`,而`AutoRefreshDataSource` 中有一个线程池 `service` 用于拉取 文件中存储的规则\n以及拉取间隔 `recommendRefreshMs` .\n：\n\n```java\n\npublic abstract class AutoRefreshDataSource<S, T> extends AbstractDataSource<S, T> {\n    private ScheduledExecutorService service;\n    protected long recommendRefreshMs = 3000L;\n\n    public AutoRefreshDataSource(Converter<S, T> configParser) {\n        super(configParser);\n        this.startTimerService();\n    }\n......\n     private void startTimerService() {\n            this.service = Executors.newScheduledThreadPool(1, new NamedThreadFactory(\"sentinel-datasource-auto-refresh-task\", true));\n            this.service.scheduleAtFixedRate(new Runnable() {\n                public void run() {\n                    try {\n                        if (!AutoRefreshDataSource.this.isModified()) {\n                            return;\n                        }\n    \n                        T newValue = AutoRefreshDataSource.this.loadConfig();\n                        AutoRefreshDataSource.this.getProperty().updateValue(newValue);\n                    } catch (Throwable var2) {\n                        RecordLog.info(\"loadConfig exception\", var2);\n                    }\n    \n                }\n            }, this.recommendRefreshMs, this.recommendRefreshMs, TimeUnit.MILLISECONDS);\n        }\n\n}\n```\n我们重点关注 `startTimerService` 这个方法,这个方法是在构造器里面调用的，也就是说当你new 一个 `FileRefreshableDataSource` 时就会调用该方法\n\n该方法就是通过线程池定时调用`isModified` 方法判断配置是否更新过，如果更新了就同步更新到父类属性 `SentinelProperty` 中，代码对应:\n\n```java\n AutoRefreshDataSource.this.getProperty().updateValue(newValue)\n```\n不难判读出，父类抽象类的`property` 属性才是真正的获取规则提供拦截判断的关键属性。后文也会用到这个知识点，这里记一下。\n\n我们可以看一下 `FileRefreshableDataSource` 构造函数：\n\n```java\n\n public FileRefreshableDataSource(File file, Converter<String, T> configParser) throws FileNotFoundException {\n        this(file, configParser, 3000L, 1048576, DEFAULT_CHAR_SET);\n    }\n\n    public FileRefreshableDataSource(String fileName, Converter<String, T> configParser) throws FileNotFoundException {\n        this(new File(fileName), configParser, 3000L, 1048576, DEFAULT_CHAR_SET);\n    }\n\n    public FileRefreshableDataSource(File file, Converter<String, T> configParser, int bufSize) throws FileNotFoundException {\n        this(file, configParser, 3000L, bufSize, DEFAULT_CHAR_SET);\n    }\n\n    public FileRefreshableDataSource(File file, Converter<String, T> configParser, Charset charset) throws FileNotFoundException {\n        this(file, configParser, 3000L, 1048576, charset);\n    }\n\n    public FileRefreshableDataSource(File file, Converter<String, T> configParser, long recommendRefreshMs, int bufSize, Charset charset) \n```\n\n不难看出，如果在 new `FileRefreshableDataSource` 时不指定刷新间隔就取默认值 3000 毫秒。\n\n### `FileWritableDataSource` 源码分析\n\n```java\n\npublic class FileWritableDataSource<T> implements WritableDataSource<T> {\n    private static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n    private final Converter<T, String> configEncoder;\n    private final File file;\n    private final Charset charset;\n    private final Lock lock;\n    \n    public void write(T value) throws Exception {\n        this.lock.lock();\n        try {\n            String convertResult = (String)this.configEncoder.convert(value);\n            FileOutputStream outputStream = null;\n\n            try {\n                outputStream = new FileOutputStream(this.file);\n                byte[] bytesArray = convertResult.getBytes(this.charset);\n                RecordLog.info(\"[FileWritableDataSource] Writing to file {}: {}\", new Object[]{this.file, convertResult});\n                outputStream.write(bytesArray);\n                outputStream.flush();\n            } finally {\n                if (outputStream != null) {\n                    try {\n                        outputStream.close();\n                    } catch (Exception var16) {\n                    }\n                }\n\n            }\n        } finally {\n            this.lock.unlock();\n        }\n    }\n}\n\n```\n代码结构也很了然，一个数据转换器，一个 file 一个lock ,当框架调用 `write` 方法时上锁并往 file中写配置。\n\n分析得差不多了，让我们看看实战效果吧；\n\n首先启动项目和控制台，然后在控制台上配置一个流控规则，可以观察到项目规则存储文件中多了点内容：\n![2](sentinel2.jpg)\n\n文件中新增的数据：\n\n```json\n[{\"clusterConfig\":{\"acquireRefuseStrategy\":0,\"clientOfflineTime\":2000,\"fallbackToLocalWhenFail\":true,\"resourceTimeout\":2000,\"resourceTimeoutStrategy\":0,\"sampleCount\":10,\"strategy\":0,\"thresholdType\":0,\"windowIntervalMs\":1000},\"clusterMode\":false,\"controlBehavior\":0,\"count\":1.0,\"grade\":1,\"limitApp\":\"default\",\"maxQueueingTimeMs\":500,\"resource\":\"test\",\"strategy\":0,\"warmUpPeriodSec\":10}]\n```\n\n我们重启项目和控制台规则也不会丢失，规则持久化生效。\n\n通过分析我们知道，这种持久化方式是一种拉模式，胜在配置简单，不需要外部数据源就能完成流控数据的持久化。由于规则是用 FileRefreshableDataSource 定时更新的，所以规则更新会有延迟。\n如果FileRefreshableDataSource定时时间过大，可能长时间延迟；如果FileRefreshableDataSource过小，又会影响性能；\n因为规则存储在本地文件，如果需要迁移微服务，那么需要把规则文件一起迁移，否则规则会丢失。\n\n文件持久化能应付我们需求的大部分场景，但对于微服务而言是不那么满足要求的；\n因为文件持久化就必定要求我们在服务器上提供一个用于存储配置文件的文件夹，而微服务项目大部分情况是容器部署，这就让文件持久化显得不那么好用了。\n\n为此，官方提供了自定义的持久化maven依赖：\n```xml\n        <dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-datasource-extension</artifactId>\n        </dependency>\n\n```\n以及在这个依赖的基础上开发的以CONSUL NACOS REDIS 作为数据源的maven 依赖：\n\n```xml\n        <dependency>\n            <artifactId>sentinel-datasource-consul</artifactId>\n            <groupId>com.alibaba.csp</groupId>\n        </dependency>\n        <dependency>\n            <artifactId>sentinel-datasource-redis</artifactId>\n            <groupId>com.alibaba.csp</groupId>\n        </dependency>\n\n        <dependency>\n            <artifactId>sentinel-datasource-nacos</artifactId>\n            <groupId>com.alibaba.csp</groupId>\n        </dependency>\n\n```\n### nacos持久化\n以上三种种持久化不同于文件持久化，它们是推模式的，而且迁移部署起来更为方便，符合微服务的特性。接下来我们就以nacos持久化为例来学习一下这种方式是怎么配置的。\n\n首先引入 nacos 相关依赖依赖：\n```xml\n\n        <dependency>\n            <artifactId>sentinel-datasource-nacos</artifactId>\n            <groupId>com.alibaba.csp</groupId>\n        </dependency>\n```\n然后通过`FlowRuleManager` 注册数据源就ok了\n```java\n        ReadableDataSource<String, List<FlowRule>> flowRuleDataSource = new NacosDataSource<>(remoteAddress, groupId, dataId,\n            source -> JSON.parseObject(source, new TypeReference<List<FlowRule>>() {\n            }));\n        FlowRuleManager.register2Property(flowRuleDataSource.getProperty());\n```\nremoteAddress 是nacos 的地址； groupId和dataId均为nacos配置中心的属性，在创建配置项的时候由使用者自定义，如图为在nacos创建配置项的截图：\n\n![3](sentinel3.jpg)\n\n\n启动nacos，启动我们的项目和控制台，然后修改nacos中的配置项，就能再控制台上观测到规则变化，nacos中存储的规则也是json,我们可以把文件持久化教程中产生json\n复制进去，这里就不在赘述。\n\n这种模式是推模式，优点是这种方式有更好的实时性和一致性保证。因为我们和文件持久化比起来少注册了一个与`FileWritableDataSource` 对应的类，\n也就是说应用中更新的规则不能反写到nacos,只能通过nacos读取到配置；因此我们在控制台上修改的规则也不会持久化到nacos中。这样设计是合理的，因为nacos作为\n配置中心不应该允许应用去反写自己的配置。\n\n## 源码分析\n\n因为文件持久化分析了一部分源码，因此这里不会对源码分析太多，只简单的介绍它是如何去读取到配置的。\n\n\n```java\n\npublic class NacosDataSource<T> extends AbstractDataSource<String, T> {\n\n    private static final int DEFAULT_TIMEOUT = 3000;\n    private final ExecutorService pool;\n    private final Listener configListener;\n    private final String groupId;\n    private final String dataId;\n    private final Properties properties;\n    private ConfigService configService;\n\n    public NacosDataSource(final Properties properties, final String groupId, final String dataId, Converter<String, T> parser) {\n        super(parser);\n        this.pool = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue(1), new NamedThreadFactory(\"sentinel-nacos-ds-update\"), new DiscardOldestPolicy());\n        this.configService = null;\n        if (!StringUtil.isBlank(groupId) && !StringUtil.isBlank(dataId)) {\n            AssertUtil.notNull(properties, \"Nacos properties must not be null, you could put some keys from PropertyKeyConst\");\n            this.groupId = groupId;\n            this.dataId = dataId;\n            this.properties = properties;\n            this.configListener = new Listener() {\n                public Executor getExecutor() {\n                    return NacosDataSource.this.pool;\n                }\n\n                public void receiveConfigInfo(String configInfo) {\n                    RecordLog.info(\"[NacosDataSource] New property value received for (properties: {}) (dataId: {}, groupId: {}): {}\", new Object[]{properties, dataId, groupId, configInfo});\n                    T newValue = NacosDataSource.this.parser.convert(configInfo);\n                    NacosDataSource.this.getProperty().updateValue(newValue);\n                }\n            };\n            this.initNacosListener();\n            this.loadInitialConfig();\n        } else {\n            throw new IllegalArgumentException(String.format(\"Bad argument: groupId=[%s], dataId=[%s]\", groupId, dataId));\n        }\n    }\n}\n```\n我们看它的构造方法，创建了一个线程池，然后通过这个线程池 new 了一个nacos的Listener，Listener是一个监听器，initNacosListener() 方法是将监听器\n注册到 nacos的configService 里面，通过这个监听器去监听nacos的配置变化，当配置发生更新的时候，调用监听器的 `receiveConfigInfo` 方法：\n\n```java\npublic void receiveConfigInfo(String configInfo) {\n    RecordLog.info(\"[NacosDataSource] New property value received for (properties: {}) (dataId: {}, groupId: {}): {}\", new Object[]{properties, dataId, groupId, configInfo});\n    T newValue = NacosDataSource.this.parser.convert(configInfo);\n    NacosDataSource.this.getProperty().updateValue(newValue);\n}\n\n```\n\n前面分析文件持久话我们就分析过，配置最终要被更新到父类的`property` 属性里面，再这里我们也看到了同样的代码。","slug":"sentinel-持久化","published":1,"updated":"2021-07-26T04:47:42.239Z","_id":"ckrk4oce70000ewqk25tn85ea","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我们之前配置的流控规则都是存储在应用的内存中的，这种方式明显无法满足我们实际开发的需求，一旦项目被重启，流控规则就被初始化了，需要我们再次去重新配置，因此规则的持久化就显得很有必要了。</p>\n<p>本节会介绍几类主流持久化方式并对自定义持久化做介绍</p>\n<h3 id=\"文件持久化\"><a href=\"#文件持久化\" class=\"headerlink\" title=\"文件持久化\"></a>文件持久化</h3><p>文件持久化是通过 sentinel spi 扩展点来加载本地文件中的持久化数据到内存中，它依赖接口 <code>InitFunc</code>，对于非spring项目这种方式可以很便捷的实现<br>文件持久化。</p>\n<p>实现文件持久化首先要自定义一个类并实现<code>InitFunc</code> 接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyflieInitFunc</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitFunc</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        URL resource = MyflieInitFunc.class.getClassLoader().getResource(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(resource.getPath()+<span class=\"string\">&quot;/config/flow.json&quot;</span>);</span><br><span class=\"line\">        File fileParent = file.getParentFile();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!fileParent.exists())&#123;</span><br><span class=\"line\">            fileParent.mkdirs();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!file.exists())&#123;</span><br><span class=\"line\">            file.createNewFile();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowReadDataSource = <span class=\"keyword\">new</span> FileRefreshableDataSource&lt;&gt;(</span><br><span class=\"line\">            resource.getPath()+<span class=\"string\">&quot;/config/flow.json&quot;</span>,</span><br><span class=\"line\">            source -&gt; JSON.parseObject(</span><br><span class=\"line\">                source,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ));</span><br><span class=\"line\">        FlowRuleManager.register2Property(flowReadDataSource.getProperty());</span><br><span class=\"line\">        WritableDataSource&lt;List&lt;FlowRule&gt;&gt; flowWriteDataSource = <span class=\"keyword\">new</span> FileWritableDataSource&lt;&gt;(</span><br><span class=\"line\">            resource.getPath()+<span class=\"string\">&quot;/config/flow.json&quot;</span>,</span><br><span class=\"line\">            t-&gt;JSON.toJSONString(t)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        WritableDataSourceRegistry.registerFlowDataSource(flowWriteDataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在resources 文件夹下新建文件 <code>META-INF\\services\\com.alibaba.csp.sentinel.init.InitFunc</code><br>内容为<code>MyflieInitFunc</code> 的类路径：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">com.muggle.sentinel.config.MyflieInitFunc</span></span><br></pre></td></tr></table></figure>\n\n<p>完成以上步骤后，文件持久化的方式就配置完成了。</p>\n<p><code>InitFunc</code> 的资源初始化方法 <code>init()</code> 并不是在项目启动的时候调用的，而是在首次产生流控数据的时候调用的，<br>也就是说它是一个懒加载的方法。<br>在文件持久化配置中，<code>FileRefreshableDataSource</code> , <code>FileWritableDataSource</code> , <code>FlowRuleManager</code> 这三个类是有必要去熟识的。</p>\n<ul>\n<li>FlowRuleManager 流控规则管理器，用于对流控规则的加载和管理，每类规则都有对应的管理器，后文会介绍。</li>\n<li>FileRefreshableDataSource 流控规则读取及刷新的类，该类配置到sentinel中后会定时拉取流控文件中的流控规则</li>\n<li>FileWritableDataSource 流控规则写入类，当我们在控制台编辑新的流控规则后，控制台会将规则推送给应用，应用接收到推送的规则后，<br>会通过该类将数据写入流控文件中</li>\n</ul>\n<h3 id=\"FlowRuleManager-源码分析\"><a href=\"#FlowRuleManager-源码分析\" class=\"headerlink\" title=\"FlowRuleManager 源码分析\"></a><code>FlowRuleManager</code> 源码分析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlowRuleManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicReference&lt;Map&lt;String, List&lt;FlowRule&gt;&gt;&gt; flowRules = <span class=\"keyword\">new</span> AtomicReference();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> FlowRuleManager.FlowPropertyListener LISTENER = <span class=\"keyword\">new</span> FlowRuleManager.FlowPropertyListener();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SentinelProperty&lt;List&lt;FlowRule&gt;&gt; currentProperty = <span class=\"keyword\">new</span> DynamicSentinelProperty();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ScheduledExecutorService SCHEDULER = Executors.newScheduledThreadPool(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> NamedThreadFactory(<span class=\"string\">&quot;sentinel-metrics-record-task&quot;</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;FlowRule&gt; <span class=\"title\">getRules</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">        List&lt;FlowRule&gt; rules = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        Iterator var1 = ((Map)flowRules.get()).entrySet().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(var1.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;String, List&lt;FlowRule&gt;&gt; entry = (Entry)var1.next();</span><br><span class=\"line\">            rules.addAll((Collection)entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rules;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loadRules</span><span class=\"params\">(List&lt;FlowRule&gt; rules)</span></span>&#123;</span><br><span class=\"line\">         currentProperty.updateValue(rules);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasConfig</span><span class=\"params\">(String resource)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> ((Map)flowRules.get()).containsKey(resource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类的静态属性包括 流控规则数组 <code>flowRules</code> ，用于监控流控规则更新的监听器<code>LISTENER</code> , 轮询监听流控配置的线程池<code>SCHEDULER</code>,sentinel 配置类<code>currentProperty</code>.<br>而它几个api也很明了，就是对流控规则的增删改查。</p>\n<h3 id=\"FileRefreshableDataSource-源码分析\"><a href=\"#FileRefreshableDataSource-源码分析\" class=\"headerlink\" title=\"FileRefreshableDataSource 源码分析\"></a><code>FileRefreshableDataSource</code> 源码分析</h3><p><code>FileRefreshableDataSource</code> 继承了<code>AutoRefreshDataSource</code>,而<code>AutoRefreshDataSource</code> 中有一个线程池 <code>service</code> 用于拉取 文件中存储的规则<br>以及拉取间隔 <code>recommendRefreshMs</code> .<br>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoRefreshDataSource</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractDataSource</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ScheduledExecutorService service;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">long</span> recommendRefreshMs = <span class=\"number\">3000L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoRefreshDataSource</span><span class=\"params\">(Converter&lt;S, T&gt; configParser)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(configParser);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.startTimerService();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startTimerService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.service = Executors.newScheduledThreadPool(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> NamedThreadFactory(<span class=\"string\">&quot;sentinel-datasource-auto-refresh-task&quot;</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.service.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!AutoRefreshDataSource.<span class=\"keyword\">this</span>.isModified()) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">                        T newValue = AutoRefreshDataSource.<span class=\"keyword\">this</span>.loadConfig();</span><br><span class=\"line\">                        AutoRefreshDataSource.<span class=\"keyword\">this</span>.getProperty().updateValue(newValue);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable var2) &#123;</span><br><span class=\"line\">                        RecordLog.info(<span class=\"string\">&quot;loadConfig exception&quot;</span>, var2);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, <span class=\"keyword\">this</span>.recommendRefreshMs, <span class=\"keyword\">this</span>.recommendRefreshMs, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们重点关注 <code>startTimerService</code> 这个方法,这个方法是在构造器里面调用的，也就是说当你new 一个 <code>FileRefreshableDataSource</code> 时就会调用该方法</p>\n<p>该方法就是通过线程池定时调用<code>isModified</code> 方法判断配置是否更新过，如果更新了就同步更新到父类属性 <code>SentinelProperty</code> 中，代码对应:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AutoRefreshDataSource.<span class=\"keyword\">this</span>.getProperty().updateValue(newValue)</span><br></pre></td></tr></table></figure>\n<p>不难判读出，父类抽象类的<code>property</code> 属性才是真正的获取规则提供拦截判断的关键属性。后文也会用到这个知识点，这里记一下。</p>\n<p>我们可以看一下 <code>FileRefreshableDataSource</code> 构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileRefreshableDataSource</span><span class=\"params\">(File file, Converter&lt;String, T&gt; configParser)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>(file, configParser, <span class=\"number\">3000L</span>, <span class=\"number\">1048576</span>, DEFAULT_CHAR_SET);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileRefreshableDataSource</span><span class=\"params\">(String fileName, Converter&lt;String, T&gt; configParser)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>(<span class=\"keyword\">new</span> File(fileName), configParser, <span class=\"number\">3000L</span>, <span class=\"number\">1048576</span>, DEFAULT_CHAR_SET);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileRefreshableDataSource</span><span class=\"params\">(File file, Converter&lt;String, T&gt; configParser, <span class=\"keyword\">int</span> bufSize)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>(file, configParser, <span class=\"number\">3000L</span>, bufSize, DEFAULT_CHAR_SET);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileRefreshableDataSource</span><span class=\"params\">(File file, Converter&lt;String, T&gt; configParser, Charset charset)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>(file, configParser, <span class=\"number\">3000L</span>, <span class=\"number\">1048576</span>, charset);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileRefreshableDataSource</span><span class=\"params\">(File file, Converter&lt;String, T&gt; configParser, <span class=\"keyword\">long</span> recommendRefreshMs, <span class=\"keyword\">int</span> bufSize, Charset charset)</span> </span></span><br></pre></td></tr></table></figure>\n\n<p>不难看出，如果在 new <code>FileRefreshableDataSource</code> 时不指定刷新间隔就取默认值 3000 毫秒。</p>\n<h3 id=\"FileWritableDataSource-源码分析\"><a href=\"#FileWritableDataSource-源码分析\" class=\"headerlink\" title=\"FileWritableDataSource 源码分析\"></a><code>FileWritableDataSource</code> 源码分析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileWritableDataSource</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">WritableDataSource</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Converter&lt;T, String&gt; configEncoder;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> File file;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Charset charset;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(T value)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String convertResult = (String)<span class=\"keyword\">this</span>.configEncoder.convert(value);</span><br><span class=\"line\">            FileOutputStream outputStream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                outputStream = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"keyword\">this</span>.file);</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] bytesArray = convertResult.getBytes(<span class=\"keyword\">this</span>.charset);</span><br><span class=\"line\">                RecordLog.info(<span class=\"string\">&quot;[FileWritableDataSource] Writing to file &#123;&#125;: &#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"keyword\">this</span>.file, convertResult&#125;);</span><br><span class=\"line\">                outputStream.write(bytesArray);</span><br><span class=\"line\">                outputStream.flush();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (outputStream != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        outputStream.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception var16) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>代码结构也很了然，一个数据转换器，一个 file 一个lock ,当框架调用 <code>write</code> 方法时上锁并往 file中写配置。</p>\n<p>分析得差不多了，让我们看看实战效果吧；</p>\n<p>首先启动项目和控制台，然后在控制台上配置一个流控规则，可以观察到项目规则存储文件中多了点内容：<br><img src=\"sentinel2.jpg\" alt=\"2\"></p>\n<p>文件中新增的数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;<span class=\"attr\">&quot;clusterConfig&quot;</span>:&#123;<span class=\"attr\">&quot;acquireRefuseStrategy&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;clientOfflineTime&quot;</span>:<span class=\"number\">2000</span>,<span class=\"attr\">&quot;fallbackToLocalWhenFail&quot;</span>:<span class=\"literal\">true</span>,<span class=\"attr\">&quot;resourceTimeout&quot;</span>:<span class=\"number\">2000</span>,<span class=\"attr\">&quot;resourceTimeoutStrategy&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;sampleCount&quot;</span>:<span class=\"number\">10</span>,<span class=\"attr\">&quot;strategy&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;thresholdType&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;windowIntervalMs&quot;</span>:<span class=\"number\">1000</span>&#125;,<span class=\"attr\">&quot;clusterMode&quot;</span>:<span class=\"literal\">false</span>,<span class=\"attr\">&quot;controlBehavior&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;count&quot;</span>:<span class=\"number\">1.0</span>,<span class=\"attr\">&quot;grade&quot;</span>:<span class=\"number\">1</span>,<span class=\"attr\">&quot;limitApp&quot;</span>:<span class=\"string\">&quot;default&quot;</span>,<span class=\"attr\">&quot;maxQueueingTimeMs&quot;</span>:<span class=\"number\">500</span>,<span class=\"attr\">&quot;resource&quot;</span>:<span class=\"string\">&quot;test&quot;</span>,<span class=\"attr\">&quot;strategy&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;warmUpPeriodSec&quot;</span>:<span class=\"number\">10</span>&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>我们重启项目和控制台规则也不会丢失，规则持久化生效。</p>\n<p>通过分析我们知道，这种持久化方式是一种拉模式，胜在配置简单，不需要外部数据源就能完成流控数据的持久化。由于规则是用 FileRefreshableDataSource 定时更新的，所以规则更新会有延迟。<br>如果FileRefreshableDataSource定时时间过大，可能长时间延迟；如果FileRefreshableDataSource过小，又会影响性能；<br>因为规则存储在本地文件，如果需要迁移微服务，那么需要把规则文件一起迁移，否则规则会丢失。</p>\n<p>文件持久化能应付我们需求的大部分场景，但对于微服务而言是不那么满足要求的；<br>因为文件持久化就必定要求我们在服务器上提供一个用于存储配置文件的文件夹，而微服务项目大部分情况是容器部署，这就让文件持久化显得不那么好用了。</p>\n<p>为此，官方提供了自定义的持久化maven依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-datasource-extension<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>以及在这个依赖的基础上开发的以CONSUL NACOS REDIS 作为数据源的maven 依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-datasource-consul<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-datasource-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"nacos持久化\"><a href=\"#nacos持久化\" class=\"headerlink\" title=\"nacos持久化\"></a>nacos持久化</h3><p>以上三种种持久化不同于文件持久化，它们是推模式的，而且迁移部署起来更为方便，符合微服务的特性。接下来我们就以nacos持久化为例来学习一下这种方式是怎么配置的。</p>\n<p>首先引入 nacos 相关依赖依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后通过<code>FlowRuleManager</code> 注册数据源就ok了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class=\"keyword\">new</span> NacosDataSource&lt;&gt;(remoteAddress, groupId, dataId,</span><br><span class=\"line\">    source -&gt; JSON.parseObject(source, <span class=\"keyword\">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br></pre></td></tr></table></figure>\n<p>remoteAddress 是nacos 的地址； groupId和dataId均为nacos配置中心的属性，在创建配置项的时候由使用者自定义，如图为在nacos创建配置项的截图：</p>\n<p><img src=\"sentinel3.jpg\" alt=\"3\"></p>\n<p>启动nacos，启动我们的项目和控制台，然后修改nacos中的配置项，就能再控制台上观测到规则变化，nacos中存储的规则也是json,我们可以把文件持久化教程中产生json<br>复制进去，这里就不在赘述。</p>\n<p>这种模式是推模式，优点是这种方式有更好的实时性和一致性保证。因为我们和文件持久化比起来少注册了一个与<code>FileWritableDataSource</code> 对应的类，<br>也就是说应用中更新的规则不能反写到nacos,只能通过nacos读取到配置；因此我们在控制台上修改的规则也不会持久化到nacos中。这样设计是合理的，因为nacos作为<br>配置中心不应该允许应用去反写自己的配置。</p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><p>因为文件持久化分析了一部分源码，因此这里不会对源码分析太多，只简单的介绍它是如何去读取到配置的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NacosDataSource</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractDataSource</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_TIMEOUT = <span class=\"number\">3000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ExecutorService pool;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Listener configListener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String groupId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String dataId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Properties properties;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ConfigService configService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NacosDataSource</span><span class=\"params\">(<span class=\"keyword\">final</span> Properties properties, <span class=\"keyword\">final</span> String groupId, <span class=\"keyword\">final</span> String dataId, Converter&lt;String, T&gt; parser)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(parser);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pool = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> ArrayBlockingQueue(<span class=\"number\">1</span>), <span class=\"keyword\">new</span> NamedThreadFactory(<span class=\"string\">&quot;sentinel-nacos-ds-update&quot;</span>), <span class=\"keyword\">new</span> DiscardOldestPolicy());</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.configService = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!StringUtil.isBlank(groupId) &amp;&amp; !StringUtil.isBlank(dataId)) &#123;</span><br><span class=\"line\">            AssertUtil.notNull(properties, <span class=\"string\">&quot;Nacos properties must not be null, you could put some keys from PropertyKeyConst&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.groupId = groupId;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.dataId = dataId;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.properties = properties;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.configListener = <span class=\"keyword\">new</span> Listener() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Executor <span class=\"title\">getExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> NacosDataSource.<span class=\"keyword\">this</span>.pool;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveConfigInfo</span><span class=\"params\">(String configInfo)</span> </span>&#123;</span><br><span class=\"line\">                    RecordLog.info(<span class=\"string\">&quot;[NacosDataSource] New property value received for (properties: &#123;&#125;) (dataId: &#123;&#125;, groupId: &#123;&#125;): &#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Object[]&#123;properties, dataId, groupId, configInfo&#125;);</span><br><span class=\"line\">                    T newValue = NacosDataSource.<span class=\"keyword\">this</span>.parser.convert(configInfo);</span><br><span class=\"line\">                    NacosDataSource.<span class=\"keyword\">this</span>.getProperty().updateValue(newValue);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.initNacosListener();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.loadInitialConfig();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(String.format(<span class=\"string\">&quot;Bad argument: groupId=[%s], dataId=[%s]&quot;</span>, groupId, dataId));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看它的构造方法，创建了一个线程池，然后通过这个线程池 new 了一个nacos的Listener，Listener是一个监听器，initNacosListener() 方法是将监听器<br>注册到 nacos的configService 里面，通过这个监听器去监听nacos的配置变化，当配置发生更新的时候，调用监听器的 <code>receiveConfigInfo</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveConfigInfo</span><span class=\"params\">(String configInfo)</span> </span>&#123;</span><br><span class=\"line\">    RecordLog.info(<span class=\"string\">&quot;[NacosDataSource] New property value received for (properties: &#123;&#125;) (dataId: &#123;&#125;, groupId: &#123;&#125;): &#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Object[]&#123;properties, dataId, groupId, configInfo&#125;);</span><br><span class=\"line\">    T newValue = NacosDataSource.<span class=\"keyword\">this</span>.parser.convert(configInfo);</span><br><span class=\"line\">    NacosDataSource.<span class=\"keyword\">this</span>.getProperty().updateValue(newValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>前面分析文件持久话我们就分析过，配置最终要被更新到父类的<code>property</code> 属性里面，再这里我们也看到了同样的代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们之前配置的流控规则都是存储在应用的内存中的，这种方式明显无法满足我们实际开发的需求，一旦项目被重启，流控规则就被初始化了，需要我们再次去重新配置，因此规则的持久化就显得很有必要了。</p>\n<p>本节会介绍几类主流持久化方式并对自定义持久化做介绍</p>\n<h3 id=\"文件持久化\"><a href=\"#文件持久化\" class=\"headerlink\" title=\"文件持久化\"></a>文件持久化</h3><p>文件持久化是通过 sentinel spi 扩展点来加载本地文件中的持久化数据到内存中，它依赖接口 <code>InitFunc</code>，对于非spring项目这种方式可以很便捷的实现<br>文件持久化。</p>\n<p>实现文件持久化首先要自定义一个类并实现<code>InitFunc</code> 接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyflieInitFunc</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitFunc</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        URL resource = MyflieInitFunc.class.getClassLoader().getResource(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(resource.getPath()+<span class=\"string\">&quot;/config/flow.json&quot;</span>);</span><br><span class=\"line\">        File fileParent = file.getParentFile();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!fileParent.exists())&#123;</span><br><span class=\"line\">            fileParent.mkdirs();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!file.exists())&#123;</span><br><span class=\"line\">            file.createNewFile();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowReadDataSource = <span class=\"keyword\">new</span> FileRefreshableDataSource&lt;&gt;(</span><br><span class=\"line\">            resource.getPath()+<span class=\"string\">&quot;/config/flow.json&quot;</span>,</span><br><span class=\"line\">            source -&gt; JSON.parseObject(</span><br><span class=\"line\">                source,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ));</span><br><span class=\"line\">        FlowRuleManager.register2Property(flowReadDataSource.getProperty());</span><br><span class=\"line\">        WritableDataSource&lt;List&lt;FlowRule&gt;&gt; flowWriteDataSource = <span class=\"keyword\">new</span> FileWritableDataSource&lt;&gt;(</span><br><span class=\"line\">            resource.getPath()+<span class=\"string\">&quot;/config/flow.json&quot;</span>,</span><br><span class=\"line\">            t-&gt;JSON.toJSONString(t)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        WritableDataSourceRegistry.registerFlowDataSource(flowWriteDataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在resources 文件夹下新建文件 <code>META-INF\\services\\com.alibaba.csp.sentinel.init.InitFunc</code><br>内容为<code>MyflieInitFunc</code> 的类路径：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">com.muggle.sentinel.config.MyflieInitFunc</span></span><br></pre></td></tr></table></figure>\n\n<p>完成以上步骤后，文件持久化的方式就配置完成了。</p>\n<p><code>InitFunc</code> 的资源初始化方法 <code>init()</code> 并不是在项目启动的时候调用的，而是在首次产生流控数据的时候调用的，<br>也就是说它是一个懒加载的方法。<br>在文件持久化配置中，<code>FileRefreshableDataSource</code> , <code>FileWritableDataSource</code> , <code>FlowRuleManager</code> 这三个类是有必要去熟识的。</p>\n<ul>\n<li>FlowRuleManager 流控规则管理器，用于对流控规则的加载和管理，每类规则都有对应的管理器，后文会介绍。</li>\n<li>FileRefreshableDataSource 流控规则读取及刷新的类，该类配置到sentinel中后会定时拉取流控文件中的流控规则</li>\n<li>FileWritableDataSource 流控规则写入类，当我们在控制台编辑新的流控规则后，控制台会将规则推送给应用，应用接收到推送的规则后，<br>会通过该类将数据写入流控文件中</li>\n</ul>\n<h3 id=\"FlowRuleManager-源码分析\"><a href=\"#FlowRuleManager-源码分析\" class=\"headerlink\" title=\"FlowRuleManager 源码分析\"></a><code>FlowRuleManager</code> 源码分析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlowRuleManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicReference&lt;Map&lt;String, List&lt;FlowRule&gt;&gt;&gt; flowRules = <span class=\"keyword\">new</span> AtomicReference();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> FlowRuleManager.FlowPropertyListener LISTENER = <span class=\"keyword\">new</span> FlowRuleManager.FlowPropertyListener();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SentinelProperty&lt;List&lt;FlowRule&gt;&gt; currentProperty = <span class=\"keyword\">new</span> DynamicSentinelProperty();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ScheduledExecutorService SCHEDULER = Executors.newScheduledThreadPool(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> NamedThreadFactory(<span class=\"string\">&quot;sentinel-metrics-record-task&quot;</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;FlowRule&gt; <span class=\"title\">getRules</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">        List&lt;FlowRule&gt; rules = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">        Iterator var1 = ((Map)flowRules.get()).entrySet().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(var1.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;String, List&lt;FlowRule&gt;&gt; entry = (Entry)var1.next();</span><br><span class=\"line\">            rules.addAll((Collection)entry.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rules;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loadRules</span><span class=\"params\">(List&lt;FlowRule&gt; rules)</span></span>&#123;</span><br><span class=\"line\">         currentProperty.updateValue(rules);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasConfig</span><span class=\"params\">(String resource)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> ((Map)flowRules.get()).containsKey(resource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类的静态属性包括 流控规则数组 <code>flowRules</code> ，用于监控流控规则更新的监听器<code>LISTENER</code> , 轮询监听流控配置的线程池<code>SCHEDULER</code>,sentinel 配置类<code>currentProperty</code>.<br>而它几个api也很明了，就是对流控规则的增删改查。</p>\n<h3 id=\"FileRefreshableDataSource-源码分析\"><a href=\"#FileRefreshableDataSource-源码分析\" class=\"headerlink\" title=\"FileRefreshableDataSource 源码分析\"></a><code>FileRefreshableDataSource</code> 源码分析</h3><p><code>FileRefreshableDataSource</code> 继承了<code>AutoRefreshDataSource</code>,而<code>AutoRefreshDataSource</code> 中有一个线程池 <code>service</code> 用于拉取 文件中存储的规则<br>以及拉取间隔 <code>recommendRefreshMs</code> .<br>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoRefreshDataSource</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractDataSource</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ScheduledExecutorService service;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">long</span> recommendRefreshMs = <span class=\"number\">3000L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoRefreshDataSource</span><span class=\"params\">(Converter&lt;S, T&gt; configParser)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(configParser);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.startTimerService();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">......</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startTimerService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.service = Executors.newScheduledThreadPool(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> NamedThreadFactory(<span class=\"string\">&quot;sentinel-datasource-auto-refresh-task&quot;</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.service.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!AutoRefreshDataSource.<span class=\"keyword\">this</span>.isModified()) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">                        T newValue = AutoRefreshDataSource.<span class=\"keyword\">this</span>.loadConfig();</span><br><span class=\"line\">                        AutoRefreshDataSource.<span class=\"keyword\">this</span>.getProperty().updateValue(newValue);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable var2) &#123;</span><br><span class=\"line\">                        RecordLog.info(<span class=\"string\">&quot;loadConfig exception&quot;</span>, var2);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, <span class=\"keyword\">this</span>.recommendRefreshMs, <span class=\"keyword\">this</span>.recommendRefreshMs, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们重点关注 <code>startTimerService</code> 这个方法,这个方法是在构造器里面调用的，也就是说当你new 一个 <code>FileRefreshableDataSource</code> 时就会调用该方法</p>\n<p>该方法就是通过线程池定时调用<code>isModified</code> 方法判断配置是否更新过，如果更新了就同步更新到父类属性 <code>SentinelProperty</code> 中，代码对应:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AutoRefreshDataSource.<span class=\"keyword\">this</span>.getProperty().updateValue(newValue)</span><br></pre></td></tr></table></figure>\n<p>不难判读出，父类抽象类的<code>property</code> 属性才是真正的获取规则提供拦截判断的关键属性。后文也会用到这个知识点，这里记一下。</p>\n<p>我们可以看一下 <code>FileRefreshableDataSource</code> 构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileRefreshableDataSource</span><span class=\"params\">(File file, Converter&lt;String, T&gt; configParser)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>(file, configParser, <span class=\"number\">3000L</span>, <span class=\"number\">1048576</span>, DEFAULT_CHAR_SET);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileRefreshableDataSource</span><span class=\"params\">(String fileName, Converter&lt;String, T&gt; configParser)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>(<span class=\"keyword\">new</span> File(fileName), configParser, <span class=\"number\">3000L</span>, <span class=\"number\">1048576</span>, DEFAULT_CHAR_SET);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileRefreshableDataSource</span><span class=\"params\">(File file, Converter&lt;String, T&gt; configParser, <span class=\"keyword\">int</span> bufSize)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>(file, configParser, <span class=\"number\">3000L</span>, bufSize, DEFAULT_CHAR_SET);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileRefreshableDataSource</span><span class=\"params\">(File file, Converter&lt;String, T&gt; configParser, Charset charset)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>(file, configParser, <span class=\"number\">3000L</span>, <span class=\"number\">1048576</span>, charset);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileRefreshableDataSource</span><span class=\"params\">(File file, Converter&lt;String, T&gt; configParser, <span class=\"keyword\">long</span> recommendRefreshMs, <span class=\"keyword\">int</span> bufSize, Charset charset)</span> </span></span><br></pre></td></tr></table></figure>\n\n<p>不难看出，如果在 new <code>FileRefreshableDataSource</code> 时不指定刷新间隔就取默认值 3000 毫秒。</p>\n<h3 id=\"FileWritableDataSource-源码分析\"><a href=\"#FileWritableDataSource-源码分析\" class=\"headerlink\" title=\"FileWritableDataSource 源码分析\"></a><code>FileWritableDataSource</code> 源码分析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileWritableDataSource</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">WritableDataSource</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Converter&lt;T, String&gt; configEncoder;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> File file;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Charset charset;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(T value)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String convertResult = (String)<span class=\"keyword\">this</span>.configEncoder.convert(value);</span><br><span class=\"line\">            FileOutputStream outputStream = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                outputStream = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"keyword\">this</span>.file);</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] bytesArray = convertResult.getBytes(<span class=\"keyword\">this</span>.charset);</span><br><span class=\"line\">                RecordLog.info(<span class=\"string\">&quot;[FileWritableDataSource] Writing to file &#123;&#125;: &#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"keyword\">this</span>.file, convertResult&#125;);</span><br><span class=\"line\">                outputStream.write(bytesArray);</span><br><span class=\"line\">                outputStream.flush();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (outputStream != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        outputStream.close();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception var16) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>代码结构也很了然，一个数据转换器，一个 file 一个lock ,当框架调用 <code>write</code> 方法时上锁并往 file中写配置。</p>\n<p>分析得差不多了，让我们看看实战效果吧；</p>\n<p>首先启动项目和控制台，然后在控制台上配置一个流控规则，可以观察到项目规则存储文件中多了点内容：<br><img src=\"sentinel2.jpg\" alt=\"2\"></p>\n<p>文件中新增的数据：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;<span class=\"attr\">&quot;clusterConfig&quot;</span>:&#123;<span class=\"attr\">&quot;acquireRefuseStrategy&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;clientOfflineTime&quot;</span>:<span class=\"number\">2000</span>,<span class=\"attr\">&quot;fallbackToLocalWhenFail&quot;</span>:<span class=\"literal\">true</span>,<span class=\"attr\">&quot;resourceTimeout&quot;</span>:<span class=\"number\">2000</span>,<span class=\"attr\">&quot;resourceTimeoutStrategy&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;sampleCount&quot;</span>:<span class=\"number\">10</span>,<span class=\"attr\">&quot;strategy&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;thresholdType&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;windowIntervalMs&quot;</span>:<span class=\"number\">1000</span>&#125;,<span class=\"attr\">&quot;clusterMode&quot;</span>:<span class=\"literal\">false</span>,<span class=\"attr\">&quot;controlBehavior&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;count&quot;</span>:<span class=\"number\">1.0</span>,<span class=\"attr\">&quot;grade&quot;</span>:<span class=\"number\">1</span>,<span class=\"attr\">&quot;limitApp&quot;</span>:<span class=\"string\">&quot;default&quot;</span>,<span class=\"attr\">&quot;maxQueueingTimeMs&quot;</span>:<span class=\"number\">500</span>,<span class=\"attr\">&quot;resource&quot;</span>:<span class=\"string\">&quot;test&quot;</span>,<span class=\"attr\">&quot;strategy&quot;</span>:<span class=\"number\">0</span>,<span class=\"attr\">&quot;warmUpPeriodSec&quot;</span>:<span class=\"number\">10</span>&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>我们重启项目和控制台规则也不会丢失，规则持久化生效。</p>\n<p>通过分析我们知道，这种持久化方式是一种拉模式，胜在配置简单，不需要外部数据源就能完成流控数据的持久化。由于规则是用 FileRefreshableDataSource 定时更新的，所以规则更新会有延迟。<br>如果FileRefreshableDataSource定时时间过大，可能长时间延迟；如果FileRefreshableDataSource过小，又会影响性能；<br>因为规则存储在本地文件，如果需要迁移微服务，那么需要把规则文件一起迁移，否则规则会丢失。</p>\n<p>文件持久化能应付我们需求的大部分场景，但对于微服务而言是不那么满足要求的；<br>因为文件持久化就必定要求我们在服务器上提供一个用于存储配置文件的文件夹，而微服务项目大部分情况是容器部署，这就让文件持久化显得不那么好用了。</p>\n<p>为此，官方提供了自定义的持久化maven依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-datasource-extension<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>以及在这个依赖的基础上开发的以CONSUL NACOS REDIS 作为数据源的maven 依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-datasource-consul<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-datasource-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"nacos持久化\"><a href=\"#nacos持久化\" class=\"headerlink\" title=\"nacos持久化\"></a>nacos持久化</h3><p>以上三种种持久化不同于文件持久化，它们是推模式的，而且迁移部署起来更为方便，符合微服务的特性。接下来我们就以nacos持久化为例来学习一下这种方式是怎么配置的。</p>\n<p>首先引入 nacos 相关依赖依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后通过<code>FlowRuleManager</code> 注册数据源就ok了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class=\"keyword\">new</span> NacosDataSource&lt;&gt;(remoteAddress, groupId, dataId,</span><br><span class=\"line\">    source -&gt; JSON.parseObject(source, <span class=\"keyword\">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br></pre></td></tr></table></figure>\n<p>remoteAddress 是nacos 的地址； groupId和dataId均为nacos配置中心的属性，在创建配置项的时候由使用者自定义，如图为在nacos创建配置项的截图：</p>\n<p><img src=\"sentinel3.jpg\" alt=\"3\"></p>\n<p>启动nacos，启动我们的项目和控制台，然后修改nacos中的配置项，就能再控制台上观测到规则变化，nacos中存储的规则也是json,我们可以把文件持久化教程中产生json<br>复制进去，这里就不在赘述。</p>\n<p>这种模式是推模式，优点是这种方式有更好的实时性和一致性保证。因为我们和文件持久化比起来少注册了一个与<code>FileWritableDataSource</code> 对应的类，<br>也就是说应用中更新的规则不能反写到nacos,只能通过nacos读取到配置；因此我们在控制台上修改的规则也不会持久化到nacos中。这样设计是合理的，因为nacos作为<br>配置中心不应该允许应用去反写自己的配置。</p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><p>因为文件持久化分析了一部分源码，因此这里不会对源码分析太多，只简单的介绍它是如何去读取到配置的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NacosDataSource</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractDataSource</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_TIMEOUT = <span class=\"number\">3000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ExecutorService pool;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Listener configListener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String groupId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String dataId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Properties properties;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ConfigService configService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NacosDataSource</span><span class=\"params\">(<span class=\"keyword\">final</span> Properties properties, <span class=\"keyword\">final</span> String groupId, <span class=\"keyword\">final</span> String dataId, Converter&lt;String, T&gt; parser)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(parser);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pool = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> ArrayBlockingQueue(<span class=\"number\">1</span>), <span class=\"keyword\">new</span> NamedThreadFactory(<span class=\"string\">&quot;sentinel-nacos-ds-update&quot;</span>), <span class=\"keyword\">new</span> DiscardOldestPolicy());</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.configService = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!StringUtil.isBlank(groupId) &amp;&amp; !StringUtil.isBlank(dataId)) &#123;</span><br><span class=\"line\">            AssertUtil.notNull(properties, <span class=\"string\">&quot;Nacos properties must not be null, you could put some keys from PropertyKeyConst&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.groupId = groupId;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.dataId = dataId;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.properties = properties;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.configListener = <span class=\"keyword\">new</span> Listener() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Executor <span class=\"title\">getExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> NacosDataSource.<span class=\"keyword\">this</span>.pool;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveConfigInfo</span><span class=\"params\">(String configInfo)</span> </span>&#123;</span><br><span class=\"line\">                    RecordLog.info(<span class=\"string\">&quot;[NacosDataSource] New property value received for (properties: &#123;&#125;) (dataId: &#123;&#125;, groupId: &#123;&#125;): &#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Object[]&#123;properties, dataId, groupId, configInfo&#125;);</span><br><span class=\"line\">                    T newValue = NacosDataSource.<span class=\"keyword\">this</span>.parser.convert(configInfo);</span><br><span class=\"line\">                    NacosDataSource.<span class=\"keyword\">this</span>.getProperty().updateValue(newValue);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.initNacosListener();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.loadInitialConfig();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(String.format(<span class=\"string\">&quot;Bad argument: groupId=[%s], dataId=[%s]&quot;</span>, groupId, dataId));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看它的构造方法，创建了一个线程池，然后通过这个线程池 new 了一个nacos的Listener，Listener是一个监听器，initNacosListener() 方法是将监听器<br>注册到 nacos的configService 里面，通过这个监听器去监听nacos的配置变化，当配置发生更新的时候，调用监听器的 <code>receiveConfigInfo</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receiveConfigInfo</span><span class=\"params\">(String configInfo)</span> </span>&#123;</span><br><span class=\"line\">    RecordLog.info(<span class=\"string\">&quot;[NacosDataSource] New property value received for (properties: &#123;&#125;) (dataId: &#123;&#125;, groupId: &#123;&#125;): &#123;&#125;&quot;</span>, <span class=\"keyword\">new</span> Object[]&#123;properties, dataId, groupId, configInfo&#125;);</span><br><span class=\"line\">    T newValue = NacosDataSource.<span class=\"keyword\">this</span>.parser.convert(configInfo);</span><br><span class=\"line\">    NacosDataSource.<span class=\"keyword\">this</span>.getProperty().updateValue(newValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>前面分析文件持久话我们就分析过，配置最终要被更新到父类的<code>property</code> 属性里面，再这里我们也看到了同样的代码。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckjtgsh5a000000wi8d8o5m6z","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckjtgsh5l000700wi4s388xnl"},{"post_id":"ckjtgsh5f000100wi3cfrhvmg","tag_id":"ckjtgsh5k000600wif33t73fb","_id":"ckjtgsh5n000c00widy9v275y"},{"post_id":"ckjtgsh5i000300wi5hdt5pax","tag_id":"ckjtgsh5m000a00wi1ywxaham","_id":"ckjtgsh5p000g00wi877a3zsb"},{"post_id":"ckjtgsh5i000400wihd5of5s1","tag_id":"ckjtgsh5o000e00wi6klfffh9","_id":"ckjtgsh5r000k00wi4i3x27zs"},{"post_id":"ckjtgsh5r000l00wihuj30ltr","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh5u000o00wi1zkebsbq"},{"post_id":"ckjtgsh5k000500wid2d10rcv","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh5u000q00wici5cf8eu"},{"post_id":"ckjtgsh5r000m00wi7ut5fmhm","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh5v000t00wibsy5eces"},{"post_id":"ckjtgsh5u000p00wi57mafomo","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh5w000v00wi1di9ey1a"},{"post_id":"ckjtgsh5l000800wi9vzkds4m","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh5x000y00wi9rh4g132"},{"post_id":"ckjtgsh5u000r00wif744cy8o","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh5x001000wign9xe798"},{"post_id":"ckjtgsh5v000u00wi17lv02ct","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh5y001300wifm4g7tea"},{"post_id":"ckjtgsh5m000900wi3trnhsf2","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh5z001500wi62h074lx"},{"post_id":"ckjtgsh5n000b00wi4lv03xpu","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh60001800wianf45vuq"},{"post_id":"ckjtgsh5y001100wi6b4684on","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh61001a00wigjoi38rx"},{"post_id":"ckjtgsh5y001400wi9z2s0e8z","tag_id":"ckjtgsh5k000600wif33t73fb","_id":"ckjtgsh62001d00wifx431t7v"},{"post_id":"ckjtgsh5n000d00wiceg061i1","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh64001f00wi0hya2ifi"},{"post_id":"ckjtgsh5z001600wi615zex7s","tag_id":"ckjtgsh5k000600wif33t73fb","_id":"ckjtgsh65001i00wi0g02gqer"},{"post_id":"ckjtgsh5o000f00wi0t5l1hdt","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh66001k00wi6vbdfy54"},{"post_id":"ckjtgsh62001e00wi5eoi29wd","tag_id":"ckjtgsh5k000600wif33t73fb","_id":"ckjtgsh66001n00wicqdcda02"},{"post_id":"ckjtgsh5p000h00widcwo3nft","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh67001p00wigpc9f9yt"},{"post_id":"ckjtgsh5q000j00wi1a45agb0","tag_id":"ckjtgsh5q000i00wi6lvj2tp9","_id":"ckjtgsh68001s00wigl1pevy1"},{"post_id":"ckjtgsh67001o00wicqmegxww","tag_id":"ckjtgsh5o000e00wi6klfffh9","_id":"ckjtgsh69001u00wi727uhfon"},{"post_id":"ckjtgsh5w000w00wi35r1h4io","tag_id":"ckjtgsh66001m00wi0lg40g75","_id":"ckjtgsh6a001x00wi1sxohrcd"},{"post_id":"ckjtgsh67001q00wi4quocb5c","tag_id":"ckjtgsh5m000a00wi1ywxaham","_id":"ckjtgsh6a001z00wi91du8vjy"},{"post_id":"ckjtgsh5x000z00wi103xbsdz","tag_id":"ckjtgsh66001m00wi0lg40g75","_id":"ckjtgsh6b002200wi5a3ee1li"},{"post_id":"ckjtgsh60001900wie6u3af6u","tag_id":"ckjtgsh69001w00wi5gfneby3","_id":"ckjtgsh6c002400wi4mzveb6j"},{"post_id":"ckjtgsh61001b00wibcnhf72e","tag_id":"ckjtgsh6b002100wi9zj0anb5","_id":"ckjtgsh6e002800wi6ii98igf"},{"post_id":"ckjtgsh6d002700wieery2kd9","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckjtgsh6e002a00wi4kkkffqn"},{"post_id":"ckjtgsh6e002900wi8x3k7vgn","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckjtgsh6f002d00wi7weu072r"},{"post_id":"ckjtgsh64001g00wi57hq4kex","tag_id":"ckjtgsh6c002600wi2h272m20","_id":"ckjtgsh6g002f00wiapk8b8md"},{"post_id":"ckjtgsh6e002b00wieaw4406z","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckjtgsh6h002i00wi48spal46"},{"post_id":"ckjtgsh65001j00wic5pien8r","tag_id":"ckjtgsh6c002600wi2h272m20","_id":"ckjtgsh6k002k00wih2mm8n0s"},{"post_id":"ckjtgsh6h002j00wiacpm5luw","tag_id":"ckjtgsh66001m00wi0lg40g75","_id":"ckjtgsh6l002n00wib27rfdao"},{"post_id":"ckjtgsh66001l00wi7ywb4vfd","tag_id":"ckjtgsh6c002600wi2h272m20","_id":"ckjtgsh6m002p00wi9ysd4fx1"},{"post_id":"ckjtgsh6l002o00wi9wgyhyks","tag_id":"ckjtgsh5m000a00wi1ywxaham","_id":"ckjtgsh6m002s00wi2gczfv50"},{"post_id":"ckjtgsh68001t00wi3k9rg2hd","tag_id":"ckjtgsh6l002m00wiegvggrh1","_id":"ckjtgsh6n002u00wi69o50mqp"},{"post_id":"ckjtgsh6n002t00wi1x4v7w3v","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckjtgsh6o002x00widecq5sdf"},{"post_id":"ckjtgsh69001v00wi729845ou","tag_id":"ckjtgsh6l002m00wiegvggrh1","_id":"ckjtgsh6o002z00wi0aaac7y0"},{"post_id":"ckjtgsh6n002v00wiff0i198y","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckjtgsh6p003200wi9qiu4qms"},{"post_id":"ckjtgsh6o002y00wi7h7jaktg","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckjtgsh6q003400wi195pgk1w"},{"post_id":"ckjtgsh6a001y00wi50bv7cov","tag_id":"ckjtgsh6l002m00wiegvggrh1","_id":"ckjtgsh6r003700wib7ok8rw8"},{"post_id":"ckjtgsh6p003000wicvvwd5um","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckjtgsh6r003900wigwlth76e"},{"post_id":"ckjtgsh6p003300wifu7rgxrn","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckjtgsh6s003c00wi8eyogekf"},{"post_id":"ckjtgsh6a002000wihgo52ozn","tag_id":"ckjtgsh6l002m00wiegvggrh1","_id":"ckjtgsh6t003e00wi9eiw6zgb"},{"post_id":"ckjtgsh6q003500wi86zab88m","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckjtgsh6u003h00wi3osjhvl1"},{"post_id":"ckjtgsh6r003800wi7famduxm","tag_id":"ckjtgsh5m000a00wi1ywxaham","_id":"ckjtgsh6v003j00wi3hhtdu36"},{"post_id":"ckjtgsh6b002300wi1obtdxqd","tag_id":"ckjtgsh6l002m00wiegvggrh1","_id":"ckjtgsh6v003m00wi2i8r9f3j"},{"post_id":"ckjtgsh6s003a00wi50j6dhe2","tag_id":"ckjtgsh5m000a00wi1ywxaham","_id":"ckjtgsh6w003o00wi8ehjfiiv"},{"post_id":"ckjtgsh6c002500wi21caegsn","tag_id":"ckjtgsh6l002m00wiegvggrh1","_id":"ckjtgsh6x003q00wiasoe3ebt"},{"post_id":"ckjtgsh6f002e00wi89qt2yhe","tag_id":"ckjtgsh6u003g00wiabeh30yc","_id":"ckjtgsh6x003t00wiby0rb74j"},{"post_id":"ckjtgsh6v003k00wi9i1w5uc6","tag_id":"ckjtgsh69001w00wi5gfneby3","_id":"ckjtgsh6y003v00wi9t1p04oy"},{"post_id":"ckjtgsh6v003n00wibgg803ao","tag_id":"ckjtgsh66001m00wi0lg40g75","_id":"ckjtgsh6z003y00wi07achz5t"},{"post_id":"ckjtgsh6g002g00wi3vnqhecw","tag_id":"ckjtgsh6v003l00wi45857m4z","_id":"ckjtgsh6z003z00wi2qqcfnk9"},{"post_id":"ckjtgsh6w003p00wihm6nffx1","tag_id":"ckjtgsh66001m00wi0lg40g75","_id":"ckjtgsh6z004100wi2q6pc0sq"},{"post_id":"ckjtgsh6x003s00wi3hq1b2ai","tag_id":"ckjtgsh66001m00wi0lg40g75","_id":"ckjtgsh6z004200wib89sdsfo"},{"post_id":"ckjtgsh6k002l00wif40pb0sl","tag_id":"ckjtgsh6x003r00wiciyp18kf","_id":"ckjtgsh6z004400wi2wohadxj"},{"post_id":"ckjtgsh6m002q00widf79510r","tag_id":"ckjtgsh6y003x00wibbmt5izq","_id":"ckjtgsh70004500wi4vug5ph5"},{"post_id":"ckjtgsh6s003d00wi41k7ej59","tag_id":"ckjtgsh6z004000wi34el3dih","_id":"ckjtgsh70004600wi5eio9pui"},{"post_id":"ckjtgsh6t003f00wibpml90ww","tag_id":"ckjtgsh6z004300widx5b02fr","_id":"ckjtgsh70004800wievxw2vga"},{"post_id":"ckjtgsh6u003i00wi6bref7j4","tag_id":"ckjtgsh70004700wi9hzw2zhr","_id":"ckjtgsh71004a00wi6pr1gm1f"},{"post_id":"ckjtgsh6x003u00wi2vwcfih1","tag_id":"ckjtgsh70004900wi0b7i3a1k","_id":"ckjtgsh71004c00wie26r1zqv"},{"post_id":"ckjtgsh6y003w00wi1q6202j1","tag_id":"ckjtgsh70004900wi0b7i3a1k","_id":"ckjtgsh71004d00wichef3uyb"},{"post_id":"ckjtgsh73004e00wi40hx2587","tag_id":"ckjtgsh70004900wi0b7i3a1k","_id":"ckjtgsh74004g00wiabph3or8"},{"post_id":"ckjtgsh73004f00wice511plk","tag_id":"ckjtgsh5k000600wif33t73fb","_id":"ckjtgsh75004i00wi30df5ou4"},{"post_id":"ckjtgsh74004h00wifv0dbmrt","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckjtgsh75004k00wifqbz3qe6"},{"post_id":"ckjtgsh75004j00wiax362imc","tag_id":"ckjtgsh5k000600wif33t73fb","_id":"ckjtgsh76004m00wi990gano0"},{"post_id":"ckjtgsh75004l00wigt0o0mr0","tag_id":"ckjtgsh76004n00wi7en7gk41","_id":"ckjtgsh76004o00wif856glvt"},{"post_id":"ckjtgsh78004q00wi3xnbefg6","tag_id":"ckjtgsh6z004000wi34el3dih","_id":"ckjtgsh7a004t00wi45e3fq5v"},{"post_id":"ckjtgsh79004s00wihl5x0zdu","tag_id":"ckjtgsh6z004000wi34el3dih","_id":"ckjtgsh7a004u00wie5fmdsf3"},{"post_id":"ckjtgsh78004p00wido8o1vx0","tag_id":"ckjtgsh78004r00widhik2syn","_id":"ckjtgsh7a004v00wiez2r62ml"},{"post_id":"ckjtgsh7b004w00wigzfbcw7a","tag_id":"ckjtgsh6v003l00wi45857m4z","_id":"ckjtgsh7b004x00wi3j039w94"},{"post_id":"ckkkluq9i000069oe8yqiaioz","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckkkluq9s000169oe1kbzffe8"},{"post_id":"ckktjgrav0000xcqk5lt5fgmk","tag_id":"ckjtgsh5o000e00wi6klfffh9","_id":"ckktjgrb20001xcqk0rbi5zx8"},{"post_id":"ckmsmcd170000roqk5qambyer","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckmsmcd1d0001roqkhn1zfep3"},{"post_id":"ckrio0f1g0000u0qkgwzzgrqi","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckrk4gihf0000ysqkar8yggrn"},{"post_id":"ckrk4oce70000ewqk25tn85ea","tag_id":"ckjtgsh5h000200wi1w8c44rk","_id":"ckrk4ppmn0000lsqkct7s2hl0"}],"Tag":[{"name":"中间件","_id":"ckjtgsh5h000200wi1w8c44rk"},{"name":"tool","_id":"ckjtgsh5k000600wif33t73fb"},{"name":"javase","_id":"ckjtgsh5m000a00wi1ywxaham"},{"name":"javaee","_id":"ckjtgsh5o000e00wi6klfffh9"},{"name":"设计模式","_id":"ckjtgsh5q000i00wi6lvj2tp9"},{"name":"cloud","_id":"ckjtgsh66001m00wi0lg40g75"},{"name":"developing","_id":"ckjtgsh69001w00wi5gfneby3"},{"name":"苟？","_id":"ckjtgsh6b002100wi9zj0anb5"},{"name":"home","_id":"ckjtgsh6c002600wi2h272m20"},{"name":"jvm","_id":"ckjtgsh6l002m00wiegvggrh1"},{"name":"算法","_id":"ckjtgsh6u003g00wiabeh30yc"},{"name":"log","_id":"ckjtgsh6v003l00wi45857m4z"},{"name":"netty","_id":"ckjtgsh6x003r00wiciyp18kf"},{"name":"photo","_id":"ckjtgsh6y003x00wibbmt5izq"},{"name":"security","_id":"ckjtgsh6z004000wi34el3dih"},{"name":"springboot","_id":"ckjtgsh6z004300widx5b02fr"},{"name":"spring","_id":"ckjtgsh70004700wi9hzw2zhr"},{"name":"thread","_id":"ckjtgsh70004900wi0b7i3a1k"},{"name":"mysql","_id":"ckjtgsh76004n00wi7en7gk41"},{"name":"redis","_id":"ckjtgsh78004r00widhik2syn"}]}}